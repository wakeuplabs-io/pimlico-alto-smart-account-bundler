#!/usr/bin/env node

import {createRequire} from "node:module";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = createRequire(import.meta.url);

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/is.js
var require_is = __commonJS((exports) => {
  var isError = function(wat) {
    switch (objectToString.call(wat)) {
      case "[object Error]":
      case "[object Exception]":
      case "[object DOMException]":
        return true;
      default:
        return isInstanceOf(wat, Error);
    }
  };
  var isBuiltin = function(wat, className) {
    return objectToString.call(wat) === `[object ${className}]`;
  };
  var isErrorEvent = function(wat) {
    return isBuiltin(wat, "ErrorEvent");
  };
  var isDOMError = function(wat) {
    return isBuiltin(wat, "DOMError");
  };
  var isDOMException = function(wat) {
    return isBuiltin(wat, "DOMException");
  };
  var isString = function(wat) {
    return isBuiltin(wat, "String");
  };
  var isParameterizedString = function(wat) {
    return typeof wat === "object" && wat !== null && "__sentry_template_string__" in wat && "__sentry_template_values__" in wat;
  };
  var isPrimitive = function(wat) {
    return wat === null || isParameterizedString(wat) || typeof wat !== "object" && typeof wat !== "function";
  };
  var isPlainObject = function(wat) {
    return isBuiltin(wat, "Object");
  };
  var isEvent = function(wat) {
    return typeof Event !== "undefined" && isInstanceOf(wat, Event);
  };
  var isElement = function(wat) {
    return typeof Element !== "undefined" && isInstanceOf(wat, Element);
  };
  var isRegExp = function(wat) {
    return isBuiltin(wat, "RegExp");
  };
  var isThenable = function(wat) {
    return Boolean(wat && wat.then && typeof wat.then === "function");
  };
  var isSyntheticEvent = function(wat) {
    return isPlainObject(wat) && "nativeEvent" in wat && "preventDefault" in wat && "stopPropagation" in wat;
  };
  var isNaN2 = function(wat) {
    return typeof wat === "number" && wat !== wat;
  };
  var isInstanceOf = function(wat, base) {
    try {
      return wat instanceof base;
    } catch (_e) {
      return false;
    }
  };
  var isVueViewModel = function(wat) {
    return !!(typeof wat === "object" && wat !== null && (wat.__isVue || wat._isVue));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var objectToString = Object.prototype.toString;
  exports.isDOMError = isDOMError;
  exports.isDOMException = isDOMException;
  exports.isElement = isElement;
  exports.isError = isError;
  exports.isErrorEvent = isErrorEvent;
  exports.isEvent = isEvent;
  exports.isInstanceOf = isInstanceOf;
  exports.isNaN = isNaN2;
  exports.isParameterizedString = isParameterizedString;
  exports.isPlainObject = isPlainObject;
  exports.isPrimitive = isPrimitive;
  exports.isRegExp = isRegExp;
  exports.isString = isString;
  exports.isSyntheticEvent = isSyntheticEvent;
  exports.isThenable = isThenable;
  exports.isVueViewModel = isVueViewModel;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/string.js
var require_string = __commonJS((exports) => {
  var truncate = function(str, max = 0) {
    if (typeof str !== "string" || max === 0) {
      return str;
    }
    return str.length <= max ? str : `${str.slice(0, max)}...`;
  };
  var snipLine = function(line, colno) {
    let newLine = line;
    const lineLength = newLine.length;
    if (lineLength <= 150) {
      return newLine;
    }
    if (colno > lineLength) {
      colno = lineLength;
    }
    let start = Math.max(colno - 60, 0);
    if (start < 5) {
      start = 0;
    }
    let end = Math.min(start + 140, lineLength);
    if (end > lineLength - 5) {
      end = lineLength;
    }
    if (end === lineLength) {
      start = Math.max(end - 140, 0);
    }
    newLine = newLine.slice(start, end);
    if (start > 0) {
      newLine = `'{snip} ${newLine}`;
    }
    if (end < lineLength) {
      newLine += " {snip}";
    }
    return newLine;
  };
  var safeJoin = function(input, delimiter) {
    if (!Array.isArray(input)) {
      return "";
    }
    const output = [];
    for (let i = 0;i < input.length; i++) {
      const value = input[i];
      try {
        if (is.isVueViewModel(value)) {
          output.push("[VueViewModel]");
        } else {
          output.push(String(value));
        }
      } catch (e) {
        output.push("[value cannot be serialized]");
      }
    }
    return output.join(delimiter);
  };
  var isMatchingPattern = function(value, pattern, requireExactStringMatch = false) {
    if (!is.isString(value)) {
      return false;
    }
    if (is.isRegExp(pattern)) {
      return pattern.test(value);
    }
    if (is.isString(pattern)) {
      return requireExactStringMatch ? value === pattern : value.includes(pattern);
    }
    return false;
  };
  var stringMatchesSomePattern = function(testString, patterns = [], requireExactStringMatch = false) {
    return patterns.some((pattern) => isMatchingPattern(testString, pattern, requireExactStringMatch));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var is = require_is();
  exports.isMatchingPattern = isMatchingPattern;
  exports.safeJoin = safeJoin;
  exports.snipLine = snipLine;
  exports.stringMatchesSomePattern = stringMatchesSomePattern;
  exports.truncate = truncate;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/aggregate-errors.js
var require_aggregate_errors = __commonJS((exports) => {
  var applyAggregateErrorsToEvent = function(exceptionFromErrorImplementation, parser, maxValueLimit = 250, key, limit, event, hint) {
    if (!event.exception || !event.exception.values || !hint || !is.isInstanceOf(hint.originalException, Error)) {
      return;
    }
    const originalException = event.exception.values.length > 0 ? event.exception.values[event.exception.values.length - 1] : undefined;
    if (originalException) {
      event.exception.values = truncateAggregateExceptions(aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, hint.originalException, key, event.exception.values, originalException, 0), maxValueLimit);
    }
  };
  var aggregateExceptionsFromError = function(exceptionFromErrorImplementation, parser, limit, error, key, prevExceptions, exception, exceptionId) {
    if (prevExceptions.length >= limit + 1) {
      return prevExceptions;
    }
    let newExceptions = [...prevExceptions];
    if (is.isInstanceOf(error[key], Error)) {
      applyExceptionGroupFieldsForParentException(exception, exceptionId);
      const newException = exceptionFromErrorImplementation(parser, error[key]);
      const newExceptionId = newExceptions.length;
      applyExceptionGroupFieldsForChildException(newException, key, newExceptionId, exceptionId);
      newExceptions = aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, error[key], key, [newException, ...newExceptions], newException, newExceptionId);
    }
    if (Array.isArray(error.errors)) {
      error.errors.forEach((childError, i) => {
        if (is.isInstanceOf(childError, Error)) {
          applyExceptionGroupFieldsForParentException(exception, exceptionId);
          const newException = exceptionFromErrorImplementation(parser, childError);
          const newExceptionId = newExceptions.length;
          applyExceptionGroupFieldsForChildException(newException, `errors[${i}]`, newExceptionId, exceptionId);
          newExceptions = aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, childError, key, [newException, ...newExceptions], newException, newExceptionId);
        }
      });
    }
    return newExceptions;
  };
  var applyExceptionGroupFieldsForParentException = function(exception, exceptionId) {
    exception.mechanism = exception.mechanism || { type: "generic", handled: true };
    exception.mechanism = {
      ...exception.mechanism,
      is_exception_group: true,
      exception_id: exceptionId
    };
  };
  var applyExceptionGroupFieldsForChildException = function(exception, source, exceptionId, parentId) {
    exception.mechanism = exception.mechanism || { type: "generic", handled: true };
    exception.mechanism = {
      ...exception.mechanism,
      type: "chained",
      source,
      exception_id: exceptionId,
      parent_id: parentId
    };
  };
  var truncateAggregateExceptions = function(exceptions, maxValueLength) {
    return exceptions.map((exception) => {
      if (exception.value) {
        exception.value = string.truncate(exception.value, maxValueLength);
      }
      return exception;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var is = require_is();
  var string = require_string();
  exports.applyAggregateErrorsToEvent = applyAggregateErrorsToEvent;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/worldwide.js
var require_worldwide = __commonJS((exports) => {
  var isGlobalObj = function(obj) {
    return obj && obj.Math == Math ? obj : undefined;
  };
  var getGlobalObject = function() {
    return GLOBAL_OBJ;
  };
  var getGlobalSingleton = function(name, creator, obj) {
    const gbl = obj || GLOBAL_OBJ;
    const __SENTRY__ = gbl.__SENTRY__ = gbl.__SENTRY__ || {};
    const singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());
    return singleton;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var GLOBAL_OBJ = typeof globalThis == "object" && isGlobalObj(globalThis) || typeof window == "object" && isGlobalObj(window) || typeof self == "object" && isGlobalObj(self) || typeof global == "object" && isGlobalObj(global) || function() {
    return this;
  }() || {};
  exports.GLOBAL_OBJ = GLOBAL_OBJ;
  exports.getGlobalObject = getGlobalObject;
  exports.getGlobalSingleton = getGlobalSingleton;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/browser.js
var require_browser = __commonJS((exports) => {
  var htmlTreeAsString = function(elem, options = {}) {
    if (!elem) {
      return "<unknown>";
    }
    try {
      let currentElem = elem;
      const MAX_TRAVERSE_HEIGHT = 5;
      const out = [];
      let height = 0;
      let len = 0;
      const separator = " > ";
      const sepLength = separator.length;
      let nextStr;
      const keyAttrs = Array.isArray(options) ? options : options.keyAttrs;
      const maxStringLength = !Array.isArray(options) && options.maxStringLength || DEFAULT_MAX_STRING_LENGTH;
      while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
        nextStr = _htmlElementAsString(currentElem, keyAttrs);
        if (nextStr === "html" || height > 1 && len + out.length * sepLength + nextStr.length >= maxStringLength) {
          break;
        }
        out.push(nextStr);
        len += nextStr.length;
        currentElem = currentElem.parentNode;
      }
      return out.reverse().join(separator);
    } catch (_oO) {
      return "<unknown>";
    }
  };
  var _htmlElementAsString = function(el, keyAttrs) {
    const elem = el;
    const out = [];
    let className;
    let classes;
    let key;
    let attr;
    let i;
    if (!elem || !elem.tagName) {
      return "";
    }
    if (WINDOW.HTMLElement) {
      if (elem instanceof HTMLElement && elem.dataset && elem.dataset["sentryComponent"]) {
        return elem.dataset["sentryComponent"];
      }
    }
    out.push(elem.tagName.toLowerCase());
    const keyAttrPairs = keyAttrs && keyAttrs.length ? keyAttrs.filter((keyAttr) => elem.getAttribute(keyAttr)).map((keyAttr) => [keyAttr, elem.getAttribute(keyAttr)]) : null;
    if (keyAttrPairs && keyAttrPairs.length) {
      keyAttrPairs.forEach((keyAttrPair) => {
        out.push(`[${keyAttrPair[0]}="${keyAttrPair[1]}"]`);
      });
    } else {
      if (elem.id) {
        out.push(`#${elem.id}`);
      }
      className = elem.className;
      if (className && is.isString(className)) {
        classes = className.split(/\s+/);
        for (i = 0;i < classes.length; i++) {
          out.push(`.${classes[i]}`);
        }
      }
    }
    const allowedAttrs = ["aria-label", "type", "name", "title", "alt"];
    for (i = 0;i < allowedAttrs.length; i++) {
      key = allowedAttrs[i];
      attr = elem.getAttribute(key);
      if (attr) {
        out.push(`[${key}="${attr}"]`);
      }
    }
    return out.join("");
  };
  var getLocationHref = function() {
    try {
      return WINDOW.document.location.href;
    } catch (oO) {
      return "";
    }
  };
  var getDomElement = function(selector) {
    if (WINDOW.document && WINDOW.document.querySelector) {
      return WINDOW.document.querySelector(selector);
    }
    return null;
  };
  var getComponentName = function(elem) {
    if (!WINDOW.HTMLElement) {
      return null;
    }
    let currentElem = elem;
    const MAX_TRAVERSE_HEIGHT = 5;
    for (let i = 0;i < MAX_TRAVERSE_HEIGHT; i++) {
      if (!currentElem) {
        return null;
      }
      if (currentElem instanceof HTMLElement && currentElem.dataset["sentryComponent"]) {
        return currentElem.dataset["sentryComponent"];
      }
      currentElem = currentElem.parentNode;
    }
    return null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var is = require_is();
  var worldwide = require_worldwide();
  var WINDOW = worldwide.getGlobalObject();
  var DEFAULT_MAX_STRING_LENGTH = 80;
  exports.getComponentName = getComponentName;
  exports.getDomElement = getDomElement;
  exports.getLocationHref = getLocationHref;
  exports.htmlTreeAsString = htmlTreeAsString;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/debug-build.js
var require_debug_build = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
  exports.DEBUG_BUILD = DEBUG_BUILD;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/logger.js
var require_logger = __commonJS((exports) => {
  var consoleSandbox = function(callback) {
    if (!("console" in worldwide.GLOBAL_OBJ)) {
      return callback();
    }
    const console2 = worldwide.GLOBAL_OBJ.console;
    const wrappedFuncs = {};
    const wrappedLevels = Object.keys(originalConsoleMethods);
    wrappedLevels.forEach((level) => {
      const originalConsoleMethod = originalConsoleMethods[level];
      wrappedFuncs[level] = console2[level];
      console2[level] = originalConsoleMethod;
    });
    try {
      return callback();
    } finally {
      wrappedLevels.forEach((level) => {
        console2[level] = wrappedFuncs[level];
      });
    }
  };
  var makeLogger = function() {
    let enabled = false;
    const logger2 = {
      enable: () => {
        enabled = true;
      },
      disable: () => {
        enabled = false;
      },
      isEnabled: () => enabled
    };
    if (debugBuild.DEBUG_BUILD) {
      CONSOLE_LEVELS.forEach((name) => {
        logger2[name] = (...args) => {
          if (enabled) {
            consoleSandbox(() => {
              worldwide.GLOBAL_OBJ.console[name](`${PREFIX}[${name}]:`, ...args);
            });
          }
        };
      });
    } else {
      CONSOLE_LEVELS.forEach((name) => {
        logger2[name] = () => {
          return;
        };
      });
    }
    return logger2;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var debugBuild = require_debug_build();
  var worldwide = require_worldwide();
  var PREFIX = "Sentry Logger ";
  var CONSOLE_LEVELS = [
    "debug",
    "info",
    "warn",
    "error",
    "log",
    "assert",
    "trace"
  ];
  var originalConsoleMethods = {};
  var logger = makeLogger();
  exports.CONSOLE_LEVELS = CONSOLE_LEVELS;
  exports.consoleSandbox = consoleSandbox;
  exports.logger = logger;
  exports.originalConsoleMethods = originalConsoleMethods;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/dsn.js
var require_dsn = __commonJS((exports) => {
  var isValidProtocol = function(protocol) {
    return protocol === "http" || protocol === "https";
  };
  var dsnToString = function(dsn, withPassword = false) {
    const { host, path, pass, port, projectId, protocol, publicKey } = dsn;
    return `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ""}` + `@${host}${port ? `:${port}` : ""}/${path ? `${path}/` : path}${projectId}`;
  };
  var dsnFromString = function(str) {
    const match = DSN_REGEX.exec(str);
    if (!match) {
      logger.consoleSandbox(() => {
        console.error(`Invalid Sentry Dsn: ${str}`);
      });
      return;
    }
    const [protocol, publicKey, pass = "", host, port = "", lastPath] = match.slice(1);
    let path = "";
    let projectId = lastPath;
    const split = projectId.split("/");
    if (split.length > 1) {
      path = split.slice(0, -1).join("/");
      projectId = split.pop();
    }
    if (projectId) {
      const projectMatch = projectId.match(/^\d+/);
      if (projectMatch) {
        projectId = projectMatch[0];
      }
    }
    return dsnFromComponents({ host, pass, path, projectId, port, protocol, publicKey });
  };
  var dsnFromComponents = function(components) {
    return {
      protocol: components.protocol,
      publicKey: components.publicKey || "",
      pass: components.pass || "",
      host: components.host,
      port: components.port || "",
      path: components.path || "",
      projectId: components.projectId
    };
  };
  var validateDsn = function(dsn) {
    if (!debugBuild.DEBUG_BUILD) {
      return true;
    }
    const { port, projectId, protocol } = dsn;
    const requiredComponents = ["protocol", "publicKey", "host", "projectId"];
    const hasMissingRequiredComponent = requiredComponents.find((component) => {
      if (!dsn[component]) {
        logger.logger.error(`Invalid Sentry Dsn: ${component} missing`);
        return true;
      }
      return false;
    });
    if (hasMissingRequiredComponent) {
      return false;
    }
    if (!projectId.match(/^\d+$/)) {
      logger.logger.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);
      return false;
    }
    if (!isValidProtocol(protocol)) {
      logger.logger.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);
      return false;
    }
    if (port && isNaN(parseInt(port, 10))) {
      logger.logger.error(`Invalid Sentry Dsn: Invalid port ${port}`);
      return false;
    }
    return true;
  };
  var makeDsn = function(from) {
    const components = typeof from === "string" ? dsnFromString(from) : dsnFromComponents(from);
    if (!components || !validateDsn(components)) {
      return;
    }
    return components;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var debugBuild = require_debug_build();
  var logger = require_logger();
  var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
  exports.dsnFromString = dsnFromString;
  exports.dsnToString = dsnToString;
  exports.makeDsn = makeDsn;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/error.js
var require_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class SentryError extends Error {
    constructor(message, logLevel = "warn") {
      super(message);
      this.message = message;
      this.name = new.target.prototype.constructor.name;
      Object.setPrototypeOf(this, new.target.prototype);
      this.logLevel = logLevel;
    }
  }
  exports.SentryError = SentryError;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/object.js
var require_object = __commonJS((exports) => {
  var fill = function(source, name, replacementFactory) {
    if (!(name in source)) {
      return;
    }
    const original = source[name];
    const wrapped = replacementFactory(original);
    if (typeof wrapped === "function") {
      markFunctionWrapped(wrapped, original);
    }
    source[name] = wrapped;
  };
  var addNonEnumerableProperty = function(obj, name, value) {
    try {
      Object.defineProperty(obj, name, {
        value,
        writable: true,
        configurable: true
      });
    } catch (o_O) {
      debugBuild.DEBUG_BUILD && logger.logger.log(`Failed to add non-enumerable property "${name}" to object`, obj);
    }
  };
  var markFunctionWrapped = function(wrapped, original) {
    try {
      const proto = original.prototype || {};
      wrapped.prototype = original.prototype = proto;
      addNonEnumerableProperty(wrapped, "__sentry_original__", original);
    } catch (o_O) {
    }
  };
  var getOriginalFunction = function(func) {
    return func.__sentry_original__;
  };
  var urlEncode = function(object) {
    return Object.keys(object).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`).join("&");
  };
  var convertToPlainObject = function(value) {
    if (is.isError(value)) {
      return {
        message: value.message,
        name: value.name,
        stack: value.stack,
        ...getOwnProperties(value)
      };
    } else if (is.isEvent(value)) {
      const newObj = {
        type: value.type,
        target: serializeEventTarget(value.target),
        currentTarget: serializeEventTarget(value.currentTarget),
        ...getOwnProperties(value)
      };
      if (typeof CustomEvent !== "undefined" && is.isInstanceOf(value, CustomEvent)) {
        newObj.detail = value.detail;
      }
      return newObj;
    } else {
      return value;
    }
  };
  var serializeEventTarget = function(target) {
    try {
      return is.isElement(target) ? browser.htmlTreeAsString(target) : Object.prototype.toString.call(target);
    } catch (_oO) {
      return "<unknown>";
    }
  };
  var getOwnProperties = function(obj) {
    if (typeof obj === "object" && obj !== null) {
      const extractedProps = {};
      for (const property in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, property)) {
          extractedProps[property] = obj[property];
        }
      }
      return extractedProps;
    } else {
      return {};
    }
  };
  var extractExceptionKeysForMessage = function(exception, maxLength = 40) {
    const keys = Object.keys(convertToPlainObject(exception));
    keys.sort();
    if (!keys.length) {
      return "[object has no keys]";
    }
    if (keys[0].length >= maxLength) {
      return string.truncate(keys[0], maxLength);
    }
    for (let includedKeys = keys.length;includedKeys > 0; includedKeys--) {
      const serialized = keys.slice(0, includedKeys).join(", ");
      if (serialized.length > maxLength) {
        continue;
      }
      if (includedKeys === keys.length) {
        return serialized;
      }
      return string.truncate(serialized, maxLength);
    }
    return "";
  };
  var dropUndefinedKeys = function(inputValue) {
    const memoizationMap = new Map;
    return _dropUndefinedKeys(inputValue, memoizationMap);
  };
  var _dropUndefinedKeys = function(inputValue, memoizationMap) {
    if (isPojo(inputValue)) {
      const memoVal = memoizationMap.get(inputValue);
      if (memoVal !== undefined) {
        return memoVal;
      }
      const returnValue = {};
      memoizationMap.set(inputValue, returnValue);
      for (const key of Object.keys(inputValue)) {
        if (typeof inputValue[key] !== "undefined") {
          returnValue[key] = _dropUndefinedKeys(inputValue[key], memoizationMap);
        }
      }
      return returnValue;
    }
    if (Array.isArray(inputValue)) {
      const memoVal = memoizationMap.get(inputValue);
      if (memoVal !== undefined) {
        return memoVal;
      }
      const returnValue = [];
      memoizationMap.set(inputValue, returnValue);
      inputValue.forEach((item) => {
        returnValue.push(_dropUndefinedKeys(item, memoizationMap));
      });
      return returnValue;
    }
    return inputValue;
  };
  var isPojo = function(input) {
    if (!is.isPlainObject(input)) {
      return false;
    }
    try {
      const name = Object.getPrototypeOf(input).constructor.name;
      return !name || name === "Object";
    } catch (e) {
      return true;
    }
  };
  var objectify = function(wat) {
    let objectified;
    switch (true) {
      case (wat === undefined || wat === null):
        objectified = new String(wat);
        break;
      case (typeof wat === "symbol" || typeof wat === "bigint"):
        objectified = Object(wat);
        break;
      case is.isPrimitive(wat):
        objectified = new wat.constructor(wat);
        break;
      default:
        objectified = wat;
        break;
    }
    return objectified;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var browser = require_browser();
  var debugBuild = require_debug_build();
  var is = require_is();
  var logger = require_logger();
  var string = require_string();
  exports.addNonEnumerableProperty = addNonEnumerableProperty;
  exports.convertToPlainObject = convertToPlainObject;
  exports.dropUndefinedKeys = dropUndefinedKeys;
  exports.extractExceptionKeysForMessage = extractExceptionKeysForMessage;
  exports.fill = fill;
  exports.getOriginalFunction = getOriginalFunction;
  exports.markFunctionWrapped = markFunctionWrapped;
  exports.objectify = objectify;
  exports.urlEncode = urlEncode;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/node-stack-trace.js
var require_node_stack_trace = __commonJS((exports) => {
  var filenameIsInApp = function(filename, isNative = false) {
    const isInternal = isNative || filename && !filename.startsWith("/") && !filename.match(/^[A-Z]:/) && !filename.startsWith(".") && !filename.match(/^[a-zA-Z]([a-zA-Z0-9.\-+])*:\/\//);
    return !isInternal && filename !== undefined && !filename.includes("node_modules/");
  };
  var node = function(getModule) {
    const FILENAME_MATCH = /^\s*[-]{4,}$/;
    const FULL_MATCH = /at (?:async )?(?:(.+?)\s+\()?(?:(.+):(\d+):(\d+)?|([^)]+))\)?/;
    return (line) => {
      const lineMatch = line.match(FULL_MATCH);
      if (lineMatch) {
        let object;
        let method;
        let functionName;
        let typeName;
        let methodName;
        if (lineMatch[1]) {
          functionName = lineMatch[1];
          let methodStart = functionName.lastIndexOf(".");
          if (functionName[methodStart - 1] === ".") {
            methodStart--;
          }
          if (methodStart > 0) {
            object = functionName.slice(0, methodStart);
            method = functionName.slice(methodStart + 1);
            const objectEnd = object.indexOf(".Module");
            if (objectEnd > 0) {
              functionName = functionName.slice(objectEnd + 1);
              object = object.slice(0, objectEnd);
            }
          }
          typeName = undefined;
        }
        if (method) {
          typeName = object;
          methodName = method;
        }
        if (method === "<anonymous>") {
          methodName = undefined;
          functionName = undefined;
        }
        if (functionName === undefined) {
          methodName = methodName || "<anonymous>";
          functionName = typeName ? `${typeName}.${methodName}` : methodName;
        }
        let filename = lineMatch[2] && lineMatch[2].startsWith("file://") ? lineMatch[2].slice(7) : lineMatch[2];
        const isNative = lineMatch[5] === "native";
        if (filename && filename.match(/\/[A-Z]:/)) {
          filename = filename.slice(1);
        }
        if (!filename && lineMatch[5] && !isNative) {
          filename = lineMatch[5];
        }
        return {
          filename,
          module: getModule ? getModule(filename) : undefined,
          function: functionName,
          lineno: parseInt(lineMatch[3], 10) || undefined,
          colno: parseInt(lineMatch[4], 10) || undefined,
          in_app: filenameIsInApp(filename, isNative)
        };
      }
      if (line.match(FILENAME_MATCH)) {
        return {
          filename: line
        };
      }
      return;
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.filenameIsInApp = filenameIsInApp;
  exports.node = node;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/stacktrace.js
var require_stacktrace = __commonJS((exports) => {
  var createStackParser = function(...parsers) {
    const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map((p) => p[1]);
    return (stack, skipFirst = 0) => {
      const frames = [];
      const lines = stack.split("\n");
      for (let i = skipFirst;i < lines.length; i++) {
        const line = lines[i];
        if (line.length > 1024) {
          continue;
        }
        const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, "$1") : line;
        if (cleanedLine.match(/\S*Error: /)) {
          continue;
        }
        for (const parser of sortedParsers) {
          const frame = parser(cleanedLine);
          if (frame) {
            frames.push(frame);
            break;
          }
        }
        if (frames.length >= STACKTRACE_FRAME_LIMIT) {
          break;
        }
      }
      return stripSentryFramesAndReverse(frames);
    };
  };
  var stackParserFromStackParserOptions = function(stackParser) {
    if (Array.isArray(stackParser)) {
      return createStackParser(...stackParser);
    }
    return stackParser;
  };
  var stripSentryFramesAndReverse = function(stack) {
    if (!stack.length) {
      return [];
    }
    const localStack = Array.from(stack);
    if (/sentryWrapped/.test(localStack[localStack.length - 1].function || "")) {
      localStack.pop();
    }
    localStack.reverse();
    if (STRIP_FRAME_REGEXP.test(localStack[localStack.length - 1].function || "")) {
      localStack.pop();
      if (STRIP_FRAME_REGEXP.test(localStack[localStack.length - 1].function || "")) {
        localStack.pop();
      }
    }
    return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map((frame) => ({
      ...frame,
      filename: frame.filename || localStack[localStack.length - 1].filename,
      function: frame.function || "?"
    }));
  };
  var getFunctionName = function(fn) {
    try {
      if (!fn || typeof fn !== "function") {
        return defaultFunctionName;
      }
      return fn.name || defaultFunctionName;
    } catch (e) {
      return defaultFunctionName;
    }
  };
  var nodeStackLineParser = function(getModule) {
    return [90, nodeStackTrace.node(getModule)];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var nodeStackTrace = require_node_stack_trace();
  var STACKTRACE_FRAME_LIMIT = 50;
  var WEBPACK_ERROR_REGEXP = /\(error: (.*)\)/;
  var STRIP_FRAME_REGEXP = /captureMessage|captureException/;
  var defaultFunctionName = "<anonymous>";
  exports.filenameIsInApp = nodeStackTrace.filenameIsInApp;
  exports.createStackParser = createStackParser;
  exports.getFunctionName = getFunctionName;
  exports.nodeStackLineParser = nodeStackLineParser;
  exports.stackParserFromStackParserOptions = stackParserFromStackParserOptions;
  exports.stripSentryFramesAndReverse = stripSentryFramesAndReverse;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/instrument/_handlers.js
var require__handlers = __commonJS((exports) => {
  var addHandler = function(type, handler) {
    handlers[type] = handlers[type] || [];
    handlers[type].push(handler);
  };
  var resetInstrumentationHandlers = function() {
    Object.keys(handlers).forEach((key) => {
      handlers[key] = undefined;
    });
  };
  var maybeInstrument = function(type, instrumentFn) {
    if (!instrumented[type]) {
      instrumentFn();
      instrumented[type] = true;
    }
  };
  var triggerHandlers = function(type, data) {
    const typeHandlers = type && handlers[type];
    if (!typeHandlers) {
      return;
    }
    for (const handler of typeHandlers) {
      try {
        handler(data);
      } catch (e) {
        debugBuild.DEBUG_BUILD && logger.logger.error(`Error while triggering instrumentation handler.\nType: ${type}\nName: ${stacktrace.getFunctionName(handler)}\nError:`, e);
      }
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var debugBuild = require_debug_build();
  var logger = require_logger();
  var stacktrace = require_stacktrace();
  var handlers = {};
  var instrumented = {};
  exports.addHandler = addHandler;
  exports.maybeInstrument = maybeInstrument;
  exports.resetInstrumentationHandlers = resetInstrumentationHandlers;
  exports.triggerHandlers = triggerHandlers;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/instrument/console.js
var require_console = __commonJS((exports) => {
  var addConsoleInstrumentationHandler = function(handler) {
    const type = "console";
    _handlers.addHandler(type, handler);
    _handlers.maybeInstrument(type, instrumentConsole);
  };
  var instrumentConsole = function() {
    if (!("console" in worldwide.GLOBAL_OBJ)) {
      return;
    }
    logger.CONSOLE_LEVELS.forEach(function(level) {
      if (!(level in worldwide.GLOBAL_OBJ.console)) {
        return;
      }
      object.fill(worldwide.GLOBAL_OBJ.console, level, function(originalConsoleMethod) {
        logger.originalConsoleMethods[level] = originalConsoleMethod;
        return function(...args) {
          const handlerData = { args, level };
          _handlers.triggerHandlers("console", handlerData);
          const log = logger.originalConsoleMethods[level];
          log && log.apply(worldwide.GLOBAL_OBJ.console, args);
        };
      });
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var logger = require_logger();
  var object = require_object();
  var worldwide = require_worldwide();
  var _handlers = require__handlers();
  exports.addConsoleInstrumentationHandler = addConsoleInstrumentationHandler;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/misc.js
var require_misc = __commonJS((exports) => {
  var uuid4 = function() {
    const gbl = worldwide.GLOBAL_OBJ;
    const crypto = gbl.crypto || gbl.msCrypto;
    let getRandomByte = () => Math.random() * 16;
    try {
      if (crypto && crypto.randomUUID) {
        return crypto.randomUUID().replace(/-/g, "");
      }
      if (crypto && crypto.getRandomValues) {
        getRandomByte = () => {
          const typedArray = new Uint8Array(1);
          crypto.getRandomValues(typedArray);
          return typedArray[0];
        };
      }
    } catch (_) {
    }
    return ([1e7] + 1000 + 4000 + 8000 + 100000000000).replace(/[018]/g, (c) => (c ^ (getRandomByte() & 15) >> c / 4).toString(16));
  };
  var getFirstException = function(event) {
    return event.exception && event.exception.values ? event.exception.values[0] : undefined;
  };
  var getEventDescription = function(event) {
    const { message, event_id: eventId } = event;
    if (message) {
      return message;
    }
    const firstException = getFirstException(event);
    if (firstException) {
      if (firstException.type && firstException.value) {
        return `${firstException.type}: ${firstException.value}`;
      }
      return firstException.type || firstException.value || eventId || "<unknown>";
    }
    return eventId || "<unknown>";
  };
  var addExceptionTypeValue = function(event, value, type) {
    const exception = event.exception = event.exception || {};
    const values = exception.values = exception.values || [];
    const firstException = values[0] = values[0] || {};
    if (!firstException.value) {
      firstException.value = value || "";
    }
    if (!firstException.type) {
      firstException.type = type || "Error";
    }
  };
  var addExceptionMechanism = function(event, newMechanism) {
    const firstException = getFirstException(event);
    if (!firstException) {
      return;
    }
    const defaultMechanism = { type: "generic", handled: true };
    const currentMechanism = firstException.mechanism;
    firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };
    if (newMechanism && "data" in newMechanism) {
      const mergedData = { ...currentMechanism && currentMechanism.data, ...newMechanism.data };
      firstException.mechanism.data = mergedData;
    }
  };
  var parseSemver = function(input) {
    const match = input.match(SEMVER_REGEXP) || [];
    const major = parseInt(match[1], 10);
    const minor = parseInt(match[2], 10);
    const patch = parseInt(match[3], 10);
    return {
      buildmetadata: match[5],
      major: isNaN(major) ? undefined : major,
      minor: isNaN(minor) ? undefined : minor,
      patch: isNaN(patch) ? undefined : patch,
      prerelease: match[4]
    };
  };
  var addContextToFrame = function(lines, frame, linesOfContext = 5) {
    if (frame.lineno === undefined) {
      return;
    }
    const maxLines = lines.length;
    const sourceLine = Math.max(Math.min(maxLines - 1, frame.lineno - 1), 0);
    frame.pre_context = lines.slice(Math.max(0, sourceLine - linesOfContext), sourceLine).map((line) => string.snipLine(line, 0));
    frame.context_line = string.snipLine(lines[Math.min(maxLines - 1, sourceLine)], frame.colno || 0);
    frame.post_context = lines.slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext).map((line) => string.snipLine(line, 0));
  };
  var checkOrSetAlreadyCaught = function(exception) {
    if (exception && exception.__sentry_captured__) {
      return true;
    }
    try {
      object.addNonEnumerableProperty(exception, "__sentry_captured__", true);
    } catch (err) {
    }
    return false;
  };
  var arrayify = function(maybeArray) {
    return Array.isArray(maybeArray) ? maybeArray : [maybeArray];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var object = require_object();
  var string = require_string();
  var worldwide = require_worldwide();
  var SEMVER_REGEXP = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
  exports.addContextToFrame = addContextToFrame;
  exports.addExceptionMechanism = addExceptionMechanism;
  exports.addExceptionTypeValue = addExceptionTypeValue;
  exports.arrayify = arrayify;
  exports.checkOrSetAlreadyCaught = checkOrSetAlreadyCaught;
  exports.getEventDescription = getEventDescription;
  exports.parseSemver = parseSemver;
  exports.uuid4 = uuid4;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/instrument/dom.js
var require_dom = __commonJS((exports) => {
  var addClickKeypressInstrumentationHandler = function(handler) {
    const type = "dom";
    _handlers.addHandler(type, handler);
    _handlers.maybeInstrument(type, instrumentDOM);
  };
  var instrumentDOM = function() {
    if (!WINDOW.document) {
      return;
    }
    const triggerDOMHandler = _handlers.triggerHandlers.bind(null, "dom");
    const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
    WINDOW.document.addEventListener("click", globalDOMEventHandler, false);
    WINDOW.document.addEventListener("keypress", globalDOMEventHandler, false);
    ["EventTarget", "Node"].forEach((target) => {
      const proto = WINDOW[target] && WINDOW[target].prototype;
      if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
        return;
      }
      object.fill(proto, "addEventListener", function(originalAddEventListener) {
        return function(type, listener, options) {
          if (type === "click" || type == "keypress") {
            try {
              const el = this;
              const handlers = el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {};
              const handlerForType = handlers[type] = handlers[type] || { refCount: 0 };
              if (!handlerForType.handler) {
                const handler = makeDOMEventHandler(triggerDOMHandler);
                handlerForType.handler = handler;
                originalAddEventListener.call(this, type, handler, options);
              }
              handlerForType.refCount++;
            } catch (e) {
            }
          }
          return originalAddEventListener.call(this, type, listener, options);
        };
      });
      object.fill(proto, "removeEventListener", function(originalRemoveEventListener) {
        return function(type, listener, options) {
          if (type === "click" || type == "keypress") {
            try {
              const el = this;
              const handlers = el.__sentry_instrumentation_handlers__ || {};
              const handlerForType = handlers[type];
              if (handlerForType) {
                handlerForType.refCount--;
                if (handlerForType.refCount <= 0) {
                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                  handlerForType.handler = undefined;
                  delete handlers[type];
                }
                if (Object.keys(handlers).length === 0) {
                  delete el.__sentry_instrumentation_handlers__;
                }
              }
            } catch (e) {
            }
          }
          return originalRemoveEventListener.call(this, type, listener, options);
        };
      });
    });
  };
  var isSimilarToLastCapturedEvent = function(event) {
    if (event.type !== lastCapturedEventType) {
      return false;
    }
    try {
      if (!event.target || event.target._sentryId !== lastCapturedEventTargetId) {
        return false;
      }
    } catch (e) {
    }
    return true;
  };
  var shouldSkipDOMEvent = function(eventType, target) {
    if (eventType !== "keypress") {
      return false;
    }
    if (!target || !target.tagName) {
      return true;
    }
    if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
      return false;
    }
    return true;
  };
  var makeDOMEventHandler = function(handler, globalListener = false) {
    return (event) => {
      if (!event || event["_sentryCaptured"]) {
        return;
      }
      const target = getEventTarget(event);
      if (shouldSkipDOMEvent(event.type, target)) {
        return;
      }
      object.addNonEnumerableProperty(event, "_sentryCaptured", true);
      if (target && !target._sentryId) {
        object.addNonEnumerableProperty(target, "_sentryId", misc.uuid4());
      }
      const name = event.type === "keypress" ? "input" : event.type;
      if (!isSimilarToLastCapturedEvent(event)) {
        const handlerData = { event, name, global: globalListener };
        handler(handlerData);
        lastCapturedEventType = event.type;
        lastCapturedEventTargetId = target ? target._sentryId : undefined;
      }
      clearTimeout(debounceTimerID);
      debounceTimerID = WINDOW.setTimeout(() => {
        lastCapturedEventTargetId = undefined;
        lastCapturedEventType = undefined;
      }, DEBOUNCE_DURATION);
    };
  };
  var getEventTarget = function(event) {
    try {
      return event.target;
    } catch (e) {
      return null;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var misc = require_misc();
  var object = require_object();
  var worldwide = require_worldwide();
  var _handlers = require__handlers();
  var WINDOW = worldwide.GLOBAL_OBJ;
  var DEBOUNCE_DURATION = 1000;
  var debounceTimerID;
  var lastCapturedEventType;
  var lastCapturedEventTargetId;
  exports.addClickKeypressInstrumentationHandler = addClickKeypressInstrumentationHandler;
  exports.instrumentDOM = instrumentDOM;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/supports.js
var require_supports = __commonJS((exports) => {
  var supportsErrorEvent = function() {
    try {
      new ErrorEvent("");
      return true;
    } catch (e) {
      return false;
    }
  };
  var supportsDOMError = function() {
    try {
      new DOMError("");
      return true;
    } catch (e) {
      return false;
    }
  };
  var supportsDOMException = function() {
    try {
      new DOMException("");
      return true;
    } catch (e) {
      return false;
    }
  };
  var supportsFetch = function() {
    if (!("fetch" in WINDOW)) {
      return false;
    }
    try {
      new Headers;
      new Request("http://www.example.com");
      new Response;
      return true;
    } catch (e) {
      return false;
    }
  };
  var isNativeFetch = function(func) {
    return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
  };
  var supportsNativeFetch = function() {
    if (typeof EdgeRuntime === "string") {
      return true;
    }
    if (!supportsFetch()) {
      return false;
    }
    if (isNativeFetch(WINDOW.fetch)) {
      return true;
    }
    let result = false;
    const doc = WINDOW.document;
    if (doc && typeof doc.createElement === "function") {
      try {
        const sandbox = doc.createElement("iframe");
        sandbox.hidden = true;
        doc.head.appendChild(sandbox);
        if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
          result = isNativeFetch(sandbox.contentWindow.fetch);
        }
        doc.head.removeChild(sandbox);
      } catch (err) {
        debugBuild.DEBUG_BUILD && logger.logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", err);
      }
    }
    return result;
  };
  var supportsReportingObserver = function() {
    return "ReportingObserver" in WINDOW;
  };
  var supportsReferrerPolicy = function() {
    if (!supportsFetch()) {
      return false;
    }
    try {
      new Request("_", {
        referrerPolicy: "origin"
      });
      return true;
    } catch (e) {
      return false;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var debugBuild = require_debug_build();
  var logger = require_logger();
  var worldwide = require_worldwide();
  var WINDOW = worldwide.getGlobalObject();
  exports.isNativeFetch = isNativeFetch;
  exports.supportsDOMError = supportsDOMError;
  exports.supportsDOMException = supportsDOMException;
  exports.supportsErrorEvent = supportsErrorEvent;
  exports.supportsFetch = supportsFetch;
  exports.supportsNativeFetch = supportsNativeFetch;
  exports.supportsReferrerPolicy = supportsReferrerPolicy;
  exports.supportsReportingObserver = supportsReportingObserver;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/instrument/fetch.js
var require_fetch = __commonJS((exports) => {
  var addFetchInstrumentationHandler = function(handler) {
    const type = "fetch";
    _handlers.addHandler(type, handler);
    _handlers.maybeInstrument(type, instrumentFetch);
  };
  var instrumentFetch = function() {
    if (!supports.supportsNativeFetch()) {
      return;
    }
    object.fill(worldwide.GLOBAL_OBJ, "fetch", function(originalFetch) {
      return function(...args) {
        const { method, url } = parseFetchArgs(args);
        const handlerData = {
          args,
          fetchData: {
            method,
            url
          },
          startTimestamp: Date.now()
        };
        _handlers.triggerHandlers("fetch", {
          ...handlerData
        });
        return originalFetch.apply(worldwide.GLOBAL_OBJ, args).then((response) => {
          const finishedHandlerData = {
            ...handlerData,
            endTimestamp: Date.now(),
            response
          };
          _handlers.triggerHandlers("fetch", finishedHandlerData);
          return response;
        }, (error) => {
          const erroredHandlerData = {
            ...handlerData,
            endTimestamp: Date.now(),
            error
          };
          _handlers.triggerHandlers("fetch", erroredHandlerData);
          throw error;
        });
      };
    });
  };
  var hasProp = function(obj, prop) {
    return !!obj && typeof obj === "object" && !!obj[prop];
  };
  var getUrlFromResource = function(resource) {
    if (typeof resource === "string") {
      return resource;
    }
    if (!resource) {
      return "";
    }
    if (hasProp(resource, "url")) {
      return resource.url;
    }
    if (resource.toString) {
      return resource.toString();
    }
    return "";
  };
  var parseFetchArgs = function(fetchArgs) {
    if (fetchArgs.length === 0) {
      return { method: "GET", url: "" };
    }
    if (fetchArgs.length === 2) {
      const [url, options] = fetchArgs;
      return {
        url: getUrlFromResource(url),
        method: hasProp(options, "method") ? String(options.method).toUpperCase() : "GET"
      };
    }
    const arg = fetchArgs[0];
    return {
      url: getUrlFromResource(arg),
      method: hasProp(arg, "method") ? String(arg.method).toUpperCase() : "GET"
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var object = require_object();
  var supports = require_supports();
  var worldwide = require_worldwide();
  var _handlers = require__handlers();
  exports.addFetchInstrumentationHandler = addFetchInstrumentationHandler;
  exports.parseFetchArgs = parseFetchArgs;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/instrument/globalError.js
var require_globalError = __commonJS((exports) => {
  var addGlobalErrorInstrumentationHandler = function(handler) {
    const type = "error";
    _handlers.addHandler(type, handler);
    _handlers.maybeInstrument(type, instrumentError);
  };
  var instrumentError = function() {
    _oldOnErrorHandler = worldwide.GLOBAL_OBJ.onerror;
    worldwide.GLOBAL_OBJ.onerror = function(msg, url, line, column, error) {
      const handlerData = {
        column,
        error,
        line,
        msg,
        url
      };
      _handlers.triggerHandlers("error", handlerData);
      if (_oldOnErrorHandler && !_oldOnErrorHandler.__SENTRY_LOADER__) {
        return _oldOnErrorHandler.apply(this, arguments);
      }
      return false;
    };
    worldwide.GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = true;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var worldwide = require_worldwide();
  var _handlers = require__handlers();
  var _oldOnErrorHandler = null;
  exports.addGlobalErrorInstrumentationHandler = addGlobalErrorInstrumentationHandler;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/instrument/globalUnhandledRejection.js
var require_globalUnhandledRejection = __commonJS((exports) => {
  var addGlobalUnhandledRejectionInstrumentationHandler = function(handler) {
    const type = "unhandledrejection";
    _handlers.addHandler(type, handler);
    _handlers.maybeInstrument(type, instrumentUnhandledRejection);
  };
  var instrumentUnhandledRejection = function() {
    _oldOnUnhandledRejectionHandler = worldwide.GLOBAL_OBJ.onunhandledrejection;
    worldwide.GLOBAL_OBJ.onunhandledrejection = function(e) {
      const handlerData = e;
      _handlers.triggerHandlers("unhandledrejection", handlerData);
      if (_oldOnUnhandledRejectionHandler && !_oldOnUnhandledRejectionHandler.__SENTRY_LOADER__) {
        return _oldOnUnhandledRejectionHandler.apply(this, arguments);
      }
      return true;
    };
    worldwide.GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var worldwide = require_worldwide();
  var _handlers = require__handlers();
  var _oldOnUnhandledRejectionHandler = null;
  exports.addGlobalUnhandledRejectionInstrumentationHandler = addGlobalUnhandledRejectionInstrumentationHandler;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/vendor/supportsHistory.js
var require_supportsHistory = __commonJS((exports) => {
  var supportsHistory = function() {
    const chrome = WINDOW.chrome;
    const isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;
    const hasHistoryApi = "history" in WINDOW && !!WINDOW.history.pushState && !!WINDOW.history.replaceState;
    return !isChromePackagedApp && hasHistoryApi;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var worldwide = require_worldwide();
  var WINDOW = worldwide.getGlobalObject();
  exports.supportsHistory = supportsHistory;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/instrument/history.js
var require_history = __commonJS((exports) => {
  var addHistoryInstrumentationHandler = function(handler) {
    const type = "history";
    _handlers.addHandler(type, handler);
    _handlers.maybeInstrument(type, instrumentHistory);
  };
  var instrumentHistory = function() {
    if (!supportsHistory.supportsHistory()) {
      return;
    }
    const oldOnPopState = WINDOW.onpopstate;
    WINDOW.onpopstate = function(...args) {
      const to = WINDOW.location.href;
      const from = lastHref;
      lastHref = to;
      const handlerData = { from, to };
      _handlers.triggerHandlers("history", handlerData);
      if (oldOnPopState) {
        try {
          return oldOnPopState.apply(this, args);
        } catch (_oO) {
        }
      }
    };
    function historyReplacementFunction(originalHistoryFunction) {
      return function(...args) {
        const url = args.length > 2 ? args[2] : undefined;
        if (url) {
          const from = lastHref;
          const to = String(url);
          lastHref = to;
          const handlerData = { from, to };
          _handlers.triggerHandlers("history", handlerData);
        }
        return originalHistoryFunction.apply(this, args);
      };
    }
    object.fill(WINDOW.history, "pushState", historyReplacementFunction);
    object.fill(WINDOW.history, "replaceState", historyReplacementFunction);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var object = require_object();
  require_debug_build();
  require_logger();
  var worldwide = require_worldwide();
  var supportsHistory = require_supportsHistory();
  var _handlers = require__handlers();
  var WINDOW = worldwide.GLOBAL_OBJ;
  var lastHref;
  exports.addHistoryInstrumentationHandler = addHistoryInstrumentationHandler;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/instrument/xhr.js
var require_xhr = __commonJS((exports) => {
  var addXhrInstrumentationHandler = function(handler) {
    const type = "xhr";
    _handlers.addHandler(type, handler);
    _handlers.maybeInstrument(type, instrumentXHR);
  };
  var instrumentXHR = function() {
    if (!WINDOW.XMLHttpRequest) {
      return;
    }
    const xhrproto = XMLHttpRequest.prototype;
    object.fill(xhrproto, "open", function(originalOpen) {
      return function(...args) {
        const startTimestamp = Date.now();
        const method = is.isString(args[0]) ? args[0].toUpperCase() : undefined;
        const url = parseUrl(args[1]);
        if (!method || !url) {
          return originalOpen.apply(this, args);
        }
        this[SENTRY_XHR_DATA_KEY] = {
          method,
          url,
          request_headers: {}
        };
        if (method === "POST" && url.match(/sentry_key/)) {
          this.__sentry_own_request__ = true;
        }
        const onreadystatechangeHandler = () => {
          const xhrInfo = this[SENTRY_XHR_DATA_KEY];
          if (!xhrInfo) {
            return;
          }
          if (this.readyState === 4) {
            try {
              xhrInfo.status_code = this.status;
            } catch (e) {
            }
            const handlerData = {
              args: [method, url],
              endTimestamp: Date.now(),
              startTimestamp,
              xhr: this
            };
            _handlers.triggerHandlers("xhr", handlerData);
          }
        };
        if ("onreadystatechange" in this && typeof this.onreadystatechange === "function") {
          object.fill(this, "onreadystatechange", function(original) {
            return function(...readyStateArgs) {
              onreadystatechangeHandler();
              return original.apply(this, readyStateArgs);
            };
          });
        } else {
          this.addEventListener("readystatechange", onreadystatechangeHandler);
        }
        object.fill(this, "setRequestHeader", function(original) {
          return function(...setRequestHeaderArgs) {
            const [header, value] = setRequestHeaderArgs;
            const xhrInfo = this[SENTRY_XHR_DATA_KEY];
            if (xhrInfo && is.isString(header) && is.isString(value)) {
              xhrInfo.request_headers[header.toLowerCase()] = value;
            }
            return original.apply(this, setRequestHeaderArgs);
          };
        });
        return originalOpen.apply(this, args);
      };
    });
    object.fill(xhrproto, "send", function(originalSend) {
      return function(...args) {
        const sentryXhrData = this[SENTRY_XHR_DATA_KEY];
        if (!sentryXhrData) {
          return originalSend.apply(this, args);
        }
        if (args[0] !== undefined) {
          sentryXhrData.body = args[0];
        }
        const handlerData = {
          args: [sentryXhrData.method, sentryXhrData.url],
          startTimestamp: Date.now(),
          xhr: this
        };
        _handlers.triggerHandlers("xhr", handlerData);
        return originalSend.apply(this, args);
      };
    });
  };
  var parseUrl = function(url) {
    if (is.isString(url)) {
      return url;
    }
    try {
      return url.toString();
    } catch (e2) {
    }
    return;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var is = require_is();
  var object = require_object();
  var worldwide = require_worldwide();
  var _handlers = require__handlers();
  var WINDOW = worldwide.GLOBAL_OBJ;
  var SENTRY_XHR_DATA_KEY = "__sentry_xhr_v3__";
  exports.SENTRY_XHR_DATA_KEY = SENTRY_XHR_DATA_KEY;
  exports.addXhrInstrumentationHandler = addXhrInstrumentationHandler;
  exports.instrumentXHR = instrumentXHR;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/instrument/index.js
var require_instrument = __commonJS((exports) => {
  var addInstrumentationHandler = function(type, callback) {
    switch (type) {
      case "console":
        return console2.addConsoleInstrumentationHandler(callback);
      case "dom":
        return dom.addClickKeypressInstrumentationHandler(callback);
      case "xhr":
        return xhr.addXhrInstrumentationHandler(callback);
      case "fetch":
        return fetch2.addFetchInstrumentationHandler(callback);
      case "history":
        return history.addHistoryInstrumentationHandler(callback);
      case "error":
        return globalError.addGlobalErrorInstrumentationHandler(callback);
      case "unhandledrejection":
        return globalUnhandledRejection.addGlobalUnhandledRejectionInstrumentationHandler(callback);
      default:
        debugBuild.DEBUG_BUILD && logger.logger.warn("unknown instrumentation type:", type);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var debugBuild = require_debug_build();
  var logger = require_logger();
  var console2 = require_console();
  var dom = require_dom();
  var fetch2 = require_fetch();
  var globalError = require_globalError();
  var globalUnhandledRejection = require_globalUnhandledRejection();
  var history = require_history();
  var xhr = require_xhr();
  exports.addConsoleInstrumentationHandler = console2.addConsoleInstrumentationHandler;
  exports.addClickKeypressInstrumentationHandler = dom.addClickKeypressInstrumentationHandler;
  exports.addFetchInstrumentationHandler = fetch2.addFetchInstrumentationHandler;
  exports.addGlobalErrorInstrumentationHandler = globalError.addGlobalErrorInstrumentationHandler;
  exports.addGlobalUnhandledRejectionInstrumentationHandler = globalUnhandledRejection.addGlobalUnhandledRejectionInstrumentationHandler;
  exports.addHistoryInstrumentationHandler = history.addHistoryInstrumentationHandler;
  exports.SENTRY_XHR_DATA_KEY = xhr.SENTRY_XHR_DATA_KEY;
  exports.addXhrInstrumentationHandler = xhr.addXhrInstrumentationHandler;
  exports.addInstrumentationHandler = addInstrumentationHandler;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/env.js
var require_env = __commonJS((exports) => {
  var isBrowserBundle = function() {
    return typeof __SENTRY_BROWSER_BUNDLE__ !== "undefined" && !!__SENTRY_BROWSER_BUNDLE__;
  };
  var getSDKSource = function() {
    return "npm";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSDKSource = getSDKSource;
  exports.isBrowserBundle = isBrowserBundle;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/node.js
var require_node = __commonJS((exports, module) => {
  var isNodeEnv = function() {
    return !env.isBrowserBundle() && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
  };
  var dynamicRequire = function(mod, request) {
    return mod.require(request);
  };
  var loadModule = function(moduleName) {
    let mod;
    try {
      mod = dynamicRequire(module, moduleName);
    } catch (e) {
    }
    try {
      const { cwd } = dynamicRequire(module, "process");
      mod = dynamicRequire(module, `${cwd()}/node_modules/${moduleName}`);
    } catch (e) {
    }
    return mod;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var env = require_env();
  exports.dynamicRequire = dynamicRequire;
  exports.isNodeEnv = isNodeEnv;
  exports.loadModule = loadModule;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/isBrowser.js
var require_isBrowser = __commonJS((exports) => {
  var isBrowser = function() {
    return typeof window !== "undefined" && (!node.isNodeEnv() || isElectronNodeRenderer());
  };
  var isElectronNodeRenderer = function() {
    return worldwide.GLOBAL_OBJ.process !== undefined && worldwide.GLOBAL_OBJ.process.type === "renderer";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var node = require_node();
  var worldwide = require_worldwide();
  exports.isBrowser = isBrowser;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/memo.js
var require_memo = __commonJS((exports) => {
  var memoBuilder = function() {
    const hasWeakSet = typeof WeakSet === "function";
    const inner = hasWeakSet ? new WeakSet : [];
    function memoize(obj) {
      if (hasWeakSet) {
        if (inner.has(obj)) {
          return true;
        }
        inner.add(obj);
        return false;
      }
      for (let i = 0;i < inner.length; i++) {
        const value = inner[i];
        if (value === obj) {
          return true;
        }
      }
      inner.push(obj);
      return false;
    }
    function unmemoize(obj) {
      if (hasWeakSet) {
        inner.delete(obj);
      } else {
        for (let i = 0;i < inner.length; i++) {
          if (inner[i] === obj) {
            inner.splice(i, 1);
            break;
          }
        }
      }
    }
    return [memoize, unmemoize];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.memoBuilder = memoBuilder;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/normalize.js
var require_normalize = __commonJS((exports) => {
  var normalize = function(input, depth = 100, maxProperties = Infinity) {
    try {
      return visit("", input, depth, maxProperties);
    } catch (err) {
      return { ERROR: `**non-serializable** (${err})` };
    }
  };
  var normalizeToSize = function(object2, depth = 3, maxSize = 100 * 1024) {
    const normalized = normalize(object2, depth);
    if (jsonSize(normalized) > maxSize) {
      return normalizeToSize(object2, depth - 1, maxSize);
    }
    return normalized;
  };
  var visit = function(key, value, depth = Infinity, maxProperties = Infinity, memo$1 = memo.memoBuilder()) {
    const [memoize, unmemoize] = memo$1;
    if (value == null || ["number", "boolean", "string"].includes(typeof value) && !is.isNaN(value)) {
      return value;
    }
    const stringified = stringifyValue(key, value);
    if (!stringified.startsWith("[object ")) {
      return stringified;
    }
    if (value["__sentry_skip_normalization__"]) {
      return value;
    }
    const remainingDepth = typeof value["__sentry_override_normalization_depth__"] === "number" ? value["__sentry_override_normalization_depth__"] : depth;
    if (remainingDepth === 0) {
      return stringified.replace("object ", "");
    }
    if (memoize(value)) {
      return "[Circular ~]";
    }
    const valueWithToJSON = value;
    if (valueWithToJSON && typeof valueWithToJSON.toJSON === "function") {
      try {
        const jsonValue = valueWithToJSON.toJSON();
        return visit("", jsonValue, remainingDepth - 1, maxProperties, memo$1);
      } catch (err) {
      }
    }
    const normalized = Array.isArray(value) ? [] : {};
    let numAdded = 0;
    const visitable = object.convertToPlainObject(value);
    for (const visitKey in visitable) {
      if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
        continue;
      }
      if (numAdded >= maxProperties) {
        normalized[visitKey] = "[MaxProperties ~]";
        break;
      }
      const visitValue = visitable[visitKey];
      normalized[visitKey] = visit(visitKey, visitValue, remainingDepth - 1, maxProperties, memo$1);
      numAdded++;
    }
    unmemoize(value);
    return normalized;
  };
  var stringifyValue = function(key, value) {
    try {
      if (key === "domain" && value && typeof value === "object" && value._events) {
        return "[Domain]";
      }
      if (key === "domainEmitter") {
        return "[DomainEmitter]";
      }
      if (typeof global !== "undefined" && value === global) {
        return "[Global]";
      }
      if (typeof window !== "undefined" && value === window) {
        return "[Window]";
      }
      if (typeof document !== "undefined" && value === document) {
        return "[Document]";
      }
      if (is.isVueViewModel(value)) {
        return "[VueViewModel]";
      }
      if (is.isSyntheticEvent(value)) {
        return "[SyntheticEvent]";
      }
      if (typeof value === "number" && value !== value) {
        return "[NaN]";
      }
      if (typeof value === "function") {
        return `[Function: ${stacktrace.getFunctionName(value)}]`;
      }
      if (typeof value === "symbol") {
        return `[${String(value)}]`;
      }
      if (typeof value === "bigint") {
        return `[BigInt: ${String(value)}]`;
      }
      const objName = getConstructorName(value);
      if (/^HTML(\w*)Element$/.test(objName)) {
        return `[HTMLElement: ${objName}]`;
      }
      return `[object ${objName}]`;
    } catch (err) {
      return `**non-serializable** (${err})`;
    }
  };
  var getConstructorName = function(value) {
    const prototype = Object.getPrototypeOf(value);
    return prototype ? prototype.constructor.name : "null prototype";
  };
  var utf8Length = function(value) {
    return ~-encodeURI(value).split(/%..|./).length;
  };
  var jsonSize = function(value) {
    return utf8Length(JSON.stringify(value));
  };
  var normalizeUrlToBase = function(url, basePath) {
    const escapedBase = basePath.replace(/\\/g, "/").replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
    let newUrl = url;
    try {
      newUrl = decodeURI(url);
    } catch (_Oo) {
    }
    return newUrl.replace(/\\/g, "/").replace(/webpack:\/?/g, "").replace(new RegExp(`(file://)?/*${escapedBase}/*`, "ig"), "app:///");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var is = require_is();
  var memo = require_memo();
  var object = require_object();
  var stacktrace = require_stacktrace();
  exports.normalize = normalize;
  exports.normalizeToSize = normalizeToSize;
  exports.normalizeUrlToBase = normalizeUrlToBase;
  exports.walk = visit;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/path.js
var require_path = __commonJS((exports) => {
  var normalizeArray = function(parts, allowAboveRoot) {
    let up = 0;
    for (let i = parts.length - 1;i >= 0; i--) {
      const last = parts[i];
      if (last === ".") {
        parts.splice(i, 1);
      } else if (last === "..") {
        parts.splice(i, 1);
        up++;
      } else if (up) {
        parts.splice(i, 1);
        up--;
      }
    }
    if (allowAboveRoot) {
      for (;up--; up) {
        parts.unshift("..");
      }
    }
    return parts;
  };
  var splitPath = function(filename) {
    const truncated = filename.length > 1024 ? `<truncated>${filename.slice(-1024)}` : filename;
    const parts = splitPathRe.exec(truncated);
    return parts ? parts.slice(1) : [];
  };
  var resolve = function(...args) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for (let i = args.length - 1;i >= -1 && !resolvedAbsolute; i--) {
      const path = i >= 0 ? args[i] : "/";
      if (!path) {
        continue;
      }
      resolvedPath = `${path}/${resolvedPath}`;
      resolvedAbsolute = path.charAt(0) === "/";
    }
    resolvedPath = normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
    return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
  };
  var trim = function(arr) {
    let start = 0;
    for (;start < arr.length; start++) {
      if (arr[start] !== "") {
        break;
      }
    }
    let end = arr.length - 1;
    for (;end >= 0; end--) {
      if (arr[end] !== "") {
        break;
      }
    }
    if (start > end) {
      return [];
    }
    return arr.slice(start, end - start + 1);
  };
  var relative = function(from, to) {
    from = resolve(from).slice(1);
    to = resolve(to).slice(1);
    const fromParts = trim(from.split("/"));
    const toParts = trim(to.split("/"));
    const length = Math.min(fromParts.length, toParts.length);
    let samePartsLength = length;
    for (let i = 0;i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }
    let outputParts = [];
    for (let i = samePartsLength;i < fromParts.length; i++) {
      outputParts.push("..");
    }
    outputParts = outputParts.concat(toParts.slice(samePartsLength));
    return outputParts.join("/");
  };
  var normalizePath = function(path) {
    const isPathAbsolute = isAbsolute(path);
    const trailingSlash = path.slice(-1) === "/";
    let normalizedPath = normalizeArray(path.split("/").filter((p) => !!p), !isPathAbsolute).join("/");
    if (!normalizedPath && !isPathAbsolute) {
      normalizedPath = ".";
    }
    if (normalizedPath && trailingSlash) {
      normalizedPath += "/";
    }
    return (isPathAbsolute ? "/" : "") + normalizedPath;
  };
  var isAbsolute = function(path) {
    return path.charAt(0) === "/";
  };
  var join = function(...args) {
    return normalizePath(args.join("/"));
  };
  var dirname = function(path) {
    const result = splitPath(path);
    const root = result[0];
    let dir = result[1];
    if (!root && !dir) {
      return ".";
    }
    if (dir) {
      dir = dir.slice(0, dir.length - 1);
    }
    return root + dir;
  };
  var basename = function(path, ext) {
    let f = splitPath(path)[2];
    if (ext && f.slice(ext.length * -1) === ext) {
      f = f.slice(0, f.length - ext.length);
    }
    return f;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var splitPathRe = /^(\S+:\\|\/?)([\s\S]*?)((?:\.{1,2}|[^/\\]+?|)(\.[^./\\]*|))(?:[/\\]*)$/;
  exports.basename = basename;
  exports.dirname = dirname;
  exports.isAbsolute = isAbsolute;
  exports.join = join;
  exports.normalizePath = normalizePath;
  exports.relative = relative;
  exports.resolve = resolve;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/syncpromise.js
var require_syncpromise = __commonJS((exports) => {
  var resolvedSyncPromise = function(value) {
    return new SyncPromise((resolve) => {
      resolve(value);
    });
  };
  var rejectedSyncPromise = function(reason) {
    return new SyncPromise((_, reject) => {
      reject(reason);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var is = require_is();
  var States;
  (function(States2) {
    const PENDING = 0;
    States2[States2["PENDING"] = PENDING] = "PENDING";
    const RESOLVED = 1;
    States2[States2["RESOLVED"] = RESOLVED] = "RESOLVED";
    const REJECTED = 2;
    States2[States2["REJECTED"] = REJECTED] = "REJECTED";
  })(States || (States = {}));

  class SyncPromise {
    constructor(executor) {
      SyncPromise.prototype.__init.call(this);
      SyncPromise.prototype.__init2.call(this);
      SyncPromise.prototype.__init3.call(this);
      SyncPromise.prototype.__init4.call(this);
      this._state = States.PENDING;
      this._handlers = [];
      try {
        executor(this._resolve, this._reject);
      } catch (e) {
        this._reject(e);
      }
    }
    then(onfulfilled, onrejected) {
      return new SyncPromise((resolve, reject) => {
        this._handlers.push([
          false,
          (result) => {
            if (!onfulfilled) {
              resolve(result);
            } else {
              try {
                resolve(onfulfilled(result));
              } catch (e) {
                reject(e);
              }
            }
          },
          (reason) => {
            if (!onrejected) {
              reject(reason);
            } else {
              try {
                resolve(onrejected(reason));
              } catch (e) {
                reject(e);
              }
            }
          }
        ]);
        this._executeHandlers();
      });
    }
    catch(onrejected) {
      return this.then((val) => val, onrejected);
    }
    finally(onfinally) {
      return new SyncPromise((resolve, reject) => {
        let val;
        let isRejected;
        return this.then((value) => {
          isRejected = false;
          val = value;
          if (onfinally) {
            onfinally();
          }
        }, (reason) => {
          isRejected = true;
          val = reason;
          if (onfinally) {
            onfinally();
          }
        }).then(() => {
          if (isRejected) {
            reject(val);
            return;
          }
          resolve(val);
        });
      });
    }
    __init() {
      this._resolve = (value) => {
        this._setResult(States.RESOLVED, value);
      };
    }
    __init2() {
      this._reject = (reason) => {
        this._setResult(States.REJECTED, reason);
      };
    }
    __init3() {
      this._setResult = (state, value) => {
        if (this._state !== States.PENDING) {
          return;
        }
        if (is.isThenable(value)) {
          value.then(this._resolve, this._reject);
          return;
        }
        this._state = state;
        this._value = value;
        this._executeHandlers();
      };
    }
    __init4() {
      this._executeHandlers = () => {
        if (this._state === States.PENDING) {
          return;
        }
        const cachedHandlers = this._handlers.slice();
        this._handlers = [];
        cachedHandlers.forEach((handler) => {
          if (handler[0]) {
            return;
          }
          if (this._state === States.RESOLVED) {
            handler[1](this._value);
          }
          if (this._state === States.REJECTED) {
            handler[2](this._value);
          }
          handler[0] = true;
        });
      };
    }
  }
  exports.SyncPromise = SyncPromise;
  exports.rejectedSyncPromise = rejectedSyncPromise;
  exports.resolvedSyncPromise = resolvedSyncPromise;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/promisebuffer.js
var require_promisebuffer = __commonJS((exports) => {
  var makePromiseBuffer = function(limit) {
    const buffer = [];
    function isReady() {
      return limit === undefined || buffer.length < limit;
    }
    function remove(task) {
      return buffer.splice(buffer.indexOf(task), 1)[0];
    }
    function add(taskProducer) {
      if (!isReady()) {
        return syncpromise.rejectedSyncPromise(new error.SentryError("Not adding Promise because buffer limit was reached."));
      }
      const task = taskProducer();
      if (buffer.indexOf(task) === -1) {
        buffer.push(task);
      }
      task.then(() => remove(task)).then(null, () => remove(task).then(null, () => {
      }));
      return task;
    }
    function drain(timeout) {
      return new syncpromise.SyncPromise((resolve, reject) => {
        let counter = buffer.length;
        if (!counter) {
          return resolve(true);
        }
        const capturedSetTimeout = setTimeout(() => {
          if (timeout && timeout > 0) {
            resolve(false);
          }
        }, timeout);
        buffer.forEach((item) => {
          syncpromise.resolvedSyncPromise(item).then(() => {
            if (!--counter) {
              clearTimeout(capturedSetTimeout);
              resolve(true);
            }
          }, reject);
        });
      });
    }
    return {
      $: buffer,
      add,
      drain
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var error = require_error();
  var syncpromise = require_syncpromise();
  exports.makePromiseBuffer = makePromiseBuffer;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/cookie.js
var require_cookie = __commonJS((exports) => {
  var parseCookie = function(str) {
    const obj = {};
    let index = 0;
    while (index < str.length) {
      const eqIdx = str.indexOf("=", index);
      if (eqIdx === -1) {
        break;
      }
      let endIdx = str.indexOf(";", index);
      if (endIdx === -1) {
        endIdx = str.length;
      } else if (endIdx < eqIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      const key = str.slice(index, eqIdx).trim();
      if (obj[key] === undefined) {
        let val = str.slice(eqIdx + 1, endIdx).trim();
        if (val.charCodeAt(0) === 34) {
          val = val.slice(1, -1);
        }
        try {
          obj[key] = val.indexOf("%") !== -1 ? decodeURIComponent(val) : val;
        } catch (e) {
          obj[key] = val;
        }
      }
      index = endIdx + 1;
    }
    return obj;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseCookie = parseCookie;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/url.js
var require_url = __commonJS((exports) => {
  var parseUrl = function(url) {
    if (!url) {
      return {};
    }
    const match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
    if (!match) {
      return {};
    }
    const query = match[6] || "";
    const fragment = match[8] || "";
    return {
      host: match[4],
      path: match[5],
      protocol: match[2],
      search: query,
      hash: fragment,
      relative: match[5] + query + fragment
    };
  };
  var stripUrlQueryAndFragment = function(urlPath) {
    return urlPath.split(/[\?#]/, 1)[0];
  };
  var getNumberOfUrlSegments = function(url) {
    return url.split(/\\?\//).filter((s) => s.length > 0 && s !== ",").length;
  };
  var getSanitizedUrlString = function(url) {
    const { protocol, host, path } = url;
    const filteredHost = host && host.replace(/^.*@/, "[filtered]:[filtered]@").replace(/(:80)$/, "").replace(/(:443)$/, "") || "";
    return `${protocol ? `${protocol}://` : ""}${filteredHost}${path}`;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getNumberOfUrlSegments = getNumberOfUrlSegments;
  exports.getSanitizedUrlString = getSanitizedUrlString;
  exports.parseUrl = parseUrl;
  exports.stripUrlQueryAndFragment = stripUrlQueryAndFragment;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/requestdata.js
var require_requestdata = __commonJS((exports) => {
  var addRequestDataToTransaction = function(transaction, req, deps) {
    if (!transaction)
      return;
    if (!transaction.metadata.source || transaction.metadata.source === "url") {
      const [name, source] = extractPathForTransaction(req, { path: true, method: true });
      transaction.updateName(name);
      transaction.setMetadata({ source });
    }
    transaction.setAttribute("url", req.originalUrl || req.url);
    if (req.baseUrl) {
      transaction.setAttribute("baseUrl", req.baseUrl);
    }
    transaction.setData("query", extractQueryParams(req, deps));
  };
  var extractPathForTransaction = function(req, options = {}) {
    const method = req.method && req.method.toUpperCase();
    let path = "";
    let source = "url";
    if (options.customRoute || req.route) {
      path = options.customRoute || `${req.baseUrl || ""}${req.route && req.route.path}`;
      source = "route";
    } else if (req.originalUrl || req.url) {
      path = url.stripUrlQueryAndFragment(req.originalUrl || req.url || "");
    }
    let name = "";
    if (options.method && method) {
      name += method;
    }
    if (options.method && options.path) {
      name += " ";
    }
    if (options.path && path) {
      name += path;
    }
    return [name, source];
  };
  var extractTransaction = function(req, type) {
    switch (type) {
      case "path": {
        return extractPathForTransaction(req, { path: true })[0];
      }
      case "handler": {
        return req.route && req.route.stack && req.route.stack[0] && req.route.stack[0].name || "<anonymous>";
      }
      case "methodPath":
      default: {
        const customRoute = req._reconstructedRoute ? req._reconstructedRoute : undefined;
        return extractPathForTransaction(req, { path: true, method: true, customRoute })[0];
      }
    }
  };
  var extractUserData = function(user, keys) {
    const extractedUser = {};
    const attributes = Array.isArray(keys) ? keys : DEFAULT_USER_INCLUDES;
    attributes.forEach((key) => {
      if (user && key in user) {
        extractedUser[key] = user[key];
      }
    });
    return extractedUser;
  };
  var extractRequestData = function(req, options) {
    const { include = DEFAULT_REQUEST_INCLUDES, deps } = options || {};
    const requestData = {};
    const headers = req.headers || {};
    const method = req.method;
    const host = headers.host || req.hostname || req.host || "<no host>";
    const protocol = req.protocol === "https" || req.socket && req.socket.encrypted ? "https" : "http";
    const originalUrl = req.originalUrl || req.url || "";
    const absoluteUrl = originalUrl.startsWith(protocol) ? originalUrl : `${protocol}://${host}${originalUrl}`;
    include.forEach((key) => {
      switch (key) {
        case "headers": {
          requestData.headers = headers;
          if (!include.includes("cookies")) {
            delete requestData.headers.cookie;
          }
          break;
        }
        case "method": {
          requestData.method = method;
          break;
        }
        case "url": {
          requestData.url = absoluteUrl;
          break;
        }
        case "cookies": {
          requestData.cookies = req.cookies || headers.cookie && cookie.parseCookie(headers.cookie) || {};
          break;
        }
        case "query_string": {
          requestData.query_string = extractQueryParams(req, deps);
          break;
        }
        case "data": {
          if (method === "GET" || method === "HEAD") {
            break;
          }
          if (req.body !== undefined) {
            requestData.data = is.isString(req.body) ? req.body : JSON.stringify(normalize.normalize(req.body));
          }
          break;
        }
        default: {
          if ({}.hasOwnProperty.call(req, key)) {
            requestData[key] = req[key];
          }
        }
      }
    });
    return requestData;
  };
  var addRequestDataToEvent = function(event, req, options) {
    const include = {
      ...DEFAULT_INCLUDES,
      ...options && options.include
    };
    if (include.request) {
      const extractedRequestData = Array.isArray(include.request) ? extractRequestData(req, { include: include.request, deps: options && options.deps }) : extractRequestData(req, { deps: options && options.deps });
      event.request = {
        ...event.request,
        ...extractedRequestData
      };
    }
    if (include.user) {
      const extractedUser = req.user && is.isPlainObject(req.user) ? extractUserData(req.user, include.user) : {};
      if (Object.keys(extractedUser).length) {
        event.user = {
          ...event.user,
          ...extractedUser
        };
      }
    }
    if (include.ip) {
      const ip = req.ip || req.socket && req.socket.remoteAddress;
      if (ip) {
        event.user = {
          ...event.user,
          ip_address: ip
        };
      }
    }
    if (include.transaction && !event.transaction) {
      event.transaction = extractTransaction(req, include.transaction);
    }
    return event;
  };
  var extractQueryParams = function(req, deps) {
    let originalUrl = req.originalUrl || req.url || "";
    if (!originalUrl) {
      return;
    }
    if (originalUrl.startsWith("/")) {
      originalUrl = `http://dogs.are.great${originalUrl}`;
    }
    try {
      return req.query || typeof URL !== "undefined" && new URL(originalUrl).search.slice(1) || deps && deps.url && deps.url.parse(originalUrl).query || undefined;
    } catch (e2) {
      return;
    }
  };
  var winterCGHeadersToDict = function(winterCGHeaders) {
    const headers = {};
    try {
      winterCGHeaders.forEach((value, key) => {
        if (typeof value === "string") {
          headers[key] = value;
        }
      });
    } catch (e) {
      debugBuild.DEBUG_BUILD && logger.logger.warn("Sentry failed extracting headers from a request object. If you see this, please file an issue.");
    }
    return headers;
  };
  var winterCGRequestToRequestData = function(req) {
    const headers = winterCGHeadersToDict(req.headers);
    return {
      method: req.method,
      url: req.url,
      headers
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var cookie = require_cookie();
  var debugBuild = require_debug_build();
  var is = require_is();
  var logger = require_logger();
  var normalize = require_normalize();
  var url = require_url();
  var DEFAULT_INCLUDES = {
    ip: false,
    request: true,
    transaction: true,
    user: true
  };
  var DEFAULT_REQUEST_INCLUDES = ["cookies", "data", "headers", "method", "query_string", "url"];
  var DEFAULT_USER_INCLUDES = ["id", "username", "email"];
  exports.DEFAULT_USER_INCLUDES = DEFAULT_USER_INCLUDES;
  exports.addRequestDataToEvent = addRequestDataToEvent;
  exports.addRequestDataToTransaction = addRequestDataToTransaction;
  exports.extractPathForTransaction = extractPathForTransaction;
  exports.extractRequestData = extractRequestData;
  exports.winterCGHeadersToDict = winterCGHeadersToDict;
  exports.winterCGRequestToRequestData = winterCGRequestToRequestData;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/severity.js
var require_severity = __commonJS((exports) => {
  var severityFromString = function(level) {
    return severityLevelFromString(level);
  };
  var severityLevelFromString = function(level) {
    return level === "warn" ? "warning" : validSeverityLevels.includes(level) ? level : "log";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var validSeverityLevels = ["fatal", "error", "warning", "log", "info", "debug"];
  exports.severityFromString = severityFromString;
  exports.severityLevelFromString = severityLevelFromString;
  exports.validSeverityLevels = validSeverityLevels;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/time.js
var require_time = __commonJS((exports) => {
  var dateTimestampInSeconds = function() {
    return Date.now() / ONE_SECOND_IN_MS;
  };
  var createUnixTimestampInSecondsFunc = function() {
    const { performance: performance2 } = worldwide.GLOBAL_OBJ;
    if (!performance2 || !performance2.now) {
      return dateTimestampInSeconds;
    }
    const approxStartingTimeOrigin = Date.now() - performance2.now();
    const timeOrigin = performance2.timeOrigin == undefined ? approxStartingTimeOrigin : performance2.timeOrigin;
    return () => {
      return (timeOrigin + performance2.now()) / ONE_SECOND_IN_MS;
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var worldwide = require_worldwide();
  var ONE_SECOND_IN_MS = 1000;
  var timestampInSeconds = createUnixTimestampInSecondsFunc();
  var timestampWithMs = timestampInSeconds;
  exports._browserPerformanceTimeOriginMode = undefined;
  var browserPerformanceTimeOrigin = (() => {
    const { performance: performance2 } = worldwide.GLOBAL_OBJ;
    if (!performance2 || !performance2.now) {
      exports._browserPerformanceTimeOriginMode = "none";
      return;
    }
    const threshold = 3600 * 1000;
    const performanceNow = performance2.now();
    const dateNow = Date.now();
    const timeOriginDelta = performance2.timeOrigin ? Math.abs(performance2.timeOrigin + performanceNow - dateNow) : threshold;
    const timeOriginIsReliable = timeOriginDelta < threshold;
    const navigationStart = performance2.timing && performance2.timing.navigationStart;
    const hasNavigationStart = typeof navigationStart === "number";
    const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
    const navigationStartIsReliable = navigationStartDelta < threshold;
    if (timeOriginIsReliable || navigationStartIsReliable) {
      if (timeOriginDelta <= navigationStartDelta) {
        exports._browserPerformanceTimeOriginMode = "timeOrigin";
        return performance2.timeOrigin;
      } else {
        exports._browserPerformanceTimeOriginMode = "navigationStart";
        return navigationStart;
      }
    }
    exports._browserPerformanceTimeOriginMode = "dateNow";
    return dateNow;
  })();
  exports.browserPerformanceTimeOrigin = browserPerformanceTimeOrigin;
  exports.dateTimestampInSeconds = dateTimestampInSeconds;
  exports.timestampInSeconds = timestampInSeconds;
  exports.timestampWithMs = timestampWithMs;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/baggage.js
var require_baggage = __commonJS((exports) => {
  var baggageHeaderToDynamicSamplingContext = function(baggageHeader) {
    if (!is.isString(baggageHeader) && !Array.isArray(baggageHeader)) {
      return;
    }
    let baggageObject = {};
    if (Array.isArray(baggageHeader)) {
      baggageObject = baggageHeader.reduce((acc, curr) => {
        const currBaggageObject = baggageHeaderToObject(curr);
        for (const key of Object.keys(currBaggageObject)) {
          acc[key] = currBaggageObject[key];
        }
        return acc;
      }, {});
    } else {
      if (!baggageHeader) {
        return;
      }
      baggageObject = baggageHeaderToObject(baggageHeader);
    }
    const dynamicSamplingContext = Object.entries(baggageObject).reduce((acc, [key, value]) => {
      if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {
        const nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);
        acc[nonPrefixedKey] = value;
      }
      return acc;
    }, {});
    if (Object.keys(dynamicSamplingContext).length > 0) {
      return dynamicSamplingContext;
    } else {
      return;
    }
  };
  var dynamicSamplingContextToSentryBaggageHeader = function(dynamicSamplingContext) {
    if (!dynamicSamplingContext) {
      return;
    }
    const sentryPrefixedDSC = Object.entries(dynamicSamplingContext).reduce((acc, [dscKey, dscValue]) => {
      if (dscValue) {
        acc[`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`] = dscValue;
      }
      return acc;
    }, {});
    return objectToBaggageHeader(sentryPrefixedDSC);
  };
  var baggageHeaderToObject = function(baggageHeader) {
    return baggageHeader.split(",").map((baggageEntry) => baggageEntry.split("=").map((keyOrValue) => decodeURIComponent(keyOrValue.trim()))).reduce((acc, [key, value]) => {
      acc[key] = value;
      return acc;
    }, {});
  };
  var objectToBaggageHeader = function(object) {
    if (Object.keys(object).length === 0) {
      return;
    }
    return Object.entries(object).reduce((baggageHeader, [objectKey, objectValue], currentIndex) => {
      const baggageEntry = `${encodeURIComponent(objectKey)}=${encodeURIComponent(objectValue)}`;
      const newBaggageHeader = currentIndex === 0 ? baggageEntry : `${baggageHeader},${baggageEntry}`;
      if (newBaggageHeader.length > MAX_BAGGAGE_STRING_LENGTH) {
        debugBuild.DEBUG_BUILD && logger.logger.warn(`Not adding key: ${objectKey} with val: ${objectValue} to baggage header due to exceeding baggage size limits.`);
        return baggageHeader;
      } else {
        return newBaggageHeader;
      }
    }, "");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var debugBuild = require_debug_build();
  var is = require_is();
  var logger = require_logger();
  var BAGGAGE_HEADER_NAME = "baggage";
  var SENTRY_BAGGAGE_KEY_PREFIX = "sentry-";
  var SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;
  var MAX_BAGGAGE_STRING_LENGTH = 8192;
  exports.BAGGAGE_HEADER_NAME = BAGGAGE_HEADER_NAME;
  exports.MAX_BAGGAGE_STRING_LENGTH = MAX_BAGGAGE_STRING_LENGTH;
  exports.SENTRY_BAGGAGE_KEY_PREFIX = SENTRY_BAGGAGE_KEY_PREFIX;
  exports.SENTRY_BAGGAGE_KEY_PREFIX_REGEX = SENTRY_BAGGAGE_KEY_PREFIX_REGEX;
  exports.baggageHeaderToDynamicSamplingContext = baggageHeaderToDynamicSamplingContext;
  exports.dynamicSamplingContextToSentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/tracing.js
var require_tracing = __commonJS((exports) => {
  var extractTraceparentData = function(traceparent) {
    if (!traceparent) {
      return;
    }
    const matches = traceparent.match(TRACEPARENT_REGEXP);
    if (!matches) {
      return;
    }
    let parentSampled;
    if (matches[3] === "1") {
      parentSampled = true;
    } else if (matches[3] === "0") {
      parentSampled = false;
    }
    return {
      traceId: matches[1],
      parentSampled,
      parentSpanId: matches[2]
    };
  };
  var tracingContextFromHeaders = function(sentryTrace, baggage$1) {
    const traceparentData = extractTraceparentData(sentryTrace);
    const dynamicSamplingContext = baggage.baggageHeaderToDynamicSamplingContext(baggage$1);
    const { traceId, parentSpanId, parentSampled } = traceparentData || {};
    if (!traceparentData) {
      return {
        traceparentData,
        dynamicSamplingContext: undefined,
        propagationContext: {
          traceId: traceId || misc.uuid4(),
          spanId: misc.uuid4().substring(16)
        }
      };
    } else {
      return {
        traceparentData,
        dynamicSamplingContext: dynamicSamplingContext || {},
        propagationContext: {
          traceId: traceId || misc.uuid4(),
          parentSpanId: parentSpanId || misc.uuid4().substring(16),
          spanId: misc.uuid4().substring(16),
          sampled: parentSampled,
          dsc: dynamicSamplingContext || {}
        }
      };
    }
  };
  var propagationContextFromHeaders = function(sentryTrace, baggage$1) {
    const traceparentData = extractTraceparentData(sentryTrace);
    const dynamicSamplingContext = baggage.baggageHeaderToDynamicSamplingContext(baggage$1);
    const { traceId, parentSpanId, parentSampled } = traceparentData || {};
    if (!traceparentData) {
      return {
        traceId: traceId || misc.uuid4(),
        spanId: misc.uuid4().substring(16)
      };
    } else {
      return {
        traceId: traceId || misc.uuid4(),
        parentSpanId: parentSpanId || misc.uuid4().substring(16),
        spanId: misc.uuid4().substring(16),
        sampled: parentSampled,
        dsc: dynamicSamplingContext || {}
      };
    }
  };
  var generateSentryTraceHeader = function(traceId = misc.uuid4(), spanId = misc.uuid4().substring(16), sampled) {
    let sampledString = "";
    if (sampled !== undefined) {
      sampledString = sampled ? "-1" : "-0";
    }
    return `${traceId}-${spanId}${sampledString}`;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var baggage = require_baggage();
  var misc = require_misc();
  var TRACEPARENT_REGEXP = new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$");
  exports.TRACEPARENT_REGEXP = TRACEPARENT_REGEXP;
  exports.extractTraceparentData = extractTraceparentData;
  exports.generateSentryTraceHeader = generateSentryTraceHeader;
  exports.propagationContextFromHeaders = propagationContextFromHeaders;
  exports.tracingContextFromHeaders = tracingContextFromHeaders;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/envelope.js
var require_envelope = __commonJS((exports) => {
  var createEnvelope = function(headers, items = []) {
    return [headers, items];
  };
  var addItemToEnvelope = function(envelope, newItem) {
    const [headers, items] = envelope;
    return [headers, [...items, newItem]];
  };
  var forEachEnvelopeItem = function(envelope, callback) {
    const envelopeItems = envelope[1];
    for (const envelopeItem of envelopeItems) {
      const envelopeItemType = envelopeItem[0].type;
      const result = callback(envelopeItem, envelopeItemType);
      if (result) {
        return true;
      }
    }
    return false;
  };
  var envelopeContainsItemType = function(envelope, types) {
    return forEachEnvelopeItem(envelope, (_, type) => types.includes(type));
  };
  var encodeUTF8 = function(input, textEncoder) {
    const utf8 = textEncoder || new TextEncoder;
    return utf8.encode(input);
  };
  var serializeEnvelope = function(envelope, textEncoder) {
    const [envHeaders, items] = envelope;
    let parts = JSON.stringify(envHeaders);
    function append(next) {
      if (typeof parts === "string") {
        parts = typeof next === "string" ? parts + next : [encodeUTF8(parts, textEncoder), next];
      } else {
        parts.push(typeof next === "string" ? encodeUTF8(next, textEncoder) : next);
      }
    }
    for (const item of items) {
      const [itemHeaders, payload] = item;
      append(`\n${JSON.stringify(itemHeaders)}\n`);
      if (typeof payload === "string" || payload instanceof Uint8Array) {
        append(payload);
      } else {
        let stringifiedPayload;
        try {
          stringifiedPayload = JSON.stringify(payload);
        } catch (e) {
          stringifiedPayload = JSON.stringify(normalize.normalize(payload));
        }
        append(stringifiedPayload);
      }
    }
    return typeof parts === "string" ? parts : concatBuffers(parts);
  };
  var concatBuffers = function(buffers) {
    const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);
    const merged = new Uint8Array(totalLength);
    let offset = 0;
    for (const buffer of buffers) {
      merged.set(buffer, offset);
      offset += buffer.length;
    }
    return merged;
  };
  var parseEnvelope = function(env, textEncoder, textDecoder) {
    let buffer = typeof env === "string" ? textEncoder.encode(env) : env;
    function readBinary(length) {
      const bin = buffer.subarray(0, length);
      buffer = buffer.subarray(length + 1);
      return bin;
    }
    function readJson() {
      let i = buffer.indexOf(10);
      if (i < 0) {
        i = buffer.length;
      }
      return JSON.parse(textDecoder.decode(readBinary(i)));
    }
    const envelopeHeader = readJson();
    const items = [];
    while (buffer.length) {
      const itemHeader = readJson();
      const binaryLength = typeof itemHeader.length === "number" ? itemHeader.length : undefined;
      items.push([itemHeader, binaryLength ? readBinary(binaryLength) : readJson()]);
    }
    return [envelopeHeader, items];
  };
  var createAttachmentEnvelopeItem = function(attachment, textEncoder) {
    const buffer = typeof attachment.data === "string" ? encodeUTF8(attachment.data, textEncoder) : attachment.data;
    return [
      object.dropUndefinedKeys({
        type: "attachment",
        length: buffer.length,
        filename: attachment.filename,
        content_type: attachment.contentType,
        attachment_type: attachment.attachmentType
      }),
      buffer
    ];
  };
  var envelopeItemTypeToDataCategory = function(type) {
    return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];
  };
  var getSdkMetadataForEnvelopeHeader = function(metadataOrEvent) {
    if (!metadataOrEvent || !metadataOrEvent.sdk) {
      return;
    }
    const { name, version } = metadataOrEvent.sdk;
    return { name, version };
  };
  var createEventEnvelopeHeaders = function(event, sdkInfo, tunnel, dsn$1) {
    const dynamicSamplingContext = event.sdkProcessingMetadata && event.sdkProcessingMetadata.dynamicSamplingContext;
    return {
      event_id: event.event_id,
      sent_at: new Date().toISOString(),
      ...sdkInfo && { sdk: sdkInfo },
      ...!!tunnel && dsn$1 && { dsn: dsn.dsnToString(dsn$1) },
      ...dynamicSamplingContext && {
        trace: object.dropUndefinedKeys({ ...dynamicSamplingContext })
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var dsn = require_dsn();
  var normalize = require_normalize();
  var object = require_object();
  var ITEM_TYPE_TO_DATA_CATEGORY_MAP = {
    session: "session",
    sessions: "session",
    attachment: "attachment",
    transaction: "transaction",
    event: "error",
    client_report: "internal",
    user_report: "default",
    profile: "profile",
    replay_event: "replay",
    replay_recording: "replay",
    check_in: "monitor",
    feedback: "feedback",
    statsd: "unknown"
  };
  exports.addItemToEnvelope = addItemToEnvelope;
  exports.createAttachmentEnvelopeItem = createAttachmentEnvelopeItem;
  exports.createEnvelope = createEnvelope;
  exports.createEventEnvelopeHeaders = createEventEnvelopeHeaders;
  exports.envelopeContainsItemType = envelopeContainsItemType;
  exports.envelopeItemTypeToDataCategory = envelopeItemTypeToDataCategory;
  exports.forEachEnvelopeItem = forEachEnvelopeItem;
  exports.getSdkMetadataForEnvelopeHeader = getSdkMetadataForEnvelopeHeader;
  exports.parseEnvelope = parseEnvelope;
  exports.serializeEnvelope = serializeEnvelope;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/clientreport.js
var require_clientreport = __commonJS((exports) => {
  var createClientReportEnvelope = function(discarded_events, dsn, timestamp) {
    const clientReportItem = [
      { type: "client_report" },
      {
        timestamp: timestamp || time.dateTimestampInSeconds(),
        discarded_events
      }
    ];
    return envelope.createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var envelope = require_envelope();
  var time = require_time();
  exports.createClientReportEnvelope = createClientReportEnvelope;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/ratelimit.js
var require_ratelimit = __commonJS((exports) => {
  var parseRetryAfterHeader = function(header, now = Date.now()) {
    const headerDelay = parseInt(`${header}`, 10);
    if (!isNaN(headerDelay)) {
      return headerDelay * 1000;
    }
    const headerDate = Date.parse(`${header}`);
    if (!isNaN(headerDate)) {
      return headerDate - now;
    }
    return DEFAULT_RETRY_AFTER;
  };
  var disabledUntil = function(limits, category) {
    return limits[category] || limits.all || 0;
  };
  var isRateLimited = function(limits, category, now = Date.now()) {
    return disabledUntil(limits, category) > now;
  };
  var updateRateLimits = function(limits, { statusCode, headers }, now = Date.now()) {
    const updatedRateLimits = {
      ...limits
    };
    const rateLimitHeader = headers && headers["x-sentry-rate-limits"];
    const retryAfterHeader = headers && headers["retry-after"];
    if (rateLimitHeader) {
      for (const limit of rateLimitHeader.trim().split(",")) {
        const [retryAfter, categories] = limit.split(":", 2);
        const headerDelay = parseInt(retryAfter, 10);
        const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000;
        if (!categories) {
          updatedRateLimits.all = now + delay;
        } else {
          for (const category of categories.split(";")) {
            updatedRateLimits[category] = now + delay;
          }
        }
      }
    } else if (retryAfterHeader) {
      updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
    } else if (statusCode === 429) {
      updatedRateLimits.all = now + 60 * 1000;
    }
    return updatedRateLimits;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var DEFAULT_RETRY_AFTER = 60 * 1000;
  exports.DEFAULT_RETRY_AFTER = DEFAULT_RETRY_AFTER;
  exports.disabledUntil = disabledUntil;
  exports.isRateLimited = isRateLimited;
  exports.parseRetryAfterHeader = parseRetryAfterHeader;
  exports.updateRateLimits = updateRateLimits;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/userIntegrations.js
var require_userIntegrations = __commonJS((exports) => {
  var setNestedKey = function(obj, keyPath, value) {
    const match = keyPath.match(/([a-z_]+)\.(.*)/i);
    if (match === null) {
      obj[keyPath] = value;
    } else {
      const innerObj = obj[match[1]];
      setNestedKey(innerObj, match[2], value);
    }
  };
  var addOrUpdateIntegration = function(defaultIntegrationInstance, userIntegrations, forcedOptions = {}) {
    return Array.isArray(userIntegrations) ? addOrUpdateIntegrationInArray(defaultIntegrationInstance, userIntegrations, forcedOptions) : addOrUpdateIntegrationInFunction(defaultIntegrationInstance, userIntegrations, forcedOptions);
  };
  var addOrUpdateIntegrationInArray = function(defaultIntegrationInstance, userIntegrations, forcedOptions) {
    const userInstance = userIntegrations.find((integration) => integration.name === defaultIntegrationInstance.name);
    if (userInstance) {
      for (const [keyPath, value] of Object.entries(forcedOptions)) {
        setNestedKey(userInstance, keyPath, value);
      }
      return userIntegrations;
    }
    return [...userIntegrations, defaultIntegrationInstance];
  };
  var addOrUpdateIntegrationInFunction = function(defaultIntegrationInstance, userIntegrationsFunc, forcedOptions) {
    const wrapper = (defaultIntegrations) => {
      const userFinalIntegrations = userIntegrationsFunc(defaultIntegrations);
      if (defaultIntegrationInstance.allowExclusionByUser) {
        const userFinalInstance = userFinalIntegrations.find((integration) => integration.name === defaultIntegrationInstance.name);
        if (!userFinalInstance) {
          return userFinalIntegrations;
        }
      }
      return addOrUpdateIntegrationInArray(defaultIntegrationInstance, userFinalIntegrations, forcedOptions);
    };
    return wrapper;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.addOrUpdateIntegration = addOrUpdateIntegration;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/cache.js
var require_cache = __commonJS((exports) => {
  var makeFifoCache = function(size) {
    let evictionOrder = [];
    let cache = {};
    return {
      add(key, value) {
        while (evictionOrder.length >= size) {
          const evictCandidate = evictionOrder.shift();
          if (evictCandidate !== undefined) {
            delete cache[evictCandidate];
          }
        }
        if (cache[key]) {
          this.delete(key);
        }
        evictionOrder.push(key);
        cache[key] = value;
      },
      clear() {
        cache = {};
        evictionOrder = [];
      },
      get(key) {
        return cache[key];
      },
      size() {
        return evictionOrder.length;
      },
      delete(key) {
        if (!cache[key]) {
          return false;
        }
        delete cache[key];
        for (let i = 0;i < evictionOrder.length; i++) {
          if (evictionOrder[i] === key) {
            evictionOrder.splice(i, 1);
            break;
          }
        }
        return true;
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.makeFifoCache = makeFifoCache;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/eventbuilder.js
var require_eventbuilder = __commonJS((exports) => {
  var parseStackFrames = function(stackParser, error) {
    return stackParser(error.stack || "", 1);
  };
  var exceptionFromError = function(stackParser, error) {
    const exception = {
      type: error.name || error.constructor.name,
      value: error.message
    };
    const frames = parseStackFrames(stackParser, error);
    if (frames.length) {
      exception.stacktrace = { frames };
    }
    return exception;
  };
  var getMessageForObject = function(exception) {
    if ("name" in exception && typeof exception.name === "string") {
      let message = `'${exception.name}' captured as exception`;
      if ("message" in exception && typeof exception.message === "string") {
        message += ` with message '${exception.message}'`;
      }
      return message;
    } else if ("message" in exception && typeof exception.message === "string") {
      return exception.message;
    } else {
      return `Object captured as exception with keys: ${object.extractExceptionKeysForMessage(exception)}`;
    }
  };
  var eventFromUnknownInput = function(getHubOrClient, stackParser, exception, hint) {
    const client = typeof getHubOrClient === "function" ? getHubOrClient().getClient() : getHubOrClient;
    let ex = exception;
    const providedMechanism = hint && hint.data && hint.data.mechanism;
    const mechanism = providedMechanism || {
      handled: true,
      type: "generic"
    };
    let extras;
    if (!is.isError(exception)) {
      if (is.isPlainObject(exception)) {
        const normalizeDepth = client && client.getOptions().normalizeDepth;
        extras = { ["__serialized__"]: normalize.normalizeToSize(exception, normalizeDepth) };
        const message = getMessageForObject(exception);
        ex = hint && hint.syntheticException || new Error(message);
        ex.message = message;
      } else {
        ex = hint && hint.syntheticException || new Error(exception);
        ex.message = exception;
      }
      mechanism.synthetic = true;
    }
    const event = {
      exception: {
        values: [exceptionFromError(stackParser, ex)]
      }
    };
    if (extras) {
      event.extra = extras;
    }
    misc.addExceptionTypeValue(event, undefined, undefined);
    misc.addExceptionMechanism(event, mechanism);
    return {
      ...event,
      event_id: hint && hint.event_id
    };
  };
  var eventFromMessage = function(stackParser, message, level = "info", hint, attachStacktrace) {
    const event = {
      event_id: hint && hint.event_id,
      level
    };
    if (attachStacktrace && hint && hint.syntheticException) {
      const frames = parseStackFrames(stackParser, hint.syntheticException);
      if (frames.length) {
        event.exception = {
          values: [
            {
              value: message,
              stacktrace: { frames }
            }
          ]
        };
      }
    }
    if (is.isParameterizedString(message)) {
      const { __sentry_template_string__, __sentry_template_values__ } = message;
      event.logentry = {
        message: __sentry_template_string__,
        params: __sentry_template_values__
      };
      return event;
    }
    event.message = message;
    return event;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var is = require_is();
  var misc = require_misc();
  var normalize = require_normalize();
  var object = require_object();
  exports.eventFromMessage = eventFromMessage;
  exports.eventFromUnknownInput = eventFromUnknownInput;
  exports.exceptionFromError = exceptionFromError;
  exports.parseStackFrames = parseStackFrames;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/anr.js
var require_anr = __commonJS((exports) => {
  var watchdogTimer = function(createTimer, pollInterval, anrThreshold, callback) {
    const timer = createTimer();
    let triggered = false;
    let enabled = true;
    setInterval(() => {
      const diffMs = timer.getTimeMs();
      if (triggered === false && diffMs > pollInterval + anrThreshold) {
        triggered = true;
        if (enabled) {
          callback();
        }
      }
      if (diffMs < pollInterval + anrThreshold) {
        triggered = false;
      }
    }, 20);
    return {
      poll: () => {
        timer.reset();
      },
      enabled: (state) => {
        enabled = state;
      }
    };
  };
  var callFrameToStackFrame = function(frame, url, getModuleFromFilename) {
    const filename = url ? url.replace(/^file:\/\//, "") : undefined;
    const colno = frame.location.columnNumber ? frame.location.columnNumber + 1 : undefined;
    const lineno = frame.location.lineNumber ? frame.location.lineNumber + 1 : undefined;
    return object.dropUndefinedKeys({
      filename,
      module: getModuleFromFilename(filename),
      function: frame.functionName || "?",
      colno,
      lineno,
      in_app: filename ? nodeStackTrace.filenameIsInApp(filename) : undefined
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var object = require_object();
  var nodeStackTrace = require_node_stack_trace();
  exports.callFrameToStackFrame = callFrameToStackFrame;
  exports.watchdogTimer = watchdogTimer;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/lru.js
var require_lru = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class LRUMap {
    constructor(_maxSize) {
      this._maxSize = _maxSize;
      this._cache = new Map;
    }
    get size() {
      return this._cache.size;
    }
    get(key) {
      const value = this._cache.get(key);
      if (value === undefined) {
        return;
      }
      this._cache.delete(key);
      this._cache.set(key, value);
      return value;
    }
    set(key, value) {
      if (this._cache.size >= this._maxSize) {
        this._cache.delete(this._cache.keys().next().value);
      }
      this._cache.set(key, value);
    }
    remove(key) {
      const value = this._cache.get(key);
      if (value) {
        this._cache.delete(key);
      }
      return value;
    }
    clear() {
      this._cache.clear();
    }
    keys() {
      return Array.from(this._cache.keys());
    }
    values() {
      const values = [];
      this._cache.forEach((value) => values.push(value));
      return values;
    }
  }
  exports.LRUMap = LRUMap;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/buildPolyfills/_nullishCoalesce.js
var require__nullishCoalesce = __commonJS((exports) => {
  var _nullishCoalesce = function(lhs, rhsFn) {
    return lhs != null ? lhs : rhsFn();
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._nullishCoalesce = _nullishCoalesce;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/buildPolyfills/_asyncNullishCoalesce.js
var require__asyncNullishCoalesce = __commonJS((exports) => {
  async function _asyncNullishCoalesce(lhs, rhsFn) {
    return _nullishCoalesce._nullishCoalesce(lhs, rhsFn);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  var _nullishCoalesce = require__nullishCoalesce();
  exports._asyncNullishCoalesce = _asyncNullishCoalesce;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/buildPolyfills/_asyncOptionalChain.js
var require__asyncOptionalChain = __commonJS((exports) => {
  async function _asyncOptionalChain(ops) {
    let lastAccessLHS = undefined;
    let value = ops[0];
    let i = 1;
    while (i < ops.length) {
      const op = ops[i];
      const fn = ops[i + 1];
      i += 2;
      if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
        return;
      }
      if (op === "access" || op === "optionalAccess") {
        lastAccessLHS = value;
        value = await fn(value);
      } else if (op === "call" || op === "optionalCall") {
        value = await fn((...args) => value.call(lastAccessLHS, ...args));
        lastAccessLHS = undefined;
      }
    }
    return value;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._asyncOptionalChain = _asyncOptionalChain;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/buildPolyfills/_asyncOptionalChainDelete.js
var require__asyncOptionalChainDelete = __commonJS((exports) => {
  async function _asyncOptionalChainDelete(ops) {
    const result = await _asyncOptionalChain._asyncOptionalChain(ops);
    return result == null ? true : result;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  var _asyncOptionalChain = require__asyncOptionalChain();
  exports._asyncOptionalChainDelete = _asyncOptionalChainDelete;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/buildPolyfills/_optionalChain.js
var require__optionalChain = __commonJS((exports) => {
  var _optionalChain = function(ops) {
    let lastAccessLHS = undefined;
    let value = ops[0];
    let i = 1;
    while (i < ops.length) {
      const op = ops[i];
      const fn = ops[i + 1];
      i += 2;
      if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
        return;
      }
      if (op === "access" || op === "optionalAccess") {
        lastAccessLHS = value;
        value = fn(value);
      } else if (op === "call" || op === "optionalCall") {
        value = fn((...args) => value.call(lastAccessLHS, ...args));
        lastAccessLHS = undefined;
      }
    }
    return value;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._optionalChain = _optionalChain;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/buildPolyfills/_optionalChainDelete.js
var require__optionalChainDelete = __commonJS((exports) => {
  var _optionalChainDelete = function(ops) {
    const result = _optionalChain._optionalChain(ops);
    return result == null ? true : result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var _optionalChain = require__optionalChain();
  exports._optionalChainDelete = _optionalChainDelete;
});

// ../node_modules/.pnpm/@sentry+utils@7.100.1/node_modules/@sentry/utils/cjs/vendor/escapeStringForRegex.js
var require_escapeStringForRegex = __commonJS((exports) => {
  var escapeStringForRegex = function(regexString) {
    return regexString.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.escapeStringForRegex = escapeStringForRegex;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/utils/cjs/index.js
var require_cjs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var aggregateErrors = require_aggregate_errors();
  var browser = require_browser();
  var dsn = require_dsn();
  var error = require_error();
  var worldwide = require_worldwide();
  var index = require_instrument();
  var is = require_is();
  var isBrowser = require_isBrowser();
  var logger = require_logger();
  var memo = require_memo();
  var misc = require_misc();
  var node = require_node();
  var normalize = require_normalize();
  var object = require_object();
  var path = require_path();
  var promisebuffer = require_promisebuffer();
  var requestdata = require_requestdata();
  var severity = require_severity();
  var stacktrace = require_stacktrace();
  var string = require_string();
  var supports = require_supports();
  var syncpromise = require_syncpromise();
  var time = require_time();
  var tracing = require_tracing();
  var env = require_env();
  var envelope = require_envelope();
  var clientreport = require_clientreport();
  var ratelimit = require_ratelimit();
  var baggage = require_baggage();
  var url = require_url();
  var userIntegrations = require_userIntegrations();
  var cache = require_cache();
  var eventbuilder = require_eventbuilder();
  var anr = require_anr();
  var lru = require_lru();
  var _asyncNullishCoalesce = require__asyncNullishCoalesce();
  var _asyncOptionalChain = require__asyncOptionalChain();
  var _asyncOptionalChainDelete = require__asyncOptionalChainDelete();
  var _nullishCoalesce = require__nullishCoalesce();
  var _optionalChain = require__optionalChain();
  var _optionalChainDelete = require__optionalChainDelete();
  var console2 = require_console();
  var dom = require_dom();
  var xhr = require_xhr();
  var fetch2 = require_fetch();
  var history = require_history();
  var globalError = require_globalError();
  var globalUnhandledRejection = require_globalUnhandledRejection();
  var _handlers = require__handlers();
  var nodeStackTrace = require_node_stack_trace();
  var escapeStringForRegex = require_escapeStringForRegex();
  var supportsHistory = require_supportsHistory();
  exports.applyAggregateErrorsToEvent = aggregateErrors.applyAggregateErrorsToEvent;
  exports.getComponentName = browser.getComponentName;
  exports.getDomElement = browser.getDomElement;
  exports.getLocationHref = browser.getLocationHref;
  exports.htmlTreeAsString = browser.htmlTreeAsString;
  exports.dsnFromString = dsn.dsnFromString;
  exports.dsnToString = dsn.dsnToString;
  exports.makeDsn = dsn.makeDsn;
  exports.SentryError = error.SentryError;
  exports.GLOBAL_OBJ = worldwide.GLOBAL_OBJ;
  exports.getGlobalObject = worldwide.getGlobalObject;
  exports.getGlobalSingleton = worldwide.getGlobalSingleton;
  exports.addInstrumentationHandler = index.addInstrumentationHandler;
  exports.isDOMError = is.isDOMError;
  exports.isDOMException = is.isDOMException;
  exports.isElement = is.isElement;
  exports.isError = is.isError;
  exports.isErrorEvent = is.isErrorEvent;
  exports.isEvent = is.isEvent;
  exports.isInstanceOf = is.isInstanceOf;
  exports.isNaN = is.isNaN;
  exports.isParameterizedString = is.isParameterizedString;
  exports.isPlainObject = is.isPlainObject;
  exports.isPrimitive = is.isPrimitive;
  exports.isRegExp = is.isRegExp;
  exports.isString = is.isString;
  exports.isSyntheticEvent = is.isSyntheticEvent;
  exports.isThenable = is.isThenable;
  exports.isVueViewModel = is.isVueViewModel;
  exports.isBrowser = isBrowser.isBrowser;
  exports.CONSOLE_LEVELS = logger.CONSOLE_LEVELS;
  exports.consoleSandbox = logger.consoleSandbox;
  exports.logger = logger.logger;
  exports.originalConsoleMethods = logger.originalConsoleMethods;
  exports.memoBuilder = memo.memoBuilder;
  exports.addContextToFrame = misc.addContextToFrame;
  exports.addExceptionMechanism = misc.addExceptionMechanism;
  exports.addExceptionTypeValue = misc.addExceptionTypeValue;
  exports.arrayify = misc.arrayify;
  exports.checkOrSetAlreadyCaught = misc.checkOrSetAlreadyCaught;
  exports.getEventDescription = misc.getEventDescription;
  exports.parseSemver = misc.parseSemver;
  exports.uuid4 = misc.uuid4;
  exports.dynamicRequire = node.dynamicRequire;
  exports.isNodeEnv = node.isNodeEnv;
  exports.loadModule = node.loadModule;
  exports.normalize = normalize.normalize;
  exports.normalizeToSize = normalize.normalizeToSize;
  exports.normalizeUrlToBase = normalize.normalizeUrlToBase;
  exports.walk = normalize.walk;
  exports.addNonEnumerableProperty = object.addNonEnumerableProperty;
  exports.convertToPlainObject = object.convertToPlainObject;
  exports.dropUndefinedKeys = object.dropUndefinedKeys;
  exports.extractExceptionKeysForMessage = object.extractExceptionKeysForMessage;
  exports.fill = object.fill;
  exports.getOriginalFunction = object.getOriginalFunction;
  exports.markFunctionWrapped = object.markFunctionWrapped;
  exports.objectify = object.objectify;
  exports.urlEncode = object.urlEncode;
  exports.basename = path.basename;
  exports.dirname = path.dirname;
  exports.isAbsolute = path.isAbsolute;
  exports.join = path.join;
  exports.normalizePath = path.normalizePath;
  exports.relative = path.relative;
  exports.resolve = path.resolve;
  exports.makePromiseBuffer = promisebuffer.makePromiseBuffer;
  exports.DEFAULT_USER_INCLUDES = requestdata.DEFAULT_USER_INCLUDES;
  exports.addRequestDataToEvent = requestdata.addRequestDataToEvent;
  exports.addRequestDataToTransaction = requestdata.addRequestDataToTransaction;
  exports.extractPathForTransaction = requestdata.extractPathForTransaction;
  exports.extractRequestData = requestdata.extractRequestData;
  exports.winterCGHeadersToDict = requestdata.winterCGHeadersToDict;
  exports.winterCGRequestToRequestData = requestdata.winterCGRequestToRequestData;
  exports.severityFromString = severity.severityFromString;
  exports.severityLevelFromString = severity.severityLevelFromString;
  exports.validSeverityLevels = severity.validSeverityLevels;
  exports.createStackParser = stacktrace.createStackParser;
  exports.getFunctionName = stacktrace.getFunctionName;
  exports.nodeStackLineParser = stacktrace.nodeStackLineParser;
  exports.stackParserFromStackParserOptions = stacktrace.stackParserFromStackParserOptions;
  exports.stripSentryFramesAndReverse = stacktrace.stripSentryFramesAndReverse;
  exports.isMatchingPattern = string.isMatchingPattern;
  exports.safeJoin = string.safeJoin;
  exports.snipLine = string.snipLine;
  exports.stringMatchesSomePattern = string.stringMatchesSomePattern;
  exports.truncate = string.truncate;
  exports.isNativeFetch = supports.isNativeFetch;
  exports.supportsDOMError = supports.supportsDOMError;
  exports.supportsDOMException = supports.supportsDOMException;
  exports.supportsErrorEvent = supports.supportsErrorEvent;
  exports.supportsFetch = supports.supportsFetch;
  exports.supportsNativeFetch = supports.supportsNativeFetch;
  exports.supportsReferrerPolicy = supports.supportsReferrerPolicy;
  exports.supportsReportingObserver = supports.supportsReportingObserver;
  exports.SyncPromise = syncpromise.SyncPromise;
  exports.rejectedSyncPromise = syncpromise.rejectedSyncPromise;
  exports.resolvedSyncPromise = syncpromise.resolvedSyncPromise;
  Object.defineProperty(exports, "_browserPerformanceTimeOriginMode", {
    enumerable: true,
    get: () => time._browserPerformanceTimeOriginMode
  });
  exports.browserPerformanceTimeOrigin = time.browserPerformanceTimeOrigin;
  exports.dateTimestampInSeconds = time.dateTimestampInSeconds;
  exports.timestampInSeconds = time.timestampInSeconds;
  exports.timestampWithMs = time.timestampWithMs;
  exports.TRACEPARENT_REGEXP = tracing.TRACEPARENT_REGEXP;
  exports.extractTraceparentData = tracing.extractTraceparentData;
  exports.generateSentryTraceHeader = tracing.generateSentryTraceHeader;
  exports.propagationContextFromHeaders = tracing.propagationContextFromHeaders;
  exports.tracingContextFromHeaders = tracing.tracingContextFromHeaders;
  exports.getSDKSource = env.getSDKSource;
  exports.isBrowserBundle = env.isBrowserBundle;
  exports.addItemToEnvelope = envelope.addItemToEnvelope;
  exports.createAttachmentEnvelopeItem = envelope.createAttachmentEnvelopeItem;
  exports.createEnvelope = envelope.createEnvelope;
  exports.createEventEnvelopeHeaders = envelope.createEventEnvelopeHeaders;
  exports.envelopeContainsItemType = envelope.envelopeContainsItemType;
  exports.envelopeItemTypeToDataCategory = envelope.envelopeItemTypeToDataCategory;
  exports.forEachEnvelopeItem = envelope.forEachEnvelopeItem;
  exports.getSdkMetadataForEnvelopeHeader = envelope.getSdkMetadataForEnvelopeHeader;
  exports.parseEnvelope = envelope.parseEnvelope;
  exports.serializeEnvelope = envelope.serializeEnvelope;
  exports.createClientReportEnvelope = clientreport.createClientReportEnvelope;
  exports.DEFAULT_RETRY_AFTER = ratelimit.DEFAULT_RETRY_AFTER;
  exports.disabledUntil = ratelimit.disabledUntil;
  exports.isRateLimited = ratelimit.isRateLimited;
  exports.parseRetryAfterHeader = ratelimit.parseRetryAfterHeader;
  exports.updateRateLimits = ratelimit.updateRateLimits;
  exports.BAGGAGE_HEADER_NAME = baggage.BAGGAGE_HEADER_NAME;
  exports.MAX_BAGGAGE_STRING_LENGTH = baggage.MAX_BAGGAGE_STRING_LENGTH;
  exports.SENTRY_BAGGAGE_KEY_PREFIX = baggage.SENTRY_BAGGAGE_KEY_PREFIX;
  exports.SENTRY_BAGGAGE_KEY_PREFIX_REGEX = baggage.SENTRY_BAGGAGE_KEY_PREFIX_REGEX;
  exports.baggageHeaderToDynamicSamplingContext = baggage.baggageHeaderToDynamicSamplingContext;
  exports.dynamicSamplingContextToSentryBaggageHeader = baggage.dynamicSamplingContextToSentryBaggageHeader;
  exports.getNumberOfUrlSegments = url.getNumberOfUrlSegments;
  exports.getSanitizedUrlString = url.getSanitizedUrlString;
  exports.parseUrl = url.parseUrl;
  exports.stripUrlQueryAndFragment = url.stripUrlQueryAndFragment;
  exports.addOrUpdateIntegration = userIntegrations.addOrUpdateIntegration;
  exports.makeFifoCache = cache.makeFifoCache;
  exports.eventFromMessage = eventbuilder.eventFromMessage;
  exports.eventFromUnknownInput = eventbuilder.eventFromUnknownInput;
  exports.exceptionFromError = eventbuilder.exceptionFromError;
  exports.parseStackFrames = eventbuilder.parseStackFrames;
  exports.callFrameToStackFrame = anr.callFrameToStackFrame;
  exports.watchdogTimer = anr.watchdogTimer;
  exports.LRUMap = lru.LRUMap;
  exports._asyncNullishCoalesce = _asyncNullishCoalesce._asyncNullishCoalesce;
  exports._asyncOptionalChain = _asyncOptionalChain._asyncOptionalChain;
  exports._asyncOptionalChainDelete = _asyncOptionalChainDelete._asyncOptionalChainDelete;
  exports._nullishCoalesce = _nullishCoalesce._nullishCoalesce;
  exports._optionalChain = _optionalChain._optionalChain;
  exports._optionalChainDelete = _optionalChainDelete._optionalChainDelete;
  exports.addConsoleInstrumentationHandler = console2.addConsoleInstrumentationHandler;
  exports.addClickKeypressInstrumentationHandler = dom.addClickKeypressInstrumentationHandler;
  exports.SENTRY_XHR_DATA_KEY = xhr.SENTRY_XHR_DATA_KEY;
  exports.addXhrInstrumentationHandler = xhr.addXhrInstrumentationHandler;
  exports.addFetchInstrumentationHandler = fetch2.addFetchInstrumentationHandler;
  exports.addHistoryInstrumentationHandler = history.addHistoryInstrumentationHandler;
  exports.addGlobalErrorInstrumentationHandler = globalError.addGlobalErrorInstrumentationHandler;
  exports.addGlobalUnhandledRejectionInstrumentationHandler = globalUnhandledRejection.addGlobalUnhandledRejectionInstrumentationHandler;
  exports.resetInstrumentationHandlers = _handlers.resetInstrumentationHandlers;
  exports.filenameIsInApp = nodeStackTrace.filenameIsInApp;
  exports.escapeStringForRegex = escapeStringForRegex.escapeStringForRegex;
  exports.supportsHistory = supportsHistory.supportsHistory;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/debug-build.js
var require_debug_build2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
  exports.DEBUG_BUILD = DEBUG_BUILD;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/constants.js
var require_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var DEFAULT_ENVIRONMENT = "production";
  exports.DEFAULT_ENVIRONMENT = DEFAULT_ENVIRONMENT;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/eventProcessors.js
var require_eventProcessors = __commonJS((exports) => {
  var getGlobalEventProcessors = function() {
    return utils.getGlobalSingleton("globalEventProcessors", () => []);
  };
  var addGlobalEventProcessor = function(callback) {
    getGlobalEventProcessors().push(callback);
  };
  var notifyEventProcessors = function(processors, event, hint, index = 0) {
    return new utils.SyncPromise((resolve, reject) => {
      const processor = processors[index];
      if (event === null || typeof processor !== "function") {
        resolve(event);
      } else {
        const result = processor({ ...event }, hint);
        debugBuild.DEBUG_BUILD && processor.id && result === null && utils.logger.log(`Event processor "${processor.id}" dropped event`);
        if (utils.isThenable(result)) {
          result.then((final) => notifyEventProcessors(processors, final, hint, index + 1).then(resolve)).then(null, reject);
        } else {
          notifyEventProcessors(processors, result, hint, index + 1).then(resolve).then(null, reject);
        }
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var debugBuild = require_debug_build2();
  exports.addGlobalEventProcessor = addGlobalEventProcessor;
  exports.getGlobalEventProcessors = getGlobalEventProcessors;
  exports.notifyEventProcessors = notifyEventProcessors;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/session.js
var require_session = __commonJS((exports) => {
  var makeSession = function(context) {
    const startingTime = utils.timestampInSeconds();
    const session = {
      sid: utils.uuid4(),
      init: true,
      timestamp: startingTime,
      started: startingTime,
      duration: 0,
      status: "ok",
      errors: 0,
      ignoreDuration: false,
      toJSON: () => sessionToJSON(session)
    };
    if (context) {
      updateSession(session, context);
    }
    return session;
  };
  var updateSession = function(session, context = {}) {
    if (context.user) {
      if (!session.ipAddress && context.user.ip_address) {
        session.ipAddress = context.user.ip_address;
      }
      if (!session.did && !context.did) {
        session.did = context.user.id || context.user.email || context.user.username;
      }
    }
    session.timestamp = context.timestamp || utils.timestampInSeconds();
    if (context.abnormal_mechanism) {
      session.abnormal_mechanism = context.abnormal_mechanism;
    }
    if (context.ignoreDuration) {
      session.ignoreDuration = context.ignoreDuration;
    }
    if (context.sid) {
      session.sid = context.sid.length === 32 ? context.sid : utils.uuid4();
    }
    if (context.init !== undefined) {
      session.init = context.init;
    }
    if (!session.did && context.did) {
      session.did = `${context.did}`;
    }
    if (typeof context.started === "number") {
      session.started = context.started;
    }
    if (session.ignoreDuration) {
      session.duration = undefined;
    } else if (typeof context.duration === "number") {
      session.duration = context.duration;
    } else {
      const duration = session.timestamp - session.started;
      session.duration = duration >= 0 ? duration : 0;
    }
    if (context.release) {
      session.release = context.release;
    }
    if (context.environment) {
      session.environment = context.environment;
    }
    if (!session.ipAddress && context.ipAddress) {
      session.ipAddress = context.ipAddress;
    }
    if (!session.userAgent && context.userAgent) {
      session.userAgent = context.userAgent;
    }
    if (typeof context.errors === "number") {
      session.errors = context.errors;
    }
    if (context.status) {
      session.status = context.status;
    }
  };
  var closeSession = function(session, status) {
    let context = {};
    if (status) {
      context = { status };
    } else if (session.status === "ok") {
      context = { status: "exited" };
    }
    updateSession(session, context);
  };
  var sessionToJSON = function(session) {
    return utils.dropUndefinedKeys({
      sid: `${session.sid}`,
      init: session.init,
      started: new Date(session.started * 1000).toISOString(),
      timestamp: new Date(session.timestamp * 1000).toISOString(),
      status: session.status,
      errors: session.errors,
      did: typeof session.did === "number" || typeof session.did === "string" ? `${session.did}` : undefined,
      duration: session.duration,
      abnormal_mechanism: session.abnormal_mechanism,
      attrs: {
        release: session.release,
        environment: session.environment,
        ip_address: session.ipAddress,
        user_agent: session.userAgent
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  exports.closeSession = closeSession;
  exports.makeSession = makeSession;
  exports.updateSession = updateSession;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/utils/spanUtils.js
var require_spanUtils = __commonJS((exports) => {
  var spanToTraceContext = function(span) {
    const { spanId: span_id, traceId: trace_id } = span.spanContext();
    const { data, op, parent_span_id, status, tags, origin } = spanToJSON(span);
    return utils.dropUndefinedKeys({
      data,
      op,
      parent_span_id,
      span_id,
      status,
      tags,
      trace_id,
      origin
    });
  };
  var spanToTraceHeader = function(span) {
    const { traceId, spanId } = span.spanContext();
    const sampled = spanIsSampled(span);
    return utils.generateSentryTraceHeader(traceId, spanId, sampled);
  };
  var spanTimeInputToSeconds = function(input) {
    if (typeof input === "number") {
      return ensureTimestampInSeconds(input);
    }
    if (Array.isArray(input)) {
      return input[0] + input[1] / 1e9;
    }
    if (input instanceof Date) {
      return ensureTimestampInSeconds(input.getTime());
    }
    return utils.timestampInSeconds();
  };
  var ensureTimestampInSeconds = function(timestamp) {
    const isMs = timestamp > 9999999999;
    return isMs ? timestamp / 1000 : timestamp;
  };
  var spanToJSON = function(span) {
    if (spanIsSpanClass(span)) {
      return span.getSpanJSON();
    }
    if (typeof span.toJSON === "function") {
      return span.toJSON();
    }
    return {};
  };
  var spanIsSpanClass = function(span) {
    return typeof span.getSpanJSON === "function";
  };
  var spanIsSampled = function(span) {
    const { traceFlags } = span.spanContext();
    return Boolean(traceFlags & TRACE_FLAG_SAMPLED);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var TRACE_FLAG_NONE = 0;
  var TRACE_FLAG_SAMPLED = 1;
  exports.TRACE_FLAG_NONE = TRACE_FLAG_NONE;
  exports.TRACE_FLAG_SAMPLED = TRACE_FLAG_SAMPLED;
  exports.spanIsSampled = spanIsSampled;
  exports.spanTimeInputToSeconds = spanTimeInputToSeconds;
  exports.spanToJSON = spanToJSON;
  exports.spanToTraceContext = spanToTraceContext;
  exports.spanToTraceHeader = spanToTraceHeader;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/utils/prepareEvent.js
var require_prepareEvent = __commonJS((exports) => {
  var prepareEvent = function(options, event, hint, scope$1, client, isolationScope) {
    const { normalizeDepth = 3, normalizeMaxBreadth = 1000 } = options;
    const prepared = {
      ...event,
      event_id: event.event_id || hint.event_id || utils.uuid4(),
      timestamp: event.timestamp || utils.dateTimestampInSeconds()
    };
    const integrations = hint.integrations || options.integrations.map((i) => i.name);
    applyClientOptions(prepared, options);
    applyIntegrationsMetadata(prepared, integrations);
    if (event.type === undefined) {
      applyDebugIds(prepared, options.stackParser);
    }
    const finalScope = getFinalScope(scope$1, hint.captureContext);
    if (hint.mechanism) {
      utils.addExceptionMechanism(prepared, hint.mechanism);
    }
    const clientEventProcessors = client && client.getEventProcessors ? client.getEventProcessors() : [];
    const data = scope.getGlobalScope().getScopeData();
    if (isolationScope) {
      const isolationData = isolationScope.getScopeData();
      applyScopeDataToEvent.mergeScopeData(data, isolationData);
    }
    if (finalScope) {
      const finalScopeData = finalScope.getScopeData();
      applyScopeDataToEvent.mergeScopeData(data, finalScopeData);
    }
    const attachments = [...hint.attachments || [], ...data.attachments];
    if (attachments.length) {
      hint.attachments = attachments;
    }
    applyScopeDataToEvent.applyScopeDataToEvent(prepared, data);
    const eventProcessors$1 = [
      ...clientEventProcessors,
      ...eventProcessors.getGlobalEventProcessors(),
      ...data.eventProcessors
    ];
    const result = eventProcessors.notifyEventProcessors(eventProcessors$1, prepared, hint);
    return result.then((evt) => {
      if (evt) {
        applyDebugMeta(evt);
      }
      if (typeof normalizeDepth === "number" && normalizeDepth > 0) {
        return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
      }
      return evt;
    });
  };
  var applyClientOptions = function(event, options) {
    const { environment, release, dist, maxValueLength = 250 } = options;
    if (!("environment" in event)) {
      event.environment = "environment" in options ? environment : constants.DEFAULT_ENVIRONMENT;
    }
    if (event.release === undefined && release !== undefined) {
      event.release = release;
    }
    if (event.dist === undefined && dist !== undefined) {
      event.dist = dist;
    }
    if (event.message) {
      event.message = utils.truncate(event.message, maxValueLength);
    }
    const exception = event.exception && event.exception.values && event.exception.values[0];
    if (exception && exception.value) {
      exception.value = utils.truncate(exception.value, maxValueLength);
    }
    const request = event.request;
    if (request && request.url) {
      request.url = utils.truncate(request.url, maxValueLength);
    }
  };
  var applyDebugIds = function(event, stackParser) {
    const debugIdMap = utils.GLOBAL_OBJ._sentryDebugIds;
    if (!debugIdMap) {
      return;
    }
    let debugIdStackFramesCache;
    const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);
    if (cachedDebugIdStackFrameCache) {
      debugIdStackFramesCache = cachedDebugIdStackFrameCache;
    } else {
      debugIdStackFramesCache = new Map;
      debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);
    }
    const filenameDebugIdMap = Object.keys(debugIdMap).reduce((acc, debugIdStackTrace) => {
      let parsedStack;
      const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);
      if (cachedParsedStack) {
        parsedStack = cachedParsedStack;
      } else {
        parsedStack = stackParser(debugIdStackTrace);
        debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);
      }
      for (let i = parsedStack.length - 1;i >= 0; i--) {
        const stackFrame = parsedStack[i];
        if (stackFrame.filename) {
          acc[stackFrame.filename] = debugIdMap[debugIdStackTrace];
          break;
        }
      }
      return acc;
    }, {});
    try {
      event.exception.values.forEach((exception) => {
        exception.stacktrace.frames.forEach((frame) => {
          if (frame.filename) {
            frame.debug_id = filenameDebugIdMap[frame.filename];
          }
        });
      });
    } catch (e) {
    }
  };
  var applyDebugMeta = function(event) {
    const filenameDebugIdMap = {};
    try {
      event.exception.values.forEach((exception) => {
        exception.stacktrace.frames.forEach((frame) => {
          if (frame.debug_id) {
            if (frame.abs_path) {
              filenameDebugIdMap[frame.abs_path] = frame.debug_id;
            } else if (frame.filename) {
              filenameDebugIdMap[frame.filename] = frame.debug_id;
            }
            delete frame.debug_id;
          }
        });
      });
    } catch (e) {
    }
    if (Object.keys(filenameDebugIdMap).length === 0) {
      return;
    }
    event.debug_meta = event.debug_meta || {};
    event.debug_meta.images = event.debug_meta.images || [];
    const images = event.debug_meta.images;
    Object.keys(filenameDebugIdMap).forEach((filename) => {
      images.push({
        type: "sourcemap",
        code_file: filename,
        debug_id: filenameDebugIdMap[filename]
      });
    });
  };
  var applyIntegrationsMetadata = function(event, integrationNames) {
    if (integrationNames.length > 0) {
      event.sdk = event.sdk || {};
      event.sdk.integrations = [...event.sdk.integrations || [], ...integrationNames];
    }
  };
  var normalizeEvent = function(event, depth, maxBreadth) {
    if (!event) {
      return null;
    }
    const normalized = {
      ...event,
      ...event.breadcrumbs && {
        breadcrumbs: event.breadcrumbs.map((b) => ({
          ...b,
          ...b.data && {
            data: utils.normalize(b.data, depth, maxBreadth)
          }
        }))
      },
      ...event.user && {
        user: utils.normalize(event.user, depth, maxBreadth)
      },
      ...event.contexts && {
        contexts: utils.normalize(event.contexts, depth, maxBreadth)
      },
      ...event.extra && {
        extra: utils.normalize(event.extra, depth, maxBreadth)
      }
    };
    if (event.contexts && event.contexts.trace && normalized.contexts) {
      normalized.contexts.trace = event.contexts.trace;
      if (event.contexts.trace.data) {
        normalized.contexts.trace.data = utils.normalize(event.contexts.trace.data, depth, maxBreadth);
      }
    }
    if (event.spans) {
      normalized.spans = event.spans.map((span) => {
        const data = spanUtils.spanToJSON(span).data;
        if (data) {
          span.data = utils.normalize(data, depth, maxBreadth);
        }
        return span;
      });
    }
    return normalized;
  };
  var getFinalScope = function(scope$1, captureContext) {
    if (!captureContext) {
      return scope$1;
    }
    const finalScope = scope$1 ? scope$1.clone() : new scope.Scope;
    finalScope.update(captureContext);
    return finalScope;
  };
  var parseEventHintOrCaptureContext = function(hint) {
    if (!hint) {
      return;
    }
    if (hintIsScopeOrFunction(hint)) {
      return { captureContext: hint };
    }
    if (hintIsScopeContext(hint)) {
      return {
        captureContext: hint
      };
    }
    return hint;
  };
  var hintIsScopeOrFunction = function(hint) {
    return hint instanceof scope.Scope || typeof hint === "function";
  };
  var hintIsScopeContext = function(hint) {
    return Object.keys(hint).some((key) => captureContextKeys.includes(key));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var constants = require_constants();
  var eventProcessors = require_eventProcessors();
  var scope = require_scope();
  var applyScopeDataToEvent = require_applyScopeDataToEvent();
  var spanUtils = require_spanUtils();
  var debugIdStackParserCache = new WeakMap;
  var captureContextKeys = [
    "user",
    "level",
    "extra",
    "contexts",
    "tags",
    "fingerprint",
    "requestSession",
    "propagationContext"
  ];
  exports.applyDebugIds = applyDebugIds;
  exports.applyDebugMeta = applyDebugMeta;
  exports.parseEventHintOrCaptureContext = parseEventHintOrCaptureContext;
  exports.prepareEvent = prepareEvent;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/exports.js
var require_exports = __commonJS((exports) => {
  var captureException = function(exception, hint) {
    return hub.getCurrentHub().captureException(exception, prepareEvent.parseEventHintOrCaptureContext(hint));
  };
  var captureMessage = function(message, captureContext) {
    const level = typeof captureContext === "string" ? captureContext : undefined;
    const context = typeof captureContext !== "string" ? { captureContext } : undefined;
    return hub.getCurrentHub().captureMessage(message, level, context);
  };
  var captureEvent = function(event, hint) {
    return hub.getCurrentHub().captureEvent(event, hint);
  };
  var configureScope = function(callback) {
    hub.getCurrentHub().configureScope(callback);
  };
  var addBreadcrumb = function(breadcrumb, hint) {
    hub.getCurrentHub().addBreadcrumb(breadcrumb, hint);
  };
  var setContext = function(name, context) {
    hub.getCurrentHub().setContext(name, context);
  };
  var setExtras = function(extras) {
    hub.getCurrentHub().setExtras(extras);
  };
  var setExtra = function(key, extra) {
    hub.getCurrentHub().setExtra(key, extra);
  };
  var setTags = function(tags) {
    hub.getCurrentHub().setTags(tags);
  };
  var setTag = function(key, value) {
    hub.getCurrentHub().setTag(key, value);
  };
  var setUser = function(user) {
    hub.getCurrentHub().setUser(user);
  };
  var withScope = function(...rest) {
    const hub$1 = hub.getCurrentHub();
    if (rest.length === 2) {
      const [scope, callback] = rest;
      if (!scope) {
        return hub$1.withScope(callback);
      }
      return hub$1.withScope(() => {
        hub$1.getStackTop().scope = scope;
        return callback(scope);
      });
    }
    return hub$1.withScope(rest[0]);
  };
  var withIsolationScope = function(callback) {
    return hub.runWithAsyncContext(() => {
      return callback(hub.getIsolationScope());
    });
  };
  var withActiveSpan = function(span, callback) {
    return withScope((scope) => {
      scope.setSpan(span);
      return callback(scope);
    });
  };
  var startTransaction = function(context, customSamplingContext) {
    return hub.getCurrentHub().startTransaction({ ...context }, customSamplingContext);
  };
  var captureCheckIn = function(checkIn, upsertMonitorConfig) {
    const scope = getCurrentScope();
    const client = getClient();
    if (!client) {
      debugBuild.DEBUG_BUILD && utils.logger.warn("Cannot capture check-in. No client defined.");
    } else if (!client.captureCheckIn) {
      debugBuild.DEBUG_BUILD && utils.logger.warn("Cannot capture check-in. Client does not support sending check-ins.");
    } else {
      return client.captureCheckIn(checkIn, upsertMonitorConfig, scope);
    }
    return utils.uuid4();
  };
  var withMonitor = function(monitorSlug, callback, upsertMonitorConfig) {
    const checkInId = captureCheckIn({ monitorSlug, status: "in_progress" }, upsertMonitorConfig);
    const now = utils.timestampInSeconds();
    function finishCheckIn(status) {
      captureCheckIn({ monitorSlug, status, checkInId, duration: utils.timestampInSeconds() - now });
    }
    let maybePromiseResult;
    try {
      maybePromiseResult = callback();
    } catch (e) {
      finishCheckIn("error");
      throw e;
    }
    if (utils.isThenable(maybePromiseResult)) {
      Promise.resolve(maybePromiseResult).then(() => {
        finishCheckIn("ok");
      }, () => {
        finishCheckIn("error");
      });
    } else {
      finishCheckIn("ok");
    }
    return maybePromiseResult;
  };
  async function flush(timeout) {
    const client = getClient();
    if (client) {
      return client.flush(timeout);
    }
    debugBuild.DEBUG_BUILD && utils.logger.warn("Cannot flush events. No client defined.");
    return Promise.resolve(false);
  }
  async function close(timeout) {
    const client = getClient();
    if (client) {
      return client.close(timeout);
    }
    debugBuild.DEBUG_BUILD && utils.logger.warn("Cannot flush events and disable SDK. No client defined.");
    return Promise.resolve(false);
  }
  var lastEventId = function() {
    return hub.getCurrentHub().lastEventId();
  };
  var getClient = function() {
    return hub.getCurrentHub().getClient();
  };
  var isInitialized = function() {
    return !!getClient();
  };
  var getCurrentScope = function() {
    return hub.getCurrentHub().getScope();
  };
  var startSession = function(context) {
    const client = getClient();
    const isolationScope = hub.getIsolationScope();
    const currentScope = getCurrentScope();
    const { release, environment = constants.DEFAULT_ENVIRONMENT } = client && client.getOptions() || {};
    const { userAgent } = utils.GLOBAL_OBJ.navigator || {};
    const session$1 = session.makeSession({
      release,
      environment,
      user: currentScope.getUser() || isolationScope.getUser(),
      ...userAgent && { userAgent },
      ...context
    });
    const currentSession = isolationScope.getSession();
    if (currentSession && currentSession.status === "ok") {
      session.updateSession(currentSession, { status: "exited" });
    }
    endSession();
    isolationScope.setSession(session$1);
    currentScope.setSession(session$1);
    return session$1;
  };
  var endSession = function() {
    const isolationScope = hub.getIsolationScope();
    const currentScope = getCurrentScope();
    const session$1 = currentScope.getSession() || isolationScope.getSession();
    if (session$1) {
      session.closeSession(session$1);
    }
    _sendSessionUpdate();
    isolationScope.setSession();
    currentScope.setSession();
  };
  var _sendSessionUpdate = function() {
    const isolationScope = hub.getIsolationScope();
    const currentScope = getCurrentScope();
    const client = getClient();
    const session2 = currentScope.getSession() || isolationScope.getSession();
    if (session2 && client && client.captureSession) {
      client.captureSession(session2);
    }
  };
  var captureSession = function(end = false) {
    if (end) {
      endSession();
      return;
    }
    _sendSessionUpdate();
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var constants = require_constants();
  var debugBuild = require_debug_build2();
  var hub = require_hub();
  var session = require_session();
  var prepareEvent = require_prepareEvent();
  exports.addBreadcrumb = addBreadcrumb;
  exports.captureCheckIn = captureCheckIn;
  exports.captureEvent = captureEvent;
  exports.captureException = captureException;
  exports.captureMessage = captureMessage;
  exports.captureSession = captureSession;
  exports.close = close;
  exports.configureScope = configureScope;
  exports.endSession = endSession;
  exports.flush = flush;
  exports.getClient = getClient;
  exports.getCurrentScope = getCurrentScope;
  exports.isInitialized = isInitialized;
  exports.lastEventId = lastEventId;
  exports.setContext = setContext;
  exports.setExtra = setExtra;
  exports.setExtras = setExtras;
  exports.setTag = setTag;
  exports.setTags = setTags;
  exports.setUser = setUser;
  exports.startSession = startSession;
  exports.startTransaction = startTransaction;
  exports.withActiveSpan = withActiveSpan;
  exports.withIsolationScope = withIsolationScope;
  exports.withMonitor = withMonitor;
  exports.withScope = withScope;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/utils/getRootSpan.js
var require_getRootSpan = __commonJS((exports) => {
  var getRootSpan = function(span) {
    return span.transaction;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRootSpan = getRootSpan;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/tracing/dynamicSamplingContext.js
var require_dynamicSamplingContext = __commonJS((exports) => {
  var getDynamicSamplingContextFromClient = function(trace_id, client, scope) {
    const options = client.getOptions();
    const { publicKey: public_key } = client.getDsn() || {};
    const { segment: user_segment } = scope && scope.getUser() || {};
    const dsc = utils.dropUndefinedKeys({
      environment: options.environment || constants.DEFAULT_ENVIRONMENT,
      release: options.release,
      user_segment,
      public_key,
      trace_id
    });
    client.emit && client.emit("createDsc", dsc);
    return dsc;
  };
  var getDynamicSamplingContextFromSpan = function(span) {
    const client = exports$1.getClient();
    if (!client) {
      return {};
    }
    const dsc = getDynamicSamplingContextFromClient(spanUtils.spanToJSON(span).trace_id || "", client, exports$1.getCurrentScope());
    const txn = getRootSpan.getRootSpan(span);
    if (!txn) {
      return dsc;
    }
    const v7FrozenDsc = txn && txn._frozenDynamicSamplingContext;
    if (v7FrozenDsc) {
      return v7FrozenDsc;
    }
    const { sampleRate: maybeSampleRate, source } = txn.metadata;
    if (maybeSampleRate != null) {
      dsc.sample_rate = `${maybeSampleRate}`;
    }
    const jsonSpan = spanUtils.spanToJSON(txn);
    if (source && source !== "url") {
      dsc.transaction = jsonSpan.description;
    }
    dsc.sampled = String(spanUtils.spanIsSampled(txn));
    client.emit && client.emit("createDsc", dsc);
    return dsc;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var constants = require_constants();
  var exports$1 = require_exports();
  var getRootSpan = require_getRootSpan();
  var spanUtils = require_spanUtils();
  exports.getDynamicSamplingContextFromClient = getDynamicSamplingContextFromClient;
  exports.getDynamicSamplingContextFromSpan = getDynamicSamplingContextFromSpan;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/utils/applyScopeDataToEvent.js
var require_applyScopeDataToEvent = __commonJS((exports) => {
  var applyScopeDataToEvent = function(event, data) {
    const { fingerprint, span, breadcrumbs, sdkProcessingMetadata } = data;
    applyDataToEvent(event, data);
    if (span) {
      applySpanToEvent(event, span);
    }
    applyFingerprintToEvent(event, fingerprint);
    applyBreadcrumbsToEvent(event, breadcrumbs);
    applySdkMetadataToEvent(event, sdkProcessingMetadata);
  };
  var mergeScopeData = function(data, mergeData) {
    const {
      extra,
      tags,
      user,
      contexts,
      level,
      sdkProcessingMetadata,
      breadcrumbs,
      fingerprint,
      eventProcessors,
      attachments,
      propagationContext,
      transactionName,
      span
    } = mergeData;
    mergeAndOverwriteScopeData(data, "extra", extra);
    mergeAndOverwriteScopeData(data, "tags", tags);
    mergeAndOverwriteScopeData(data, "user", user);
    mergeAndOverwriteScopeData(data, "contexts", contexts);
    mergeAndOverwriteScopeData(data, "sdkProcessingMetadata", sdkProcessingMetadata);
    if (level) {
      data.level = level;
    }
    if (transactionName) {
      data.transactionName = transactionName;
    }
    if (span) {
      data.span = span;
    }
    if (breadcrumbs.length) {
      data.breadcrumbs = [...data.breadcrumbs, ...breadcrumbs];
    }
    if (fingerprint.length) {
      data.fingerprint = [...data.fingerprint, ...fingerprint];
    }
    if (eventProcessors.length) {
      data.eventProcessors = [...data.eventProcessors, ...eventProcessors];
    }
    if (attachments.length) {
      data.attachments = [...data.attachments, ...attachments];
    }
    data.propagationContext = { ...data.propagationContext, ...propagationContext };
  };
  var mergeAndOverwriteScopeData = function(data, prop, mergeVal) {
    if (mergeVal && Object.keys(mergeVal).length) {
      data[prop] = { ...data[prop] };
      for (const key in mergeVal) {
        if (Object.prototype.hasOwnProperty.call(mergeVal, key)) {
          data[prop][key] = mergeVal[key];
        }
      }
    }
  };
  var applyDataToEvent = function(event, data) {
    const {
      extra,
      tags,
      user,
      contexts,
      level,
      transactionName
    } = data;
    const cleanedExtra = utils.dropUndefinedKeys(extra);
    if (cleanedExtra && Object.keys(cleanedExtra).length) {
      event.extra = { ...cleanedExtra, ...event.extra };
    }
    const cleanedTags = utils.dropUndefinedKeys(tags);
    if (cleanedTags && Object.keys(cleanedTags).length) {
      event.tags = { ...cleanedTags, ...event.tags };
    }
    const cleanedUser = utils.dropUndefinedKeys(user);
    if (cleanedUser && Object.keys(cleanedUser).length) {
      event.user = { ...cleanedUser, ...event.user };
    }
    const cleanedContexts = utils.dropUndefinedKeys(contexts);
    if (cleanedContexts && Object.keys(cleanedContexts).length) {
      event.contexts = { ...cleanedContexts, ...event.contexts };
    }
    if (level) {
      event.level = level;
    }
    if (transactionName) {
      event.transaction = transactionName;
    }
  };
  var applyBreadcrumbsToEvent = function(event, breadcrumbs) {
    const mergedBreadcrumbs = [...event.breadcrumbs || [], ...breadcrumbs];
    event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : undefined;
  };
  var applySdkMetadataToEvent = function(event, sdkProcessingMetadata) {
    event.sdkProcessingMetadata = {
      ...event.sdkProcessingMetadata,
      ...sdkProcessingMetadata
    };
  };
  var applySpanToEvent = function(event, span) {
    event.contexts = { trace: spanUtils.spanToTraceContext(span), ...event.contexts };
    const rootSpan = getRootSpan.getRootSpan(span);
    if (rootSpan) {
      event.sdkProcessingMetadata = {
        dynamicSamplingContext: dynamicSamplingContext.getDynamicSamplingContextFromSpan(span),
        ...event.sdkProcessingMetadata
      };
      const transactionName = spanUtils.spanToJSON(rootSpan).description;
      if (transactionName) {
        event.tags = { transaction: transactionName, ...event.tags };
      }
    }
  };
  var applyFingerprintToEvent = function(event, fingerprint) {
    event.fingerprint = event.fingerprint ? utils.arrayify(event.fingerprint) : [];
    if (fingerprint) {
      event.fingerprint = event.fingerprint.concat(fingerprint);
    }
    if (event.fingerprint && !event.fingerprint.length) {
      delete event.fingerprint;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var dynamicSamplingContext = require_dynamicSamplingContext();
  var getRootSpan = require_getRootSpan();
  var spanUtils = require_spanUtils();
  exports.applyScopeDataToEvent = applyScopeDataToEvent;
  exports.mergeAndOverwriteScopeData = mergeAndOverwriteScopeData;
  exports.mergeScopeData = mergeScopeData;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/scope.js
var require_scope = __commonJS((exports) => {
  var getGlobalScope = function() {
    if (!globalScope) {
      globalScope = new Scope;
    }
    return globalScope;
  };
  var setGlobalScope = function(scope) {
    globalScope = scope;
  };
  var generatePropagationContext = function() {
    return {
      traceId: utils.uuid4(),
      spanId: utils.uuid4().substring(16)
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var eventProcessors = require_eventProcessors();
  var session = require_session();
  var applyScopeDataToEvent = require_applyScopeDataToEvent();
  var DEFAULT_MAX_BREADCRUMBS = 100;
  var globalScope;

  class Scope {
    constructor() {
      this._notifyingListeners = false;
      this._scopeListeners = [];
      this._eventProcessors = [];
      this._breadcrumbs = [];
      this._attachments = [];
      this._user = {};
      this._tags = {};
      this._extra = {};
      this._contexts = {};
      this._sdkProcessingMetadata = {};
      this._propagationContext = generatePropagationContext();
    }
    static clone(scope) {
      return scope ? scope.clone() : new Scope;
    }
    clone() {
      const newScope = new Scope;
      newScope._breadcrumbs = [...this._breadcrumbs];
      newScope._tags = { ...this._tags };
      newScope._extra = { ...this._extra };
      newScope._contexts = { ...this._contexts };
      newScope._user = this._user;
      newScope._level = this._level;
      newScope._span = this._span;
      newScope._session = this._session;
      newScope._transactionName = this._transactionName;
      newScope._fingerprint = this._fingerprint;
      newScope._eventProcessors = [...this._eventProcessors];
      newScope._requestSession = this._requestSession;
      newScope._attachments = [...this._attachments];
      newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };
      newScope._propagationContext = { ...this._propagationContext };
      newScope._client = this._client;
      return newScope;
    }
    setClient(client) {
      this._client = client;
    }
    getClient() {
      return this._client;
    }
    addScopeListener(callback) {
      this._scopeListeners.push(callback);
    }
    addEventProcessor(callback) {
      this._eventProcessors.push(callback);
      return this;
    }
    setUser(user) {
      this._user = user || {
        email: undefined,
        id: undefined,
        ip_address: undefined,
        segment: undefined,
        username: undefined
      };
      if (this._session) {
        session.updateSession(this._session, { user });
      }
      this._notifyScopeListeners();
      return this;
    }
    getUser() {
      return this._user;
    }
    getRequestSession() {
      return this._requestSession;
    }
    setRequestSession(requestSession) {
      this._requestSession = requestSession;
      return this;
    }
    setTags(tags) {
      this._tags = {
        ...this._tags,
        ...tags
      };
      this._notifyScopeListeners();
      return this;
    }
    setTag(key, value) {
      this._tags = { ...this._tags, [key]: value };
      this._notifyScopeListeners();
      return this;
    }
    setExtras(extras) {
      this._extra = {
        ...this._extra,
        ...extras
      };
      this._notifyScopeListeners();
      return this;
    }
    setExtra(key, extra) {
      this._extra = { ...this._extra, [key]: extra };
      this._notifyScopeListeners();
      return this;
    }
    setFingerprint(fingerprint) {
      this._fingerprint = fingerprint;
      this._notifyScopeListeners();
      return this;
    }
    setLevel(level) {
      this._level = level;
      this._notifyScopeListeners();
      return this;
    }
    setTransactionName(name) {
      this._transactionName = name;
      this._notifyScopeListeners();
      return this;
    }
    setContext(key, context) {
      if (context === null) {
        delete this._contexts[key];
      } else {
        this._contexts[key] = context;
      }
      this._notifyScopeListeners();
      return this;
    }
    setSpan(span) {
      this._span = span;
      this._notifyScopeListeners();
      return this;
    }
    getSpan() {
      return this._span;
    }
    getTransaction() {
      const span = this._span;
      return span && span.transaction;
    }
    setSession(session2) {
      if (!session2) {
        delete this._session;
      } else {
        this._session = session2;
      }
      this._notifyScopeListeners();
      return this;
    }
    getSession() {
      return this._session;
    }
    update(captureContext) {
      if (!captureContext) {
        return this;
      }
      if (typeof captureContext === "function") {
        const updatedScope = captureContext(this);
        return updatedScope instanceof Scope ? updatedScope : this;
      }
      if (captureContext instanceof Scope) {
        this._tags = { ...this._tags, ...captureContext._tags };
        this._extra = { ...this._extra, ...captureContext._extra };
        this._contexts = { ...this._contexts, ...captureContext._contexts };
        if (captureContext._user && Object.keys(captureContext._user).length) {
          this._user = captureContext._user;
        }
        if (captureContext._level) {
          this._level = captureContext._level;
        }
        if (captureContext._fingerprint) {
          this._fingerprint = captureContext._fingerprint;
        }
        if (captureContext._requestSession) {
          this._requestSession = captureContext._requestSession;
        }
        if (captureContext._propagationContext) {
          this._propagationContext = captureContext._propagationContext;
        }
      } else if (utils.isPlainObject(captureContext)) {
        captureContext = captureContext;
        this._tags = { ...this._tags, ...captureContext.tags };
        this._extra = { ...this._extra, ...captureContext.extra };
        this._contexts = { ...this._contexts, ...captureContext.contexts };
        if (captureContext.user) {
          this._user = captureContext.user;
        }
        if (captureContext.level) {
          this._level = captureContext.level;
        }
        if (captureContext.fingerprint) {
          this._fingerprint = captureContext.fingerprint;
        }
        if (captureContext.requestSession) {
          this._requestSession = captureContext.requestSession;
        }
        if (captureContext.propagationContext) {
          this._propagationContext = captureContext.propagationContext;
        }
      }
      return this;
    }
    clear() {
      this._breadcrumbs = [];
      this._tags = {};
      this._extra = {};
      this._user = {};
      this._contexts = {};
      this._level = undefined;
      this._transactionName = undefined;
      this._fingerprint = undefined;
      this._requestSession = undefined;
      this._span = undefined;
      this._session = undefined;
      this._notifyScopeListeners();
      this._attachments = [];
      this._propagationContext = generatePropagationContext();
      return this;
    }
    addBreadcrumb(breadcrumb, maxBreadcrumbs) {
      const maxCrumbs = typeof maxBreadcrumbs === "number" ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;
      if (maxCrumbs <= 0) {
        return this;
      }
      const mergedBreadcrumb = {
        timestamp: utils.dateTimestampInSeconds(),
        ...breadcrumb
      };
      const breadcrumbs = this._breadcrumbs;
      breadcrumbs.push(mergedBreadcrumb);
      this._breadcrumbs = breadcrumbs.length > maxCrumbs ? breadcrumbs.slice(-maxCrumbs) : breadcrumbs;
      this._notifyScopeListeners();
      return this;
    }
    getLastBreadcrumb() {
      return this._breadcrumbs[this._breadcrumbs.length - 1];
    }
    clearBreadcrumbs() {
      this._breadcrumbs = [];
      this._notifyScopeListeners();
      return this;
    }
    addAttachment(attachment) {
      this._attachments.push(attachment);
      return this;
    }
    getAttachments() {
      const data = this.getScopeData();
      return data.attachments;
    }
    clearAttachments() {
      this._attachments = [];
      return this;
    }
    getScopeData() {
      const {
        _breadcrumbs,
        _attachments,
        _contexts,
        _tags,
        _extra,
        _user,
        _level,
        _fingerprint,
        _eventProcessors,
        _propagationContext,
        _sdkProcessingMetadata,
        _transactionName,
        _span
      } = this;
      return {
        breadcrumbs: _breadcrumbs,
        attachments: _attachments,
        contexts: _contexts,
        tags: _tags,
        extra: _extra,
        user: _user,
        level: _level,
        fingerprint: _fingerprint || [],
        eventProcessors: _eventProcessors,
        propagationContext: _propagationContext,
        sdkProcessingMetadata: _sdkProcessingMetadata,
        transactionName: _transactionName,
        span: _span
      };
    }
    applyToEvent(event, hint = {}, additionalEventProcessors = []) {
      applyScopeDataToEvent.applyScopeDataToEvent(event, this.getScopeData());
      const eventProcessors$1 = [
        ...additionalEventProcessors,
        ...eventProcessors.getGlobalEventProcessors(),
        ...this._eventProcessors
      ];
      return eventProcessors.notifyEventProcessors(eventProcessors$1, event, hint);
    }
    setSDKProcessingMetadata(newData) {
      this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...newData };
      return this;
    }
    setPropagationContext(context) {
      this._propagationContext = context;
      return this;
    }
    getPropagationContext() {
      return this._propagationContext;
    }
    captureException(exception, hint) {
      const eventId = hint && hint.event_id ? hint.event_id : utils.uuid4();
      if (!this._client) {
        utils.logger.warn("No client configured on scope - will not capture exception!");
        return eventId;
      }
      const syntheticException = new Error("Sentry syntheticException");
      this._client.captureException(exception, {
        originalException: exception,
        syntheticException,
        ...hint,
        event_id: eventId
      }, this);
      return eventId;
    }
    captureMessage(message, level, hint) {
      const eventId = hint && hint.event_id ? hint.event_id : utils.uuid4();
      if (!this._client) {
        utils.logger.warn("No client configured on scope - will not capture message!");
        return eventId;
      }
      const syntheticException = new Error(message);
      this._client.captureMessage(message, level, {
        originalException: message,
        syntheticException,
        ...hint,
        event_id: eventId
      }, this);
      return eventId;
    }
    captureEvent(event, hint) {
      const eventId = hint && hint.event_id ? hint.event_id : utils.uuid4();
      if (!this._client) {
        utils.logger.warn("No client configured on scope - will not capture event!");
        return eventId;
      }
      this._client.captureEvent(event, { ...hint, event_id: eventId }, this);
      return eventId;
    }
    _notifyScopeListeners() {
      if (!this._notifyingListeners) {
        this._notifyingListeners = true;
        this._scopeListeners.forEach((callback) => {
          callback(this);
        });
        this._notifyingListeners = false;
      }
    }
  }
  exports.Scope = Scope;
  exports.getGlobalScope = getGlobalScope;
  exports.setGlobalScope = setGlobalScope;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/version.js
var require_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var SDK_VERSION = "7.100.1";
  exports.SDK_VERSION = SDK_VERSION;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/hub.js
var require_hub = __commonJS((exports) => {
  var getMainCarrier = function() {
    utils.GLOBAL_OBJ.__SENTRY__ = utils.GLOBAL_OBJ.__SENTRY__ || {
      extensions: {},
      hub: undefined
    };
    return utils.GLOBAL_OBJ;
  };
  var makeMain = function(hub) {
    const registry = getMainCarrier();
    const oldHub = getHubFromCarrier(registry);
    setHubOnCarrier(registry, hub);
    return oldHub;
  };
  var getCurrentHub = function() {
    const registry = getMainCarrier();
    if (registry.__SENTRY__ && registry.__SENTRY__.acs) {
      const hub = registry.__SENTRY__.acs.getCurrentHub();
      if (hub) {
        return hub;
      }
    }
    return getGlobalHub(registry);
  };
  var getIsolationScope = function() {
    return getCurrentHub().getIsolationScope();
  };
  var getGlobalHub = function(registry = getMainCarrier()) {
    if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(API_VERSION)) {
      setHubOnCarrier(registry, new Hub);
    }
    return getHubFromCarrier(registry);
  };
  var ensureHubOnCarrier = function(carrier, parent = getGlobalHub()) {
    if (!hasHubOnCarrier(carrier) || getHubFromCarrier(carrier).isOlderThan(API_VERSION)) {
      const client = parent.getClient();
      const scope2 = parent.getScope();
      const isolationScope = parent.getIsolationScope();
      setHubOnCarrier(carrier, new Hub(client, scope2.clone(), isolationScope.clone()));
    }
  };
  var setAsyncContextStrategy = function(strategy) {
    const registry = getMainCarrier();
    registry.__SENTRY__ = registry.__SENTRY__ || {};
    registry.__SENTRY__.acs = strategy;
  };
  var runWithAsyncContext = function(callback, options = {}) {
    const registry = getMainCarrier();
    if (registry.__SENTRY__ && registry.__SENTRY__.acs) {
      return registry.__SENTRY__.acs.runWithAsyncContext(callback, options);
    }
    return callback();
  };
  var hasHubOnCarrier = function(carrier) {
    return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
  };
  var getHubFromCarrier = function(carrier) {
    return utils.getGlobalSingleton("hub", () => new Hub, carrier);
  };
  var setHubOnCarrier = function(carrier, hub) {
    if (!carrier)
      return false;
    const __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};
    __SENTRY__.hub = hub;
    return true;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var constants = require_constants();
  var debugBuild = require_debug_build2();
  var scope = require_scope();
  var session = require_session();
  var version = require_version();
  var API_VERSION = parseFloat(version.SDK_VERSION);
  var DEFAULT_BREADCRUMBS = 100;

  class Hub {
    constructor(client, scope$1, isolationScope, _version = API_VERSION) {
      this._version = _version;
      let assignedScope;
      if (!scope$1) {
        assignedScope = new scope.Scope;
        assignedScope.setClient(client);
      } else {
        assignedScope = scope$1;
      }
      let assignedIsolationScope;
      if (!isolationScope) {
        assignedIsolationScope = new scope.Scope;
        assignedIsolationScope.setClient(client);
      } else {
        assignedIsolationScope = isolationScope;
      }
      this._stack = [{ scope: assignedScope }];
      if (client) {
        this.bindClient(client);
      }
      this._isolationScope = assignedIsolationScope;
    }
    isOlderThan(version2) {
      return this._version < version2;
    }
    bindClient(client) {
      const top = this.getStackTop();
      top.client = client;
      top.scope.setClient(client);
      if (client && client.setupIntegrations) {
        client.setupIntegrations();
      }
    }
    pushScope() {
      const scope2 = this.getScope().clone();
      this.getStack().push({
        client: this.getClient(),
        scope: scope2
      });
      return scope2;
    }
    popScope() {
      if (this.getStack().length <= 1)
        return false;
      return !!this.getStack().pop();
    }
    withScope(callback) {
      const scope2 = this.pushScope();
      let maybePromiseResult;
      try {
        maybePromiseResult = callback(scope2);
      } catch (e) {
        this.popScope();
        throw e;
      }
      if (utils.isThenable(maybePromiseResult)) {
        return maybePromiseResult.then((res) => {
          this.popScope();
          return res;
        }, (e) => {
          this.popScope();
          throw e;
        });
      }
      this.popScope();
      return maybePromiseResult;
    }
    getClient() {
      return this.getStackTop().client;
    }
    getScope() {
      return this.getStackTop().scope;
    }
    getIsolationScope() {
      return this._isolationScope;
    }
    getStack() {
      return this._stack;
    }
    getStackTop() {
      return this._stack[this._stack.length - 1];
    }
    captureException(exception, hint) {
      const eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : utils.uuid4();
      const syntheticException = new Error("Sentry syntheticException");
      this.getScope().captureException(exception, {
        originalException: exception,
        syntheticException,
        ...hint,
        event_id: eventId
      });
      return eventId;
    }
    captureMessage(message, level, hint) {
      const eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : utils.uuid4();
      const syntheticException = new Error(message);
      this.getScope().captureMessage(message, level, {
        originalException: message,
        syntheticException,
        ...hint,
        event_id: eventId
      });
      return eventId;
    }
    captureEvent(event, hint) {
      const eventId = hint && hint.event_id ? hint.event_id : utils.uuid4();
      if (!event.type) {
        this._lastEventId = eventId;
      }
      this.getScope().captureEvent(event, { ...hint, event_id: eventId });
      return eventId;
    }
    lastEventId() {
      return this._lastEventId;
    }
    addBreadcrumb(breadcrumb, hint) {
      const { scope: scope2, client } = this.getStackTop();
      if (!client)
        return;
      const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } = client.getOptions && client.getOptions() || {};
      if (maxBreadcrumbs <= 0)
        return;
      const timestamp = utils.dateTimestampInSeconds();
      const mergedBreadcrumb = { timestamp, ...breadcrumb };
      const finalBreadcrumb = beforeBreadcrumb ? utils.consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) : mergedBreadcrumb;
      if (finalBreadcrumb === null)
        return;
      if (client.emit) {
        client.emit("beforeAddBreadcrumb", finalBreadcrumb, hint);
      }
      scope2.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
    }
    setUser(user) {
      this.getScope().setUser(user);
      this.getIsolationScope().setUser(user);
    }
    setTags(tags) {
      this.getScope().setTags(tags);
      this.getIsolationScope().setTags(tags);
    }
    setExtras(extras) {
      this.getScope().setExtras(extras);
      this.getIsolationScope().setExtras(extras);
    }
    setTag(key, value) {
      this.getScope().setTag(key, value);
      this.getIsolationScope().setTag(key, value);
    }
    setExtra(key, extra) {
      this.getScope().setExtra(key, extra);
      this.getIsolationScope().setExtra(key, extra);
    }
    setContext(name, context) {
      this.getScope().setContext(name, context);
      this.getIsolationScope().setContext(name, context);
    }
    configureScope(callback) {
      const { scope: scope2, client } = this.getStackTop();
      if (client) {
        callback(scope2);
      }
    }
    run(callback) {
      const oldHub = makeMain(this);
      try {
        callback(this);
      } finally {
        makeMain(oldHub);
      }
    }
    getIntegration(integration) {
      const client = this.getClient();
      if (!client)
        return null;
      try {
        return client.getIntegration(integration);
      } catch (_oO) {
        debugBuild.DEBUG_BUILD && utils.logger.warn(`Cannot retrieve integration ${integration.id} from the current Hub`);
        return null;
      }
    }
    startTransaction(context, customSamplingContext) {
      const result = this._callExtensionMethod("startTransaction", context, customSamplingContext);
      if (debugBuild.DEBUG_BUILD && !result) {
        const client = this.getClient();
        if (!client) {
          utils.logger.warn("Tracing extension 'startTransaction' is missing. You should 'init' the SDK before calling 'startTransaction'");
        } else {
          utils.logger.warn(`Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':
Sentry.addTracingExtensions();
Sentry.init({...});
`);
        }
      }
      return result;
    }
    traceHeaders() {
      return this._callExtensionMethod("traceHeaders");
    }
    captureSession(endSession = false) {
      if (endSession) {
        return this.endSession();
      }
      this._sendSessionUpdate();
    }
    endSession() {
      const layer = this.getStackTop();
      const scope2 = layer.scope;
      const session$1 = scope2.getSession();
      if (session$1) {
        session.closeSession(session$1);
      }
      this._sendSessionUpdate();
      scope2.setSession();
    }
    startSession(context) {
      const { scope: scope2, client } = this.getStackTop();
      const { release, environment = constants.DEFAULT_ENVIRONMENT } = client && client.getOptions() || {};
      const { userAgent } = utils.GLOBAL_OBJ.navigator || {};
      const session$1 = session.makeSession({
        release,
        environment,
        user: scope2.getUser(),
        ...userAgent && { userAgent },
        ...context
      });
      const currentSession = scope2.getSession && scope2.getSession();
      if (currentSession && currentSession.status === "ok") {
        session.updateSession(currentSession, { status: "exited" });
      }
      this.endSession();
      scope2.setSession(session$1);
      return session$1;
    }
    shouldSendDefaultPii() {
      const client = this.getClient();
      const options = client && client.getOptions();
      return Boolean(options && options.sendDefaultPii);
    }
    _sendSessionUpdate() {
      const { scope: scope2, client } = this.getStackTop();
      const session2 = scope2.getSession();
      if (session2 && client && client.captureSession) {
        client.captureSession(session2);
      }
    }
    _callExtensionMethod(method, ...args) {
      const carrier = getMainCarrier();
      const sentry = carrier.__SENTRY__;
      if (sentry && sentry.extensions && typeof sentry.extensions[method] === "function") {
        return sentry.extensions[method].apply(this, args);
      }
      debugBuild.DEBUG_BUILD && utils.logger.warn(`Extension method ${method} couldn't be found, doing nothing.`);
    }
  }
  exports.API_VERSION = API_VERSION;
  exports.Hub = Hub;
  exports.ensureHubOnCarrier = ensureHubOnCarrier;
  exports.getCurrentHub = getCurrentHub;
  exports.getHubFromCarrier = getHubFromCarrier;
  exports.getIsolationScope = getIsolationScope;
  exports.getMainCarrier = getMainCarrier;
  exports.makeMain = makeMain;
  exports.runWithAsyncContext = runWithAsyncContext;
  exports.setAsyncContextStrategy = setAsyncContextStrategy;
  exports.setHubOnCarrier = setHubOnCarrier;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/tracing/utils.js
var require_utils = __commonJS((exports) => {
  var getActiveTransaction = function(maybeHub) {
    const hub$1 = maybeHub || hub.getCurrentHub();
    const scope = hub$1.getScope();
    return scope.getTransaction();
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var hub = require_hub();
  var extractTraceparentData = utils.extractTraceparentData;
  exports.stripUrlQueryAndFragment = utils.stripUrlQueryAndFragment;
  exports.extractTraceparentData = extractTraceparentData;
  exports.getActiveTransaction = getActiveTransaction;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/tracing/errors.js
var require_errors = __commonJS((exports) => {
  var registerErrorInstrumentation = function() {
    if (errorsInstrumented) {
      return;
    }
    errorsInstrumented = true;
    utils.addGlobalErrorInstrumentationHandler(errorCallback);
    utils.addGlobalUnhandledRejectionInstrumentationHandler(errorCallback);
  };
  var errorCallback = function() {
    const activeTransaction = utils$1.getActiveTransaction();
    if (activeTransaction) {
      const status = "internal_error";
      debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Transaction: ${status} -> Global error occured`);
      activeTransaction.setStatus(status);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var debugBuild = require_debug_build2();
  var utils$1 = require_utils();
  var errorsInstrumented = false;
  errorCallback.tag = "sentry_tracingErrorCallback";
  exports.registerErrorInstrumentation = registerErrorInstrumentation;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/semanticAttributes.js
var require_semanticAttributes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = "sentry.source";
  var SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = "sentry.sample_rate";
  var SEMANTIC_ATTRIBUTE_SENTRY_OP = "sentry.op";
  var SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = "sentry.origin";
  exports.SEMANTIC_ATTRIBUTE_SENTRY_OP = SEMANTIC_ATTRIBUTE_SENTRY_OP;
  exports.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN;
  exports.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE;
  exports.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = SEMANTIC_ATTRIBUTE_SENTRY_SOURCE;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/tracing/spanstatus.js
var require_spanstatus = __commonJS((exports) => {
  var getSpanStatusFromHttpCode = function(httpStatus) {
    if (httpStatus < 400 && httpStatus >= 100) {
      return "ok";
    }
    if (httpStatus >= 400 && httpStatus < 500) {
      switch (httpStatus) {
        case 401:
          return "unauthenticated";
        case 403:
          return "permission_denied";
        case 404:
          return "not_found";
        case 409:
          return "already_exists";
        case 413:
          return "failed_precondition";
        case 429:
          return "resource_exhausted";
        default:
          return "invalid_argument";
      }
    }
    if (httpStatus >= 500 && httpStatus < 600) {
      switch (httpStatus) {
        case 501:
          return "unimplemented";
        case 503:
          return "unavailable";
        case 504:
          return "deadline_exceeded";
        default:
          return "internal_error";
      }
    }
    return "unknown_error";
  };
  var setHttpStatus = function(span, httpStatus) {
    span.setTag("http.status_code", String(httpStatus));
    span.setData("http.response.status_code", httpStatus);
    const spanStatus = getSpanStatusFromHttpCode(httpStatus);
    if (spanStatus !== "unknown_error") {
      span.setStatus(spanStatus);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanStatus = undefined;
  (function(SpanStatus) {
    const Ok = "ok";
    SpanStatus["Ok"] = Ok;
    const DeadlineExceeded = "deadline_exceeded";
    SpanStatus["DeadlineExceeded"] = DeadlineExceeded;
    const Unauthenticated = "unauthenticated";
    SpanStatus["Unauthenticated"] = Unauthenticated;
    const PermissionDenied = "permission_denied";
    SpanStatus["PermissionDenied"] = PermissionDenied;
    const NotFound = "not_found";
    SpanStatus["NotFound"] = NotFound;
    const ResourceExhausted = "resource_exhausted";
    SpanStatus["ResourceExhausted"] = ResourceExhausted;
    const InvalidArgument = "invalid_argument";
    SpanStatus["InvalidArgument"] = InvalidArgument;
    const Unimplemented = "unimplemented";
    SpanStatus["Unimplemented"] = Unimplemented;
    const Unavailable = "unavailable";
    SpanStatus["Unavailable"] = Unavailable;
    const InternalError = "internal_error";
    SpanStatus["InternalError"] = InternalError;
    const UnknownError = "unknown_error";
    SpanStatus["UnknownError"] = UnknownError;
    const Cancelled = "cancelled";
    SpanStatus["Cancelled"] = Cancelled;
    const AlreadyExists = "already_exists";
    SpanStatus["AlreadyExists"] = AlreadyExists;
    const FailedPrecondition = "failed_precondition";
    SpanStatus["FailedPrecondition"] = FailedPrecondition;
    const Aborted = "aborted";
    SpanStatus["Aborted"] = Aborted;
    const OutOfRange = "out_of_range";
    SpanStatus["OutOfRange"] = OutOfRange;
    const DataLoss = "data_loss";
    SpanStatus["DataLoss"] = DataLoss;
  })(exports.SpanStatus || (exports.SpanStatus = {}));
  var spanStatusfromHttpCode = getSpanStatusFromHttpCode;
  exports.getSpanStatusFromHttpCode = getSpanStatusFromHttpCode;
  exports.setHttpStatus = setHttpStatus;
  exports.spanStatusfromHttpCode = spanStatusfromHttpCode;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/tracing/span.js
var require_span = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var debugBuild = require_debug_build2();
  var semanticAttributes = require_semanticAttributes();
  var getRootSpan = require_getRootSpan();
  var spanUtils = require_spanUtils();
  var spanstatus = require_spanstatus();

  class SpanRecorder {
    constructor(maxlen = 1000) {
      this._maxlen = maxlen;
      this.spans = [];
    }
    add(span) {
      if (this.spans.length > this._maxlen) {
        span.spanRecorder = undefined;
      } else {
        this.spans.push(span);
      }
    }
  }

  class Span {
    constructor(spanContext = {}) {
      this._traceId = spanContext.traceId || utils.uuid4();
      this._spanId = spanContext.spanId || utils.uuid4().substring(16);
      this._startTime = spanContext.startTimestamp || utils.timestampInSeconds();
      this.tags = spanContext.tags ? { ...spanContext.tags } : {};
      this.data = spanContext.data ? { ...spanContext.data } : {};
      this.instrumenter = spanContext.instrumenter || "sentry";
      this._attributes = {};
      this.setAttributes({
        [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: spanContext.origin || "manual",
        [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP]: spanContext.op,
        ...spanContext.attributes
      });
      this._name = spanContext.name || spanContext.description;
      if (spanContext.parentSpanId) {
        this._parentSpanId = spanContext.parentSpanId;
      }
      if ("sampled" in spanContext) {
        this._sampled = spanContext.sampled;
      }
      if (spanContext.status) {
        this._status = spanContext.status;
      }
      if (spanContext.endTimestamp) {
        this._endTime = spanContext.endTimestamp;
      }
    }
    get name() {
      return this._name || "";
    }
    set name(name) {
      this.updateName(name);
    }
    get description() {
      return this._name;
    }
    set description(description) {
      this._name = description;
    }
    get traceId() {
      return this._traceId;
    }
    set traceId(traceId) {
      this._traceId = traceId;
    }
    get spanId() {
      return this._spanId;
    }
    set spanId(spanId) {
      this._spanId = spanId;
    }
    set parentSpanId(string) {
      this._parentSpanId = string;
    }
    get parentSpanId() {
      return this._parentSpanId;
    }
    get sampled() {
      return this._sampled;
    }
    set sampled(sampled) {
      this._sampled = sampled;
    }
    get attributes() {
      return this._attributes;
    }
    set attributes(attributes) {
      this._attributes = attributes;
    }
    get startTimestamp() {
      return this._startTime;
    }
    set startTimestamp(startTime) {
      this._startTime = startTime;
    }
    get endTimestamp() {
      return this._endTime;
    }
    set endTimestamp(endTime) {
      this._endTime = endTime;
    }
    get status() {
      return this._status;
    }
    set status(status) {
      this._status = status;
    }
    get op() {
      return this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP];
    }
    set op(op) {
      this.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP, op);
    }
    get origin() {
      return this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN];
    }
    set origin(origin) {
      this.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, origin);
    }
    spanContext() {
      const { _spanId: spanId, _traceId: traceId, _sampled: sampled } = this;
      return {
        spanId,
        traceId,
        traceFlags: sampled ? spanUtils.TRACE_FLAG_SAMPLED : spanUtils.TRACE_FLAG_NONE
      };
    }
    startChild(spanContext) {
      const childSpan = new Span({
        ...spanContext,
        parentSpanId: this._spanId,
        sampled: this._sampled,
        traceId: this._traceId
      });
      childSpan.spanRecorder = this.spanRecorder;
      if (childSpan.spanRecorder) {
        childSpan.spanRecorder.add(childSpan);
      }
      const rootSpan = getRootSpan.getRootSpan(this);
      childSpan.transaction = rootSpan;
      if (debugBuild.DEBUG_BUILD && rootSpan) {
        const opStr = spanContext && spanContext.op || "< unknown op >";
        const nameStr = spanUtils.spanToJSON(childSpan).description || "< unknown name >";
        const idStr = rootSpan.spanContext().spanId;
        const logMessage = `[Tracing] Starting '${opStr}' span on transaction '${nameStr}' (${idStr}).`;
        utils.logger.log(logMessage);
        this._logMessage = logMessage;
      }
      return childSpan;
    }
    setTag(key, value) {
      this.tags = { ...this.tags, [key]: value };
      return this;
    }
    setData(key, value) {
      this.data = { ...this.data, [key]: value };
      return this;
    }
    setAttribute(key, value) {
      if (value === undefined) {
        delete this._attributes[key];
      } else {
        this._attributes[key] = value;
      }
    }
    setAttributes(attributes) {
      Object.keys(attributes).forEach((key) => this.setAttribute(key, attributes[key]));
    }
    setStatus(value) {
      this._status = value;
      return this;
    }
    setHttpStatus(httpStatus) {
      spanstatus.setHttpStatus(this, httpStatus);
      return this;
    }
    setName(name) {
      this.updateName(name);
    }
    updateName(name) {
      this._name = name;
      return this;
    }
    isSuccess() {
      return this._status === "ok";
    }
    finish(endTimestamp) {
      return this.end(endTimestamp);
    }
    end(endTimestamp) {
      if (this._endTime) {
        return;
      }
      const rootSpan = getRootSpan.getRootSpan(this);
      if (debugBuild.DEBUG_BUILD && rootSpan && rootSpan.spanContext().spanId !== this._spanId) {
        const logMessage = this._logMessage;
        if (logMessage) {
          utils.logger.log(logMessage.replace("Starting", "Finishing"));
        }
      }
      this._endTime = spanUtils.spanTimeInputToSeconds(endTimestamp);
    }
    toTraceparent() {
      return spanUtils.spanToTraceHeader(this);
    }
    toContext() {
      return utils.dropUndefinedKeys({
        data: this._getData(),
        description: this._name,
        endTimestamp: this._endTime,
        op: this.op,
        parentSpanId: this._parentSpanId,
        sampled: this._sampled,
        spanId: this._spanId,
        startTimestamp: this._startTime,
        status: this._status,
        tags: this.tags,
        traceId: this._traceId
      });
    }
    updateWithContext(spanContext) {
      this.data = spanContext.data || {};
      this._name = spanContext.name || spanContext.description;
      this._endTime = spanContext.endTimestamp;
      this.op = spanContext.op;
      this._parentSpanId = spanContext.parentSpanId;
      this._sampled = spanContext.sampled;
      this._spanId = spanContext.spanId || this._spanId;
      this._startTime = spanContext.startTimestamp || this._startTime;
      this._status = spanContext.status;
      this.tags = spanContext.tags || {};
      this._traceId = spanContext.traceId || this._traceId;
      return this;
    }
    getTraceContext() {
      return spanUtils.spanToTraceContext(this);
    }
    getSpanJSON() {
      return utils.dropUndefinedKeys({
        data: this._getData(),
        description: this._name,
        op: this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP],
        parent_span_id: this._parentSpanId,
        span_id: this._spanId,
        start_timestamp: this._startTime,
        status: this._status,
        tags: Object.keys(this.tags).length > 0 ? this.tags : undefined,
        timestamp: this._endTime,
        trace_id: this._traceId,
        origin: this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]
      });
    }
    isRecording() {
      return !this._endTime && !!this._sampled;
    }
    toJSON() {
      return this.getSpanJSON();
    }
    _getData() {
      const { data, _attributes: attributes } = this;
      const hasData = Object.keys(data).length > 0;
      const hasAttributes = Object.keys(attributes).length > 0;
      if (!hasData && !hasAttributes) {
        return;
      }
      if (hasData && hasAttributes) {
        return {
          ...data,
          ...attributes
        };
      }
      return hasData ? data : attributes;
    }
  }
  exports.Span = Span;
  exports.SpanRecorder = SpanRecorder;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/utils/handleCallbackErrors.js
var require_handleCallbackErrors = __commonJS((exports) => {
  var handleCallbackErrors = function(fn, onError, onFinally = () => {
  }) {
    let maybePromiseResult;
    try {
      maybePromiseResult = fn();
    } catch (e) {
      onError(e);
      onFinally();
      throw e;
    }
    return maybeHandlePromiseRejection(maybePromiseResult, onError, onFinally);
  };
  var maybeHandlePromiseRejection = function(value, onError, onFinally) {
    if (utils.isThenable(value)) {
      return value.then((res) => {
        onFinally();
        return res;
      }, (e) => {
        onError(e);
        onFinally();
        throw e;
      });
    }
    onFinally();
    return value;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  exports.handleCallbackErrors = handleCallbackErrors;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/utils/hasTracingEnabled.js
var require_hasTracingEnabled = __commonJS((exports) => {
  var hasTracingEnabled = function(maybeOptions) {
    if (typeof __SENTRY_TRACING__ === "boolean" && !__SENTRY_TRACING__) {
      return false;
    }
    const client = exports$1.getClient();
    const options = maybeOptions || client && client.getOptions();
    return !!options && (options.enableTracing || ("tracesSampleRate" in options) || ("tracesSampler" in options));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var exports$1 = require_exports();
  exports.hasTracingEnabled = hasTracingEnabled;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/tracing/trace.js
var require_trace = __commonJS((exports) => {
  var trace = function(context, callback, onError = () => {
  }, afterFinish = () => {
  }) {
    const hub$1 = hub.getCurrentHub();
    const scope = exports$1.getCurrentScope();
    const parentSpan = scope.getSpan();
    const ctx = normalizeContext(context);
    const activeSpan = createChildSpanOrTransaction(hub$1, parentSpan, ctx);
    scope.setSpan(activeSpan);
    return handleCallbackErrors.handleCallbackErrors(() => callback(activeSpan), (error) => {
      activeSpan && activeSpan.setStatus("internal_error");
      onError(error, activeSpan);
    }, () => {
      activeSpan && activeSpan.end();
      scope.setSpan(parentSpan);
      afterFinish();
    });
  };
  var startSpan = function(context, callback) {
    const ctx = normalizeContext(context);
    return hub.runWithAsyncContext(() => {
      return exports$1.withScope(context.scope, (scope) => {
        const hub$1 = hub.getCurrentHub();
        const parentSpan = scope.getSpan();
        const shouldSkipSpan = context.onlyIfParent && !parentSpan;
        const activeSpan = shouldSkipSpan ? undefined : createChildSpanOrTransaction(hub$1, parentSpan, ctx);
        scope.setSpan(activeSpan);
        return handleCallbackErrors.handleCallbackErrors(() => callback(activeSpan), () => {
          if (activeSpan) {
            const { status } = spanUtils.spanToJSON(activeSpan);
            if (!status || status === "ok") {
              activeSpan.setStatus("internal_error");
            }
          }
        }, () => activeSpan && activeSpan.end());
      });
    });
  };
  var startSpanManual = function(context, callback) {
    const ctx = normalizeContext(context);
    return hub.runWithAsyncContext(() => {
      return exports$1.withScope(context.scope, (scope) => {
        const hub$1 = hub.getCurrentHub();
        const parentSpan = scope.getSpan();
        const shouldSkipSpan = context.onlyIfParent && !parentSpan;
        const activeSpan = shouldSkipSpan ? undefined : createChildSpanOrTransaction(hub$1, parentSpan, ctx);
        scope.setSpan(activeSpan);
        function finishAndSetSpan() {
          activeSpan && activeSpan.end();
        }
        return handleCallbackErrors.handleCallbackErrors(() => callback(activeSpan, finishAndSetSpan), () => {
          if (activeSpan && activeSpan.isRecording()) {
            const { status } = spanUtils.spanToJSON(activeSpan);
            if (!status || status === "ok") {
              activeSpan.setStatus("internal_error");
            }
          }
        });
      });
    });
  };
  var startInactiveSpan = function(context) {
    if (!hasTracingEnabled.hasTracingEnabled()) {
      return;
    }
    const ctx = normalizeContext(context);
    const hub$1 = hub.getCurrentHub();
    const parentSpan = context.scope ? context.scope.getSpan() : getActiveSpan();
    const shouldSkipSpan = context.onlyIfParent && !parentSpan;
    if (shouldSkipSpan) {
      return;
    }
    const isolationScope = hub.getIsolationScope();
    const scope = exports$1.getCurrentScope();
    let span;
    if (parentSpan) {
      span = parentSpan.startChild(ctx);
    } else {
      const { traceId, dsc, parentSpanId, sampled } = {
        ...isolationScope.getPropagationContext(),
        ...scope.getPropagationContext()
      };
      span = hub$1.startTransaction({
        traceId,
        parentSpanId,
        parentSampled: sampled,
        ...ctx,
        metadata: {
          dynamicSamplingContext: dsc,
          ...ctx.metadata
        }
      });
    }
    setCapturedScopesOnSpan(span, scope, isolationScope);
    return span;
  };
  var getActiveSpan = function() {
    return exports$1.getCurrentScope().getSpan();
  };
  var createChildSpanOrTransaction = function(hub$1, parentSpan, ctx) {
    if (!hasTracingEnabled.hasTracingEnabled()) {
      return;
    }
    const isolationScope = hub.getIsolationScope();
    const scope = exports$1.getCurrentScope();
    let span;
    if (parentSpan) {
      span = parentSpan.startChild(ctx);
    } else {
      const { traceId, dsc, parentSpanId, sampled } = {
        ...isolationScope.getPropagationContext(),
        ...scope.getPropagationContext()
      };
      span = hub$1.startTransaction({
        traceId,
        parentSpanId,
        parentSampled: sampled,
        ...ctx,
        metadata: {
          dynamicSamplingContext: dsc,
          ...ctx.metadata
        }
      });
    }
    setCapturedScopesOnSpan(span, scope, isolationScope);
    return span;
  };
  var normalizeContext = function(context) {
    if (context.startTime) {
      const ctx = { ...context };
      ctx.startTimestamp = spanUtils.spanTimeInputToSeconds(context.startTime);
      delete ctx.startTime;
      return ctx;
    }
    return context;
  };
  var setCapturedScopesOnSpan = function(span, scope, isolationScope) {
    if (span) {
      utils.addNonEnumerableProperty(span, ISOLATION_SCOPE_ON_START_SPAN_FIELD, isolationScope);
      utils.addNonEnumerableProperty(span, SCOPE_ON_START_SPAN_FIELD, scope);
    }
  };
  var getCapturedScopesOnSpan = function(span) {
    return {
      scope: span[SCOPE_ON_START_SPAN_FIELD],
      isolationScope: span[ISOLATION_SCOPE_ON_START_SPAN_FIELD]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var debugBuild = require_debug_build2();
  var exports$1 = require_exports();
  var hub = require_hub();
  var handleCallbackErrors = require_handleCallbackErrors();
  var hasTracingEnabled = require_hasTracingEnabled();
  var spanUtils = require_spanUtils();
  var startActiveSpan = startSpan;
  var continueTrace = ({
    sentryTrace,
    baggage
  }, callback) => {
    const currentScope = exports$1.getCurrentScope();
    const { traceparentData, dynamicSamplingContext, propagationContext } = utils.tracingContextFromHeaders(sentryTrace, baggage);
    currentScope.setPropagationContext(propagationContext);
    if (debugBuild.DEBUG_BUILD && traceparentData) {
      utils.logger.log(`[Tracing] Continuing trace ${traceparentData.traceId}.`);
    }
    const transactionContext = {
      ...traceparentData,
      metadata: utils.dropUndefinedKeys({
        dynamicSamplingContext
      })
    };
    if (!callback) {
      return transactionContext;
    }
    return hub.runWithAsyncContext(() => {
      return callback(transactionContext);
    });
  };
  var SCOPE_ON_START_SPAN_FIELD = "_sentryScope";
  var ISOLATION_SCOPE_ON_START_SPAN_FIELD = "_sentryIsolationScope";
  exports.continueTrace = continueTrace;
  exports.getActiveSpan = getActiveSpan;
  exports.getCapturedScopesOnSpan = getCapturedScopesOnSpan;
  exports.startActiveSpan = startActiveSpan;
  exports.startInactiveSpan = startInactiveSpan;
  exports.startSpan = startSpan;
  exports.startSpanManual = startSpanManual;
  exports.trace = trace;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/tracing/transaction.js
var require_transaction = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var debugBuild = require_debug_build2();
  var hub = require_hub();
  var semanticAttributes = require_semanticAttributes();
  var spanUtils = require_spanUtils();
  var dynamicSamplingContext = require_dynamicSamplingContext();
  var span = require_span();
  var trace = require_trace();

  class Transaction extends span.Span {
    constructor(transactionContext, hub$1) {
      super(transactionContext);
      this._measurements = {};
      this._contexts = {};
      this._hub = hub$1 || hub.getCurrentHub();
      this._name = transactionContext.name || "";
      this._metadata = {
        ...transactionContext.metadata
      };
      this._trimEnd = transactionContext.trimEnd;
      this.transaction = this;
      const incomingDynamicSamplingContext = this._metadata.dynamicSamplingContext;
      if (incomingDynamicSamplingContext) {
        this._frozenDynamicSamplingContext = { ...incomingDynamicSamplingContext };
      }
    }
    get name() {
      return this._name;
    }
    set name(newName) {
      this.setName(newName);
    }
    get metadata() {
      return {
        source: "custom",
        spanMetadata: {},
        ...this._metadata,
        ...this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] && {
          source: this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]
        },
        ...this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] && {
          sampleRate: this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]
        }
      };
    }
    set metadata(metadata) {
      this._metadata = metadata;
    }
    setName(name, source = "custom") {
      this._name = name;
      this.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, source);
    }
    updateName(name) {
      this._name = name;
      return this;
    }
    initSpanRecorder(maxlen = 1000) {
      if (!this.spanRecorder) {
        this.spanRecorder = new span.SpanRecorder(maxlen);
      }
      this.spanRecorder.add(this);
    }
    setContext(key, context) {
      if (context === null) {
        delete this._contexts[key];
      } else {
        this._contexts[key] = context;
      }
    }
    setMeasurement(name, value, unit = "") {
      this._measurements[name] = { value, unit };
    }
    setMetadata(newMetadata) {
      this._metadata = { ...this._metadata, ...newMetadata };
    }
    end(endTimestamp) {
      const timestampInS = spanUtils.spanTimeInputToSeconds(endTimestamp);
      const transaction = this._finishTransaction(timestampInS);
      if (!transaction) {
        return;
      }
      return this._hub.captureEvent(transaction);
    }
    toContext() {
      const spanContext = super.toContext();
      return utils.dropUndefinedKeys({
        ...spanContext,
        name: this._name,
        trimEnd: this._trimEnd
      });
    }
    updateWithContext(transactionContext) {
      super.updateWithContext(transactionContext);
      this._name = transactionContext.name || "";
      this._trimEnd = transactionContext.trimEnd;
      return this;
    }
    getDynamicSamplingContext() {
      return dynamicSamplingContext.getDynamicSamplingContextFromSpan(this);
    }
    setHub(hub2) {
      this._hub = hub2;
    }
    _finishTransaction(endTimestamp) {
      if (this._endTime !== undefined) {
        return;
      }
      if (!this._name) {
        debugBuild.DEBUG_BUILD && utils.logger.warn("Transaction has no name, falling back to `<unlabeled transaction>`.");
        this._name = "<unlabeled transaction>";
      }
      super.end(endTimestamp);
      const client = this._hub.getClient();
      if (client && client.emit) {
        client.emit("finishTransaction", this);
      }
      if (this._sampled !== true) {
        debugBuild.DEBUG_BUILD && utils.logger.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled.");
        if (client) {
          client.recordDroppedEvent("sample_rate", "transaction");
        }
        return;
      }
      const finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter((span2) => span2 !== this && spanUtils.spanToJSON(span2).timestamp) : [];
      if (this._trimEnd && finishedSpans.length > 0) {
        const endTimes = finishedSpans.map((span2) => spanUtils.spanToJSON(span2).timestamp).filter(Boolean);
        this._endTime = endTimes.reduce((prev, current) => {
          return prev > current ? prev : current;
        });
      }
      const { scope: capturedSpanScope, isolationScope: capturedSpanIsolationScope } = trace.getCapturedScopesOnSpan(this);
      const { metadata } = this;
      const { source } = metadata;
      const transaction = {
        contexts: {
          ...this._contexts,
          trace: spanUtils.spanToTraceContext(this)
        },
        spans: finishedSpans,
        start_timestamp: this._startTime,
        tags: this.tags,
        timestamp: this._endTime,
        transaction: this._name,
        type: "transaction",
        sdkProcessingMetadata: {
          ...metadata,
          capturedSpanScope,
          capturedSpanIsolationScope,
          dynamicSamplingContext: dynamicSamplingContext.getDynamicSamplingContextFromSpan(this)
        },
        ...source && {
          transaction_info: {
            source
          }
        }
      };
      const hasMeasurements = Object.keys(this._measurements).length > 0;
      if (hasMeasurements) {
        debugBuild.DEBUG_BUILD && utils.logger.log("[Measurements] Adding measurements to transaction", JSON.stringify(this._measurements, undefined, 2));
        transaction.measurements = this._measurements;
      }
      debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Finishing ${this.op} transaction: ${this._name}.`);
      return transaction;
    }
  }
  exports.Transaction = Transaction;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/tracing/idletransaction.js
var require_idletransaction = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var debugBuild = require_debug_build2();
  var spanUtils = require_spanUtils();
  var span = require_span();
  var transaction = require_transaction();
  var TRACING_DEFAULTS = {
    idleTimeout: 1000,
    finalTimeout: 30000,
    heartbeatInterval: 5000
  };
  var FINISH_REASON_TAG = "finishReason";
  var IDLE_TRANSACTION_FINISH_REASONS = [
    "heartbeatFailed",
    "idleTimeout",
    "documentHidden",
    "finalTimeout",
    "externalFinish",
    "cancelled"
  ];

  class IdleTransactionSpanRecorder extends span.SpanRecorder {
    constructor(_pushActivity, _popActivity, transactionSpanId, maxlen) {
      super(maxlen);
      this._pushActivity = _pushActivity;
      this._popActivity = _popActivity;
      this.transactionSpanId = transactionSpanId;
    }
    add(span2) {
      if (span2.spanContext().spanId !== this.transactionSpanId) {
        const originalEnd = span2.end;
        span2.end = (...rest) => {
          this._popActivity(span2.spanContext().spanId);
          return originalEnd.apply(span2, rest);
        };
        if (spanUtils.spanToJSON(span2).timestamp === undefined) {
          this._pushActivity(span2.spanContext().spanId);
        }
      }
      super.add(span2);
    }
  }

  class IdleTransaction extends transaction.Transaction {
    constructor(transactionContext, _idleHub, _idleTimeout = TRACING_DEFAULTS.idleTimeout, _finalTimeout = TRACING_DEFAULTS.finalTimeout, _heartbeatInterval = TRACING_DEFAULTS.heartbeatInterval, _onScope = false, delayAutoFinishUntilSignal = false) {
      super(transactionContext, _idleHub);
      this._idleHub = _idleHub;
      this._idleTimeout = _idleTimeout;
      this._finalTimeout = _finalTimeout;
      this._heartbeatInterval = _heartbeatInterval;
      this._onScope = _onScope;
      this.activities = {};
      this._heartbeatCounter = 0;
      this._finished = false;
      this._idleTimeoutCanceledPermanently = false;
      this._beforeFinishCallbacks = [];
      this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[4];
      this._autoFinishAllowed = !delayAutoFinishUntilSignal;
      if (_onScope) {
        debugBuild.DEBUG_BUILD && utils.logger.log(`Setting idle transaction on scope. Span ID: ${this.spanContext().spanId}`);
        _idleHub.getScope().setSpan(this);
      }
      if (!delayAutoFinishUntilSignal) {
        this._restartIdleTimeout();
      }
      setTimeout(() => {
        if (!this._finished) {
          this.setStatus("deadline_exceeded");
          this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[3];
          this.end();
        }
      }, this._finalTimeout);
    }
    end(endTimestamp) {
      const endTimestampInS = spanUtils.spanTimeInputToSeconds(endTimestamp);
      this._finished = true;
      this.activities = {};
      if (this.op === "ui.action.click") {
        this.setAttribute(FINISH_REASON_TAG, this._finishReason);
      }
      if (this.spanRecorder) {
        debugBuild.DEBUG_BUILD && utils.logger.log("[Tracing] finishing IdleTransaction", new Date(endTimestampInS * 1000).toISOString(), this.op);
        for (const callback of this._beforeFinishCallbacks) {
          callback(this, endTimestampInS);
        }
        this.spanRecorder.spans = this.spanRecorder.spans.filter((span2) => {
          if (span2.spanContext().spanId === this.spanContext().spanId) {
            return true;
          }
          if (!spanUtils.spanToJSON(span2).timestamp) {
            span2.setStatus("cancelled");
            span2.end(endTimestampInS);
            debugBuild.DEBUG_BUILD && utils.logger.log("[Tracing] cancelling span since transaction ended early", JSON.stringify(span2, undefined, 2));
          }
          const { start_timestamp: startTime, timestamp: endTime } = spanUtils.spanToJSON(span2);
          const spanStartedBeforeTransactionFinish = startTime && startTime < endTimestampInS;
          const timeoutWithMarginOfError = (this._finalTimeout + this._idleTimeout) / 1000;
          const spanEndedBeforeFinalTimeout = endTime && startTime && endTime - startTime < timeoutWithMarginOfError;
          if (debugBuild.DEBUG_BUILD) {
            const stringifiedSpan = JSON.stringify(span2, undefined, 2);
            if (!spanStartedBeforeTransactionFinish) {
              utils.logger.log("[Tracing] discarding Span since it happened after Transaction was finished", stringifiedSpan);
            } else if (!spanEndedBeforeFinalTimeout) {
              utils.logger.log("[Tracing] discarding Span since it finished after Transaction final timeout", stringifiedSpan);
            }
          }
          return spanStartedBeforeTransactionFinish && spanEndedBeforeFinalTimeout;
        });
        debugBuild.DEBUG_BUILD && utils.logger.log("[Tracing] flushing IdleTransaction");
      } else {
        debugBuild.DEBUG_BUILD && utils.logger.log("[Tracing] No active IdleTransaction");
      }
      if (this._onScope) {
        const scope = this._idleHub.getScope();
        if (scope.getTransaction() === this) {
          scope.setSpan(undefined);
        }
      }
      return super.end(endTimestamp);
    }
    registerBeforeFinishCallback(callback) {
      this._beforeFinishCallbacks.push(callback);
    }
    initSpanRecorder(maxlen) {
      if (!this.spanRecorder) {
        const pushActivity = (id) => {
          if (this._finished) {
            return;
          }
          this._pushActivity(id);
        };
        const popActivity = (id) => {
          if (this._finished) {
            return;
          }
          this._popActivity(id);
        };
        this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanContext().spanId, maxlen);
        debugBuild.DEBUG_BUILD && utils.logger.log("Starting heartbeat");
        this._pingHeartbeat();
      }
      this.spanRecorder.add(this);
    }
    cancelIdleTimeout(endTimestamp, {
      restartOnChildSpanChange
    } = {
      restartOnChildSpanChange: true
    }) {
      this._idleTimeoutCanceledPermanently = restartOnChildSpanChange === false;
      if (this._idleTimeoutID) {
        clearTimeout(this._idleTimeoutID);
        this._idleTimeoutID = undefined;
        if (Object.keys(this.activities).length === 0 && this._idleTimeoutCanceledPermanently) {
          this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];
          this.end(endTimestamp);
        }
      }
    }
    setFinishReason(reason) {
      this._finishReason = reason;
    }
    sendAutoFinishSignal() {
      if (!this._autoFinishAllowed) {
        debugBuild.DEBUG_BUILD && utils.logger.log("[Tracing] Received finish signal for idle transaction.");
        this._restartIdleTimeout();
        this._autoFinishAllowed = true;
      }
    }
    _restartIdleTimeout(endTimestamp) {
      this.cancelIdleTimeout();
      this._idleTimeoutID = setTimeout(() => {
        if (!this._finished && Object.keys(this.activities).length === 0) {
          this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[1];
          this.end(endTimestamp);
        }
      }, this._idleTimeout);
    }
    _pushActivity(spanId) {
      this.cancelIdleTimeout(undefined, { restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently });
      debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] pushActivity: ${spanId}`);
      this.activities[spanId] = true;
      debugBuild.DEBUG_BUILD && utils.logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
    }
    _popActivity(spanId) {
      if (this.activities[spanId]) {
        debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] popActivity ${spanId}`);
        delete this.activities[spanId];
        debugBuild.DEBUG_BUILD && utils.logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
      }
      if (Object.keys(this.activities).length === 0) {
        const endTimestamp = utils.timestampInSeconds();
        if (this._idleTimeoutCanceledPermanently) {
          if (this._autoFinishAllowed) {
            this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];
            this.end(endTimestamp);
          }
        } else {
          this._restartIdleTimeout(endTimestamp + this._idleTimeout / 1000);
        }
      }
    }
    _beat() {
      if (this._finished) {
        return;
      }
      const heartbeatString = Object.keys(this.activities).join("");
      if (heartbeatString === this._prevHeartbeatString) {
        this._heartbeatCounter++;
      } else {
        this._heartbeatCounter = 1;
      }
      this._prevHeartbeatString = heartbeatString;
      if (this._heartbeatCounter >= 3) {
        if (this._autoFinishAllowed) {
          debugBuild.DEBUG_BUILD && utils.logger.log("[Tracing] Transaction finished because of no change for 3 heart beats");
          this.setStatus("deadline_exceeded");
          this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[0];
          this.end();
        }
      } else {
        this._pingHeartbeat();
      }
    }
    _pingHeartbeat() {
      debugBuild.DEBUG_BUILD && utils.logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);
      setTimeout(() => {
        this._beat();
      }, this._heartbeatInterval);
    }
  }
  exports.IdleTransaction = IdleTransaction;
  exports.IdleTransactionSpanRecorder = IdleTransactionSpanRecorder;
  exports.TRACING_DEFAULTS = TRACING_DEFAULTS;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/tracing/sampling.js
var require_sampling = __commonJS((exports) => {
  var sampleTransaction = function(transaction, options, samplingContext) {
    if (!hasTracingEnabled.hasTracingEnabled(options)) {
      transaction.sampled = false;
      return transaction;
    }
    if (transaction.sampled !== undefined) {
      transaction.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, Number(transaction.sampled));
      return transaction;
    }
    let sampleRate;
    if (typeof options.tracesSampler === "function") {
      sampleRate = options.tracesSampler(samplingContext);
      transaction.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, Number(sampleRate));
    } else if (samplingContext.parentSampled !== undefined) {
      sampleRate = samplingContext.parentSampled;
    } else if (typeof options.tracesSampleRate !== "undefined") {
      sampleRate = options.tracesSampleRate;
      transaction.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, Number(sampleRate));
    } else {
      sampleRate = 1;
      transaction.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, sampleRate);
    }
    if (!isValidSampleRate(sampleRate)) {
      debugBuild.DEBUG_BUILD && utils.logger.warn("[Tracing] Discarding transaction because of invalid sample rate.");
      transaction.sampled = false;
      return transaction;
    }
    if (!sampleRate) {
      debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Discarding transaction because ${typeof options.tracesSampler === "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"}`);
      transaction.sampled = false;
      return transaction;
    }
    transaction.sampled = Math.random() < sampleRate;
    if (!transaction.sampled) {
      debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(sampleRate)})`);
      return transaction;
    }
    debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] starting ${transaction.op} transaction - ${spanUtils.spanToJSON(transaction).description}`);
    return transaction;
  };
  var isValidSampleRate = function(rate) {
    if (utils.isNaN(rate) || !(typeof rate === "number" || typeof rate === "boolean")) {
      debugBuild.DEBUG_BUILD && utils.logger.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(rate)} of type ${JSON.stringify(typeof rate)}.`);
      return false;
    }
    if (rate < 0 || rate > 1) {
      debugBuild.DEBUG_BUILD && utils.logger.warn(`[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${rate}.`);
      return false;
    }
    return true;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var debugBuild = require_debug_build2();
  var semanticAttributes = require_semanticAttributes();
  var hasTracingEnabled = require_hasTracingEnabled();
  var spanUtils = require_spanUtils();
  exports.sampleTransaction = sampleTransaction;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/tracing/hubextensions.js
var require_hubextensions = __commonJS((exports) => {
  var traceHeaders = function() {
    const scope = this.getScope();
    const span = scope.getSpan();
    return span ? {
      "sentry-trace": spanUtils.spanToTraceHeader(span)
    } : {};
  };
  var _startTransaction = function(transactionContext, customSamplingContext) {
    const client = this.getClient();
    const options = client && client.getOptions() || {};
    const configInstrumenter = options.instrumenter || "sentry";
    const transactionInstrumenter = transactionContext.instrumenter || "sentry";
    if (configInstrumenter !== transactionInstrumenter) {
      debugBuild.DEBUG_BUILD && utils.logger.error(`A transaction was started with instrumenter=\`${transactionInstrumenter}\`, but the SDK is configured with the \`${configInstrumenter}\` instrumenter.
The transaction will not be sampled. Please use the ${configInstrumenter} instrumentation to start transactions.`);
      transactionContext.sampled = false;
    }
    let transaction$1 = new transaction.Transaction(transactionContext, this);
    transaction$1 = sampling.sampleTransaction(transaction$1, options, {
      name: transactionContext.name,
      parentSampled: transactionContext.parentSampled,
      transactionContext,
      attributes: {
        ...transactionContext.data,
        ...transactionContext.attributes
      },
      ...customSamplingContext
    });
    if (transaction$1.isRecording()) {
      transaction$1.initSpanRecorder(options._experiments && options._experiments.maxSpans);
    }
    if (client && client.emit) {
      client.emit("startTransaction", transaction$1);
    }
    return transaction$1;
  };
  var startIdleTransaction = function(hub2, transactionContext, idleTimeout, finalTimeout, onScope, customSamplingContext, heartbeatInterval, delayAutoFinishUntilSignal = false) {
    const client = hub2.getClient();
    const options = client && client.getOptions() || {};
    let transaction2 = new idletransaction.IdleTransaction(transactionContext, hub2, idleTimeout, finalTimeout, heartbeatInterval, onScope, delayAutoFinishUntilSignal);
    transaction2 = sampling.sampleTransaction(transaction2, options, {
      name: transactionContext.name,
      parentSampled: transactionContext.parentSampled,
      transactionContext,
      attributes: {
        ...transactionContext.data,
        ...transactionContext.attributes
      },
      ...customSamplingContext
    });
    if (transaction2.isRecording()) {
      transaction2.initSpanRecorder(options._experiments && options._experiments.maxSpans);
    }
    if (client && client.emit) {
      client.emit("startTransaction", transaction2);
    }
    return transaction2;
  };
  var addTracingExtensions = function() {
    const carrier = hub.getMainCarrier();
    if (!carrier.__SENTRY__) {
      return;
    }
    carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};
    if (!carrier.__SENTRY__.extensions.startTransaction) {
      carrier.__SENTRY__.extensions.startTransaction = _startTransaction;
    }
    if (!carrier.__SENTRY__.extensions.traceHeaders) {
      carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;
    }
    errors.registerErrorInstrumentation();
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var debugBuild = require_debug_build2();
  var hub = require_hub();
  var spanUtils = require_spanUtils();
  var errors = require_errors();
  var idletransaction = require_idletransaction();
  var sampling = require_sampling();
  var transaction = require_transaction();
  exports.addTracingExtensions = addTracingExtensions;
  exports.startIdleTransaction = startIdleTransaction;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/tracing/measurement.js
var require_measurement = __commonJS((exports) => {
  var setMeasurement = function(name, value, unit) {
    const transaction = utils.getActiveTransaction();
    if (transaction) {
      transaction.setMeasurement(name, value, unit);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_utils();
  exports.setMeasurement = setMeasurement;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/envelope.js
var require_envelope2 = __commonJS((exports) => {
  var enhanceEventWithSdkInfo = function(event, sdkInfo) {
    if (!sdkInfo) {
      return event;
    }
    event.sdk = event.sdk || {};
    event.sdk.name = event.sdk.name || sdkInfo.name;
    event.sdk.version = event.sdk.version || sdkInfo.version;
    event.sdk.integrations = [...event.sdk.integrations || [], ...sdkInfo.integrations || []];
    event.sdk.packages = [...event.sdk.packages || [], ...sdkInfo.packages || []];
    return event;
  };
  var createSessionEnvelope = function(session, dsn, metadata, tunnel) {
    const sdkInfo = utils.getSdkMetadataForEnvelopeHeader(metadata);
    const envelopeHeaders = {
      sent_at: new Date().toISOString(),
      ...sdkInfo && { sdk: sdkInfo },
      ...!!tunnel && dsn && { dsn: utils.dsnToString(dsn) }
    };
    const envelopeItem = "aggregates" in session ? [{ type: "sessions" }, session] : [{ type: "session" }, session.toJSON()];
    return utils.createEnvelope(envelopeHeaders, [envelopeItem]);
  };
  var createEventEnvelope = function(event, dsn, metadata, tunnel) {
    const sdkInfo = utils.getSdkMetadataForEnvelopeHeader(metadata);
    const eventType = event.type && event.type !== "replay_event" ? event.type : "event";
    enhanceEventWithSdkInfo(event, metadata && metadata.sdk);
    const envelopeHeaders = utils.createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);
    delete event.sdkProcessingMetadata;
    const eventItem = [{ type: eventType }, event];
    return utils.createEnvelope(envelopeHeaders, [eventItem]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  exports.createEventEnvelope = createEventEnvelope;
  exports.createSessionEnvelope = createSessionEnvelope;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/sessionflusher.js
var require_sessionflusher = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var exports$1 = require_exports();

  class SessionFlusher {
    constructor(client, attrs) {
      this._client = client;
      this.flushTimeout = 60;
      this._pendingAggregates = {};
      this._isEnabled = true;
      this._intervalId = setInterval(() => this.flush(), this.flushTimeout * 1000);
      this._sessionAttrs = attrs;
    }
    flush() {
      const sessionAggregates = this.getSessionAggregates();
      if (sessionAggregates.aggregates.length === 0) {
        return;
      }
      this._pendingAggregates = {};
      this._client.sendSession(sessionAggregates);
    }
    getSessionAggregates() {
      const aggregates = Object.keys(this._pendingAggregates).map((key) => {
        return this._pendingAggregates[parseInt(key)];
      });
      const sessionAggregates = {
        attrs: this._sessionAttrs,
        aggregates
      };
      return utils.dropUndefinedKeys(sessionAggregates);
    }
    close() {
      clearInterval(this._intervalId);
      this._isEnabled = false;
      this.flush();
    }
    incrementSessionStatusCount() {
      if (!this._isEnabled) {
        return;
      }
      const scope = exports$1.getCurrentScope();
      const requestSession = scope.getRequestSession();
      if (requestSession && requestSession.status) {
        this._incrementSessionStatusCount(requestSession.status, new Date);
        scope.setRequestSession(undefined);
      }
    }
    _incrementSessionStatusCount(status, date) {
      const sessionStartedTrunc = new Date(date).setSeconds(0, 0);
      this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};
      const aggregationCounts = this._pendingAggregates[sessionStartedTrunc];
      if (!aggregationCounts.started) {
        aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();
      }
      switch (status) {
        case "errored":
          aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;
          return aggregationCounts.errored;
        case "ok":
          aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;
          return aggregationCounts.exited;
        default:
          aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;
          return aggregationCounts.crashed;
      }
    }
  }
  exports.SessionFlusher = SessionFlusher;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/api.js
var require_api = __commonJS((exports) => {
  var getBaseApiEndpoint = function(dsn) {
    const protocol = dsn.protocol ? `${dsn.protocol}:` : "";
    const port = dsn.port ? `:${dsn.port}` : "";
    return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ""}/api/`;
  };
  var _getIngestEndpoint = function(dsn) {
    return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;
  };
  var _encodedAuth = function(dsn, sdkInfo) {
    return utils.urlEncode({
      sentry_key: dsn.publicKey,
      sentry_version: SENTRY_API_VERSION,
      ...sdkInfo && { sentry_client: `${sdkInfo.name}/${sdkInfo.version}` }
    });
  };
  var getEnvelopeEndpointWithUrlEncodedAuth = function(dsn, tunnelOrOptions = {}) {
    const tunnel = typeof tunnelOrOptions === "string" ? tunnelOrOptions : tunnelOrOptions.tunnel;
    const sdkInfo = typeof tunnelOrOptions === "string" || !tunnelOrOptions._metadata ? undefined : tunnelOrOptions._metadata.sdk;
    return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;
  };
  var getReportDialogEndpoint = function(dsnLike, dialogOptions) {
    const dsn = utils.makeDsn(dsnLike);
    if (!dsn) {
      return "";
    }
    const endpoint = `${getBaseApiEndpoint(dsn)}embed/error-page/`;
    let encodedOptions = `dsn=${utils.dsnToString(dsn)}`;
    for (const key in dialogOptions) {
      if (key === "dsn") {
        continue;
      }
      if (key === "onClose") {
        continue;
      }
      if (key === "user") {
        const user = dialogOptions.user;
        if (!user) {
          continue;
        }
        if (user.name) {
          encodedOptions += `&name=${encodeURIComponent(user.name)}`;
        }
        if (user.email) {
          encodedOptions += `&email=${encodeURIComponent(user.email)}`;
        }
      } else {
        encodedOptions += `&${encodeURIComponent(key)}=${encodeURIComponent(dialogOptions[key])}`;
      }
    }
    return `${endpoint}?${encodedOptions}`;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var SENTRY_API_VERSION = "7";
  exports.getEnvelopeEndpointWithUrlEncodedAuth = getEnvelopeEndpointWithUrlEncodedAuth;
  exports.getReportDialogEndpoint = getReportDialogEndpoint;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/integration.js
var require_integration = __commonJS((exports) => {
  var filterDuplicates = function(integrations) {
    const integrationsByName = {};
    integrations.forEach((currentInstance) => {
      const { name } = currentInstance;
      const existingInstance = integrationsByName[name];
      if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {
        return;
      }
      integrationsByName[name] = currentInstance;
    });
    return Object.keys(integrationsByName).map((k) => integrationsByName[k]);
  };
  var getIntegrationsToSetup = function(options) {
    const defaultIntegrations = options.defaultIntegrations || [];
    const userIntegrations = options.integrations;
    defaultIntegrations.forEach((integration) => {
      integration.isDefaultInstance = true;
    });
    let integrations;
    if (Array.isArray(userIntegrations)) {
      integrations = [...defaultIntegrations, ...userIntegrations];
    } else if (typeof userIntegrations === "function") {
      integrations = utils.arrayify(userIntegrations(defaultIntegrations));
    } else {
      integrations = defaultIntegrations;
    }
    const finalIntegrations = filterDuplicates(integrations);
    const debugIndex = findIndex(finalIntegrations, (integration) => integration.name === "Debug");
    if (debugIndex !== -1) {
      const [debugInstance] = finalIntegrations.splice(debugIndex, 1);
      finalIntegrations.push(debugInstance);
    }
    return finalIntegrations;
  };
  var setupIntegrations = function(client, integrations) {
    const integrationIndex = {};
    integrations.forEach((integration) => {
      if (integration) {
        setupIntegration(client, integration, integrationIndex);
      }
    });
    return integrationIndex;
  };
  var afterSetupIntegrations = function(client, integrations) {
    for (const integration of integrations) {
      if (integration && integration.afterAllSetup) {
        integration.afterAllSetup(client);
      }
    }
  };
  var setupIntegration = function(client, integration, integrationIndex) {
    if (integrationIndex[integration.name]) {
      debugBuild.DEBUG_BUILD && utils.logger.log(`Integration skipped because it was already installed: ${integration.name}`);
      return;
    }
    integrationIndex[integration.name] = integration;
    if (installedIntegrations.indexOf(integration.name) === -1) {
      integration.setupOnce(eventProcessors.addGlobalEventProcessor, hub.getCurrentHub);
      installedIntegrations.push(integration.name);
    }
    if (integration.setup && typeof integration.setup === "function") {
      integration.setup(client);
    }
    if (client.on && typeof integration.preprocessEvent === "function") {
      const callback = integration.preprocessEvent.bind(integration);
      client.on("preprocessEvent", (event, hint) => callback(event, hint, client));
    }
    if (client.addEventProcessor && typeof integration.processEvent === "function") {
      const callback = integration.processEvent.bind(integration);
      const processor = Object.assign((event, hint) => callback(event, hint, client), {
        id: integration.name
      });
      client.addEventProcessor(processor);
    }
    debugBuild.DEBUG_BUILD && utils.logger.log(`Integration installed: ${integration.name}`);
  };
  var addIntegration = function(integration) {
    const client = exports$1.getClient();
    if (!client || !client.addIntegration) {
      debugBuild.DEBUG_BUILD && utils.logger.warn(`Cannot add integration "${integration.name}" because no SDK Client is available.`);
      return;
    }
    client.addIntegration(integration);
  };
  var findIndex = function(arr, callback) {
    for (let i = 0;i < arr.length; i++) {
      if (callback(arr[i]) === true) {
        return i;
      }
    }
    return -1;
  };
  var convertIntegrationFnToClass = function(name, fn) {
    return Object.assign(function ConvertedIntegration(...args) {
      return fn(...args);
    }, { id: name });
  };
  var defineIntegration = function(fn) {
    return fn;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var debugBuild = require_debug_build2();
  var eventProcessors = require_eventProcessors();
  var exports$1 = require_exports();
  var hub = require_hub();
  var installedIntegrations = [];
  exports.addIntegration = addIntegration;
  exports.afterSetupIntegrations = afterSetupIntegrations;
  exports.convertIntegrationFnToClass = convertIntegrationFnToClass;
  exports.defineIntegration = defineIntegration;
  exports.getIntegrationsToSetup = getIntegrationsToSetup;
  exports.installedIntegrations = installedIntegrations;
  exports.setupIntegration = setupIntegration;
  exports.setupIntegrations = setupIntegrations;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/metrics/constants.js
var require_constants2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var COUNTER_METRIC_TYPE = "c";
  var GAUGE_METRIC_TYPE = "g";
  var SET_METRIC_TYPE = "s";
  var DISTRIBUTION_METRIC_TYPE = "d";
  var NAME_AND_TAG_KEY_NORMALIZATION_REGEX = /[^a-zA-Z0-9_/.-]+/g;
  var TAG_VALUE_NORMALIZATION_REGEX = /[^\w\d_:/@.{}[\]$-]+/g;
  var DEFAULT_BROWSER_FLUSH_INTERVAL = 5000;
  var DEFAULT_FLUSH_INTERVAL = 1e4;
  var MAX_WEIGHT = 1e4;
  exports.COUNTER_METRIC_TYPE = COUNTER_METRIC_TYPE;
  exports.DEFAULT_BROWSER_FLUSH_INTERVAL = DEFAULT_BROWSER_FLUSH_INTERVAL;
  exports.DEFAULT_FLUSH_INTERVAL = DEFAULT_FLUSH_INTERVAL;
  exports.DISTRIBUTION_METRIC_TYPE = DISTRIBUTION_METRIC_TYPE;
  exports.GAUGE_METRIC_TYPE = GAUGE_METRIC_TYPE;
  exports.MAX_WEIGHT = MAX_WEIGHT;
  exports.NAME_AND_TAG_KEY_NORMALIZATION_REGEX = NAME_AND_TAG_KEY_NORMALIZATION_REGEX;
  exports.SET_METRIC_TYPE = SET_METRIC_TYPE;
  exports.TAG_VALUE_NORMALIZATION_REGEX = TAG_VALUE_NORMALIZATION_REGEX;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/metrics/utils.js
var require_utils2 = __commonJS((exports) => {
  var getBucketKey = function(metricType, name, unit, tags) {
    const stringifiedTags = Object.entries(utils.dropUndefinedKeys(tags)).sort((a, b) => a[0].localeCompare(b[0]));
    return `${metricType}${name}${unit}${stringifiedTags}`;
  };
  var simpleHash = function(s) {
    let rv = 0;
    for (let i = 0;i < s.length; i++) {
      const c = s.charCodeAt(i);
      rv = (rv << 5) - rv + c;
      rv &= rv;
    }
    return rv >>> 0;
  };
  var serializeMetricBuckets = function(metricBucketItems) {
    let out = "";
    for (const item of metricBucketItems) {
      const tagEntries = Object.entries(item.tags);
      const maybeTags = tagEntries.length > 0 ? `|#${tagEntries.map(([key, value]) => `${key}:${value}`).join(",")}` : "";
      out += `${item.name}@${item.unit}:${item.metric}|${item.metricType}${maybeTags}|T${item.timestamp}\n`;
    }
    return out;
  };
  var sanitizeTags = function(unsanitizedTags) {
    const tags = {};
    for (const key in unsanitizedTags) {
      if (Object.prototype.hasOwnProperty.call(unsanitizedTags, key)) {
        const sanitizedKey = key.replace(constants.NAME_AND_TAG_KEY_NORMALIZATION_REGEX, "_");
        tags[sanitizedKey] = String(unsanitizedTags[key]).replace(constants.TAG_VALUE_NORMALIZATION_REGEX, "_");
      }
    }
    return tags;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var constants = require_constants2();
  exports.getBucketKey = getBucketKey;
  exports.sanitizeTags = sanitizeTags;
  exports.serializeMetricBuckets = serializeMetricBuckets;
  exports.simpleHash = simpleHash;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/metrics/envelope.js
var require_envelope3 = __commonJS((exports) => {
  var createMetricEnvelope = function(metricBucketItems, dsn, metadata, tunnel) {
    const headers = {
      sent_at: new Date().toISOString()
    };
    if (metadata && metadata.sdk) {
      headers.sdk = {
        name: metadata.sdk.name,
        version: metadata.sdk.version
      };
    }
    if (!!tunnel && dsn) {
      headers.dsn = utils.dsnToString(dsn);
    }
    const item = createMetricEnvelopeItem(metricBucketItems);
    return utils.createEnvelope(headers, [item]);
  };
  var createMetricEnvelopeItem = function(metricBucketItems) {
    const payload = utils$1.serializeMetricBuckets(metricBucketItems);
    const metricHeaders = {
      type: "statsd",
      length: payload.length
    };
    return [metricHeaders, payload];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var utils$1 = require_utils2();
  exports.createMetricEnvelope = createMetricEnvelope;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/baseclient.js
var require_baseclient = __commonJS((exports) => {
  var _validateBeforeSendResult = function(beforeSendResult, beforeSendLabel) {
    const invalidValueError = `${beforeSendLabel} must return \`null\` or a valid event.`;
    if (utils.isThenable(beforeSendResult)) {
      return beforeSendResult.then((event) => {
        if (!utils.isPlainObject(event) && event !== null) {
          throw new utils.SentryError(invalidValueError);
        }
        return event;
      }, (e) => {
        throw new utils.SentryError(`${beforeSendLabel} rejected with ${e}`);
      });
    } else if (!utils.isPlainObject(beforeSendResult) && beforeSendResult !== null) {
      throw new utils.SentryError(invalidValueError);
    }
    return beforeSendResult;
  };
  var processBeforeSend = function(options, event, hint) {
    const { beforeSend, beforeSendTransaction } = options;
    if (isErrorEvent(event) && beforeSend) {
      return beforeSend(event, hint);
    }
    if (isTransactionEvent(event) && beforeSendTransaction) {
      return beforeSendTransaction(event, hint);
    }
    return event;
  };
  var isErrorEvent = function(event) {
    return event.type === undefined;
  };
  var isTransactionEvent = function(event) {
    return event.type === "transaction";
  };
  var addEventProcessor = function(callback) {
    const client = exports$1.getClient();
    if (!client || !client.addEventProcessor) {
      return;
    }
    client.addEventProcessor(callback);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var api = require_api();
  var debugBuild = require_debug_build2();
  var envelope = require_envelope2();
  var exports$1 = require_exports();
  var hub = require_hub();
  var integration = require_integration();
  var envelope$1 = require_envelope3();
  var session = require_session();
  var dynamicSamplingContext = require_dynamicSamplingContext();
  var prepareEvent = require_prepareEvent();
  var ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";

  class BaseClient {
    constructor(options) {
      this._options = options;
      this._integrations = {};
      this._integrationsInitialized = false;
      this._numProcessing = 0;
      this._outcomes = {};
      this._hooks = {};
      this._eventProcessors = [];
      if (options.dsn) {
        this._dsn = utils.makeDsn(options.dsn);
      } else {
        debugBuild.DEBUG_BUILD && utils.logger.warn("No DSN provided, client will not send events.");
      }
      if (this._dsn) {
        const url = api.getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options);
        this._transport = options.transport({
          recordDroppedEvent: this.recordDroppedEvent.bind(this),
          ...options.transportOptions,
          url
        });
      }
    }
    captureException(exception, hint, scope) {
      if (utils.checkOrSetAlreadyCaught(exception)) {
        debugBuild.DEBUG_BUILD && utils.logger.log(ALREADY_SEEN_ERROR);
        return;
      }
      let eventId = hint && hint.event_id;
      this._process(this.eventFromException(exception, hint).then((event) => this._captureEvent(event, hint, scope)).then((result) => {
        eventId = result;
      }));
      return eventId;
    }
    captureMessage(message, level, hint, scope) {
      let eventId = hint && hint.event_id;
      const eventMessage = utils.isParameterizedString(message) ? message : String(message);
      const promisedEvent = utils.isPrimitive(message) ? this.eventFromMessage(eventMessage, level, hint) : this.eventFromException(message, hint);
      this._process(promisedEvent.then((event) => this._captureEvent(event, hint, scope)).then((result) => {
        eventId = result;
      }));
      return eventId;
    }
    captureEvent(event, hint, scope) {
      if (hint && hint.originalException && utils.checkOrSetAlreadyCaught(hint.originalException)) {
        debugBuild.DEBUG_BUILD && utils.logger.log(ALREADY_SEEN_ERROR);
        return;
      }
      let eventId = hint && hint.event_id;
      const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
      const capturedSpanScope = sdkProcessingMetadata.capturedSpanScope;
      this._process(this._captureEvent(event, hint, capturedSpanScope || scope).then((result) => {
        eventId = result;
      }));
      return eventId;
    }
    captureSession(session$1) {
      if (!(typeof session$1.release === "string")) {
        debugBuild.DEBUG_BUILD && utils.logger.warn("Discarded session because of missing or non-string release");
      } else {
        this.sendSession(session$1);
        session.updateSession(session$1, { init: false });
      }
    }
    getDsn() {
      return this._dsn;
    }
    getOptions() {
      return this._options;
    }
    getSdkMetadata() {
      return this._options._metadata;
    }
    getTransport() {
      return this._transport;
    }
    flush(timeout) {
      const transport = this._transport;
      if (transport) {
        if (this.metricsAggregator) {
          this.metricsAggregator.flush();
        }
        return this._isClientDoneProcessing(timeout).then((clientFinished) => {
          return transport.flush(timeout).then((transportFlushed) => clientFinished && transportFlushed);
        });
      } else {
        return utils.resolvedSyncPromise(true);
      }
    }
    close(timeout) {
      return this.flush(timeout).then((result) => {
        this.getOptions().enabled = false;
        if (this.metricsAggregator) {
          this.metricsAggregator.close();
        }
        return result;
      });
    }
    getEventProcessors() {
      return this._eventProcessors;
    }
    addEventProcessor(eventProcessor) {
      this._eventProcessors.push(eventProcessor);
    }
    setupIntegrations(forceInitialize) {
      if (forceInitialize && !this._integrationsInitialized || this._isEnabled() && !this._integrationsInitialized) {
        this._setupIntegrations();
      }
    }
    init() {
      if (this._isEnabled()) {
        this._setupIntegrations();
      }
    }
    getIntegrationById(integrationId) {
      return this.getIntegrationByName(integrationId);
    }
    getIntegrationByName(integrationName) {
      return this._integrations[integrationName];
    }
    getIntegration(integration2) {
      try {
        return this._integrations[integration2.id] || null;
      } catch (_oO) {
        debugBuild.DEBUG_BUILD && utils.logger.warn(`Cannot retrieve integration ${integration2.id} from the current Client`);
        return null;
      }
    }
    addIntegration(integration$1) {
      const isAlreadyInstalled = this._integrations[integration$1.name];
      integration.setupIntegration(this, integration$1, this._integrations);
      if (!isAlreadyInstalled) {
        integration.afterSetupIntegrations(this, [integration$1]);
      }
    }
    sendEvent(event, hint = {}) {
      this.emit("beforeSendEvent", event, hint);
      let env = envelope.createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);
      for (const attachment of hint.attachments || []) {
        env = utils.addItemToEnvelope(env, utils.createAttachmentEnvelopeItem(attachment, this._options.transportOptions && this._options.transportOptions.textEncoder));
      }
      const promise = this._sendEnvelope(env);
      if (promise) {
        promise.then((sendResponse) => this.emit("afterSendEvent", event, sendResponse), null);
      }
    }
    sendSession(session2) {
      const env = envelope.createSessionEnvelope(session2, this._dsn, this._options._metadata, this._options.tunnel);
      this._sendEnvelope(env);
    }
    recordDroppedEvent(reason, category, _event) {
      if (this._options.sendClientReports) {
        const key = `${reason}:${category}`;
        debugBuild.DEBUG_BUILD && utils.logger.log(`Adding outcome: "${key}"`);
        this._outcomes[key] = this._outcomes[key] + 1 || 1;
      }
    }
    captureAggregateMetrics(metricBucketItems) {
      debugBuild.DEBUG_BUILD && utils.logger.log(`Flushing aggregated metrics, number of metrics: ${metricBucketItems.length}`);
      const metricsEnvelope = envelope$1.createMetricEnvelope(metricBucketItems, this._dsn, this._options._metadata, this._options.tunnel);
      this._sendEnvelope(metricsEnvelope);
    }
    on(hook, callback) {
      if (!this._hooks[hook]) {
        this._hooks[hook] = [];
      }
      this._hooks[hook].push(callback);
    }
    emit(hook, ...rest) {
      if (this._hooks[hook]) {
        this._hooks[hook].forEach((callback) => callback(...rest));
      }
    }
    _setupIntegrations() {
      const { integrations } = this._options;
      this._integrations = integration.setupIntegrations(this, integrations);
      integration.afterSetupIntegrations(this, integrations);
      this._integrationsInitialized = true;
    }
    _updateSessionFromEvent(session$1, event) {
      let crashed = false;
      let errored = false;
      const exceptions = event.exception && event.exception.values;
      if (exceptions) {
        errored = true;
        for (const ex of exceptions) {
          const mechanism = ex.mechanism;
          if (mechanism && mechanism.handled === false) {
            crashed = true;
            break;
          }
        }
      }
      const sessionNonTerminal = session$1.status === "ok";
      const shouldUpdateAndSend = sessionNonTerminal && session$1.errors === 0 || sessionNonTerminal && crashed;
      if (shouldUpdateAndSend) {
        session.updateSession(session$1, {
          ...crashed && { status: "crashed" },
          errors: session$1.errors || Number(errored || crashed)
        });
        this.captureSession(session$1);
      }
    }
    _isClientDoneProcessing(timeout) {
      return new utils.SyncPromise((resolve) => {
        let ticked = 0;
        const tick = 1;
        const interval = setInterval(() => {
          if (this._numProcessing == 0) {
            clearInterval(interval);
            resolve(true);
          } else {
            ticked += tick;
            if (timeout && ticked >= timeout) {
              clearInterval(interval);
              resolve(false);
            }
          }
        }, tick);
      });
    }
    _isEnabled() {
      return this.getOptions().enabled !== false && this._transport !== undefined;
    }
    _prepareEvent(event, hint, scope, isolationScope = hub.getIsolationScope()) {
      const options = this.getOptions();
      const integrations = Object.keys(this._integrations);
      if (!hint.integrations && integrations.length > 0) {
        hint.integrations = integrations;
      }
      this.emit("preprocessEvent", event, hint);
      return prepareEvent.prepareEvent(options, event, hint, scope, this, isolationScope).then((evt) => {
        if (evt === null) {
          return evt;
        }
        const propagationContext = {
          ...isolationScope.getPropagationContext(),
          ...scope ? scope.getPropagationContext() : undefined
        };
        const trace = evt.contexts && evt.contexts.trace;
        if (!trace && propagationContext) {
          const { traceId: trace_id, spanId, parentSpanId, dsc } = propagationContext;
          evt.contexts = {
            trace: {
              trace_id,
              span_id: spanId,
              parent_span_id: parentSpanId
            },
            ...evt.contexts
          };
          const dynamicSamplingContext$1 = dsc ? dsc : dynamicSamplingContext.getDynamicSamplingContextFromClient(trace_id, this, scope);
          evt.sdkProcessingMetadata = {
            dynamicSamplingContext: dynamicSamplingContext$1,
            ...evt.sdkProcessingMetadata
          };
        }
        return evt;
      });
    }
    _captureEvent(event, hint = {}, scope) {
      return this._processEvent(event, hint, scope).then((finalEvent) => {
        return finalEvent.event_id;
      }, (reason) => {
        if (debugBuild.DEBUG_BUILD) {
          const sentryError = reason;
          if (sentryError.logLevel === "log") {
            utils.logger.log(sentryError.message);
          } else {
            utils.logger.warn(sentryError);
          }
        }
        return;
      });
    }
    _processEvent(event, hint, scope) {
      const options = this.getOptions();
      const { sampleRate } = options;
      const isTransaction = isTransactionEvent(event);
      const isError = isErrorEvent(event);
      const eventType = event.type || "error";
      const beforeSendLabel = `before send for type \`${eventType}\``;
      if (isError && typeof sampleRate === "number" && Math.random() > sampleRate) {
        this.recordDroppedEvent("sample_rate", "error", event);
        return utils.rejectedSyncPromise(new utils.SentryError(`Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`, "log"));
      }
      const dataCategory = eventType === "replay_event" ? "replay" : eventType;
      const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
      const capturedSpanIsolationScope = sdkProcessingMetadata.capturedSpanIsolationScope;
      return this._prepareEvent(event, hint, scope, capturedSpanIsolationScope).then((prepared) => {
        if (prepared === null) {
          this.recordDroppedEvent("event_processor", dataCategory, event);
          throw new utils.SentryError("An event processor returned `null`, will not send event.", "log");
        }
        const isInternalException = hint.data && hint.data.__sentry__ === true;
        if (isInternalException) {
          return prepared;
        }
        const result = processBeforeSend(options, prepared, hint);
        return _validateBeforeSendResult(result, beforeSendLabel);
      }).then((processedEvent) => {
        if (processedEvent === null) {
          this.recordDroppedEvent("before_send", dataCategory, event);
          throw new utils.SentryError(`${beforeSendLabel} returned \`null\`, will not send event.`, "log");
        }
        const session2 = scope && scope.getSession();
        if (!isTransaction && session2) {
          this._updateSessionFromEvent(session2, processedEvent);
        }
        const transactionInfo = processedEvent.transaction_info;
        if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {
          const source = "custom";
          processedEvent.transaction_info = {
            ...transactionInfo,
            source
          };
        }
        this.sendEvent(processedEvent, hint);
        return processedEvent;
      }).then(null, (reason) => {
        if (reason instanceof utils.SentryError) {
          throw reason;
        }
        this.captureException(reason, {
          data: {
            __sentry__: true
          },
          originalException: reason
        });
        throw new utils.SentryError(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: ${reason}`);
      });
    }
    _process(promise) {
      this._numProcessing++;
      promise.then((value) => {
        this._numProcessing--;
        return value;
      }, (reason) => {
        this._numProcessing--;
        return reason;
      });
    }
    _sendEnvelope(envelope2) {
      this.emit("beforeEnvelope", envelope2);
      if (this._isEnabled() && this._transport) {
        return this._transport.send(envelope2).then(null, (reason) => {
          debugBuild.DEBUG_BUILD && utils.logger.error("Error while sending event:", reason);
        });
      } else {
        debugBuild.DEBUG_BUILD && utils.logger.error("Transport disabled");
      }
    }
    _clearOutcomes() {
      const outcomes = this._outcomes;
      this._outcomes = {};
      return Object.keys(outcomes).map((key) => {
        const [reason, category] = key.split(":");
        return {
          reason,
          category,
          quantity: outcomes[key]
        };
      });
    }
  }
  exports.BaseClient = BaseClient;
  exports.addEventProcessor = addEventProcessor;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/checkin.js
var require_checkin = __commonJS((exports) => {
  var createCheckInEnvelope = function(checkIn, dynamicSamplingContext, metadata, tunnel, dsn) {
    const headers = {
      sent_at: new Date().toISOString()
    };
    if (metadata && metadata.sdk) {
      headers.sdk = {
        name: metadata.sdk.name,
        version: metadata.sdk.version
      };
    }
    if (!!tunnel && !!dsn) {
      headers.dsn = utils.dsnToString(dsn);
    }
    if (dynamicSamplingContext) {
      headers.trace = utils.dropUndefinedKeys(dynamicSamplingContext);
    }
    const item = createCheckInEnvelopeItem(checkIn);
    return utils.createEnvelope(headers, [item]);
  };
  var createCheckInEnvelopeItem = function(checkIn) {
    const checkInHeaders = {
      type: "check_in"
    };
    return [checkInHeaders, checkIn];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  exports.createCheckInEnvelope = createCheckInEnvelope;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/metrics/instance.js
var require_instance = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var constants = require_constants2();
  var utils = require_utils2();

  class CounterMetric {
    constructor(_value) {
      this._value = _value;
    }
    get weight() {
      return 1;
    }
    add(value) {
      this._value += value;
    }
    toString() {
      return `${this._value}`;
    }
  }

  class GaugeMetric {
    constructor(value) {
      this._last = value;
      this._min = value;
      this._max = value;
      this._sum = value;
      this._count = 1;
    }
    get weight() {
      return 5;
    }
    add(value) {
      this._last = value;
      if (value < this._min) {
        this._min = value;
      }
      if (value > this._max) {
        this._max = value;
      }
      this._sum += value;
      this._count++;
    }
    toString() {
      return `${this._last}:${this._min}:${this._max}:${this._sum}:${this._count}`;
    }
  }

  class DistributionMetric {
    constructor(first) {
      this._value = [first];
    }
    get weight() {
      return this._value.length;
    }
    add(value) {
      this._value.push(value);
    }
    toString() {
      return this._value.join(":");
    }
  }

  class SetMetric {
    constructor(first) {
      this.first = first;
      this._value = new Set([first]);
    }
    get weight() {
      return this._value.size;
    }
    add(value) {
      this._value.add(value);
    }
    toString() {
      return Array.from(this._value).map((val) => typeof val === "string" ? utils.simpleHash(val) : val).join(":");
    }
  }
  var METRIC_MAP = {
    [constants.COUNTER_METRIC_TYPE]: CounterMetric,
    [constants.GAUGE_METRIC_TYPE]: GaugeMetric,
    [constants.DISTRIBUTION_METRIC_TYPE]: DistributionMetric,
    [constants.SET_METRIC_TYPE]: SetMetric
  };
  exports.CounterMetric = CounterMetric;
  exports.DistributionMetric = DistributionMetric;
  exports.GaugeMetric = GaugeMetric;
  exports.METRIC_MAP = METRIC_MAP;
  exports.SetMetric = SetMetric;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/metrics/aggregator.js
var require_aggregator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils$1 = require_cjs();
  var constants = require_constants2();
  var instance = require_instance();
  var utils = require_utils2();

  class MetricsAggregator {
    constructor(_client) {
      this._client = _client;
      this._buckets = new Map;
      this._bucketsTotalWeight = 0;
      this._interval = setInterval(() => this._flush(), constants.DEFAULT_FLUSH_INTERVAL);
      this._flushShift = Math.floor(Math.random() * constants.DEFAULT_FLUSH_INTERVAL / 1000);
      this._forceFlush = false;
    }
    add(metricType, unsanitizedName, value, unit = "none", unsanitizedTags = {}, maybeFloatTimestamp = utils$1.timestampInSeconds()) {
      const timestamp = Math.floor(maybeFloatTimestamp);
      const name = unsanitizedName.replace(constants.NAME_AND_TAG_KEY_NORMALIZATION_REGEX, "_");
      const tags = utils.sanitizeTags(unsanitizedTags);
      const bucketKey = utils.getBucketKey(metricType, name, unit, tags);
      let bucketItem = this._buckets.get(bucketKey);
      if (bucketItem) {
        bucketItem.metric.add(value);
        if (bucketItem.timestamp < timestamp) {
          bucketItem.timestamp = timestamp;
        }
      } else {
        bucketItem = {
          metric: new instance.METRIC_MAP[metricType](value),
          timestamp,
          metricType,
          name,
          unit,
          tags
        };
        this._buckets.set(bucketKey, bucketItem);
      }
      this._bucketsTotalWeight += bucketItem.metric.weight;
      if (this._bucketsTotalWeight >= constants.MAX_WEIGHT) {
        this.flush();
      }
    }
    flush() {
      this._forceFlush = true;
      this._flush();
    }
    close() {
      this._forceFlush = true;
      clearInterval(this._interval);
      this._flush();
    }
    _flush() {
      if (this._forceFlush) {
        this._forceFlush = false;
        this._bucketsTotalWeight = 0;
        this._captureMetrics(this._buckets);
        this._buckets.clear();
        return;
      }
      const cutoffSeconds = Math.floor(utils$1.timestampInSeconds()) - constants.DEFAULT_FLUSH_INTERVAL / 1000 - this._flushShift;
      const flushedBuckets = new Map;
      for (const [key, bucket] of this._buckets) {
        if (bucket.timestamp <= cutoffSeconds) {
          flushedBuckets.set(key, bucket);
          this._bucketsTotalWeight -= bucket.metric.weight;
        }
      }
      for (const [key] of flushedBuckets) {
        this._buckets.delete(key);
      }
      this._captureMetrics(flushedBuckets);
    }
    _captureMetrics(flushedBuckets) {
      if (flushedBuckets.size > 0 && this._client.captureAggregateMetrics) {
        const buckets = Array.from(flushedBuckets).map(([, bucketItem]) => bucketItem);
        this._client.captureAggregateMetrics(buckets);
      }
    }
  }
  exports.MetricsAggregator = MetricsAggregator;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/server-runtime-client.js
var require_server_runtime_client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var baseclient = require_baseclient();
  var checkin = require_checkin();
  var debugBuild = require_debug_build2();
  var exports$1 = require_exports();
  var aggregator = require_aggregator();
  var sessionflusher = require_sessionflusher();
  var hubextensions = require_hubextensions();
  var spanUtils = require_spanUtils();
  var getRootSpan = require_getRootSpan();
  require_spanstatus();
  var dynamicSamplingContext = require_dynamicSamplingContext();

  class ServerRuntimeClient extends baseclient.BaseClient {
    constructor(options) {
      hubextensions.addTracingExtensions();
      super(options);
      if (options._experiments && options._experiments["metricsAggregator"]) {
        this.metricsAggregator = new aggregator.MetricsAggregator(this);
      }
    }
    eventFromException(exception, hint) {
      return utils.resolvedSyncPromise(utils.eventFromUnknownInput(exports$1.getClient(), this._options.stackParser, exception, hint));
    }
    eventFromMessage(message, level = "info", hint) {
      return utils.resolvedSyncPromise(utils.eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace));
    }
    captureException(exception, hint, scope) {
      if (this._options.autoSessionTracking && this._sessionFlusher && scope) {
        const requestSession = scope.getRequestSession();
        if (requestSession && requestSession.status === "ok") {
          requestSession.status = "errored";
        }
      }
      return super.captureException(exception, hint, scope);
    }
    captureEvent(event, hint, scope) {
      if (this._options.autoSessionTracking && this._sessionFlusher && scope) {
        const eventType = event.type || "exception";
        const isException = eventType === "exception" && event.exception && event.exception.values && event.exception.values.length > 0;
        if (isException) {
          const requestSession = scope.getRequestSession();
          if (requestSession && requestSession.status === "ok") {
            requestSession.status = "errored";
          }
        }
      }
      return super.captureEvent(event, hint, scope);
    }
    close(timeout) {
      if (this._sessionFlusher) {
        this._sessionFlusher.close();
      }
      return super.close(timeout);
    }
    initSessionFlusher() {
      const { release, environment } = this._options;
      if (!release) {
        debugBuild.DEBUG_BUILD && utils.logger.warn("Cannot initialise an instance of SessionFlusher if no release is provided!");
      } else {
        this._sessionFlusher = new sessionflusher.SessionFlusher(this, {
          release,
          environment
        });
      }
    }
    captureCheckIn(checkIn, monitorConfig, scope) {
      const id = "checkInId" in checkIn && checkIn.checkInId ? checkIn.checkInId : utils.uuid4();
      if (!this._isEnabled()) {
        debugBuild.DEBUG_BUILD && utils.logger.warn("SDK not enabled, will not capture checkin.");
        return id;
      }
      const options = this.getOptions();
      const { release, environment, tunnel } = options;
      const serializedCheckIn = {
        check_in_id: id,
        monitor_slug: checkIn.monitorSlug,
        status: checkIn.status,
        release,
        environment
      };
      if ("duration" in checkIn) {
        serializedCheckIn.duration = checkIn.duration;
      }
      if (monitorConfig) {
        serializedCheckIn.monitor_config = {
          schedule: monitorConfig.schedule,
          checkin_margin: monitorConfig.checkinMargin,
          max_runtime: monitorConfig.maxRuntime,
          timezone: monitorConfig.timezone
        };
      }
      const [dynamicSamplingContext2, traceContext] = this._getTraceInfoFromScope(scope);
      if (traceContext) {
        serializedCheckIn.contexts = {
          trace: traceContext
        };
      }
      const envelope = checkin.createCheckInEnvelope(serializedCheckIn, dynamicSamplingContext2, this.getSdkMetadata(), tunnel, this.getDsn());
      debugBuild.DEBUG_BUILD && utils.logger.info("Sending checkin:", checkIn.monitorSlug, checkIn.status);
      this._sendEnvelope(envelope);
      return id;
    }
    _captureRequestSession() {
      if (!this._sessionFlusher) {
        debugBuild.DEBUG_BUILD && utils.logger.warn("Discarded request mode session because autoSessionTracking option was disabled");
      } else {
        this._sessionFlusher.incrementSessionStatusCount();
      }
    }
    _prepareEvent(event, hint, scope, isolationScope) {
      if (this._options.platform) {
        event.platform = event.platform || this._options.platform;
      }
      if (this._options.runtime) {
        event.contexts = {
          ...event.contexts,
          runtime: (event.contexts || {}).runtime || this._options.runtime
        };
      }
      if (this._options.serverName) {
        event.server_name = event.server_name || this._options.serverName;
      }
      return super._prepareEvent(event, hint, scope, isolationScope);
    }
    _getTraceInfoFromScope(scope) {
      if (!scope) {
        return [undefined, undefined];
      }
      const span = scope.getSpan();
      if (span) {
        const samplingContext = getRootSpan.getRootSpan(span) ? dynamicSamplingContext.getDynamicSamplingContextFromSpan(span) : undefined;
        return [samplingContext, spanUtils.spanToTraceContext(span)];
      }
      const { traceId, spanId, parentSpanId, dsc } = scope.getPropagationContext();
      const traceContext = {
        trace_id: traceId,
        span_id: spanId,
        parent_span_id: parentSpanId
      };
      if (dsc) {
        return [dsc, traceContext];
      }
      return [dynamicSamplingContext.getDynamicSamplingContextFromClient(traceId, this, scope), traceContext];
    }
  }
  exports.ServerRuntimeClient = ServerRuntimeClient;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/sdk.js
var require_sdk = __commonJS((exports) => {
  var initAndBind = function(clientClass, options) {
    if (options.debug === true) {
      if (debugBuild.DEBUG_BUILD) {
        utils.logger.enable();
      } else {
        utils.consoleSandbox(() => {
          console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
        });
      }
    }
    const scope = exports$1.getCurrentScope();
    scope.update(options.initialScope);
    const client = new clientClass(options);
    setCurrentClient(client);
    initializeClient(client);
  };
  var setCurrentClient = function(client) {
    const hub$1 = hub.getCurrentHub();
    const top = hub$1.getStackTop();
    top.client = client;
    top.scope.setClient(client);
  };
  var initializeClient = function(client) {
    if (client.init) {
      client.init();
    } else if (client.setupIntegrations) {
      client.setupIntegrations();
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var debugBuild = require_debug_build2();
  var exports$1 = require_exports();
  var hub = require_hub();
  exports.initAndBind = initAndBind;
  exports.setCurrentClient = setCurrentClient;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/transports/base.js
var require_base = __commonJS((exports) => {
  var createTransport = function(options, makeRequest, buffer = utils.makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE)) {
    let rateLimits = {};
    const flush = (timeout) => buffer.drain(timeout);
    function send(envelope) {
      const filteredEnvelopeItems = [];
      utils.forEachEnvelopeItem(envelope, (item, type) => {
        const envelopeItemDataCategory = utils.envelopeItemTypeToDataCategory(type);
        if (utils.isRateLimited(rateLimits, envelopeItemDataCategory)) {
          const event = getEventForEnvelopeItem(item, type);
          options.recordDroppedEvent("ratelimit_backoff", envelopeItemDataCategory, event);
        } else {
          filteredEnvelopeItems.push(item);
        }
      });
      if (filteredEnvelopeItems.length === 0) {
        return utils.resolvedSyncPromise();
      }
      const filteredEnvelope = utils.createEnvelope(envelope[0], filteredEnvelopeItems);
      const recordEnvelopeLoss = (reason) => {
        utils.forEachEnvelopeItem(filteredEnvelope, (item, type) => {
          const event = getEventForEnvelopeItem(item, type);
          options.recordDroppedEvent(reason, utils.envelopeItemTypeToDataCategory(type), event);
        });
      };
      const requestTask = () => makeRequest({ body: utils.serializeEnvelope(filteredEnvelope, options.textEncoder) }).then((response) => {
        if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode >= 300)) {
          debugBuild.DEBUG_BUILD && utils.logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);
        }
        rateLimits = utils.updateRateLimits(rateLimits, response);
        return response;
      }, (error) => {
        recordEnvelopeLoss("network_error");
        throw error;
      });
      return buffer.add(requestTask).then((result) => result, (error) => {
        if (error instanceof utils.SentryError) {
          debugBuild.DEBUG_BUILD && utils.logger.error("Skipped sending event because buffer is full.");
          recordEnvelopeLoss("queue_overflow");
          return utils.resolvedSyncPromise();
        } else {
          throw error;
        }
      });
    }
    send.__sentry__baseTransport__ = true;
    return {
      send,
      flush
    };
  };
  var getEventForEnvelopeItem = function(item, type) {
    if (type !== "event" && type !== "transaction") {
      return;
    }
    return Array.isArray(item) ? item[1] : undefined;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var debugBuild = require_debug_build2();
  var DEFAULT_TRANSPORT_BUFFER_SIZE = 30;
  exports.DEFAULT_TRANSPORT_BUFFER_SIZE = DEFAULT_TRANSPORT_BUFFER_SIZE;
  exports.createTransport = createTransport;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/transports/offline.js
var require_offline = __commonJS((exports) => {
  var log = function(msg, error) {
    debugBuild.DEBUG_BUILD && utils.logger.info(`[Offline]: ${msg}`, error);
  };
  var makeOfflineTransport = function(createTransport) {
    return (options) => {
      const transport = createTransport(options);
      const store = options.createStore ? options.createStore(options) : undefined;
      let retryDelay = START_DELAY;
      let flushTimer;
      function shouldQueue(env, error, retryDelay2) {
        if (utils.envelopeContainsItemType(env, ["replay_event", "replay_recording", "client_report"])) {
          return false;
        }
        if (options.shouldStore) {
          return options.shouldStore(env, error, retryDelay2);
        }
        return true;
      }
      function flushIn(delay) {
        if (!store) {
          return;
        }
        if (flushTimer) {
          clearTimeout(flushTimer);
        }
        flushTimer = setTimeout(async () => {
          flushTimer = undefined;
          const found = await store.pop();
          if (found) {
            log("Attempting to send previously queued event");
            send(found).catch((e) => {
              log("Failed to retry sending", e);
            });
          }
        }, delay);
        if (typeof flushTimer !== "number" && flushTimer.unref) {
          flushTimer.unref();
        }
      }
      function flushWithBackOff() {
        if (flushTimer) {
          return;
        }
        flushIn(retryDelay);
        retryDelay = Math.min(retryDelay * 2, MAX_DELAY);
      }
      async function send(envelope) {
        try {
          const result = await transport.send(envelope);
          let delay = MIN_DELAY;
          if (result) {
            if (result.headers && result.headers["retry-after"]) {
              delay = utils.parseRetryAfterHeader(result.headers["retry-after"]);
            } else if ((result.statusCode || 0) >= 400) {
              return result;
            }
          }
          flushIn(delay);
          retryDelay = START_DELAY;
          return result;
        } catch (e) {
          if (store && await shouldQueue(envelope, e, retryDelay)) {
            await store.insert(envelope);
            flushWithBackOff();
            log("Error sending. Event queued", e);
            return {};
          } else {
            throw e;
          }
        }
      }
      if (options.flushAtStartup) {
        flushWithBackOff();
      }
      return {
        send,
        flush: (t) => transport.flush(t)
      };
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var debugBuild = require_debug_build2();
  var MIN_DELAY = 100;
  var START_DELAY = 5000;
  var MAX_DELAY = 3600000;
  exports.MIN_DELAY = MIN_DELAY;
  exports.START_DELAY = START_DELAY;
  exports.makeOfflineTransport = makeOfflineTransport;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/transports/multiplexed.js
var require_multiplexed = __commonJS((exports) => {
  var eventFromEnvelope = function(env, types) {
    let event;
    utils.forEachEnvelopeItem(env, (item, type) => {
      if (types.includes(type)) {
        event = Array.isArray(item) ? item[1] : undefined;
      }
      return !!event;
    });
    return event;
  };
  var makeOverrideReleaseTransport = function(createTransport, release) {
    return (options) => {
      const transport = createTransport(options);
      return {
        send: async (envelope) => {
          const event = eventFromEnvelope(envelope, ["event", "transaction", "profile", "replay_event"]);
          if (event) {
            event.release = release;
          }
          return transport.send(envelope);
        },
        flush: (timeout) => transport.flush(timeout)
      };
    };
  };
  var makeMultiplexedTransport = function(createTransport, matcher) {
    return (options) => {
      const fallbackTransport = createTransport(options);
      const otherTransports = {};
      function getTransport(dsn, release) {
        const key = release ? `${dsn}:${release}` : dsn;
        if (!otherTransports[key]) {
          const validatedDsn = utils.dsnFromString(dsn);
          if (!validatedDsn) {
            return;
          }
          const url = api.getEnvelopeEndpointWithUrlEncodedAuth(validatedDsn);
          otherTransports[key] = release ? makeOverrideReleaseTransport(createTransport, release)({ ...options, url }) : createTransport({ ...options, url });
        }
        return otherTransports[key];
      }
      async function send(envelope) {
        function getEvent(types) {
          const eventTypes = types && types.length ? types : ["event"];
          return eventFromEnvelope(envelope, eventTypes);
        }
        const transports = matcher({ envelope, getEvent }).map((result) => {
          if (typeof result === "string") {
            return getTransport(result, undefined);
          } else {
            return getTransport(result.dsn, result.release);
          }
        }).filter((t) => !!t);
        if (transports.length === 0) {
          transports.push(fallbackTransport);
        }
        const results = await Promise.all(transports.map((transport) => transport.send(envelope)));
        return results[0];
      }
      async function flush(timeout) {
        const allTransports = [...Object.keys(otherTransports).map((dsn) => otherTransports[dsn]), fallbackTransport];
        const results = await Promise.all(allTransports.map((transport) => transport.flush(timeout)));
        return results.every((r) => r);
      }
      return {
        send,
        flush
      };
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var api = require_api();
  exports.eventFromEnvelope = eventFromEnvelope;
  exports.makeMultiplexedTransport = makeMultiplexedTransport;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/utils/isSentryRequestUrl.js
var require_isSentryRequestUrl = __commonJS((exports) => {
  var isSentryRequestUrl = function(url, hubOrClient) {
    const client = hubOrClient && isHub(hubOrClient) ? hubOrClient.getClient() : hubOrClient;
    const dsn = client && client.getDsn();
    const tunnel = client && client.getOptions().tunnel;
    return checkDsn(url, dsn) || checkTunnel(url, tunnel);
  };
  var checkTunnel = function(url, tunnel) {
    if (!tunnel) {
      return false;
    }
    return removeTrailingSlash(url) === removeTrailingSlash(tunnel);
  };
  var checkDsn = function(url, dsn) {
    return dsn ? url.includes(dsn.host) : false;
  };
  var removeTrailingSlash = function(str) {
    return str[str.length - 1] === "/" ? str.slice(0, -1) : str;
  };
  var isHub = function(hubOrClient) {
    return hubOrClient.getClient !== undefined;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isSentryRequestUrl = isSentryRequestUrl;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/utils/parameterize.js
var require_parameterize = __commonJS((exports) => {
  var parameterize = function(strings, ...values) {
    const formatted = new String(String.raw(strings, ...values));
    formatted.__sentry_template_string__ = strings.join("\0").replace(/%/g, "%%").replace(/\0/g, "%s");
    formatted.__sentry_template_values__ = values;
    return formatted;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parameterize = parameterize;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/utils/sdkMetadata.js
var require_sdkMetadata = __commonJS((exports) => {
  var applySdkMetadata = function(options, name, names = [name], source = "npm") {
    const metadata = options._metadata || {};
    if (!metadata.sdk) {
      metadata.sdk = {
        name: `sentry.javascript.${name}`,
        packages: names.map((name2) => ({
          name: `${source}:@sentry/${name2}`,
          version: version.SDK_VERSION
        })),
        version: version.SDK_VERSION
      };
    }
    options._metadata = metadata;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var version = require_version();
  exports.applySdkMetadata = applySdkMetadata;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/metadata.js
var require_metadata = __commonJS((exports) => {
  var ensureMetadataStacksAreParsed = function(parser) {
    if (!utils.GLOBAL_OBJ._sentryModuleMetadata) {
      return;
    }
    for (const stack of Object.keys(utils.GLOBAL_OBJ._sentryModuleMetadata)) {
      const metadata = utils.GLOBAL_OBJ._sentryModuleMetadata[stack];
      if (parsedStacks.has(stack)) {
        continue;
      }
      parsedStacks.add(stack);
      const frames = parser(stack);
      for (const frame of frames.reverse()) {
        if (frame.filename) {
          filenameMetadataMap.set(frame.filename, metadata);
          break;
        }
      }
    }
  };
  var getMetadataForUrl = function(parser, filename) {
    ensureMetadataStacksAreParsed(parser);
    return filenameMetadataMap.get(filename);
  };
  var addMetadataToStackFrames = function(parser, event) {
    try {
      event.exception.values.forEach((exception) => {
        if (!exception.stacktrace) {
          return;
        }
        for (const frame of exception.stacktrace.frames || []) {
          if (!frame.filename) {
            continue;
          }
          const metadata = getMetadataForUrl(parser, frame.filename);
          if (metadata) {
            frame.module_metadata = metadata;
          }
        }
      });
    } catch (_) {
    }
  };
  var stripMetadataFromStackFrames = function(event) {
    try {
      event.exception.values.forEach((exception) => {
        if (!exception.stacktrace) {
          return;
        }
        for (const frame of exception.stacktrace.frames || []) {
          delete frame.module_metadata;
        }
      });
    } catch (_) {
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var filenameMetadataMap = new Map;
  var parsedStacks = new Set;
  exports.addMetadataToStackFrames = addMetadataToStackFrames;
  exports.getMetadataForUrl = getMetadataForUrl;
  exports.stripMetadataFromStackFrames = stripMetadataFromStackFrames;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/integrations/metadata.js
var require_metadata2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var integration = require_integration();
  var metadata = require_metadata();
  var INTEGRATION_NAME = "ModuleMetadata";
  var _moduleMetadataIntegration = () => {
    return {
      name: INTEGRATION_NAME,
      setupOnce() {
      },
      setup(client) {
        if (typeof client.on !== "function") {
          return;
        }
        client.on("beforeEnvelope", (envelope) => {
          utils.forEachEnvelopeItem(envelope, (item, type) => {
            if (type === "event") {
              const event = Array.isArray(item) ? item[1] : undefined;
              if (event) {
                metadata.stripMetadataFromStackFrames(event);
                item[1] = event;
              }
            }
          });
        });
      },
      processEvent(event, _hint, client) {
        const stackParser = client.getOptions().stackParser;
        metadata.addMetadataToStackFrames(stackParser, event);
        return event;
      }
    };
  };
  var moduleMetadataIntegration = integration.defineIntegration(_moduleMetadataIntegration);
  var ModuleMetadata = integration.convertIntegrationFnToClass(INTEGRATION_NAME, moduleMetadataIntegration);
  exports.ModuleMetadata = ModuleMetadata;
  exports.moduleMetadataIntegration = moduleMetadataIntegration;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/integrations/requestdata.js
var require_requestdata2 = __commonJS((exports) => {
  var convertReqDataIntegrationOptsToAddReqDataOpts = function(integrationOptions) {
    const {
      transactionNamingScheme,
      include: { ip, user, ...requestOptions }
    } = integrationOptions;
    const requestIncludeKeys = [];
    for (const [key, value] of Object.entries(requestOptions)) {
      if (value) {
        requestIncludeKeys.push(key);
      }
    }
    let addReqDataUserOpt;
    if (user === undefined) {
      addReqDataUserOpt = true;
    } else if (typeof user === "boolean") {
      addReqDataUserOpt = user;
    } else {
      const userIncludeKeys = [];
      for (const [key, value] of Object.entries(user)) {
        if (value) {
          userIncludeKeys.push(key);
        }
      }
      addReqDataUserOpt = userIncludeKeys;
    }
    return {
      include: {
        ip,
        user: addReqDataUserOpt,
        request: requestIncludeKeys.length !== 0 ? requestIncludeKeys : undefined,
        transaction: transactionNamingScheme
      }
    };
  };
  var getSDKName = function(client) {
    try {
      return client.getOptions()._metadata.sdk.name;
    } catch (err) {
      return;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var integration = require_integration();
  var spanUtils = require_spanUtils();
  var DEFAULT_OPTIONS = {
    include: {
      cookies: true,
      data: true,
      headers: true,
      ip: false,
      query_string: true,
      url: true,
      user: {
        id: true,
        username: true,
        email: true
      }
    },
    transactionNamingScheme: "methodPath"
  };
  var INTEGRATION_NAME = "RequestData";
  var _requestDataIntegration = (options = {}) => {
    const _addRequestData = utils.addRequestDataToEvent;
    const _options = {
      ...DEFAULT_OPTIONS,
      ...options,
      include: {
        method: true,
        ...DEFAULT_OPTIONS.include,
        ...options.include,
        user: options.include && typeof options.include.user === "boolean" ? options.include.user : {
          ...DEFAULT_OPTIONS.include.user,
          ...(options.include || {}).user
        }
      }
    };
    return {
      name: INTEGRATION_NAME,
      setupOnce() {
      },
      processEvent(event, _hint, client) {
        const { transactionNamingScheme } = _options;
        const { sdkProcessingMetadata = {} } = event;
        const req = sdkProcessingMetadata.request;
        if (!req) {
          return event;
        }
        const addRequestDataOptions = sdkProcessingMetadata.requestDataOptionsFromExpressHandler || sdkProcessingMetadata.requestDataOptionsFromGCPWrapper || convertReqDataIntegrationOptsToAddReqDataOpts(_options);
        const processedEvent = _addRequestData(event, req, addRequestDataOptions);
        if (event.type === "transaction" || transactionNamingScheme === "handler") {
          return processedEvent;
        }
        const reqWithTransaction = req;
        const transaction = reqWithTransaction._sentryTransaction;
        if (transaction) {
          const name = spanUtils.spanToJSON(transaction).description || "";
          const shouldIncludeMethodInTransactionName = getSDKName(client) === "sentry.javascript.nextjs" ? name.startsWith("/api") : transactionNamingScheme !== "path";
          const [transactionValue] = utils.extractPathForTransaction(req, {
            path: true,
            method: shouldIncludeMethodInTransactionName,
            customRoute: name
          });
          processedEvent.transaction = transactionValue;
        }
        return processedEvent;
      }
    };
  };
  var requestDataIntegration = integration.defineIntegration(_requestDataIntegration);
  var RequestData = integration.convertIntegrationFnToClass(INTEGRATION_NAME, requestDataIntegration);
  exports.RequestData = RequestData;
  exports.requestDataIntegration = requestDataIntegration;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/integrations/inboundfilters.js
var require_inboundfilters = __commonJS((exports) => {
  var _mergeOptions = function(internalOptions = {}, clientOptions = {}) {
    return {
      allowUrls: [...internalOptions.allowUrls || [], ...clientOptions.allowUrls || []],
      denyUrls: [...internalOptions.denyUrls || [], ...clientOptions.denyUrls || []],
      ignoreErrors: [
        ...internalOptions.ignoreErrors || [],
        ...clientOptions.ignoreErrors || [],
        ...internalOptions.disableErrorDefaults ? [] : DEFAULT_IGNORE_ERRORS
      ],
      ignoreTransactions: [
        ...internalOptions.ignoreTransactions || [],
        ...clientOptions.ignoreTransactions || [],
        ...internalOptions.disableTransactionDefaults ? [] : DEFAULT_IGNORE_TRANSACTIONS
      ],
      ignoreInternal: internalOptions.ignoreInternal !== undefined ? internalOptions.ignoreInternal : true
    };
  };
  var _shouldDropEvent = function(event, options) {
    if (options.ignoreInternal && _isSentryError(event)) {
      debugBuild.DEBUG_BUILD && utils.logger.warn(`Event dropped due to being internal Sentry Error.\nEvent: ${utils.getEventDescription(event)}`);
      return true;
    }
    if (_isIgnoredError(event, options.ignoreErrors)) {
      debugBuild.DEBUG_BUILD && utils.logger.warn(`Event dropped due to being matched by \`ignoreErrors\` option.\nEvent: ${utils.getEventDescription(event)}`);
      return true;
    }
    if (_isIgnoredTransaction(event, options.ignoreTransactions)) {
      debugBuild.DEBUG_BUILD && utils.logger.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.\nEvent: ${utils.getEventDescription(event)}`);
      return true;
    }
    if (_isDeniedUrl(event, options.denyUrls)) {
      debugBuild.DEBUG_BUILD && utils.logger.warn(`Event dropped due to being matched by \`denyUrls\` option.\nEvent: ${utils.getEventDescription(event)}.\nUrl: ${_getEventFilterUrl(event)}`);
      return true;
    }
    if (!_isAllowedUrl(event, options.allowUrls)) {
      debugBuild.DEBUG_BUILD && utils.logger.warn(`Event dropped due to not being matched by \`allowUrls\` option.\nEvent: ${utils.getEventDescription(event)}.\nUrl: ${_getEventFilterUrl(event)}`);
      return true;
    }
    return false;
  };
  var _isIgnoredError = function(event, ignoreErrors) {
    if (event.type || !ignoreErrors || !ignoreErrors.length) {
      return false;
    }
    return _getPossibleEventMessages(event).some((message) => utils.stringMatchesSomePattern(message, ignoreErrors));
  };
  var _isIgnoredTransaction = function(event, ignoreTransactions) {
    if (event.type !== "transaction" || !ignoreTransactions || !ignoreTransactions.length) {
      return false;
    }
    const name = event.transaction;
    return name ? utils.stringMatchesSomePattern(name, ignoreTransactions) : false;
  };
  var _isDeniedUrl = function(event, denyUrls) {
    if (!denyUrls || !denyUrls.length) {
      return false;
    }
    const url = _getEventFilterUrl(event);
    return !url ? false : utils.stringMatchesSomePattern(url, denyUrls);
  };
  var _isAllowedUrl = function(event, allowUrls) {
    if (!allowUrls || !allowUrls.length) {
      return true;
    }
    const url = _getEventFilterUrl(event);
    return !url ? true : utils.stringMatchesSomePattern(url, allowUrls);
  };
  var _getPossibleEventMessages = function(event) {
    const possibleMessages = [];
    if (event.message) {
      possibleMessages.push(event.message);
    }
    let lastException;
    try {
      lastException = event.exception.values[event.exception.values.length - 1];
    } catch (e) {
    }
    if (lastException) {
      if (lastException.value) {
        possibleMessages.push(lastException.value);
        if (lastException.type) {
          possibleMessages.push(`${lastException.type}: ${lastException.value}`);
        }
      }
    }
    if (debugBuild.DEBUG_BUILD && possibleMessages.length === 0) {
      utils.logger.error(`Could not extract message for event ${utils.getEventDescription(event)}`);
    }
    return possibleMessages;
  };
  var _isSentryError = function(event) {
    try {
      return event.exception.values[0].type === "SentryError";
    } catch (e) {
    }
    return false;
  };
  var _getLastValidUrl = function(frames = []) {
    for (let i = frames.length - 1;i >= 0; i--) {
      const frame = frames[i];
      if (frame && frame.filename !== "<anonymous>" && frame.filename !== "[native code]") {
        return frame.filename || null;
      }
    }
    return null;
  };
  var _getEventFilterUrl = function(event) {
    try {
      let frames;
      try {
        frames = event.exception.values[0].stacktrace.frames;
      } catch (e) {
      }
      return frames ? _getLastValidUrl(frames) : null;
    } catch (oO) {
      debugBuild.DEBUG_BUILD && utils.logger.error(`Cannot extract url for event ${utils.getEventDescription(event)}`);
      return null;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var debugBuild = require_debug_build2();
  var integration = require_integration();
  var DEFAULT_IGNORE_ERRORS = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
  var DEFAULT_IGNORE_TRANSACTIONS = [
    /^.*\/healthcheck$/,
    /^.*\/healthy$/,
    /^.*\/live$/,
    /^.*\/ready$/,
    /^.*\/heartbeat$/,
    /^.*\/health$/,
    /^.*\/healthz$/
  ];
  var INTEGRATION_NAME = "InboundFilters";
  var _inboundFiltersIntegration = (options = {}) => {
    return {
      name: INTEGRATION_NAME,
      setupOnce() {
      },
      processEvent(event, _hint, client) {
        const clientOptions = client.getOptions();
        const mergedOptions = _mergeOptions(options, clientOptions);
        return _shouldDropEvent(event, mergedOptions) ? null : event;
      }
    };
  };
  var inboundFiltersIntegration = integration.defineIntegration(_inboundFiltersIntegration);
  var InboundFilters = integration.convertIntegrationFnToClass(INTEGRATION_NAME, inboundFiltersIntegration);
  exports.InboundFilters = InboundFilters;
  exports.inboundFiltersIntegration = inboundFiltersIntegration;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/integrations/functiontostring.js
var require_functiontostring = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var exports$1 = require_exports();
  var integration = require_integration();
  var originalFunctionToString;
  var INTEGRATION_NAME = "FunctionToString";
  var SETUP_CLIENTS = new WeakMap;
  var _functionToStringIntegration = () => {
    return {
      name: INTEGRATION_NAME,
      setupOnce() {
        originalFunctionToString = Function.prototype.toString;
        try {
          Function.prototype.toString = function(...args) {
            const originalFunction = utils.getOriginalFunction(this);
            const context = SETUP_CLIENTS.has(exports$1.getClient()) && originalFunction !== undefined ? originalFunction : this;
            return originalFunctionToString.apply(context, args);
          };
        } catch (e) {
        }
      },
      setup(client) {
        SETUP_CLIENTS.set(client, true);
      }
    };
  };
  var functionToStringIntegration = integration.defineIntegration(_functionToStringIntegration);
  var FunctionToString = integration.convertIntegrationFnToClass(INTEGRATION_NAME, functionToStringIntegration);
  exports.FunctionToString = FunctionToString;
  exports.functionToStringIntegration = functionToStringIntegration;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/integrations/linkederrors.js
var require_linkederrors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var integration = require_integration();
  var DEFAULT_KEY = "cause";
  var DEFAULT_LIMIT = 5;
  var INTEGRATION_NAME = "LinkedErrors";
  var _linkedErrorsIntegration = (options = {}) => {
    const limit = options.limit || DEFAULT_LIMIT;
    const key = options.key || DEFAULT_KEY;
    return {
      name: INTEGRATION_NAME,
      setupOnce() {
      },
      preprocessEvent(event, hint, client) {
        const options2 = client.getOptions();
        utils.applyAggregateErrorsToEvent(utils.exceptionFromError, options2.stackParser, options2.maxValueLength, key, limit, event, hint);
      }
    };
  };
  var linkedErrorsIntegration = integration.defineIntegration(_linkedErrorsIntegration);
  var LinkedErrors = integration.convertIntegrationFnToClass(INTEGRATION_NAME, linkedErrorsIntegration);
  exports.LinkedErrors = LinkedErrors;
  exports.linkedErrorsIntegration = linkedErrorsIntegration;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/integrations/index.js
var require_integrations = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var functiontostring = require_functiontostring();
  var inboundfilters = require_inboundfilters();
  var linkederrors = require_linkederrors();
  exports.FunctionToString = functiontostring.FunctionToString;
  exports.InboundFilters = inboundfilters.InboundFilters;
  exports.LinkedErrors = linkederrors.LinkedErrors;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/metrics/browser-aggregator.js
var require_browser_aggregator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils$1 = require_cjs();
  var constants = require_constants2();
  var instance = require_instance();
  var utils = require_utils2();

  class BrowserMetricsAggregator {
    constructor(_client) {
      this._client = _client;
      this._buckets = new Map;
      this._interval = setInterval(() => this.flush(), constants.DEFAULT_BROWSER_FLUSH_INTERVAL);
    }
    add(metricType, unsanitizedName, value, unit = "none", unsanitizedTags = {}, maybeFloatTimestamp = utils$1.timestampInSeconds()) {
      const timestamp = Math.floor(maybeFloatTimestamp);
      const name = unsanitizedName.replace(constants.NAME_AND_TAG_KEY_NORMALIZATION_REGEX, "_");
      const tags = utils.sanitizeTags(unsanitizedTags);
      const bucketKey = utils.getBucketKey(metricType, name, unit, tags);
      const bucketItem = this._buckets.get(bucketKey);
      if (bucketItem) {
        bucketItem.metric.add(value);
        if (bucketItem.timestamp < timestamp) {
          bucketItem.timestamp = timestamp;
        }
      } else {
        this._buckets.set(bucketKey, {
          metric: new instance.METRIC_MAP[metricType](value),
          timestamp,
          metricType,
          name,
          unit,
          tags
        });
      }
    }
    flush() {
      if (this._buckets.size === 0) {
        return;
      }
      if (this._client.captureAggregateMetrics) {
        const metricBuckets = Array.from(this._buckets).map(([, bucketItem]) => bucketItem);
        this._client.captureAggregateMetrics(metricBuckets);
      }
      this._buckets.clear();
    }
    close() {
      clearInterval(this._interval);
      this.flush();
    }
  }
  exports.BrowserMetricsAggregator = BrowserMetricsAggregator;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/metrics/integration.js
var require_integration2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var integration = require_integration();
  var browserAggregator = require_browser_aggregator();
  var INTEGRATION_NAME = "MetricsAggregator";
  var _metricsAggregatorIntegration = () => {
    return {
      name: INTEGRATION_NAME,
      setupOnce() {
      },
      setup(client) {
        client.metricsAggregator = new browserAggregator.BrowserMetricsAggregator(client);
      }
    };
  };
  var metricsAggregatorIntegration = integration.defineIntegration(_metricsAggregatorIntegration);
  var MetricsAggregator = integration.convertIntegrationFnToClass(INTEGRATION_NAME, metricsAggregatorIntegration);
  exports.MetricsAggregator = MetricsAggregator;
  exports.metricsAggregatorIntegration = metricsAggregatorIntegration;
});

// ../node_modules/.pnpm/@sentry+core@7.100.1/node_modules/@sentry/core/cjs/metrics/exports.js
var require_exports2 = __commonJS((exports) => {
  var addToMetricsAggregator = function(metricType, name, value, data = {}) {
    const client = exports$1.getClient();
    const scope = exports$1.getCurrentScope();
    if (client) {
      if (!client.metricsAggregator) {
        debugBuild.DEBUG_BUILD && utils.logger.warn("No metrics aggregator enabled. Please add the MetricsAggregator integration to use metrics APIs");
        return;
      }
      const { unit, tags, timestamp } = data;
      const { release, environment } = client.getOptions();
      const transaction = scope.getTransaction();
      const metricTags = {};
      if (release) {
        metricTags.release = release;
      }
      if (environment) {
        metricTags.environment = environment;
      }
      if (transaction) {
        metricTags.transaction = spanUtils.spanToJSON(transaction).description || "";
      }
      debugBuild.DEBUG_BUILD && utils.logger.log(`Adding value of ${value} to ${metricType} metric ${name}`);
      client.metricsAggregator.add(metricType, name, value, unit, { ...metricTags, ...tags }, timestamp);
    }
  };
  var increment = function(name, value = 1, data) {
    addToMetricsAggregator(constants.COUNTER_METRIC_TYPE, name, value, data);
  };
  var distribution = function(name, value, data) {
    addToMetricsAggregator(constants.DISTRIBUTION_METRIC_TYPE, name, value, data);
  };
  var set = function(name, value, data) {
    addToMetricsAggregator(constants.SET_METRIC_TYPE, name, value, data);
  };
  var gauge = function(name, value, data) {
    addToMetricsAggregator(constants.GAUGE_METRIC_TYPE, name, value, data);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var debugBuild = require_debug_build2();
  var exports$1 = require_exports();
  var spanUtils = require_spanUtils();
  var constants = require_constants2();
  var integration = require_integration2();
  var metrics = {
    increment,
    distribution,
    set,
    gauge,
    MetricsAggregator: integration.MetricsAggregator,
    metricsAggregatorIntegration: integration.metricsAggregatorIntegration
  };
  exports.distribution = distribution;
  exports.gauge = gauge;
  exports.increment = increment;
  exports.metrics = metrics;
  exports.set = set;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/core/cjs/index.js
var require_cjs2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var hubextensions = require_hubextensions();
  var idletransaction = require_idletransaction();
  var span = require_span();
  var transaction = require_transaction();
  var utils = require_utils();
  var spanstatus = require_spanstatus();
  var trace = require_trace();
  var dynamicSamplingContext = require_dynamicSamplingContext();
  var measurement = require_measurement();
  var semanticAttributes = require_semanticAttributes();
  var envelope = require_envelope2();
  var exports$1 = require_exports();
  var hub = require_hub();
  var session = require_session();
  var sessionflusher = require_sessionflusher();
  var scope = require_scope();
  var eventProcessors = require_eventProcessors();
  var api = require_api();
  var baseclient = require_baseclient();
  var serverRuntimeClient = require_server_runtime_client();
  var sdk = require_sdk();
  var base = require_base();
  var offline = require_offline();
  var multiplexed = require_multiplexed();
  var version = require_version();
  var integration = require_integration();
  var applyScopeDataToEvent = require_applyScopeDataToEvent();
  var prepareEvent = require_prepareEvent();
  var checkin = require_checkin();
  var hasTracingEnabled = require_hasTracingEnabled();
  var isSentryRequestUrl = require_isSentryRequestUrl();
  var handleCallbackErrors = require_handleCallbackErrors();
  var parameterize = require_parameterize();
  var spanUtils = require_spanUtils();
  var getRootSpan = require_getRootSpan();
  var sdkMetadata = require_sdkMetadata();
  var constants = require_constants();
  var metadata = require_metadata2();
  var requestdata = require_requestdata2();
  var inboundfilters = require_inboundfilters();
  var functiontostring = require_functiontostring();
  var linkederrors = require_linkederrors();
  var index = require_integrations();
  var exports$2 = require_exports2();
  var Integrations = index;
  exports.addTracingExtensions = hubextensions.addTracingExtensions;
  exports.startIdleTransaction = hubextensions.startIdleTransaction;
  exports.IdleTransaction = idletransaction.IdleTransaction;
  exports.TRACING_DEFAULTS = idletransaction.TRACING_DEFAULTS;
  exports.Span = span.Span;
  exports.Transaction = transaction.Transaction;
  exports.extractTraceparentData = utils.extractTraceparentData;
  exports.getActiveTransaction = utils.getActiveTransaction;
  Object.defineProperty(exports, "SpanStatus", {
    enumerable: true,
    get: () => spanstatus.SpanStatus
  });
  exports.getSpanStatusFromHttpCode = spanstatus.getSpanStatusFromHttpCode;
  exports.setHttpStatus = spanstatus.setHttpStatus;
  exports.spanStatusfromHttpCode = spanstatus.spanStatusfromHttpCode;
  exports.continueTrace = trace.continueTrace;
  exports.getActiveSpan = trace.getActiveSpan;
  exports.startActiveSpan = trace.startActiveSpan;
  exports.startInactiveSpan = trace.startInactiveSpan;
  exports.startSpan = trace.startSpan;
  exports.startSpanManual = trace.startSpanManual;
  exports.trace = trace.trace;
  exports.getDynamicSamplingContextFromClient = dynamicSamplingContext.getDynamicSamplingContextFromClient;
  exports.getDynamicSamplingContextFromSpan = dynamicSamplingContext.getDynamicSamplingContextFromSpan;
  exports.setMeasurement = measurement.setMeasurement;
  exports.SEMANTIC_ATTRIBUTE_SENTRY_OP = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP;
  exports.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN;
  exports.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE;
  exports.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE;
  exports.createEventEnvelope = envelope.createEventEnvelope;
  exports.createSessionEnvelope = envelope.createSessionEnvelope;
  exports.addBreadcrumb = exports$1.addBreadcrumb;
  exports.captureCheckIn = exports$1.captureCheckIn;
  exports.captureEvent = exports$1.captureEvent;
  exports.captureException = exports$1.captureException;
  exports.captureMessage = exports$1.captureMessage;
  exports.captureSession = exports$1.captureSession;
  exports.close = exports$1.close;
  exports.configureScope = exports$1.configureScope;
  exports.endSession = exports$1.endSession;
  exports.flush = exports$1.flush;
  exports.getClient = exports$1.getClient;
  exports.getCurrentScope = exports$1.getCurrentScope;
  exports.isInitialized = exports$1.isInitialized;
  exports.lastEventId = exports$1.lastEventId;
  exports.setContext = exports$1.setContext;
  exports.setExtra = exports$1.setExtra;
  exports.setExtras = exports$1.setExtras;
  exports.setTag = exports$1.setTag;
  exports.setTags = exports$1.setTags;
  exports.setUser = exports$1.setUser;
  exports.startSession = exports$1.startSession;
  exports.startTransaction = exports$1.startTransaction;
  exports.withActiveSpan = exports$1.withActiveSpan;
  exports.withIsolationScope = exports$1.withIsolationScope;
  exports.withMonitor = exports$1.withMonitor;
  exports.withScope = exports$1.withScope;
  exports.Hub = hub.Hub;
  exports.ensureHubOnCarrier = hub.ensureHubOnCarrier;
  exports.getCurrentHub = hub.getCurrentHub;
  exports.getHubFromCarrier = hub.getHubFromCarrier;
  exports.getIsolationScope = hub.getIsolationScope;
  exports.getMainCarrier = hub.getMainCarrier;
  exports.makeMain = hub.makeMain;
  exports.runWithAsyncContext = hub.runWithAsyncContext;
  exports.setAsyncContextStrategy = hub.setAsyncContextStrategy;
  exports.setHubOnCarrier = hub.setHubOnCarrier;
  exports.closeSession = session.closeSession;
  exports.makeSession = session.makeSession;
  exports.updateSession = session.updateSession;
  exports.SessionFlusher = sessionflusher.SessionFlusher;
  exports.Scope = scope.Scope;
  exports.getGlobalScope = scope.getGlobalScope;
  exports.setGlobalScope = scope.setGlobalScope;
  exports.addGlobalEventProcessor = eventProcessors.addGlobalEventProcessor;
  exports.notifyEventProcessors = eventProcessors.notifyEventProcessors;
  exports.getEnvelopeEndpointWithUrlEncodedAuth = api.getEnvelopeEndpointWithUrlEncodedAuth;
  exports.getReportDialogEndpoint = api.getReportDialogEndpoint;
  exports.BaseClient = baseclient.BaseClient;
  exports.addEventProcessor = baseclient.addEventProcessor;
  exports.ServerRuntimeClient = serverRuntimeClient.ServerRuntimeClient;
  exports.initAndBind = sdk.initAndBind;
  exports.setCurrentClient = sdk.setCurrentClient;
  exports.createTransport = base.createTransport;
  exports.makeOfflineTransport = offline.makeOfflineTransport;
  exports.makeMultiplexedTransport = multiplexed.makeMultiplexedTransport;
  exports.SDK_VERSION = version.SDK_VERSION;
  exports.addIntegration = integration.addIntegration;
  exports.convertIntegrationFnToClass = integration.convertIntegrationFnToClass;
  exports.defineIntegration = integration.defineIntegration;
  exports.getIntegrationsToSetup = integration.getIntegrationsToSetup;
  exports.applyScopeDataToEvent = applyScopeDataToEvent.applyScopeDataToEvent;
  exports.mergeScopeData = applyScopeDataToEvent.mergeScopeData;
  exports.prepareEvent = prepareEvent.prepareEvent;
  exports.createCheckInEnvelope = checkin.createCheckInEnvelope;
  exports.hasTracingEnabled = hasTracingEnabled.hasTracingEnabled;
  exports.isSentryRequestUrl = isSentryRequestUrl.isSentryRequestUrl;
  exports.handleCallbackErrors = handleCallbackErrors.handleCallbackErrors;
  exports.parameterize = parameterize.parameterize;
  exports.spanIsSampled = spanUtils.spanIsSampled;
  exports.spanToJSON = spanUtils.spanToJSON;
  exports.spanToTraceContext = spanUtils.spanToTraceContext;
  exports.spanToTraceHeader = spanUtils.spanToTraceHeader;
  exports.getRootSpan = getRootSpan.getRootSpan;
  exports.applySdkMetadata = sdkMetadata.applySdkMetadata;
  exports.DEFAULT_ENVIRONMENT = constants.DEFAULT_ENVIRONMENT;
  exports.ModuleMetadata = metadata.ModuleMetadata;
  exports.moduleMetadataIntegration = metadata.moduleMetadataIntegration;
  exports.RequestData = requestdata.RequestData;
  exports.requestDataIntegration = requestdata.requestDataIntegration;
  exports.InboundFilters = inboundfilters.InboundFilters;
  exports.inboundFiltersIntegration = inboundfilters.inboundFiltersIntegration;
  exports.FunctionToString = functiontostring.FunctionToString;
  exports.functionToStringIntegration = functiontostring.functionToStringIntegration;
  exports.LinkedErrors = linkederrors.LinkedErrors;
  exports.linkedErrorsIntegration = linkederrors.linkedErrorsIntegration;
  exports.metrics = exports$2.metrics;
  exports.Integrations = Integrations;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/common/debug-build.js
var require_debug_build3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
  exports.DEBUG_BUILD = DEBUG_BUILD;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/node/integrations/utils/node-utils.js
var require_node_utils = __commonJS((exports) => {
  var shouldDisableAutoInstrumentation = function(getCurrentHub) {
    const clientOptions = _optionalChain([getCurrentHub, "call", (_) => _(), "access", (_2) => _2.getClient, "call", (_3) => _3(), "optionalAccess", (_4) => _4.getOptions, "call", (_5) => _5()]);
    const instrumenter = _optionalChain([clientOptions, "optionalAccess", (_6) => _6.instrumenter]) || "sentry";
    return instrumenter !== "sentry";
  };
  var {
    _optionalChain
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shouldDisableAutoInstrumentation = shouldDisableAutoInstrumentation;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/node/integrations/express.js
var require_express = __commonJS((exports) => {
  var wrap = function(fn, method) {
    const arity = fn.length;
    switch (arity) {
      case 2: {
        return function(req, res) {
          const transaction = res.__sentry_transaction;
          if (transaction) {
            const span = transaction.startChild({
              description: fn.name,
              op: `middleware.express.${method}`,
              origin: "auto.middleware.express"
            });
            res.once("finish", () => {
              span.end();
            });
          }
          return fn.call(this, req, res);
        };
      }
      case 3: {
        return function(req, res, next) {
          const transaction = res.__sentry_transaction;
          const span = _optionalChain([transaction, "optionalAccess", (_2) => _2.startChild, "call", (_3) => _3({
            description: fn.name,
            op: `middleware.express.${method}`,
            origin: "auto.middleware.express"
          })]);
          fn.call(this, req, res, function(...args) {
            _optionalChain([span, "optionalAccess", (_4) => _4.end, "call", (_5) => _5()]);
            next.call(this, ...args);
          });
        };
      }
      case 4: {
        return function(err, req, res, next) {
          const transaction = res.__sentry_transaction;
          const span = _optionalChain([transaction, "optionalAccess", (_6) => _6.startChild, "call", (_7) => _7({
            description: fn.name,
            op: `middleware.express.${method}`,
            origin: "auto.middleware.express"
          })]);
          fn.call(this, err, req, res, function(...args) {
            _optionalChain([span, "optionalAccess", (_8) => _8.end, "call", (_9) => _9()]);
            next.call(this, ...args);
          });
        };
      }
      default: {
        throw new Error(`Express middleware takes 2-4 arguments. Got: ${arity}`);
      }
    }
  };
  var wrapMiddlewareArgs = function(args, method) {
    return args.map((arg) => {
      if (typeof arg === "function") {
        return wrap(arg, method);
      }
      if (Array.isArray(arg)) {
        return arg.map((a) => {
          if (typeof a === "function") {
            return wrap(a, method);
          }
          return a;
        });
      }
      return arg;
    });
  };
  var patchMiddleware = function(router, method) {
    const originalCallback = router[method];
    router[method] = function(...args) {
      return originalCallback.call(this, ...wrapMiddlewareArgs(args, method));
    };
    return router;
  };
  var instrumentMiddlewares = function(router, methods = []) {
    methods.forEach((method) => patchMiddleware(router, method));
  };
  var instrumentRouter = function(appOrRouter) {
    const isApp = "settings" in appOrRouter;
    if (isApp && appOrRouter._router === undefined && appOrRouter.lazyrouter) {
      appOrRouter.lazyrouter();
    }
    const router = isApp ? appOrRouter._router : appOrRouter;
    if (!router) {
      debugBuild.DEBUG_BUILD && utils.logger.debug("Cannot instrument router for URL Parameterization (did not find a valid router).");
      debugBuild.DEBUG_BUILD && utils.logger.debug("Routing instrumentation is currently only supported in Express 4.");
      return;
    }
    const routerProto = Object.getPrototypeOf(router);
    const originalProcessParams = routerProto.process_params;
    routerProto.process_params = function process_params(layer, called, req, res, done) {
      if (!req._reconstructedRoute) {
        req._reconstructedRoute = "";
      }
      const { layerRoutePath, isRegex, isArray, numExtraSegments } = getLayerRoutePathInfo(layer);
      if (layerRoutePath || isRegex || isArray) {
        req._hasParameters = true;
      }
      let partialRoute;
      if (layerRoutePath) {
        partialRoute = layerRoutePath;
      } else {
        partialRoute = preventDuplicateSegments(req.originalUrl, req._reconstructedRoute, layer.path) || "";
      }
      const finalPartialRoute = partialRoute.split("/").filter((segment) => segment.length > 0 && (isRegex || isArray || !segment.includes("*"))).join("/");
      if (finalPartialRoute && finalPartialRoute.length > 0) {
        req._reconstructedRoute += `/${finalPartialRoute}${isRegex ? "/" : ""}`;
      }
      const urlLength = utils.getNumberOfUrlSegments(utils.stripUrlQueryAndFragment(req.originalUrl || "")) + numExtraSegments;
      const routeLength = utils.getNumberOfUrlSegments(req._reconstructedRoute);
      if (urlLength === routeLength) {
        if (!req._hasParameters) {
          if (req._reconstructedRoute !== req.originalUrl) {
            req._reconstructedRoute = req.originalUrl ? utils.stripUrlQueryAndFragment(req.originalUrl) : req.originalUrl;
          }
        }
        const transaction = res.__sentry_transaction;
        const attributes = transaction && core.spanToJSON(transaction).data || {};
        if (transaction && attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] !== "custom") {
          const finalRoute = req._reconstructedRoute || "/";
          const [name, source] = utils.extractPathForTransaction(req, { path: true, method: true, customRoute: finalRoute });
          transaction.updateName(name);
          transaction.setAttribute(core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, source);
        }
      }
      return originalProcessParams.call(this, layer, called, req, res, done);
    };
  };
  var getLayerRoutePathInfo = function(layer) {
    let lrp = _optionalChain([layer, "access", (_12) => _12.route, "optionalAccess", (_13) => _13.path]);
    const isRegex = utils.isRegExp(lrp);
    const isArray = Array.isArray(lrp);
    if (!lrp) {
      const [major] = utils.GLOBAL_OBJ.process.versions.node.split(".").map(Number);
      if (major >= 16) {
        lrp = extractOriginalRoute(layer.path, layer.regexp, layer.keys);
      }
    }
    if (!lrp) {
      return { isRegex, isArray, numExtraSegments: 0 };
    }
    const numExtraSegments = isArray ? Math.max(getNumberOfArrayUrlSegments(lrp) - utils.getNumberOfUrlSegments(layer.path || ""), 0) : 0;
    const layerRoutePath = getLayerRoutePathString(isArray, lrp);
    return { layerRoutePath, isRegex, isArray, numExtraSegments };
  };
  var getNumberOfArrayUrlSegments = function(routesArray) {
    return routesArray.reduce((accNumSegments, currentRoute) => {
      return accNumSegments + utils.getNumberOfUrlSegments(currentRoute.toString());
    }, 0);
  };
  var getLayerRoutePathString = function(isArray, lrp) {
    if (isArray) {
      return lrp.map((r) => r.toString()).join(",");
    }
    return lrp && lrp.toString();
  };
  var preventDuplicateSegments = function(originalUrl, reconstructedRoute, layerPath) {
    const normalizeURL = utils.stripUrlQueryAndFragment(originalUrl || "");
    const originalUrlSplit = _optionalChain([normalizeURL, "optionalAccess", (_14) => _14.split, "call", (_15) => _15("/"), "access", (_16) => _16.filter, "call", (_17) => _17((v) => !!v)]);
    let tempCounter = 0;
    const currentOffset = _optionalChain([reconstructedRoute, "optionalAccess", (_18) => _18.split, "call", (_19) => _19("/"), "access", (_20) => _20.filter, "call", (_21) => _21((v) => !!v), "access", (_22) => _22.length]) || 0;
    const result = _optionalChain([
      layerPath,
      "optionalAccess",
      (_23) => _23.split,
      "call",
      (_24) => _24("/"),
      "access",
      (_25) => _25.filter,
      "call",
      (_26) => _26((segment) => {
        if (_optionalChain([originalUrlSplit, "optionalAccess", (_27) => _27[currentOffset + tempCounter]]) === segment) {
          tempCounter += 1;
          return true;
        }
        return false;
      }),
      "access",
      (_28) => _28.join,
      "call",
      (_29) => _29("/")
    ]);
    return result;
  };
  var {
    _optionalChain
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var utils = require_cjs();
  var debugBuild = require_debug_build3();
  var nodeUtils = require_node_utils();

  class Express {
    static __initStatic() {
      this.id = "Express";
    }
    constructor(options = {}) {
      this.name = Express.id;
      this._router = options.router || options.app;
      this._methods = (Array.isArray(options.methods) ? options.methods : []).concat("use");
    }
    setupOnce(_, getCurrentHub) {
      if (!this._router) {
        debugBuild.DEBUG_BUILD && utils.logger.error("ExpressIntegration is missing an Express instance");
        return;
      }
      if (nodeUtils.shouldDisableAutoInstrumentation(getCurrentHub)) {
        debugBuild.DEBUG_BUILD && utils.logger.log("Express Integration is skipped because of instrumenter configuration.");
        return;
      }
      instrumentMiddlewares(this._router, this._methods);
      instrumentRouter(this._router);
    }
  }
  Express.__initStatic();
  var extractOriginalRoute = (path, regexp, keys) => {
    if (!path || !regexp || !keys || Object.keys(keys).length === 0 || !_optionalChain([keys, "access", (_10) => _10[0], "optionalAccess", (_11) => _11.offset])) {
      return;
    }
    const orderedKeys = keys.sort((a, b) => a.offset - b.offset);
    const pathRegex = new RegExp(regexp, `${regexp.flags}d`);
    const execResult = pathRegex.exec(path);
    if (!execResult || !execResult.indices) {
      return;
    }
    const [, ...paramIndices] = execResult.indices;
    if (paramIndices.length !== orderedKeys.length) {
      return;
    }
    let resultPath = path;
    let indexShift = 0;
    paramIndices.forEach((item, index) => {
      if (item) {
        const [startOffset, endOffset] = item;
        const substr1 = resultPath.substring(0, startOffset - indexShift);
        const replacement = `:${orderedKeys[index].name}`;
        const substr2 = resultPath.substring(endOffset - indexShift);
        resultPath = substr1 + replacement + substr2;
        indexShift = indexShift + (endOffset - startOffset - replacement.length);
      }
    });
    return resultPath;
  };
  exports.Express = Express;
  exports.extractOriginalRoute = extractOriginalRoute;
  exports.preventDuplicateSegments = preventDuplicateSegments;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/node/integrations/postgres.js
var require_postgres = __commonJS((exports) => {
  var {
    _optionalChain
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var debugBuild = require_debug_build3();
  var nodeUtils = require_node_utils();

  class Postgres {
    static __initStatic() {
      this.id = "Postgres";
    }
    constructor(options = {}) {
      this.name = Postgres.id;
      this._usePgNative = !!options.usePgNative;
      this._module = options.module;
    }
    loadDependency() {
      return this._module = this._module || utils.loadModule("pg");
    }
    setupOnce(_, getCurrentHub) {
      if (nodeUtils.shouldDisableAutoInstrumentation(getCurrentHub)) {
        debugBuild.DEBUG_BUILD && utils.logger.log("Postgres Integration is skipped because of instrumenter configuration.");
        return;
      }
      const pkg = this.loadDependency();
      if (!pkg) {
        debugBuild.DEBUG_BUILD && utils.logger.error("Postgres Integration was unable to require `pg` package.");
        return;
      }
      const Client = this._usePgNative ? _optionalChain([pkg, "access", (_2) => _2.native, "optionalAccess", (_3) => _3.Client]) : pkg.Client;
      if (!Client) {
        debugBuild.DEBUG_BUILD && utils.logger.error("Postgres Integration was unable to access 'pg-native' bindings.");
        return;
      }
      utils.fill(Client.prototype, "query", function(orig) {
        return function(config, values, callback) {
          const scope = getCurrentHub().getScope();
          const parentSpan = scope.getSpan();
          const data = {
            "db.system": "postgresql"
          };
          try {
            if (this.database) {
              data["db.name"] = this.database;
            }
            if (this.host) {
              data["server.address"] = this.host;
            }
            if (this.port) {
              data["server.port"] = this.port;
            }
            if (this.user) {
              data["db.user"] = this.user;
            }
          } catch (e) {
          }
          const span = _optionalChain([parentSpan, "optionalAccess", (_4) => _4.startChild, "call", (_5) => _5({
            description: typeof config === "string" ? config : config.text,
            op: "db",
            origin: "auto.db.postgres",
            data
          })]);
          if (typeof callback === "function") {
            return orig.call(this, config, values, function(err, result) {
              _optionalChain([span, "optionalAccess", (_6) => _6.end, "call", (_7) => _7()]);
              callback(err, result);
            });
          }
          if (typeof values === "function") {
            return orig.call(this, config, function(err, result) {
              _optionalChain([span, "optionalAccess", (_8) => _8.end, "call", (_9) => _9()]);
              values(err, result);
            });
          }
          const rv = typeof values !== "undefined" ? orig.call(this, config, values) : orig.call(this, config);
          if (utils.isThenable(rv)) {
            return rv.then((res) => {
              _optionalChain([span, "optionalAccess", (_10) => _10.end, "call", (_11) => _11()]);
              return res;
            });
          }
          _optionalChain([span, "optionalAccess", (_12) => _12.end, "call", (_13) => _13()]);
          return rv;
        };
      });
    }
  }
  Postgres.__initStatic();
  exports.Postgres = Postgres;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/node/integrations/mysql.js
var require_mysql = __commonJS((exports) => {
  var {
    _optionalChain
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var debugBuild = require_debug_build3();
  var nodeUtils = require_node_utils();

  class Mysql {
    static __initStatic() {
      this.id = "Mysql";
    }
    constructor() {
      this.name = Mysql.id;
    }
    loadDependency() {
      return this._module = this._module || utils.loadModule("mysql/lib/Connection.js");
    }
    setupOnce(_, getCurrentHub) {
      if (nodeUtils.shouldDisableAutoInstrumentation(getCurrentHub)) {
        debugBuild.DEBUG_BUILD && utils.logger.log("Mysql Integration is skipped because of instrumenter configuration.");
        return;
      }
      const pkg = this.loadDependency();
      if (!pkg) {
        debugBuild.DEBUG_BUILD && utils.logger.error("Mysql Integration was unable to require `mysql` package.");
        return;
      }
      let mySqlConfig = undefined;
      try {
        pkg.prototype.connect = new Proxy(pkg.prototype.connect, {
          apply(wrappingTarget, thisArg, args) {
            if (!mySqlConfig) {
              mySqlConfig = thisArg.config;
            }
            return wrappingTarget.apply(thisArg, args);
          }
        });
      } catch (e) {
        debugBuild.DEBUG_BUILD && utils.logger.error("Mysql Integration was unable to instrument `mysql` config.");
      }
      function spanDataFromConfig() {
        if (!mySqlConfig) {
          return {};
        }
        return {
          "server.address": mySqlConfig.host,
          "server.port": mySqlConfig.port,
          "db.user": mySqlConfig.user
        };
      }
      function finishSpan(span) {
        if (!span) {
          return;
        }
        const data = spanDataFromConfig();
        Object.keys(data).forEach((key) => {
          span.setAttribute(key, data[key]);
        });
        span.end();
      }
      utils.fill(pkg, "createQuery", function(orig) {
        return function(options, values, callback) {
          const scope = getCurrentHub().getScope();
          const parentSpan = scope.getSpan();
          const span = _optionalChain([parentSpan, "optionalAccess", (_2) => _2.startChild, "call", (_3) => _3({
            description: typeof options === "string" ? options : options.sql,
            op: "db",
            origin: "auto.db.mysql",
            data: {
              "db.system": "mysql"
            }
          })]);
          if (typeof callback === "function") {
            return orig.call(this, options, values, function(err, result, fields) {
              finishSpan(span);
              callback(err, result, fields);
            });
          }
          if (typeof values === "function") {
            return orig.call(this, options, function(err, result, fields) {
              finishSpan(span);
              values(err, result, fields);
            });
          }
          const query = orig.call(this, options, values);
          query.on("end", () => {
            finishSpan(span);
          });
          return query;
        };
      });
    }
  }
  Mysql.__initStatic();
  exports.Mysql = Mysql;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/node/integrations/mongo.js
var require_mongo = __commonJS((exports) => {
  var isCursor = function(maybeCursor) {
    return maybeCursor && typeof maybeCursor === "object" && maybeCursor.once && typeof maybeCursor.once === "function";
  };
  var {
    _optionalChain
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var debugBuild = require_debug_build3();
  var nodeUtils = require_node_utils();
  var OPERATIONS = [
    "aggregate",
    "bulkWrite",
    "countDocuments",
    "createIndex",
    "createIndexes",
    "deleteMany",
    "deleteOne",
    "distinct",
    "drop",
    "dropIndex",
    "dropIndexes",
    "estimatedDocumentCount",
    "find",
    "findOne",
    "findOneAndDelete",
    "findOneAndReplace",
    "findOneAndUpdate",
    "indexes",
    "indexExists",
    "indexInformation",
    "initializeOrderedBulkOp",
    "insertMany",
    "insertOne",
    "isCapped",
    "mapReduce",
    "options",
    "parallelCollectionScan",
    "rename",
    "replaceOne",
    "stats",
    "updateMany",
    "updateOne"
  ];
  var OPERATION_SIGNATURES = {
    bulkWrite: ["operations"],
    countDocuments: ["query"],
    createIndex: ["fieldOrSpec"],
    createIndexes: ["indexSpecs"],
    deleteMany: ["filter"],
    deleteOne: ["filter"],
    distinct: ["key", "query"],
    dropIndex: ["indexName"],
    find: ["query"],
    findOne: ["query"],
    findOneAndDelete: ["filter"],
    findOneAndReplace: ["filter", "replacement"],
    findOneAndUpdate: ["filter", "update"],
    indexExists: ["indexes"],
    insertMany: ["docs"],
    insertOne: ["doc"],
    mapReduce: ["map", "reduce"],
    rename: ["newName"],
    replaceOne: ["filter", "doc"],
    updateMany: ["filter", "update"],
    updateOne: ["filter", "update"]
  };

  class Mongo {
    static __initStatic() {
      this.id = "Mongo";
    }
    constructor(options = {}) {
      this.name = Mongo.id;
      this._operations = Array.isArray(options.operations) ? options.operations : OPERATIONS;
      this._describeOperations = "describeOperations" in options ? options.describeOperations : true;
      this._useMongoose = !!options.useMongoose;
    }
    loadDependency() {
      const moduleName = this._useMongoose ? "mongoose" : "mongodb";
      return this._module = this._module || utils.loadModule(moduleName);
    }
    setupOnce(_, getCurrentHub) {
      if (nodeUtils.shouldDisableAutoInstrumentation(getCurrentHub)) {
        debugBuild.DEBUG_BUILD && utils.logger.log("Mongo Integration is skipped because of instrumenter configuration.");
        return;
      }
      const pkg = this.loadDependency();
      if (!pkg) {
        const moduleName = this._useMongoose ? "mongoose" : "mongodb";
        debugBuild.DEBUG_BUILD && utils.logger.error(`Mongo Integration was unable to require \`${moduleName}\` package.`);
        return;
      }
      this._instrumentOperations(pkg.Collection, this._operations, getCurrentHub);
    }
    _instrumentOperations(collection, operations, getCurrentHub) {
      operations.forEach((operation) => this._patchOperation(collection, operation, getCurrentHub));
    }
    _patchOperation(collection, operation, getCurrentHub) {
      if (!(operation in collection.prototype))
        return;
      const getSpanContext = this._getSpanContextFromOperationArguments.bind(this);
      utils.fill(collection.prototype, operation, function(orig) {
        return function(...args) {
          const lastArg = args[args.length - 1];
          const hub = getCurrentHub();
          const scope = hub.getScope();
          const client = hub.getClient();
          const parentSpan = scope.getSpan();
          const sendDefaultPii = _optionalChain([client, "optionalAccess", (_2) => _2.getOptions, "call", (_3) => _3(), "access", (_4) => _4.sendDefaultPii]);
          if (typeof lastArg !== "function" || operation === "mapReduce" && args.length === 2) {
            const span2 = _optionalChain([parentSpan, "optionalAccess", (_5) => _5.startChild, "call", (_6) => _6(getSpanContext(this, operation, args, sendDefaultPii))]);
            const maybePromiseOrCursor = orig.call(this, ...args);
            if (utils.isThenable(maybePromiseOrCursor)) {
              return maybePromiseOrCursor.then((res) => {
                _optionalChain([span2, "optionalAccess", (_7) => _7.end, "call", (_8) => _8()]);
                return res;
              });
            } else if (isCursor(maybePromiseOrCursor)) {
              const cursor = maybePromiseOrCursor;
              try {
                cursor.once("close", () => {
                  _optionalChain([span2, "optionalAccess", (_9) => _9.end, "call", (_10) => _10()]);
                });
              } catch (e) {
                _optionalChain([span2, "optionalAccess", (_11) => _11.end, "call", (_12) => _12()]);
              }
              return cursor;
            } else {
              _optionalChain([span2, "optionalAccess", (_13) => _13.end, "call", (_14) => _14()]);
              return maybePromiseOrCursor;
            }
          }
          const span = _optionalChain([parentSpan, "optionalAccess", (_15) => _15.startChild, "call", (_16) => _16(getSpanContext(this, operation, args.slice(0, -1)))]);
          return orig.call(this, ...args.slice(0, -1), function(err, result) {
            _optionalChain([span, "optionalAccess", (_17) => _17.end, "call", (_18) => _18()]);
            lastArg(err, result);
          });
        };
      });
    }
    _getSpanContextFromOperationArguments(collection, operation, args, sendDefaultPii = false) {
      const data = {
        "db.system": "mongodb",
        "db.name": collection.dbName,
        "db.operation": operation,
        "db.mongodb.collection": collection.collectionName
      };
      const spanContext = {
        op: "db",
        origin: "auto.db.mongo",
        description: operation,
        data
      };
      const signature = OPERATION_SIGNATURES[operation];
      const shouldDescribe = Array.isArray(this._describeOperations) ? this._describeOperations.includes(operation) : this._describeOperations;
      if (!signature || !shouldDescribe || !sendDefaultPii) {
        return spanContext;
      }
      try {
        if (operation === "mapReduce") {
          const [map, reduce] = args;
          data[signature[0]] = typeof map === "string" ? map : map.name || "<anonymous>";
          data[signature[1]] = typeof reduce === "string" ? reduce : reduce.name || "<anonymous>";
        } else {
          for (let i = 0;i < signature.length; i++) {
            data[`db.mongodb.${signature[i]}`] = JSON.stringify(args[i]);
          }
        }
      } catch (_oO) {
      }
      return spanContext;
    }
  }
  Mongo.__initStatic();
  exports.Mongo = Mongo;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/node/integrations/prisma.js
var require_prisma = __commonJS((exports) => {
  var isValidPrismaClient = function(possibleClient) {
    return !!possibleClient && !!possibleClient["$use"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var utils = require_cjs();
  var debugBuild = require_debug_build3();
  var nodeUtils = require_node_utils();

  class Prisma {
    static __initStatic() {
      this.id = "Prisma";
    }
    constructor(options = {}) {
      this.name = Prisma.id;
      if (isValidPrismaClient(options.client) && !options.client._sentryInstrumented) {
        utils.addNonEnumerableProperty(options.client, "_sentryInstrumented", true);
        const clientData = {};
        try {
          const engineConfig = options.client._engineConfig;
          if (engineConfig) {
            const { activeProvider, clientVersion } = engineConfig;
            if (activeProvider) {
              clientData["db.system"] = activeProvider;
            }
            if (clientVersion) {
              clientData["db.prisma.version"] = clientVersion;
            }
          }
        } catch (e) {
        }
        options.client.$use((params, next) => {
          if (nodeUtils.shouldDisableAutoInstrumentation(core.getCurrentHub)) {
            return next(params);
          }
          const action = params.action;
          const model = params.model;
          return core.startSpan({
            name: model ? `${model} ${action}` : action,
            onlyIfParent: true,
            op: "db.prisma",
            attributes: {
              [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.db.prisma"
            },
            data: { ...clientData, "db.operation": action }
          }, () => next(params));
        });
      } else {
        debugBuild.DEBUG_BUILD && utils.logger.warn("Unsupported Prisma client provided to PrismaIntegration. Provided client:", options.client);
      }
    }
    setupOnce() {
    }
  }
  Prisma.__initStatic();
  exports.Prisma = Prisma;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/node/integrations/graphql.js
var require_graphql = __commonJS((exports) => {
  var {
    _optionalChain
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var debugBuild = require_debug_build3();
  var nodeUtils = require_node_utils();

  class GraphQL {
    static __initStatic() {
      this.id = "GraphQL";
    }
    constructor() {
      this.name = GraphQL.id;
    }
    loadDependency() {
      return this._module = this._module || utils.loadModule("graphql/execution/execute.js");
    }
    setupOnce(_, getCurrentHub) {
      if (nodeUtils.shouldDisableAutoInstrumentation(getCurrentHub)) {
        debugBuild.DEBUG_BUILD && utils.logger.log("GraphQL Integration is skipped because of instrumenter configuration.");
        return;
      }
      const pkg = this.loadDependency();
      if (!pkg) {
        debugBuild.DEBUG_BUILD && utils.logger.error("GraphQL Integration was unable to require graphql/execution package.");
        return;
      }
      utils.fill(pkg, "execute", function(orig) {
        return function(...args) {
          const scope = getCurrentHub().getScope();
          const parentSpan = scope.getSpan();
          const span = _optionalChain([parentSpan, "optionalAccess", (_2) => _2.startChild, "call", (_3) => _3({
            description: "execute",
            op: "graphql.execute",
            origin: "auto.graphql.graphql"
          })]);
          _optionalChain([scope, "optionalAccess", (_4) => _4.setSpan, "call", (_5) => _5(span)]);
          const rv = orig.call(this, ...args);
          if (utils.isThenable(rv)) {
            return rv.then((res) => {
              _optionalChain([span, "optionalAccess", (_6) => _6.end, "call", (_7) => _7()]);
              _optionalChain([scope, "optionalAccess", (_8) => _8.setSpan, "call", (_9) => _9(parentSpan)]);
              return res;
            });
          }
          _optionalChain([span, "optionalAccess", (_10) => _10.end, "call", (_11) => _11()]);
          _optionalChain([scope, "optionalAccess", (_12) => _12.setSpan, "call", (_13) => _13(parentSpan)]);
          return rv;
        };
      });
    }
  }
  GraphQL.__initStatic();
  exports.GraphQL = GraphQL;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/node/integrations/apollo.js
var require_apollo = __commonJS((exports) => {
  var instrumentResolvers = function(resolvers, getCurrentHub) {
    return resolvers.map((model) => {
      Object.keys(model).forEach((resolverGroupName) => {
        Object.keys(model[resolverGroupName]).forEach((resolverName) => {
          if (typeof model[resolverGroupName][resolverName] !== "function") {
            return;
          }
          wrapResolver(model, resolverGroupName, resolverName, getCurrentHub);
        });
      });
      return model;
    });
  };
  var wrapResolver = function(model, resolverGroupName, resolverName, getCurrentHub) {
    utils.fill(model[resolverGroupName], resolverName, function(orig) {
      return function(...args) {
        const scope = getCurrentHub().getScope();
        const parentSpan = scope.getSpan();
        const span = _optionalChain([parentSpan, "optionalAccess", (_2) => _2.startChild, "call", (_3) => _3({
          description: `${resolverGroupName}.${resolverName}`,
          op: "graphql.resolve",
          origin: "auto.graphql.apollo"
        })]);
        const rv = orig.call(this, ...args);
        if (utils.isThenable(rv)) {
          return rv.then((res) => {
            _optionalChain([span, "optionalAccess", (_4) => _4.end, "call", (_5) => _5()]);
            return res;
          });
        }
        _optionalChain([span, "optionalAccess", (_6) => _6.end, "call", (_7) => _7()]);
        return rv;
      };
    });
  };
  var {
    _optionalChain
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var debugBuild = require_debug_build3();
  var nodeUtils = require_node_utils();

  class Apollo {
    static __initStatic() {
      this.id = "Apollo";
    }
    constructor(options = {
      useNestjs: false
    }) {
      this.name = Apollo.id;
      this._useNest = !!options.useNestjs;
    }
    loadDependency() {
      if (this._useNest) {
        this._module = this._module || utils.loadModule("@nestjs/graphql");
      } else {
        this._module = this._module || utils.loadModule("apollo-server-core");
      }
      return this._module;
    }
    setupOnce(_, getCurrentHub) {
      if (nodeUtils.shouldDisableAutoInstrumentation(getCurrentHub)) {
        debugBuild.DEBUG_BUILD && utils.logger.log("Apollo Integration is skipped because of instrumenter configuration.");
        return;
      }
      if (this._useNest) {
        const pkg = this.loadDependency();
        if (!pkg) {
          debugBuild.DEBUG_BUILD && utils.logger.error("Apollo-NestJS Integration was unable to require @nestjs/graphql package.");
          return;
        }
        utils.fill(pkg.GraphQLFactory.prototype, "mergeWithSchema", function(orig) {
          return function(...args) {
            utils.fill(this.resolversExplorerService, "explore", function(orig2) {
              return function() {
                const resolvers = utils.arrayify(orig2.call(this));
                const instrumentedResolvers = instrumentResolvers(resolvers, getCurrentHub);
                return instrumentedResolvers;
              };
            });
            return orig.call(this, ...args);
          };
        });
      } else {
        const pkg = this.loadDependency();
        if (!pkg) {
          debugBuild.DEBUG_BUILD && utils.logger.error("Apollo Integration was unable to require apollo-server-core package.");
          return;
        }
        utils.fill(pkg.ApolloServerBase.prototype, "constructSchema", function(orig) {
          return function() {
            if (!this.config.resolvers) {
              if (debugBuild.DEBUG_BUILD) {
                if (this.config.schema) {
                  utils.logger.warn("Apollo integration is not able to trace `ApolloServer` instances constructed via `schema` property.If you are using NestJS with Apollo, please use `Sentry.Integrations.Apollo({ useNestjs: true })` instead.");
                  utils.logger.warn();
                } else if (this.config.modules) {
                  utils.logger.warn("Apollo integration is not able to trace `ApolloServer` instances constructed via `modules` property.");
                }
                utils.logger.error("Skipping tracing as no resolvers found on the `ApolloServer` instance.");
              }
              return orig.call(this);
            }
            const resolvers = utils.arrayify(this.config.resolvers);
            this.config.resolvers = instrumentResolvers(resolvers, getCurrentHub);
            return orig.call(this);
          };
        });
      }
    }
  }
  Apollo.__initStatic();
  exports.Apollo = Apollo;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/node/integrations/lazy.js
var require_lazy = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var lazyLoadedNodePerformanceMonitoringIntegrations = [
    () => {
      const integration = utils.dynamicRequire(module, "./apollo");
      return new integration.Apollo;
    },
    () => {
      const integration = utils.dynamicRequire(module, "./apollo");
      return new integration.Apollo({ useNestjs: true });
    },
    () => {
      const integration = utils.dynamicRequire(module, "./graphql");
      return new integration.GraphQL;
    },
    () => {
      const integration = utils.dynamicRequire(module, "./mongo");
      return new integration.Mongo;
    },
    () => {
      const integration = utils.dynamicRequire(module, "./mongo");
      return new integration.Mongo({ mongoose: true });
    },
    () => {
      const integration = utils.dynamicRequire(module, "./mysql");
      return new integration.Mysql;
    },
    () => {
      const integration = utils.dynamicRequire(module, "./postgres");
      return new integration.Postgres;
    }
  ];
  exports.lazyLoadedNodePerformanceMonitoringIntegrations = lazyLoadedNodePerformanceMonitoringIntegrations;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/browser/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var WINDOW = utils.GLOBAL_OBJ;
  exports.WINDOW = WINDOW;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/browser/backgroundtab.js
var require_backgroundtab = __commonJS((exports) => {
  var registerBackgroundTabDetection = function() {
    if (types.WINDOW && types.WINDOW.document) {
      types.WINDOW.document.addEventListener("visibilitychange", () => {
        const activeTransaction = core.getActiveTransaction();
        if (types.WINDOW.document.hidden && activeTransaction) {
          const statusType = "cancelled";
          const { op, status } = core.spanToJSON(activeTransaction);
          debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Transaction: ${statusType} -> since tab moved to the background, op: ${op}`);
          if (!status) {
            activeTransaction.setStatus(statusType);
          }
          activeTransaction.setTag("visibilitychange", "document.hidden");
          activeTransaction.end();
        }
      });
    } else {
      debugBuild.DEBUG_BUILD && utils.logger.warn("[Tracing] Could not set up background tab detection due to lack of global document");
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var utils = require_cjs();
  var debugBuild = require_debug_build3();
  var types = require_types();
  exports.registerBackgroundTabDetection = registerBackgroundTabDetection;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/bindReporter.js
var require_bindReporter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var bindReporter = (callback, metric, reportAllChanges) => {
    let prevValue;
    let delta;
    return (forceReport) => {
      if (metric.value >= 0) {
        if (forceReport || reportAllChanges) {
          delta = metric.value - (prevValue || 0);
          if (delta || prevValue === undefined) {
            prevValue = metric.value;
            metric.delta = delta;
            callback(metric);
          }
        }
      }
    };
  };
  exports.bindReporter = bindReporter;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/generateUniqueID.js
var require_generateUniqueID = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generateUniqueID = () => {
    return `v3-${Date.now()}-${Math.floor(Math.random() * (9000000000000 - 1)) + 1000000000000}`;
  };
  exports.generateUniqueID = generateUniqueID;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/getNavigationEntry.js
var require_getNavigationEntry = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var types = require_types();
  var getNavigationEntryFromPerformanceTiming = () => {
    const timing = types.WINDOW.performance.timing;
    const type = types.WINDOW.performance.navigation.type;
    const navigationEntry = {
      entryType: "navigation",
      startTime: 0,
      type: type == 2 ? "back_forward" : type === 1 ? "reload" : "navigate"
    };
    for (const key in timing) {
      if (key !== "navigationStart" && key !== "toJSON") {
        navigationEntry[key] = Math.max(timing[key] - timing.navigationStart, 0);
      }
    }
    return navigationEntry;
  };
  var getNavigationEntry = () => {
    if (types.WINDOW.__WEB_VITALS_POLYFILL__) {
      return types.WINDOW.performance && (performance.getEntriesByType && performance.getEntriesByType("navigation")[0] || getNavigationEntryFromPerformanceTiming());
    } else {
      return types.WINDOW.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0];
    }
  };
  exports.getNavigationEntry = getNavigationEntry;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/getActivationStart.js
var require_getActivationStart = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var getNavigationEntry = require_getNavigationEntry();
  var getActivationStart = () => {
    const navEntry = getNavigationEntry.getNavigationEntry();
    return navEntry && navEntry.activationStart || 0;
  };
  exports.getActivationStart = getActivationStart;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/initMetric.js
var require_initMetric = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var types = require_types();
  var generateUniqueID = require_generateUniqueID();
  var getActivationStart = require_getActivationStart();
  var getNavigationEntry = require_getNavigationEntry();
  var initMetric = (name, value) => {
    const navEntry = getNavigationEntry.getNavigationEntry();
    let navigationType = "navigate";
    if (navEntry) {
      if (types.WINDOW.document.prerendering || getActivationStart.getActivationStart() > 0) {
        navigationType = "prerender";
      } else {
        navigationType = navEntry.type.replace(/_/g, "-");
      }
    }
    return {
      name,
      value: typeof value === "undefined" ? -1 : value,
      rating: "good",
      delta: 0,
      entries: [],
      id: generateUniqueID.generateUniqueID(),
      navigationType
    };
  };
  exports.initMetric = initMetric;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/observe.js
var require_observe = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var observe = (type, callback, opts) => {
    try {
      if (PerformanceObserver.supportedEntryTypes.includes(type)) {
        const po = new PerformanceObserver((list) => {
          callback(list.getEntries());
        });
        po.observe(Object.assign({
          type,
          buffered: true
        }, opts || {}));
        return po;
      }
    } catch (e) {
    }
    return;
  };
  exports.observe = observe;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/onHidden.js
var require_onHidden = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var types = require_types();
  var onHidden = (cb, once) => {
    const onHiddenOrPageHide = (event) => {
      if (event.type === "pagehide" || types.WINDOW.document.visibilityState === "hidden") {
        cb(event);
        if (once) {
          removeEventListener("visibilitychange", onHiddenOrPageHide, true);
          removeEventListener("pagehide", onHiddenOrPageHide, true);
        }
      }
    };
    addEventListener("visibilitychange", onHiddenOrPageHide, true);
    addEventListener("pagehide", onHiddenOrPageHide, true);
  };
  exports.onHidden = onHidden;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/getCLS.js
var require_getCLS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var bindReporter = require_bindReporter();
  var initMetric = require_initMetric();
  var observe = require_observe();
  var onHidden = require_onHidden();
  var onCLS = (onReport) => {
    const metric = initMetric.initMetric("CLS", 0);
    let report;
    let sessionValue = 0;
    let sessionEntries = [];
    const handleEntries = (entries) => {
      entries.forEach((entry) => {
        if (!entry.hadRecentInput) {
          const firstSessionEntry = sessionEntries[0];
          const lastSessionEntry = sessionEntries[sessionEntries.length - 1];
          if (sessionValue && sessionEntries.length !== 0 && entry.startTime - lastSessionEntry.startTime < 1000 && entry.startTime - firstSessionEntry.startTime < 5000) {
            sessionValue += entry.value;
            sessionEntries.push(entry);
          } else {
            sessionValue = entry.value;
            sessionEntries = [entry];
          }
          if (sessionValue > metric.value) {
            metric.value = sessionValue;
            metric.entries = sessionEntries;
            if (report) {
              report();
            }
          }
        }
      });
    };
    const po = observe.observe("layout-shift", handleEntries);
    if (po) {
      report = bindReporter.bindReporter(onReport, metric);
      const stopListening = () => {
        handleEntries(po.takeRecords());
        report(true);
      };
      onHidden.onHidden(stopListening);
      return stopListening;
    }
    return;
  };
  exports.onCLS = onCLS;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/getVisibilityWatcher.js
var require_getVisibilityWatcher = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var types = require_types();
  var onHidden = require_onHidden();
  var firstHiddenTime = -1;
  var initHiddenTime = () => {
    return types.WINDOW.document.visibilityState === "hidden" && !types.WINDOW.document.prerendering ? 0 : Infinity;
  };
  var trackChanges = () => {
    onHidden.onHidden(({ timeStamp }) => {
      firstHiddenTime = timeStamp;
    }, true);
  };
  var getVisibilityWatcher = () => {
    if (firstHiddenTime < 0) {
      firstHiddenTime = initHiddenTime();
      trackChanges();
    }
    return {
      get firstHiddenTime() {
        return firstHiddenTime;
      }
    };
  };
  exports.getVisibilityWatcher = getVisibilityWatcher;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/getFID.js
var require_getFID = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var bindReporter = require_bindReporter();
  var getVisibilityWatcher = require_getVisibilityWatcher();
  var initMetric = require_initMetric();
  var observe = require_observe();
  var onHidden = require_onHidden();
  var onFID = (onReport) => {
    const visibilityWatcher = getVisibilityWatcher.getVisibilityWatcher();
    const metric = initMetric.initMetric("FID");
    let report;
    const handleEntry = (entry) => {
      if (entry.startTime < visibilityWatcher.firstHiddenTime) {
        metric.value = entry.processingStart - entry.startTime;
        metric.entries.push(entry);
        report(true);
      }
    };
    const handleEntries = (entries) => {
      entries.forEach(handleEntry);
    };
    const po = observe.observe("first-input", handleEntries);
    report = bindReporter.bindReporter(onReport, metric);
    if (po) {
      onHidden.onHidden(() => {
        handleEntries(po.takeRecords());
        po.disconnect();
      }, true);
    }
  };
  exports.onFID = onFID;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/getLCP.js
var require_getLCP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var bindReporter = require_bindReporter();
  var getActivationStart = require_getActivationStart();
  var getVisibilityWatcher = require_getVisibilityWatcher();
  var initMetric = require_initMetric();
  var observe = require_observe();
  var onHidden = require_onHidden();
  var reportedMetricIDs = {};
  var onLCP = (onReport) => {
    const visibilityWatcher = getVisibilityWatcher.getVisibilityWatcher();
    const metric = initMetric.initMetric("LCP");
    let report;
    const handleEntries = (entries) => {
      const lastEntry = entries[entries.length - 1];
      if (lastEntry) {
        const value = Math.max(lastEntry.startTime - getActivationStart.getActivationStart(), 0);
        if (value < visibilityWatcher.firstHiddenTime) {
          metric.value = value;
          metric.entries = [lastEntry];
          report();
        }
      }
    };
    const po = observe.observe("largest-contentful-paint", handleEntries);
    if (po) {
      report = bindReporter.bindReporter(onReport, metric);
      const stopListening = () => {
        if (!reportedMetricIDs[metric.id]) {
          handleEntries(po.takeRecords());
          po.disconnect();
          reportedMetricIDs[metric.id] = true;
          report(true);
        }
      };
      ["keydown", "click"].forEach((type) => {
        addEventListener(type, stopListening, { once: true, capture: true });
      });
      onHidden.onHidden(stopListening, true);
      return stopListening;
    }
    return;
  };
  exports.onLCP = onLCP;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/browser/instrument.js
var require_instrument2 = __commonJS((exports) => {
  var addClsInstrumentationHandler = function(callback, stopOnCallback = false) {
    return addMetricObserver("cls", callback, instrumentCls, _previousCls, stopOnCallback);
  };
  var addLcpInstrumentationHandler = function(callback, stopOnCallback = false) {
    return addMetricObserver("lcp", callback, instrumentLcp, _previousLcp, stopOnCallback);
  };
  var addFidInstrumentationHandler = function(callback) {
    return addMetricObserver("fid", callback, instrumentFid, _previousFid);
  };
  var addPerformanceInstrumentationHandler = function(type, callback) {
    addHandler(type, callback);
    if (!instrumented[type]) {
      instrumentPerformanceObserver(type);
      instrumented[type] = true;
    }
    return getCleanupCallback(type, callback);
  };
  var triggerHandlers = function(type, data) {
    const typeHandlers = handlers[type];
    if (!typeHandlers || !typeHandlers.length) {
      return;
    }
    for (const handler of typeHandlers) {
      try {
        handler(data);
      } catch (e) {
        debugBuild.DEBUG_BUILD && utils.logger.error(`Error while triggering instrumentation handler.\nType: ${type}\nName: ${utils.getFunctionName(handler)}\nError:`, e);
      }
    }
  };
  var instrumentCls = function() {
    return getCLS.onCLS((metric) => {
      triggerHandlers("cls", {
        metric
      });
      _previousCls = metric;
    });
  };
  var instrumentFid = function() {
    return getFID.onFID((metric) => {
      triggerHandlers("fid", {
        metric
      });
      _previousFid = metric;
    });
  };
  var instrumentLcp = function() {
    return getLCP.onLCP((metric) => {
      triggerHandlers("lcp", {
        metric
      });
      _previousLcp = metric;
    });
  };
  var addMetricObserver = function(type, callback, instrumentFn, previousValue, stopOnCallback = false) {
    addHandler(type, callback);
    let stopListening;
    if (!instrumented[type]) {
      stopListening = instrumentFn();
      instrumented[type] = true;
    }
    if (previousValue) {
      callback({ metric: previousValue });
    }
    return getCleanupCallback(type, callback, stopOnCallback ? stopListening : undefined);
  };
  var instrumentPerformanceObserver = function(type) {
    const options = {};
    if (type === "event") {
      options.durationThreshold = 0;
    }
    observe.observe(type, (entries) => {
      triggerHandlers(type, { entries });
    }, options);
  };
  var addHandler = function(type, handler) {
    handlers[type] = handlers[type] || [];
    handlers[type].push(handler);
  };
  var getCleanupCallback = function(type, callback, stopListening) {
    return () => {
      if (stopListening) {
        stopListening();
      }
      const typeHandlers = handlers[type];
      if (!typeHandlers) {
        return;
      }
      const index = typeHandlers.indexOf(callback);
      if (index !== -1) {
        typeHandlers.splice(index, 1);
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var debugBuild = require_debug_build3();
  var getCLS = require_getCLS();
  var getFID = require_getFID();
  var getLCP = require_getLCP();
  var observe = require_observe();
  var handlers = {};
  var instrumented = {};
  var _previousCls;
  var _previousFid;
  var _previousLcp;
  exports.addClsInstrumentationHandler = addClsInstrumentationHandler;
  exports.addFidInstrumentationHandler = addFidInstrumentationHandler;
  exports.addLcpInstrumentationHandler = addLcpInstrumentationHandler;
  exports.addPerformanceInstrumentationHandler = addPerformanceInstrumentationHandler;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/browser/metrics/utils.js
var require_utils3 = __commonJS((exports) => {
  var isMeasurementValue = function(value) {
    return typeof value === "number" && isFinite(value);
  };
  var _startChild = function(transaction, { startTimestamp, ...ctx }) {
    if (startTimestamp && transaction.startTimestamp > startTimestamp) {
      transaction.startTimestamp = startTimestamp;
    }
    return transaction.startChild({
      startTimestamp,
      ...ctx
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._startChild = _startChild;
  exports.isMeasurementValue = isMeasurementValue;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/browser/metrics/index.js
var require_metrics = __commonJS((exports) => {
  var msToSec = function(time) {
    return time / 1000;
  };
  var getBrowserPerformanceAPI = function() {
    return types.WINDOW && types.WINDOW.addEventListener && types.WINDOW.performance;
  };
  var startTrackingWebVitals = function() {
    const performance2 = getBrowserPerformanceAPI();
    if (performance2 && utils.browserPerformanceTimeOrigin) {
      if (performance2.mark) {
        types.WINDOW.performance.mark("sentry-tracing-init");
      }
      const fidCallback = _trackFID();
      const clsCallback = _trackCLS();
      const lcpCallback = _trackLCP();
      return () => {
        fidCallback();
        clsCallback();
        lcpCallback();
      };
    }
    return () => {
      return;
    };
  };
  var startTrackingLongTasks = function() {
    instrument.addPerformanceInstrumentationHandler("longtask", ({ entries }) => {
      for (const entry of entries) {
        const transaction = core.getActiveTransaction();
        if (!transaction) {
          return;
        }
        const startTime = msToSec(utils.browserPerformanceTimeOrigin + entry.startTime);
        const duration = msToSec(entry.duration);
        transaction.startChild({
          description: "Main UI thread blocked",
          op: "ui.long-task",
          origin: "auto.ui.browser.metrics",
          startTimestamp: startTime,
          endTimestamp: startTime + duration
        });
      }
    });
  };
  var startTrackingInteractions = function() {
    instrument.addPerformanceInstrumentationHandler("event", ({ entries }) => {
      for (const entry of entries) {
        const transaction = core.getActiveTransaction();
        if (!transaction) {
          return;
        }
        if (entry.name === "click") {
          const startTime = msToSec(utils.browserPerformanceTimeOrigin + entry.startTime);
          const duration = msToSec(entry.duration);
          const span = {
            description: utils.htmlTreeAsString(entry.target),
            op: `ui.interaction.${entry.name}`,
            origin: "auto.ui.browser.metrics",
            startTimestamp: startTime,
            endTimestamp: startTime + duration
          };
          const componentName = utils.getComponentName(entry.target);
          if (componentName) {
            span.attributes = { "ui.component_name": componentName };
          }
          transaction.startChild(span);
        }
      }
    });
  };
  var _trackCLS = function() {
    return instrument.addClsInstrumentationHandler(({ metric }) => {
      const entry = metric.entries[metric.entries.length - 1];
      if (!entry) {
        return;
      }
      debugBuild.DEBUG_BUILD && utils.logger.log("[Measurements] Adding CLS");
      _measurements["cls"] = { value: metric.value, unit: "" };
      _clsEntry = entry;
    }, true);
  };
  var _trackLCP = function() {
    return instrument.addLcpInstrumentationHandler(({ metric }) => {
      const entry = metric.entries[metric.entries.length - 1];
      if (!entry) {
        return;
      }
      debugBuild.DEBUG_BUILD && utils.logger.log("[Measurements] Adding LCP");
      _measurements["lcp"] = { value: metric.value, unit: "millisecond" };
      _lcpEntry = entry;
    }, true);
  };
  var _trackFID = function() {
    return instrument.addFidInstrumentationHandler(({ metric }) => {
      const entry = metric.entries[metric.entries.length - 1];
      if (!entry) {
        return;
      }
      const timeOrigin = msToSec(utils.browserPerformanceTimeOrigin);
      const startTime = msToSec(entry.startTime);
      debugBuild.DEBUG_BUILD && utils.logger.log("[Measurements] Adding FID");
      _measurements["fid"] = { value: metric.value, unit: "millisecond" };
      _measurements["mark.fid"] = { value: timeOrigin + startTime, unit: "second" };
    });
  };
  var addPerformanceEntries = function(transaction) {
    const performance2 = getBrowserPerformanceAPI();
    if (!performance2 || !types.WINDOW.performance.getEntries || !utils.browserPerformanceTimeOrigin) {
      return;
    }
    debugBuild.DEBUG_BUILD && utils.logger.log("[Tracing] Adding & adjusting spans using Performance API");
    const timeOrigin = msToSec(utils.browserPerformanceTimeOrigin);
    const performanceEntries = performance2.getEntries();
    let responseStartTimestamp;
    let requestStartTimestamp;
    const { op, start_timestamp: transactionStartTime } = core.spanToJSON(transaction);
    performanceEntries.slice(_performanceCursor).forEach((entry) => {
      const startTime = msToSec(entry.startTime);
      const duration = msToSec(entry.duration);
      if (transaction.op === "navigation" && transactionStartTime && timeOrigin + startTime < transactionStartTime) {
        return;
      }
      switch (entry.entryType) {
        case "navigation": {
          _addNavigationSpans(transaction, entry, timeOrigin);
          responseStartTimestamp = timeOrigin + msToSec(entry.responseStart);
          requestStartTimestamp = timeOrigin + msToSec(entry.requestStart);
          break;
        }
        case "mark":
        case "paint":
        case "measure": {
          _addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);
          const firstHidden = getVisibilityWatcher.getVisibilityWatcher();
          const shouldRecord = entry.startTime < firstHidden.firstHiddenTime;
          if (entry.name === "first-paint" && shouldRecord) {
            debugBuild.DEBUG_BUILD && utils.logger.log("[Measurements] Adding FP");
            _measurements["fp"] = { value: entry.startTime, unit: "millisecond" };
          }
          if (entry.name === "first-contentful-paint" && shouldRecord) {
            debugBuild.DEBUG_BUILD && utils.logger.log("[Measurements] Adding FCP");
            _measurements["fcp"] = { value: entry.startTime, unit: "millisecond" };
          }
          break;
        }
        case "resource": {
          _addResourceSpans(transaction, entry, entry.name, startTime, duration, timeOrigin);
          break;
        }
      }
    });
    _performanceCursor = Math.max(performanceEntries.length - 1, 0);
    _trackNavigator(transaction);
    if (op === "pageload") {
      _addTtfbToMeasurements(_measurements, responseStartTimestamp, requestStartTimestamp, transactionStartTime);
      ["fcp", "fp", "lcp"].forEach((name) => {
        if (!_measurements[name] || !transactionStartTime || timeOrigin >= transactionStartTime) {
          return;
        }
        const oldValue = _measurements[name].value;
        const measurementTimestamp = timeOrigin + msToSec(oldValue);
        const normalizedValue = Math.abs((measurementTimestamp - transactionStartTime) * 1000);
        const delta = normalizedValue - oldValue;
        debugBuild.DEBUG_BUILD && utils.logger.log(`[Measurements] Normalized ${name} from ${oldValue} to ${normalizedValue} (${delta})`);
        _measurements[name].value = normalizedValue;
      });
      const fidMark = _measurements["mark.fid"];
      if (fidMark && _measurements["fid"]) {
        utils$1._startChild(transaction, {
          description: "first input delay",
          endTimestamp: fidMark.value + msToSec(_measurements["fid"].value),
          op: "ui.action",
          origin: "auto.ui.browser.metrics",
          startTimestamp: fidMark.value
        });
        delete _measurements["mark.fid"];
      }
      if (!("fcp" in _measurements)) {
        delete _measurements.cls;
      }
      Object.keys(_measurements).forEach((measurementName) => {
        core.setMeasurement(measurementName, _measurements[measurementName].value, _measurements[measurementName].unit);
      });
      _tagMetricInfo(transaction);
    }
    _lcpEntry = undefined;
    _clsEntry = undefined;
    _measurements = {};
  };
  var _addMeasureSpans = function(transaction, entry, startTime, duration, timeOrigin) {
    const measureStartTimestamp = timeOrigin + startTime;
    const measureEndTimestamp = measureStartTimestamp + duration;
    utils$1._startChild(transaction, {
      description: entry.name,
      endTimestamp: measureEndTimestamp,
      op: entry.entryType,
      origin: "auto.resource.browser.metrics",
      startTimestamp: measureStartTimestamp
    });
    return measureStartTimestamp;
  };
  var _addNavigationSpans = function(transaction, entry, timeOrigin) {
    ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach((event) => {
      _addPerformanceNavigationTiming(transaction, entry, event, timeOrigin);
    });
    _addPerformanceNavigationTiming(transaction, entry, "secureConnection", timeOrigin, "TLS/SSL", "connectEnd");
    _addPerformanceNavigationTiming(transaction, entry, "fetch", timeOrigin, "cache", "domainLookupStart");
    _addPerformanceNavigationTiming(transaction, entry, "domainLookup", timeOrigin, "DNS");
    _addRequest(transaction, entry, timeOrigin);
  };
  var _addPerformanceNavigationTiming = function(transaction, entry, event, timeOrigin, description, eventEnd) {
    const end = eventEnd ? entry[eventEnd] : entry[`${event}End`];
    const start = entry[`${event}Start`];
    if (!start || !end) {
      return;
    }
    utils$1._startChild(transaction, {
      op: "browser",
      origin: "auto.browser.browser.metrics",
      description: description || event,
      startTimestamp: timeOrigin + msToSec(start),
      endTimestamp: timeOrigin + msToSec(end)
    });
  };
  var _addRequest = function(transaction, entry, timeOrigin) {
    if (entry.responseEnd) {
      utils$1._startChild(transaction, {
        op: "browser",
        origin: "auto.browser.browser.metrics",
        description: "request",
        startTimestamp: timeOrigin + msToSec(entry.requestStart),
        endTimestamp: timeOrigin + msToSec(entry.responseEnd)
      });
      utils$1._startChild(transaction, {
        op: "browser",
        origin: "auto.browser.browser.metrics",
        description: "response",
        startTimestamp: timeOrigin + msToSec(entry.responseStart),
        endTimestamp: timeOrigin + msToSec(entry.responseEnd)
      });
    }
  };
  var _addResourceSpans = function(transaction, entry, resourceUrl, startTime, duration, timeOrigin) {
    if (entry.initiatorType === "xmlhttprequest" || entry.initiatorType === "fetch") {
      return;
    }
    const parsedUrl = utils.parseUrl(resourceUrl);
    const data = {};
    setResourceEntrySizeData(data, entry, "transferSize", "http.response_transfer_size");
    setResourceEntrySizeData(data, entry, "encodedBodySize", "http.response_content_length");
    setResourceEntrySizeData(data, entry, "decodedBodySize", "http.decoded_response_content_length");
    if ("renderBlockingStatus" in entry) {
      data["resource.render_blocking_status"] = entry.renderBlockingStatus;
    }
    if (parsedUrl.protocol) {
      data["url.scheme"] = parsedUrl.protocol.split(":").pop();
    }
    if (parsedUrl.host) {
      data["server.address"] = parsedUrl.host;
    }
    data["url.same_origin"] = resourceUrl.includes(types.WINDOW.location.origin);
    const startTimestamp = timeOrigin + startTime;
    const endTimestamp = startTimestamp + duration;
    utils$1._startChild(transaction, {
      description: resourceUrl.replace(types.WINDOW.location.origin, ""),
      endTimestamp,
      op: entry.initiatorType ? `resource.${entry.initiatorType}` : "resource.other",
      origin: "auto.resource.browser.metrics",
      startTimestamp,
      data
    });
  };
  var _trackNavigator = function(transaction) {
    const navigator = types.WINDOW.navigator;
    if (!navigator) {
      return;
    }
    const connection = navigator.connection;
    if (connection) {
      if (connection.effectiveType) {
        transaction.setTag("effectiveConnectionType", connection.effectiveType);
      }
      if (connection.type) {
        transaction.setTag("connectionType", connection.type);
      }
      if (utils$1.isMeasurementValue(connection.rtt)) {
        _measurements["connection.rtt"] = { value: connection.rtt, unit: "millisecond" };
      }
    }
    if (utils$1.isMeasurementValue(navigator.deviceMemory)) {
      transaction.setTag("deviceMemory", `${navigator.deviceMemory} GB`);
    }
    if (utils$1.isMeasurementValue(navigator.hardwareConcurrency)) {
      transaction.setTag("hardwareConcurrency", String(navigator.hardwareConcurrency));
    }
  };
  var _tagMetricInfo = function(transaction) {
    if (_lcpEntry) {
      debugBuild.DEBUG_BUILD && utils.logger.log("[Measurements] Adding LCP Data");
      if (_lcpEntry.element) {
        transaction.setTag("lcp.element", utils.htmlTreeAsString(_lcpEntry.element));
      }
      if (_lcpEntry.id) {
        transaction.setTag("lcp.id", _lcpEntry.id);
      }
      if (_lcpEntry.url) {
        transaction.setTag("lcp.url", _lcpEntry.url.trim().slice(0, 200));
      }
      transaction.setTag("lcp.size", _lcpEntry.size);
    }
    if (_clsEntry && _clsEntry.sources) {
      debugBuild.DEBUG_BUILD && utils.logger.log("[Measurements] Adding CLS Data");
      _clsEntry.sources.forEach((source, index) => transaction.setTag(`cls.source.${index + 1}`, utils.htmlTreeAsString(source.node)));
    }
  };
  var setResourceEntrySizeData = function(data, entry, key, dataKey) {
    const entryVal = entry[key];
    if (entryVal != null && entryVal < MAX_INT_AS_BYTES) {
      data[dataKey] = entryVal;
    }
  };
  var _addTtfbToMeasurements = function(_measurements2, responseStartTimestamp, requestStartTimestamp, transactionStartTime) {
    if (typeof responseStartTimestamp === "number" && transactionStartTime) {
      debugBuild.DEBUG_BUILD && utils.logger.log("[Measurements] Adding TTFB");
      _measurements2["ttfb"] = {
        value: Math.max(responseStartTimestamp - transactionStartTime, 0) * 1000,
        unit: "millisecond"
      };
      if (typeof requestStartTimestamp === "number" && requestStartTimestamp <= responseStartTimestamp) {
        _measurements2["ttfb.requestTime"] = {
          value: (responseStartTimestamp - requestStartTimestamp) * 1000,
          unit: "millisecond"
        };
      }
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var utils = require_cjs();
  var debugBuild = require_debug_build3();
  var instrument = require_instrument2();
  var types = require_types();
  var getVisibilityWatcher = require_getVisibilityWatcher();
  var utils$1 = require_utils3();
  var MAX_INT_AS_BYTES = 2147483647;
  var _performanceCursor = 0;
  var _measurements = {};
  var _lcpEntry;
  var _clsEntry;
  exports._addMeasureSpans = _addMeasureSpans;
  exports._addResourceSpans = _addResourceSpans;
  exports._addTtfbToMeasurements = _addTtfbToMeasurements;
  exports.addPerformanceEntries = addPerformanceEntries;
  exports.startTrackingInteractions = startTrackingInteractions;
  exports.startTrackingLongTasks = startTrackingLongTasks;
  exports.startTrackingWebVitals = startTrackingWebVitals;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/common/fetch.js
var require_fetch2 = __commonJS((exports) => {
  var instrumentFetchRequest = function(handlerData, shouldCreateSpan, shouldAttachHeaders, spans, spanOrigin = "auto.http.browser") {
    if (!core.hasTracingEnabled() || !handlerData.fetchData) {
      return;
    }
    const shouldCreateSpanResult = shouldCreateSpan(handlerData.fetchData.url);
    if (handlerData.endTimestamp && shouldCreateSpanResult) {
      const spanId = handlerData.fetchData.__span;
      if (!spanId)
        return;
      const span2 = spans[spanId];
      if (span2) {
        if (handlerData.response) {
          core.setHttpStatus(span2, handlerData.response.status);
          const contentLength = handlerData.response && handlerData.response.headers && handlerData.response.headers.get("content-length");
          if (contentLength) {
            const contentLengthNum = parseInt(contentLength);
            if (contentLengthNum > 0) {
              span2.setAttribute("http.response_content_length", contentLengthNum);
            }
          }
        } else if (handlerData.error) {
          span2.setStatus("internal_error");
        }
        span2.end();
        delete spans[spanId];
      }
      return;
    }
    const scope = core.getCurrentScope();
    const client = core.getClient();
    const { method, url } = handlerData.fetchData;
    const span = shouldCreateSpanResult ? core.startInactiveSpan({
      name: `${method} ${url}`,
      onlyIfParent: true,
      attributes: {
        url,
        type: "fetch",
        "http.method": method,
        [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: spanOrigin
      },
      op: "http.client"
    }) : undefined;
    if (span) {
      handlerData.fetchData.__span = span.spanContext().spanId;
      spans[span.spanContext().spanId] = span;
    }
    if (shouldAttachHeaders(handlerData.fetchData.url) && client) {
      const request = handlerData.args[0];
      handlerData.args[1] = handlerData.args[1] || {};
      const options = handlerData.args[1];
      options.headers = addTracingHeadersToFetchRequest(request, client, scope, options, span);
    }
    return span;
  };
  var addTracingHeadersToFetchRequest = function(request, client, scope, options, requestSpan) {
    const span = requestSpan || scope.getSpan();
    const isolationScope = core.getIsolationScope();
    const { traceId, spanId, sampled, dsc } = {
      ...isolationScope.getPropagationContext(),
      ...scope.getPropagationContext()
    };
    const sentryTraceHeader = span ? core.spanToTraceHeader(span) : utils.generateSentryTraceHeader(traceId, spanId, sampled);
    const sentryBaggageHeader = utils.dynamicSamplingContextToSentryBaggageHeader(dsc || (span ? core.getDynamicSamplingContextFromSpan(span) : core.getDynamicSamplingContextFromClient(traceId, client, scope)));
    const headers = options.headers || (typeof Request !== "undefined" && utils.isInstanceOf(request, Request) ? request.headers : undefined);
    if (!headers) {
      return { "sentry-trace": sentryTraceHeader, baggage: sentryBaggageHeader };
    } else if (typeof Headers !== "undefined" && utils.isInstanceOf(headers, Headers)) {
      const newHeaders = new Headers(headers);
      newHeaders.append("sentry-trace", sentryTraceHeader);
      if (sentryBaggageHeader) {
        newHeaders.append(utils.BAGGAGE_HEADER_NAME, sentryBaggageHeader);
      }
      return newHeaders;
    } else if (Array.isArray(headers)) {
      const newHeaders = [...headers, ["sentry-trace", sentryTraceHeader]];
      if (sentryBaggageHeader) {
        newHeaders.push([utils.BAGGAGE_HEADER_NAME, sentryBaggageHeader]);
      }
      return newHeaders;
    } else {
      const existingBaggageHeader = "baggage" in headers ? headers.baggage : undefined;
      const newBaggageHeaders = [];
      if (Array.isArray(existingBaggageHeader)) {
        newBaggageHeaders.push(...existingBaggageHeader);
      } else if (existingBaggageHeader) {
        newBaggageHeaders.push(existingBaggageHeader);
      }
      if (sentryBaggageHeader) {
        newBaggageHeaders.push(sentryBaggageHeader);
      }
      return {
        ...headers,
        "sentry-trace": sentryTraceHeader,
        baggage: newBaggageHeaders.length > 0 ? newBaggageHeaders.join(",") : undefined
      };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var utils = require_cjs();
  exports.addTracingHeadersToFetchRequest = addTracingHeadersToFetchRequest;
  exports.instrumentFetchRequest = instrumentFetchRequest;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/browser/request.js
var require_request = __commonJS((exports) => {
  var instrumentOutgoingRequests = function(_options) {
    const {
      traceFetch,
      traceXHR,
      tracePropagationTargets,
      tracingOrigins,
      shouldCreateSpanForRequest,
      enableHTTPTimings
    } = {
      traceFetch: defaultRequestInstrumentationOptions.traceFetch,
      traceXHR: defaultRequestInstrumentationOptions.traceXHR,
      ..._options
    };
    const shouldCreateSpan = typeof shouldCreateSpanForRequest === "function" ? shouldCreateSpanForRequest : (_) => true;
    const shouldAttachHeadersWithTargets = (url) => shouldAttachHeaders(url, tracePropagationTargets || tracingOrigins);
    const spans = {};
    if (traceFetch) {
      utils.addFetchInstrumentationHandler((handlerData) => {
        const createdSpan = fetch2.instrumentFetchRequest(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);
        if (enableHTTPTimings && createdSpan) {
          addHTTPTimings(createdSpan);
        }
      });
    }
    if (traceXHR) {
      utils.addXhrInstrumentationHandler((handlerData) => {
        const createdSpan = xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);
        if (enableHTTPTimings && createdSpan) {
          addHTTPTimings(createdSpan);
        }
      });
    }
  };
  var isPerformanceResourceTiming = function(entry) {
    return entry.entryType === "resource" && "initiatorType" in entry && typeof entry.nextHopProtocol === "string" && (entry.initiatorType === "fetch" || entry.initiatorType === "xmlhttprequest");
  };
  var addHTTPTimings = function(span) {
    const { url } = core.spanToJSON(span).data || {};
    if (!url || typeof url !== "string") {
      return;
    }
    const cleanup = instrument.addPerformanceInstrumentationHandler("resource", ({ entries }) => {
      entries.forEach((entry) => {
        if (isPerformanceResourceTiming(entry) && entry.name.endsWith(url)) {
          const spanData = resourceTimingEntryToSpanData(entry);
          spanData.forEach((data) => span.setAttribute(...data));
          setTimeout(cleanup);
        }
      });
    });
  };
  var extractNetworkProtocol = function(nextHopProtocol) {
    let name = "unknown";
    let version = "unknown";
    let _name = "";
    for (const char of nextHopProtocol) {
      if (char === "/") {
        [name, version] = nextHopProtocol.split("/");
        break;
      }
      if (!isNaN(Number(char))) {
        name = _name === "h" ? "http" : _name;
        version = nextHopProtocol.split(_name)[1];
        break;
      }
      _name += char;
    }
    if (_name === nextHopProtocol) {
      name = _name;
    }
    return { name, version };
  };
  var getAbsoluteTime = function(time = 0) {
    return ((utils.browserPerformanceTimeOrigin || performance.timeOrigin) + time) / 1000;
  };
  var resourceTimingEntryToSpanData = function(resourceTiming) {
    const { name, version } = extractNetworkProtocol(resourceTiming.nextHopProtocol);
    const timingSpanData = [];
    timingSpanData.push(["network.protocol.version", version], ["network.protocol.name", name]);
    if (!utils.browserPerformanceTimeOrigin) {
      return timingSpanData;
    }
    return [
      ...timingSpanData,
      ["http.request.redirect_start", getAbsoluteTime(resourceTiming.redirectStart)],
      ["http.request.fetch_start", getAbsoluteTime(resourceTiming.fetchStart)],
      ["http.request.domain_lookup_start", getAbsoluteTime(resourceTiming.domainLookupStart)],
      ["http.request.domain_lookup_end", getAbsoluteTime(resourceTiming.domainLookupEnd)],
      ["http.request.connect_start", getAbsoluteTime(resourceTiming.connectStart)],
      ["http.request.secure_connection_start", getAbsoluteTime(resourceTiming.secureConnectionStart)],
      ["http.request.connection_end", getAbsoluteTime(resourceTiming.connectEnd)],
      ["http.request.request_start", getAbsoluteTime(resourceTiming.requestStart)],
      ["http.request.response_start", getAbsoluteTime(resourceTiming.responseStart)],
      ["http.request.response_end", getAbsoluteTime(resourceTiming.responseEnd)]
    ];
  };
  var shouldAttachHeaders = function(url, tracePropagationTargets) {
    return utils.stringMatchesSomePattern(url, tracePropagationTargets || DEFAULT_TRACE_PROPAGATION_TARGETS);
  };
  var xhrCallback = function(handlerData, shouldCreateSpan, shouldAttachHeaders2, spans) {
    const xhr = handlerData.xhr;
    const sentryXhrData = xhr && xhr[utils.SENTRY_XHR_DATA_KEY];
    if (!core.hasTracingEnabled() || !xhr || xhr.__sentry_own_request__ || !sentryXhrData) {
      return;
    }
    const shouldCreateSpanResult = shouldCreateSpan(sentryXhrData.url);
    if (handlerData.endTimestamp && shouldCreateSpanResult) {
      const spanId = xhr.__sentry_xhr_span_id__;
      if (!spanId)
        return;
      const span2 = spans[spanId];
      if (span2 && sentryXhrData.status_code !== undefined) {
        core.setHttpStatus(span2, sentryXhrData.status_code);
        span2.end();
        delete spans[spanId];
      }
      return;
    }
    const scope = core.getCurrentScope();
    const isolationScope = core.getIsolationScope();
    const span = shouldCreateSpanResult ? core.startInactiveSpan({
      name: `${sentryXhrData.method} ${sentryXhrData.url}`,
      onlyIfParent: true,
      attributes: {
        type: "xhr",
        "http.method": sentryXhrData.method,
        url: sentryXhrData.url,
        [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.http.browser"
      },
      op: "http.client"
    }) : undefined;
    if (span) {
      xhr.__sentry_xhr_span_id__ = span.spanContext().spanId;
      spans[xhr.__sentry_xhr_span_id__] = span;
    }
    const client = core.getClient();
    if (xhr.setRequestHeader && shouldAttachHeaders2(sentryXhrData.url) && client) {
      const { traceId, spanId, sampled, dsc } = {
        ...isolationScope.getPropagationContext(),
        ...scope.getPropagationContext()
      };
      const sentryTraceHeader = span ? core.spanToTraceHeader(span) : utils.generateSentryTraceHeader(traceId, spanId, sampled);
      const sentryBaggageHeader = utils.dynamicSamplingContextToSentryBaggageHeader(dsc || (span ? core.getDynamicSamplingContextFromSpan(span) : core.getDynamicSamplingContextFromClient(traceId, client, scope)));
      setHeaderOnXhr(xhr, sentryTraceHeader, sentryBaggageHeader);
    }
    return span;
  };
  var setHeaderOnXhr = function(xhr, sentryTraceHeader, sentryBaggageHeader) {
    try {
      xhr.setRequestHeader("sentry-trace", sentryTraceHeader);
      if (sentryBaggageHeader) {
        xhr.setRequestHeader(utils.BAGGAGE_HEADER_NAME, sentryBaggageHeader);
      }
    } catch (_) {
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var utils = require_cjs();
  var fetch2 = require_fetch2();
  var instrument = require_instrument2();
  var DEFAULT_TRACE_PROPAGATION_TARGETS = ["localhost", /^\/(?!\/)/];
  var defaultRequestInstrumentationOptions = {
    traceFetch: true,
    traceXHR: true,
    enableHTTPTimings: true,
    tracingOrigins: DEFAULT_TRACE_PROPAGATION_TARGETS,
    tracePropagationTargets: DEFAULT_TRACE_PROPAGATION_TARGETS
  };
  exports.DEFAULT_TRACE_PROPAGATION_TARGETS = DEFAULT_TRACE_PROPAGATION_TARGETS;
  exports.defaultRequestInstrumentationOptions = defaultRequestInstrumentationOptions;
  exports.extractNetworkProtocol = extractNetworkProtocol;
  exports.instrumentOutgoingRequests = instrumentOutgoingRequests;
  exports.shouldAttachHeaders = shouldAttachHeaders;
  exports.xhrCallback = xhrCallback;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/browser/router.js
var require_router = __commonJS((exports) => {
  var instrumentRoutingWithDefaults = function(customStartTransaction, startTransactionOnPageLoad = true, startTransactionOnLocationChange = true) {
    if (!types.WINDOW || !types.WINDOW.location) {
      debugBuild.DEBUG_BUILD && utils.logger.warn("Could not initialize routing instrumentation due to invalid location");
      return;
    }
    let startingUrl = types.WINDOW.location.href;
    let activeTransaction;
    if (startTransactionOnPageLoad) {
      activeTransaction = customStartTransaction({
        name: types.WINDOW.location.pathname,
        startTimestamp: utils.browserPerformanceTimeOrigin ? utils.browserPerformanceTimeOrigin / 1000 : undefined,
        op: "pageload",
        origin: "auto.pageload.browser",
        metadata: { source: "url" }
      });
    }
    if (startTransactionOnLocationChange) {
      utils.addHistoryInstrumentationHandler(({ to, from }) => {
        if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {
          startingUrl = undefined;
          return;
        }
        if (from !== to) {
          startingUrl = undefined;
          if (activeTransaction) {
            debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Finishing current transaction with op: ${activeTransaction.op}`);
            activeTransaction.end();
          }
          activeTransaction = customStartTransaction({
            name: types.WINDOW.location.pathname,
            op: "navigation",
            origin: "auto.navigation.browser",
            metadata: { source: "url" }
          });
        }
      });
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var debugBuild = require_debug_build3();
  var types = require_types();
  exports.instrumentRoutingWithDefaults = instrumentRoutingWithDefaults;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/browser/browsertracing.js
var require_browsertracing = __commonJS((exports) => {
  var getMetaContent = function(metaName) {
    const metaTag = utils.getDomElement(`meta[name=${metaName}]`);
    return metaTag ? metaTag.getAttribute("content") : undefined;
  };
  var getSource = function(context) {
    const sourceFromAttributes = context.attributes && context.attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
    const sourceFromData = context.data && context.data[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
    const sourceFromMetadata = context.metadata && context.metadata.source;
    return sourceFromAttributes || sourceFromData || sourceFromMetadata;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var utils = require_cjs();
  var debugBuild = require_debug_build3();
  var backgroundtab = require_backgroundtab();
  var index = require_metrics();
  var request = require_request();
  var router = require_router();
  var types = require_types();
  var BROWSER_TRACING_INTEGRATION_ID = "BrowserTracing";
  var DEFAULT_BROWSER_TRACING_OPTIONS = {
    ...core.TRACING_DEFAULTS,
    markBackgroundTransactions: true,
    routingInstrumentation: router.instrumentRoutingWithDefaults,
    startTransactionOnLocationChange: true,
    startTransactionOnPageLoad: true,
    enableLongTask: true,
    _experiments: {},
    ...request.defaultRequestInstrumentationOptions
  };

  class BrowserTracing {
    constructor(_options) {
      this.name = BROWSER_TRACING_INTEGRATION_ID;
      this._hasSetTracePropagationTargets = false;
      core.addTracingExtensions();
      if (debugBuild.DEBUG_BUILD) {
        this._hasSetTracePropagationTargets = !!(_options && (_options.tracePropagationTargets || _options.tracingOrigins));
      }
      this.options = {
        ...DEFAULT_BROWSER_TRACING_OPTIONS,
        ..._options
      };
      if (this.options._experiments.enableLongTask !== undefined) {
        this.options.enableLongTask = this.options._experiments.enableLongTask;
      }
      if (_options && !_options.tracePropagationTargets && _options.tracingOrigins) {
        this.options.tracePropagationTargets = _options.tracingOrigins;
      }
      this._collectWebVitals = index.startTrackingWebVitals();
      if (this.options.enableLongTask) {
        index.startTrackingLongTasks();
      }
      if (this.options._experiments.enableInteractions) {
        index.startTrackingInteractions();
      }
    }
    setupOnce(_, getCurrentHub) {
      this._getCurrentHub = getCurrentHub;
      const hub = getCurrentHub();
      const client = hub.getClient();
      const clientOptions = client && client.getOptions();
      const {
        routingInstrumentation: instrumentRouting,
        startTransactionOnLocationChange,
        startTransactionOnPageLoad,
        markBackgroundTransactions,
        traceFetch,
        traceXHR,
        shouldCreateSpanForRequest,
        enableHTTPTimings,
        _experiments
      } = this.options;
      const clientOptionsTracePropagationTargets = clientOptions && clientOptions.tracePropagationTargets;
      const tracePropagationTargets = clientOptionsTracePropagationTargets || this.options.tracePropagationTargets;
      if (debugBuild.DEBUG_BUILD && this._hasSetTracePropagationTargets && clientOptionsTracePropagationTargets) {
        utils.logger.warn("[Tracing] The `tracePropagationTargets` option was set in the BrowserTracing integration and top level `Sentry.init`. The top level `Sentry.init` value is being used.");
      }
      instrumentRouting((context) => {
        const transaction = this._createRouteTransaction(context);
        this.options._experiments.onStartRouteTransaction && this.options._experiments.onStartRouteTransaction(transaction, context, getCurrentHub);
        return transaction;
      }, startTransactionOnPageLoad, startTransactionOnLocationChange);
      if (markBackgroundTransactions) {
        backgroundtab.registerBackgroundTabDetection();
      }
      if (_experiments.enableInteractions) {
        this._registerInteractionListener();
      }
      request.instrumentOutgoingRequests({
        traceFetch,
        traceXHR,
        tracePropagationTargets,
        shouldCreateSpanForRequest,
        enableHTTPTimings
      });
    }
    _createRouteTransaction(context) {
      if (!this._getCurrentHub) {
        debugBuild.DEBUG_BUILD && utils.logger.warn(`[Tracing] Did not create ${context.op} transaction because _getCurrentHub is invalid.`);
        return;
      }
      const hub = this._getCurrentHub();
      const { beforeNavigate, idleTimeout, finalTimeout, heartbeatInterval } = this.options;
      const isPageloadTransaction = context.op === "pageload";
      let expandedContext;
      if (isPageloadTransaction) {
        const sentryTrace = isPageloadTransaction ? getMetaContent("sentry-trace") : "";
        const baggage = isPageloadTransaction ? getMetaContent("baggage") : undefined;
        const { traceId, dsc, parentSpanId, sampled } = utils.propagationContextFromHeaders(sentryTrace, baggage);
        expandedContext = {
          traceId,
          parentSpanId,
          parentSampled: sampled,
          ...context,
          metadata: {
            ...context.metadata,
            dynamicSamplingContext: dsc
          },
          trimEnd: true
        };
      } else {
        expandedContext = {
          trimEnd: true,
          ...context
        };
      }
      const modifiedContext = typeof beforeNavigate === "function" ? beforeNavigate(expandedContext) : expandedContext;
      const finalContext = modifiedContext === undefined ? { ...expandedContext, sampled: false } : modifiedContext;
      finalContext.metadata = finalContext.name !== expandedContext.name ? { ...finalContext.metadata, source: "custom" } : finalContext.metadata;
      this._latestRouteName = finalContext.name;
      this._latestRouteSource = getSource(finalContext);
      if (finalContext.sampled === false) {
        debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Will not send ${finalContext.op} transaction because of beforeNavigate.`);
      }
      debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Starting ${finalContext.op} transaction on scope`);
      const { location } = types.WINDOW;
      const idleTransaction = core.startIdleTransaction(hub, finalContext, idleTimeout, finalTimeout, true, { location }, heartbeatInterval, isPageloadTransaction);
      if (isPageloadTransaction) {
        types.WINDOW.document.addEventListener("readystatechange", () => {
          if (["interactive", "complete"].includes(types.WINDOW.document.readyState)) {
            idleTransaction.sendAutoFinishSignal();
          }
        });
        if (["interactive", "complete"].includes(types.WINDOW.document.readyState)) {
          idleTransaction.sendAutoFinishSignal();
        }
      }
      idleTransaction.registerBeforeFinishCallback((transaction) => {
        this._collectWebVitals();
        index.addPerformanceEntries(transaction);
      });
      return idleTransaction;
    }
    _registerInteractionListener() {
      let inflightInteractionTransaction;
      const registerInteractionTransaction = () => {
        const { idleTimeout, finalTimeout, heartbeatInterval } = this.options;
        const op = "ui.action.click";
        const currentTransaction = core.getActiveTransaction();
        if (currentTransaction && currentTransaction.op && ["navigation", "pageload"].includes(currentTransaction.op)) {
          debugBuild.DEBUG_BUILD && utils.logger.warn(`[Tracing] Did not create ${op} transaction because a pageload or navigation transaction is in progress.`);
          return;
        }
        if (inflightInteractionTransaction) {
          inflightInteractionTransaction.setFinishReason("interactionInterrupted");
          inflightInteractionTransaction.end();
          inflightInteractionTransaction = undefined;
        }
        if (!this._getCurrentHub) {
          debugBuild.DEBUG_BUILD && utils.logger.warn(`[Tracing] Did not create ${op} transaction because _getCurrentHub is invalid.`);
          return;
        }
        if (!this._latestRouteName) {
          debugBuild.DEBUG_BUILD && utils.logger.warn(`[Tracing] Did not create ${op} transaction because _latestRouteName is missing.`);
          return;
        }
        const hub = this._getCurrentHub();
        const { location } = types.WINDOW;
        const context = {
          name: this._latestRouteName,
          op,
          trimEnd: true,
          data: {
            [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: this._latestRouteSource || "url"
          }
        };
        inflightInteractionTransaction = core.startIdleTransaction(hub, context, idleTimeout, finalTimeout, true, { location }, heartbeatInterval);
      };
      ["click"].forEach((type) => {
        addEventListener(type, registerInteractionTransaction, { once: false, capture: true });
      });
    }
  }
  exports.BROWSER_TRACING_INTEGRATION_ID = BROWSER_TRACING_INTEGRATION_ID;
  exports.BrowserTracing = BrowserTracing;
  exports.getMetaContent = getMetaContent;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/browser/browserTracingIntegration.js
var require_browserTracingIntegration = __commonJS((exports) => {
  var startBrowserTracingPageLoadSpan = function(client, spanOptions) {
    if (!client.emit) {
      return;
    }
    client.emit("startPageLoadSpan", spanOptions);
  };
  var startBrowserTracingNavigationSpan = function(client, spanOptions) {
    if (!client.emit) {
      return;
    }
    client.emit("startNavigationSpan", spanOptions);
  };
  var getMetaContent = function(metaName) {
    const metaTag = utils.getDomElement(`meta[name=${metaName}]`);
    return metaTag ? metaTag.getAttribute("content") : undefined;
  };
  var registerInteractionListener = function(options, latestRouteName, latestRouteSource) {
    let inflightInteractionTransaction;
    const registerInteractionTransaction = () => {
      const { idleTimeout, finalTimeout, heartbeatInterval } = options;
      const op = "ui.action.click";
      const currentTransaction = core.getActiveTransaction();
      if (currentTransaction && currentTransaction.op && ["navigation", "pageload"].includes(currentTransaction.op)) {
        debugBuild.DEBUG_BUILD && utils.logger.warn(`[Tracing] Did not create ${op} transaction because a pageload or navigation transaction is in progress.`);
        return;
      }
      if (inflightInteractionTransaction) {
        inflightInteractionTransaction.setFinishReason("interactionInterrupted");
        inflightInteractionTransaction.end();
        inflightInteractionTransaction = undefined;
      }
      if (!latestRouteName) {
        debugBuild.DEBUG_BUILD && utils.logger.warn(`[Tracing] Did not create ${op} transaction because _latestRouteName is missing.`);
        return;
      }
      const { location } = types.WINDOW;
      const context = {
        name: latestRouteName,
        op,
        trimEnd: true,
        data: {
          [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: latestRouteSource || "url"
        }
      };
      inflightInteractionTransaction = core.startIdleTransaction(core.getCurrentHub(), context, idleTimeout, finalTimeout, true, { location }, heartbeatInterval);
    };
    ["click"].forEach((type) => {
      addEventListener(type, registerInteractionTransaction, { once: false, capture: true });
    });
  };
  var getSource = function(context) {
    const sourceFromAttributes = context.attributes && context.attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
    const sourceFromData = context.data && context.data[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
    const sourceFromMetadata = context.metadata && context.metadata.source;
    return sourceFromAttributes || sourceFromData || sourceFromMetadata;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var utils = require_cjs();
  var debugBuild = require_debug_build3();
  var backgroundtab = require_backgroundtab();
  var index = require_metrics();
  var request = require_request();
  var types = require_types();
  var BROWSER_TRACING_INTEGRATION_ID = "BrowserTracing";
  var DEFAULT_BROWSER_TRACING_OPTIONS = {
    ...core.TRACING_DEFAULTS,
    instrumentNavigation: true,
    instrumentPageLoad: true,
    markBackgroundSpan: true,
    enableLongTask: true,
    _experiments: {},
    ...request.defaultRequestInstrumentationOptions
  };
  var browserTracingIntegration = (_options = {}) => {
    const _hasSetTracePropagationTargets = debugBuild.DEBUG_BUILD ? !!(_options.tracePropagationTargets || _options.tracingOrigins) : false;
    core.addTracingExtensions();
    if (!_options.tracePropagationTargets && _options.tracingOrigins) {
      _options.tracePropagationTargets = _options.tracingOrigins;
    }
    const options = {
      ...DEFAULT_BROWSER_TRACING_OPTIONS,
      ..._options
    };
    const _collectWebVitals = index.startTrackingWebVitals();
    if (options.enableLongTask) {
      index.startTrackingLongTasks();
    }
    if (options._experiments.enableInteractions) {
      index.startTrackingInteractions();
    }
    let latestRouteName;
    let latestRouteSource;
    function _createRouteTransaction(context) {
      const hub = core.getCurrentHub();
      const { beforeStartSpan, idleTimeout, finalTimeout, heartbeatInterval } = options;
      const isPageloadTransaction = context.op === "pageload";
      let expandedContext;
      if (isPageloadTransaction) {
        const sentryTrace = isPageloadTransaction ? getMetaContent("sentry-trace") : "";
        const baggage = isPageloadTransaction ? getMetaContent("baggage") : undefined;
        const { traceId, dsc, parentSpanId, sampled } = utils.propagationContextFromHeaders(sentryTrace, baggage);
        expandedContext = {
          traceId,
          parentSpanId,
          parentSampled: sampled,
          ...context,
          metadata: {
            ...context.metadata,
            dynamicSamplingContext: dsc
          },
          trimEnd: true
        };
      } else {
        expandedContext = {
          trimEnd: true,
          ...context
        };
      }
      const finalContext = beforeStartSpan ? beforeStartSpan(expandedContext) : expandedContext;
      finalContext.metadata = finalContext.name !== expandedContext.name ? { ...finalContext.metadata, source: "custom" } : finalContext.metadata;
      latestRouteName = finalContext.name;
      latestRouteSource = getSource(finalContext);
      if (finalContext.sampled === false) {
        debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Will not send ${finalContext.op} transaction because of beforeNavigate.`);
      }
      debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Starting ${finalContext.op} transaction on scope`);
      const { location } = types.WINDOW;
      const idleTransaction = core.startIdleTransaction(hub, finalContext, idleTimeout, finalTimeout, true, { location }, heartbeatInterval, isPageloadTransaction);
      if (isPageloadTransaction) {
        types.WINDOW.document.addEventListener("readystatechange", () => {
          if (["interactive", "complete"].includes(types.WINDOW.document.readyState)) {
            idleTransaction.sendAutoFinishSignal();
          }
        });
        if (["interactive", "complete"].includes(types.WINDOW.document.readyState)) {
          idleTransaction.sendAutoFinishSignal();
        }
      }
      idleTransaction.registerBeforeFinishCallback((transaction) => {
        _collectWebVitals();
        index.addPerformanceEntries(transaction);
      });
      return idleTransaction;
    }
    return {
      name: BROWSER_TRACING_INTEGRATION_ID,
      setupOnce: () => {
      },
      afterAllSetup(client) {
        const clientOptions = client.getOptions();
        const { markBackgroundSpan, traceFetch, traceXHR, shouldCreateSpanForRequest, enableHTTPTimings, _experiments } = options;
        const clientOptionsTracePropagationTargets = clientOptions && clientOptions.tracePropagationTargets;
        const tracePropagationTargets = clientOptionsTracePropagationTargets || options.tracePropagationTargets;
        if (debugBuild.DEBUG_BUILD && _hasSetTracePropagationTargets && clientOptionsTracePropagationTargets) {
          utils.logger.warn("[Tracing] The `tracePropagationTargets` option was set in the BrowserTracing integration and top level `Sentry.init`. The top level `Sentry.init` value is being used.");
        }
        let activeSpan;
        let startingUrl = types.WINDOW.location.href;
        if (client.on) {
          client.on("startNavigationSpan", (context) => {
            if (activeSpan) {
              debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Finishing current transaction with op: ${core.spanToJSON(activeSpan).op}`);
              activeSpan.end();
            }
            activeSpan = _createRouteTransaction(context);
          });
          client.on("startPageLoadSpan", (context) => {
            if (activeSpan) {
              debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Finishing current transaction with op: ${core.spanToJSON(activeSpan).op}`);
              activeSpan.end();
            }
            activeSpan = _createRouteTransaction(context);
          });
        }
        if (options.instrumentPageLoad && client.emit) {
          const context = {
            name: types.WINDOW.location.pathname,
            startTimestamp: utils.browserPerformanceTimeOrigin ? utils.browserPerformanceTimeOrigin / 1000 : undefined,
            op: "pageload",
            origin: "auto.pageload.browser",
            attributes: {
              [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: "url"
            }
          };
          startBrowserTracingPageLoadSpan(client, context);
        }
        if (options.instrumentNavigation && client.emit) {
          utils.addHistoryInstrumentationHandler(({ to, from }) => {
            if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {
              startingUrl = undefined;
              return;
            }
            if (from !== to) {
              startingUrl = undefined;
              const context = {
                name: types.WINDOW.location.pathname,
                op: "navigation",
                origin: "auto.navigation.browser",
                attributes: {
                  [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: "url"
                }
              };
              startBrowserTracingNavigationSpan(client, context);
            }
          });
        }
        if (markBackgroundSpan) {
          backgroundtab.registerBackgroundTabDetection();
        }
        if (_experiments.enableInteractions) {
          registerInteractionListener(options, latestRouteName, latestRouteSource);
        }
        request.instrumentOutgoingRequests({
          traceFetch,
          traceXHR,
          tracePropagationTargets,
          shouldCreateSpanForRequest,
          enableHTTPTimings
        });
      },
      options
    };
  };
  exports.BROWSER_TRACING_INTEGRATION_ID = BROWSER_TRACING_INTEGRATION_ID;
  exports.browserTracingIntegration = browserTracingIntegration;
  exports.getMetaContent = getMetaContent;
  exports.startBrowserTracingNavigationSpan = startBrowserTracingNavigationSpan;
  exports.startBrowserTracingPageLoadSpan = startBrowserTracingPageLoadSpan;
});

// ../node_modules/.pnpm/@sentry-internal+tracing@7.100.1/node_modules/@sentry-internal/tracing/cjs/extensions.js
var require_extensions = __commonJS((exports, module) => {
  var _autoloadDatabaseIntegrations = function() {
    const carrier = core.getMainCarrier();
    if (!carrier.__SENTRY__) {
      return;
    }
    const packageToIntegrationMapping = {
      mongodb() {
        const integration = utils.dynamicRequire(module, "./node/integrations/mongo");
        return new integration.Mongo;
      },
      mongoose() {
        const integration = utils.dynamicRequire(module, "./node/integrations/mongo");
        return new integration.Mongo;
      },
      mysql() {
        const integration = utils.dynamicRequire(module, "./node/integrations/mysql");
        return new integration.Mysql;
      },
      pg() {
        const integration = utils.dynamicRequire(module, "./node/integrations/postgres");
        return new integration.Postgres;
      }
    };
    const mappedPackages = Object.keys(packageToIntegrationMapping).filter((moduleName) => !!utils.loadModule(moduleName)).map((pkg) => {
      try {
        return packageToIntegrationMapping[pkg]();
      } catch (e) {
        return;
      }
    }).filter((p) => p);
    if (mappedPackages.length > 0) {
      carrier.__SENTRY__.integrations = [...carrier.__SENTRY__.integrations || [], ...mappedPackages];
    }
  };
  var addExtensionMethods = function() {
    core.addTracingExtensions();
    if (utils.isNodeEnv()) {
      _autoloadDatabaseIntegrations();
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var utils = require_cjs();
  exports.addExtensionMethods = addExtensionMethods;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry-internal/tracing/cjs/index.js
var require_cjs3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var utils = require_cjs();
  var express = require_express();
  var postgres = require_postgres();
  var mysql = require_mysql();
  var mongo = require_mongo();
  var prisma = require_prisma();
  var graphql = require_graphql();
  var apollo = require_apollo();
  var lazy = require_lazy();
  var browsertracing = require_browsertracing();
  var browserTracingIntegration = require_browserTracingIntegration();
  var request = require_request();
  var instrument = require_instrument2();
  var fetch2 = require_fetch2();
  var extensions = require_extensions();
  exports.IdleTransaction = core.IdleTransaction;
  exports.Span = core.Span;
  exports.SpanStatus = core.SpanStatus;
  exports.Transaction = core.Transaction;
  exports.extractTraceparentData = core.extractTraceparentData;
  exports.getActiveTransaction = core.getActiveTransaction;
  exports.hasTracingEnabled = core.hasTracingEnabled;
  exports.spanStatusfromHttpCode = core.spanStatusfromHttpCode;
  exports.startIdleTransaction = core.startIdleTransaction;
  exports.TRACEPARENT_REGEXP = utils.TRACEPARENT_REGEXP;
  exports.stripUrlQueryAndFragment = utils.stripUrlQueryAndFragment;
  exports.Express = express.Express;
  exports.Postgres = postgres.Postgres;
  exports.Mysql = mysql.Mysql;
  exports.Mongo = mongo.Mongo;
  exports.Prisma = prisma.Prisma;
  exports.GraphQL = graphql.GraphQL;
  exports.Apollo = apollo.Apollo;
  exports.lazyLoadedNodePerformanceMonitoringIntegrations = lazy.lazyLoadedNodePerformanceMonitoringIntegrations;
  exports.BROWSER_TRACING_INTEGRATION_ID = browsertracing.BROWSER_TRACING_INTEGRATION_ID;
  exports.BrowserTracing = browsertracing.BrowserTracing;
  exports.browserTracingIntegration = browserTracingIntegration.browserTracingIntegration;
  exports.startBrowserTracingNavigationSpan = browserTracingIntegration.startBrowserTracingNavigationSpan;
  exports.startBrowserTracingPageLoadSpan = browserTracingIntegration.startBrowserTracingPageLoadSpan;
  exports.defaultRequestInstrumentationOptions = request.defaultRequestInstrumentationOptions;
  exports.instrumentOutgoingRequests = request.instrumentOutgoingRequests;
  exports.addClsInstrumentationHandler = instrument.addClsInstrumentationHandler;
  exports.addFidInstrumentationHandler = instrument.addFidInstrumentationHandler;
  exports.addLcpInstrumentationHandler = instrument.addLcpInstrumentationHandler;
  exports.addPerformanceInstrumentationHandler = instrument.addPerformanceInstrumentationHandler;
  exports.addTracingHeadersToFetchRequest = fetch2.addTracingHeadersToFetchRequest;
  exports.instrumentFetchRequest = fetch2.instrumentFetchRequest;
  exports.addExtensionMethods = extensions.addExtensionMethods;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/tracing/index.js
var require_tracing2 = __commonJS((exports) => {
  var autoDiscoverNodePerformanceMonitoringIntegrations = function() {
    const loadedIntegrations = tracing.lazyLoadedNodePerformanceMonitoringIntegrations.map((tryLoad) => {
      try {
        return tryLoad();
      } catch (_) {
        return;
      }
    }).filter((integration) => !!integration);
    if (loadedIntegrations.length === 0) {
      utils.logger.warn("Performance monitoring integrations could not be automatically loaded.");
    }
    return loadedIntegrations.filter((integration) => !!integration.loadDependency());
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var tracing = require_cjs3();
  var utils = require_cjs();
  exports.autoDiscoverNodePerformanceMonitoringIntegrations = autoDiscoverNodePerformanceMonitoringIntegrations;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/client.js
var require_client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var os = __require("os");
  var util = __require("util");
  var core = require_cjs2();

  class NodeClient extends core.ServerRuntimeClient {
    constructor(options) {
      core.applySdkMetadata(options, "node");
      options.transportOptions = {
        textEncoder: new util.TextEncoder,
        ...options.transportOptions
      };
      const clientOptions = {
        ...options,
        platform: "node",
        runtime: { name: "node", version: global.process.version },
        serverName: options.serverName || global.process.env.SENTRY_NAME || os.hostname()
      };
      super(clientOptions);
    }
  }
  exports.NodeClient = NodeClient;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/proxy/base.js
var require_base2 = __commonJS((exports) => {
  var {
    _nullishCoalesce
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  var http = __require("http");
  __require("https");
  var INTERNAL = Symbol("AgentBaseInternalState");

  class Agent extends http.Agent {
    constructor(opts) {
      super(opts);
      this[INTERNAL] = {};
    }
    isSecureEndpoint(options) {
      if (options) {
        if (typeof options.secureEndpoint === "boolean") {
          return options.secureEndpoint;
        }
        if (typeof options.protocol === "string") {
          return options.protocol === "https:";
        }
      }
      const { stack } = new Error;
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    createSocket(req, options, cb) {
      const connectOpts = {
        ...options,
        secureEndpoint: this.isSecureEndpoint(options)
      };
      Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
        if (socket instanceof http.Agent) {
          return socket.addRequest(req, connectOpts);
        }
        this[INTERNAL].currentSocket = socket;
        super.createSocket(req, options, cb);
      }, cb);
    }
    createConnection() {
      const socket = this[INTERNAL].currentSocket;
      this[INTERNAL].currentSocket = undefined;
      if (!socket) {
        throw new Error("No socket was returned in the `connect()` function");
      }
      return socket;
    }
    get defaultPort() {
      return _nullishCoalesce(this[INTERNAL].defaultPort, () => this.protocol === "https:" ? 443 : 80);
    }
    set defaultPort(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].defaultPort = v;
      }
    }
    get protocol() {
      return _nullishCoalesce(this[INTERNAL].protocol, () => this.isSecureEndpoint() ? "https:" : "http:");
    }
    set protocol(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].protocol = v;
      }
    }
  }
  exports.Agent = Agent;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/proxy/parse-proxy-response.js
var require_parse_proxy_response = __commonJS((exports) => {
  var debug = function(...args) {
    utils.logger.log("[https-proxy-agent:parse-proxy-response]", ...args);
  };
  var parseProxyResponse = function(socket) {
    return new Promise((resolve, reject) => {
      let buffersLength = 0;
      const buffers = [];
      function read() {
        const b = socket.read();
        if (b)
          ondata(b);
        else
          socket.once("readable", read);
      }
      function cleanup() {
        socket.removeListener("end", onend);
        socket.removeListener("error", onerror);
        socket.removeListener("readable", read);
      }
      function onend() {
        cleanup();
        debug("onend");
        reject(new Error("Proxy connection ended before receiving CONNECT response"));
      }
      function onerror(err) {
        cleanup();
        debug("onerror %o", err);
        reject(err);
      }
      function ondata(b) {
        buffers.push(b);
        buffersLength += b.length;
        const buffered = Buffer.concat(buffers, buffersLength);
        const endOfHeaders = buffered.indexOf("\r\n\r\n");
        if (endOfHeaders === -1) {
          debug("have not received end of HTTP headers yet...");
          read();
          return;
        }
        const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
        const firstLine = headerParts.shift();
        if (!firstLine) {
          socket.destroy();
          return reject(new Error("No header received from proxy CONNECT response"));
        }
        const firstLineParts = firstLine.split(" ");
        const statusCode = +firstLineParts[1];
        const statusText = firstLineParts.slice(2).join(" ");
        const headers = {};
        for (const header of headerParts) {
          if (!header)
            continue;
          const firstColon = header.indexOf(":");
          if (firstColon === -1) {
            socket.destroy();
            return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
          }
          const key = header.slice(0, firstColon).toLowerCase();
          const value = header.slice(firstColon + 1).trimStart();
          const current = headers[key];
          if (typeof current === "string") {
            headers[key] = [current, value];
          } else if (Array.isArray(current)) {
            current.push(value);
          } else {
            headers[key] = value;
          }
        }
        debug("got proxy server response: %o %o", firstLine, headers);
        cleanup();
        resolve({
          connect: {
            statusCode,
            statusText,
            headers
          },
          buffered
        });
      }
      socket.on("error", onerror);
      socket.on("end", onend);
      read();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  exports.parseProxyResponse = parseProxyResponse;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/proxy/index.js
var require_proxy = __commonJS((exports) => {
  var debug = function(...args) {
    utils.logger.log("[https-proxy-agent]", ...args);
  };
  var resume = function(socket) {
    socket.resume();
  };
  var omit = function(obj, ...keys) {
    const ret2 = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret2[key] = obj[key];
      }
    }
    return ret2;
  };
  var {
    _nullishCoalesce,
    _optionalChain
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  var assert = __require("assert");
  var net = __require("net");
  var tls = __require("tls");
  var url = __require("url");
  var utils = require_cjs();
  var base = require_base2();
  var parseProxyResponse = require_parse_proxy_response();

  class HttpsProxyAgent extends base.Agent {
    static __initStatic() {
      this.protocols = ["http", "https"];
    }
    constructor(proxy, opts) {
      super(opts);
      this.options = {};
      this.proxy = typeof proxy === "string" ? new url.URL(proxy) : proxy;
      this.proxyHeaders = _nullishCoalesce(_optionalChain([opts, "optionalAccess", (_2) => _2.headers]), () => ({}));
      debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
      const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
      const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        ALPNProtocols: ["http/1.1"],
        ...opts ? omit(opts, "headers") : null,
        host,
        port
      };
    }
    async connect(req, opts) {
      const { proxy } = this;
      if (!opts.host) {
        throw new TypeError('No "host" provided');
      }
      let socket;
      if (proxy.protocol === "https:") {
        debug("Creating `tls.Socket`: %o", this.connectOpts);
        const servername = this.connectOpts.servername || this.connectOpts.host;
        socket = tls.connect({
          ...this.connectOpts,
          servername: servername && net.isIP(servername) ? undefined : servername
        });
      } else {
        debug("Creating `net.Socket`: %o", this.connectOpts);
        socket = net.connect(this.connectOpts);
      }
      const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
      const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
      let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r\n`;
      if (proxy.username || proxy.password) {
        const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
        headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
      }
      headers.Host = `${host}:${opts.port}`;
      if (!headers["Proxy-Connection"]) {
        headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
      }
      for (const name of Object.keys(headers)) {
        payload += `${name}: ${headers[name]}\r\n`;
      }
      const proxyResponsePromise = parseProxyResponse.parseProxyResponse(socket);
      socket.write(`${payload}\r\n`);
      const { connect, buffered } = await proxyResponsePromise;
      req.emit("proxyConnect", connect);
      this.emit("proxyConnect", connect, req);
      if (connect.statusCode === 200) {
        req.once("socket", resume);
        if (opts.secureEndpoint) {
          debug("Upgrading socket connection to TLS");
          const servername = opts.servername || opts.host;
          return tls.connect({
            ...omit(opts, "host", "path", "port"),
            socket,
            servername: net.isIP(servername) ? undefined : servername
          });
        }
        return socket;
      }
      socket.destroy();
      const fakeSocket = new net.Socket({ writable: false });
      fakeSocket.readable = true;
      req.once("socket", (s) => {
        debug("Replaying proxy buffer for failed request");
        assert.default(s.listenerCount("data") > 0);
        s.push(buffered);
        s.push(null);
      });
      return fakeSocket;
    }
  }
  HttpsProxyAgent.__initStatic();
  exports.HttpsProxyAgent = HttpsProxyAgent;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/transports/http.js
var require_http = __commonJS((exports) => {
  var streamFromBody = function(body) {
    return new stream.Readable({
      read() {
        this.push(body);
        this.push(null);
      }
    });
  };
  var makeNodeTransport = function(options) {
    let urlSegments;
    try {
      urlSegments = new url.URL(options.url);
    } catch (e) {
      utils.consoleSandbox(() => {
        console.warn("[@sentry/node]: Invalid dsn or tunnel option, will not send any events. The tunnel option must be a full URL when used.");
      });
      return core.createTransport(options, () => Promise.resolve({}));
    }
    const isHttps = urlSegments.protocol === "https:";
    const proxy = applyNoProxyOption(urlSegments, options.proxy || (isHttps ? process.env.https_proxy : undefined) || process.env.http_proxy);
    const nativeHttpModule = isHttps ? https : http;
    const keepAlive = options.keepAlive === undefined ? false : options.keepAlive;
    const agent = proxy ? new index.HttpsProxyAgent(proxy) : new nativeHttpModule.Agent({ keepAlive, maxSockets: 30, timeout: 2000 });
    const requestExecutor = createRequestExecutor(options, _nullishCoalesce(options.httpModule, () => nativeHttpModule), agent);
    return core.createTransport(options, requestExecutor);
  };
  var applyNoProxyOption = function(transportUrlSegments, proxy) {
    const { no_proxy } = process.env;
    const urlIsExemptFromProxy = no_proxy && no_proxy.split(",").some((exemption) => transportUrlSegments.host.endsWith(exemption) || transportUrlSegments.hostname.endsWith(exemption));
    if (urlIsExemptFromProxy) {
      return;
    } else {
      return proxy;
    }
  };
  var createRequestExecutor = function(options, httpModule, agent) {
    const { hostname, pathname, port, protocol, search } = new url.URL(options.url);
    return function makeRequest(request) {
      return new Promise((resolve, reject) => {
        let body = streamFromBody(request.body);
        const headers = { ...options.headers };
        if (request.body.length > GZIP_THRESHOLD) {
          headers["content-encoding"] = "gzip";
          body = body.pipe(zlib.createGzip());
        }
        const req = httpModule.request({
          method: "POST",
          agent,
          headers,
          hostname,
          path: `${pathname}${search}`,
          port,
          protocol,
          ca: options.caCerts
        }, (res) => {
          res.on("data", () => {
          });
          res.on("end", () => {
          });
          res.setEncoding("utf8");
          const retryAfterHeader = _nullishCoalesce(res.headers["retry-after"], () => null);
          const rateLimitsHeader = _nullishCoalesce(res.headers["x-sentry-rate-limits"], () => null);
          resolve({
            statusCode: res.statusCode,
            headers: {
              "retry-after": retryAfterHeader,
              "x-sentry-rate-limits": Array.isArray(rateLimitsHeader) ? rateLimitsHeader[0] : rateLimitsHeader
            }
          });
        });
        req.on("error", reject);
        body.pipe(req);
      });
    };
  };
  var {
    _nullishCoalesce
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  var http = __require("http");
  var https = __require("https");
  var stream = __require("stream");
  var url = __require("url");
  var zlib = __require("zlib");
  var core = require_cjs2();
  var utils = require_cjs();
  var index = require_proxy();
  var GZIP_THRESHOLD = 1024 * 32;
  exports.makeNodeTransport = makeNodeTransport;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/nodeVersion.js
var require_nodeVersion = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  var NODE_VERSION = utils.parseSemver(process.versions.node);
  exports.NODE_VERSION = NODE_VERSION;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/async/domain.js
var require_domain = __commonJS((exports) => {
  var getActiveDomain = function() {
    return domain.active;
  };
  var getCurrentHub = function() {
    const activeDomain = getActiveDomain();
    if (!activeDomain) {
      return;
    }
    core.ensureHubOnCarrier(activeDomain);
    return core.getHubFromCarrier(activeDomain);
  };
  var createNewHub = function(parent) {
    const carrier = {};
    core.ensureHubOnCarrier(carrier, parent);
    return core.getHubFromCarrier(carrier);
  };
  var runWithAsyncContext = function(callback, options) {
    const activeDomain = getActiveDomain();
    if (activeDomain && _optionalChain([options, "optionalAccess", (_) => _.reuseExisting])) {
      return callback();
    }
    const local = domain.create();
    const parentHub = activeDomain ? core.getHubFromCarrier(activeDomain) : undefined;
    const newHub = createNewHub(parentHub);
    core.setHubOnCarrier(local, newHub);
    return local.bind(() => {
      return callback();
    })();
  };
  var setDomainAsyncContextStrategy = function() {
    core.setAsyncContextStrategy({ getCurrentHub, runWithAsyncContext });
  };
  var {
    _optionalChain
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  var domain = __require("domain");
  var core = require_cjs2();
  exports.setDomainAsyncContextStrategy = setDomainAsyncContextStrategy;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/async/hooks.js
var require_hooks = __commonJS((exports) => {
  var setHooksAsyncContextStrategy = function() {
    if (!asyncStorage) {
      asyncStorage = new async_hooks.AsyncLocalStorage;
    }
    function getCurrentHub() {
      return asyncStorage.getStore();
    }
    function createNewHub(parent) {
      const carrier = {};
      core.ensureHubOnCarrier(carrier, parent);
      return core.getHubFromCarrier(carrier);
    }
    function runWithAsyncContext(callback, options) {
      const existingHub = getCurrentHub();
      if (existingHub && _optionalChain([options, "optionalAccess", (_) => _.reuseExisting])) {
        return callback();
      }
      const newHub = createNewHub(existingHub);
      return asyncStorage.run(newHub, () => {
        return callback();
      });
    }
    core.setAsyncContextStrategy({ getCurrentHub, runWithAsyncContext });
  };
  var {
    _optionalChain
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var async_hooks = __require("async_hooks");
  var asyncStorage;
  exports.setHooksAsyncContextStrategy = setHooksAsyncContextStrategy;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/async/index.js
var require_async = __commonJS((exports) => {
  var setNodeAsyncContextStrategy = function() {
    if (nodeVersion.NODE_VERSION.major >= 14) {
      hooks.setHooksAsyncContextStrategy();
    } else {
      domain.setDomainAsyncContextStrategy();
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var nodeVersion = require_nodeVersion();
  var domain = require_domain();
  var hooks = require_hooks();
  exports.setNodeAsyncContextStrategy = setNodeAsyncContextStrategy;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/integrations/console.js
var require_console2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util = __require("util");
  var core = require_cjs2();
  var utils = require_cjs();
  var INTEGRATION_NAME = "Console";
  var _consoleIntegration = () => {
    return {
      name: INTEGRATION_NAME,
      setupOnce() {
      },
      setup(client) {
        utils.addConsoleInstrumentationHandler(({ args, level }) => {
          if (core.getClient() !== client) {
            return;
          }
          core.addBreadcrumb({
            category: "console",
            level: utils.severityLevelFromString(level),
            message: util.format.apply(undefined, args)
          }, {
            input: [...args],
            level
          });
        });
      }
    };
  };
  var consoleIntegration = core.defineIntegration(_consoleIntegration);
  var Console = core.convertIntegrationFnToClass(INTEGRATION_NAME, consoleIntegration);
  exports.Console = Console;
  exports.consoleIntegration = consoleIntegration;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/integrations/context.js
var require_context = __commonJS((exports) => {
  var _updateContext = function(contexts) {
    if (_optionalChain([contexts, "optionalAccess", (_11) => _11.app, "optionalAccess", (_12) => _12.app_memory])) {
      contexts.app.app_memory = process.memoryUsage().rss;
    }
    if (_optionalChain([contexts, "optionalAccess", (_13) => _13.device, "optionalAccess", (_14) => _14.free_memory])) {
      contexts.device.free_memory = os.freemem();
    }
    return contexts;
  };
  async function getOsContext() {
    const platformId = os.platform();
    switch (platformId) {
      case "darwin":
        return getDarwinInfo();
      case "linux":
        return getLinuxInfo();
      default:
        return {
          name: PLATFORM_NAMES[platformId] || platformId,
          version: os.release()
        };
    }
  }
  var getCultureContext = function() {
    try {
      if (typeof process.versions.icu !== "string") {
        return;
      }
      const january = new Date(900000000);
      const spanish = new Intl.DateTimeFormat("es", { month: "long" });
      if (spanish.format(january) === "enero") {
        const options = Intl.DateTimeFormat().resolvedOptions();
        return {
          locale: options.locale,
          timezone: options.timeZone
        };
      }
    } catch (err) {
    }
    return;
  };
  var getAppContext = function() {
    const app_memory = process.memoryUsage().rss;
    const app_start_time = new Date(Date.now() - process.uptime() * 1000).toISOString();
    return { app_start_time, app_memory };
  };
  var getDeviceContext = function(deviceOpt) {
    const device = {};
    let uptime;
    try {
      uptime = os.uptime && os.uptime();
    } catch (e) {
    }
    if (typeof uptime === "number") {
      device.boot_time = new Date(Date.now() - uptime * 1000).toISOString();
    }
    device.arch = os.arch();
    if (deviceOpt === true || deviceOpt.memory) {
      device.memory_size = os.totalmem();
      device.free_memory = os.freemem();
    }
    if (deviceOpt === true || deviceOpt.cpu) {
      const cpuInfo = os.cpus();
      if (cpuInfo && cpuInfo.length) {
        const firstCpu = cpuInfo[0];
        device.processor_count = cpuInfo.length;
        device.cpu_description = firstCpu.model;
        device.processor_frequency = firstCpu.speed;
      }
    }
    return device;
  };
  var matchFirst = function(regex, text) {
    const match = regex.exec(text);
    return match ? match[1] : undefined;
  };
  async function getDarwinInfo() {
    const darwinInfo = {
      kernel_version: os.release(),
      name: "Mac OS X",
      version: `10.${Number(os.release().split(".")[0]) - 4}`
    };
    try {
      const output = await new Promise((resolve, reject) => {
        child_process.execFile("/usr/bin/sw_vers", (error, stdout) => {
          if (error) {
            reject(error);
            return;
          }
          resolve(stdout);
        });
      });
      darwinInfo.name = matchFirst(/^ProductName:\s+(.*)$/m, output);
      darwinInfo.version = matchFirst(/^ProductVersion:\s+(.*)$/m, output);
      darwinInfo.build = matchFirst(/^BuildVersion:\s+(.*)$/m, output);
    } catch (e) {
    }
    return darwinInfo;
  }
  var getLinuxDistroId = function(name) {
    return name.split(" ")[0].toLowerCase();
  };
  async function getLinuxInfo() {
    const linuxInfo = {
      kernel_version: os.release(),
      name: "Linux"
    };
    try {
      const etcFiles = await readDirAsync("/etc");
      const distroFile = LINUX_DISTROS.find((file) => etcFiles.includes(file.name));
      if (!distroFile) {
        return linuxInfo;
      }
      const distroPath = path.join("/etc", distroFile.name);
      const contents = (await readFileAsync(distroPath, { encoding: "utf-8" })).toLowerCase();
      const { distros } = distroFile;
      linuxInfo.name = distros.find((d) => contents.indexOf(getLinuxDistroId(d)) >= 0) || distros[0];
      const id = getLinuxDistroId(linuxInfo.name);
      linuxInfo.version = LINUX_VERSIONS[id](contents);
    } catch (e) {
    }
    return linuxInfo;
  }
  var getCloudResourceContext = function() {
    if (process.env.VERCEL) {
      return {
        "cloud.provider": "vercel",
        "cloud.region": process.env.VERCEL_REGION
      };
    } else if (process.env.AWS_REGION) {
      return {
        "cloud.provider": "aws",
        "cloud.region": process.env.AWS_REGION,
        "cloud.platform": process.env.AWS_EXECUTION_ENV
      };
    } else if (process.env.GCP_PROJECT) {
      return {
        "cloud.provider": "gcp"
      };
    } else if (process.env.ALIYUN_REGION_ID) {
      return {
        "cloud.provider": "alibaba_cloud",
        "cloud.region": process.env.ALIYUN_REGION_ID
      };
    } else if (process.env.WEBSITE_SITE_NAME && process.env.REGION_NAME) {
      return {
        "cloud.provider": "azure",
        "cloud.region": process.env.REGION_NAME
      };
    } else if (process.env.IBM_CLOUD_REGION) {
      return {
        "cloud.provider": "ibm_cloud",
        "cloud.region": process.env.IBM_CLOUD_REGION
      };
    } else if (process.env.TENCENTCLOUD_REGION) {
      return {
        "cloud.provider": "tencent_cloud",
        "cloud.region": process.env.TENCENTCLOUD_REGION,
        "cloud.account.id": process.env.TENCENTCLOUD_APPID,
        "cloud.availability_zone": process.env.TENCENTCLOUD_ZONE
      };
    } else if (process.env.NETLIFY) {
      return {
        "cloud.provider": "netlify"
      };
    } else if (process.env.FLY_REGION) {
      return {
        "cloud.provider": "fly.io",
        "cloud.region": process.env.FLY_REGION
      };
    } else if (process.env.DYNO) {
      return {
        "cloud.provider": "heroku"
      };
    } else {
      return;
    }
  };
  var {
    _optionalChain
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  var child_process = __require("child_process");
  var fs = __require("fs");
  var os = __require("os");
  var path = __require("path");
  var util = __require("util");
  var core = require_cjs2();
  var readFileAsync = util.promisify(fs.readFile);
  var readDirAsync = util.promisify(fs.readdir);
  var INTEGRATION_NAME = "Context";
  var _nodeContextIntegration = (options = {}) => {
    let cachedContext;
    const _options = {
      app: true,
      os: true,
      device: true,
      culture: true,
      cloudResource: true,
      ...options
    };
    async function addContext(event) {
      if (cachedContext === undefined) {
        cachedContext = _getContexts();
      }
      const updatedContext = _updateContext(await cachedContext);
      event.contexts = {
        ...event.contexts,
        app: { ...updatedContext.app, ..._optionalChain([event, "access", (_) => _.contexts, "optionalAccess", (_2) => _2.app]) },
        os: { ...updatedContext.os, ..._optionalChain([event, "access", (_3) => _3.contexts, "optionalAccess", (_4) => _4.os]) },
        device: { ...updatedContext.device, ..._optionalChain([event, "access", (_5) => _5.contexts, "optionalAccess", (_6) => _6.device]) },
        culture: { ...updatedContext.culture, ..._optionalChain([event, "access", (_7) => _7.contexts, "optionalAccess", (_8) => _8.culture]) },
        cloud_resource: { ...updatedContext.cloud_resource, ..._optionalChain([event, "access", (_9) => _9.contexts, "optionalAccess", (_10) => _10.cloud_resource]) }
      };
      return event;
    }
    async function _getContexts() {
      const contexts = {};
      if (_options.os) {
        contexts.os = await getOsContext();
      }
      if (_options.app) {
        contexts.app = getAppContext();
      }
      if (_options.device) {
        contexts.device = getDeviceContext(_options.device);
      }
      if (_options.culture) {
        const culture = getCultureContext();
        if (culture) {
          contexts.culture = culture;
        }
      }
      if (_options.cloudResource) {
        contexts.cloud_resource = getCloudResourceContext();
      }
      return contexts;
    }
    return {
      name: INTEGRATION_NAME,
      setupOnce() {
      },
      processEvent(event) {
        return addContext(event);
      }
    };
  };
  var nodeContextIntegration = core.defineIntegration(_nodeContextIntegration);
  var Context = core.convertIntegrationFnToClass(INTEGRATION_NAME, nodeContextIntegration);
  var PLATFORM_NAMES = {
    aix: "IBM AIX",
    freebsd: "FreeBSD",
    openbsd: "OpenBSD",
    sunos: "SunOS",
    win32: "Windows"
  };
  var LINUX_DISTROS = [
    { name: "fedora-release", distros: ["Fedora"] },
    { name: "redhat-release", distros: ["Red Hat Linux", "Centos"] },
    { name: "redhat_version", distros: ["Red Hat Linux"] },
    { name: "SuSE-release", distros: ["SUSE Linux"] },
    { name: "lsb-release", distros: ["Ubuntu Linux", "Arch Linux"] },
    { name: "debian_version", distros: ["Debian"] },
    { name: "debian_release", distros: ["Debian"] },
    { name: "arch-release", distros: ["Arch Linux"] },
    { name: "gentoo-release", distros: ["Gentoo Linux"] },
    { name: "novell-release", distros: ["SUSE Linux"] },
    { name: "alpine-release", distros: ["Alpine Linux"] }
  ];
  var LINUX_VERSIONS = {
    alpine: (content) => content,
    arch: (content) => matchFirst(/distrib_release=(.*)/, content),
    centos: (content) => matchFirst(/release ([^ ]+)/, content),
    debian: (content) => content,
    fedora: (content) => matchFirst(/release (..)/, content),
    mint: (content) => matchFirst(/distrib_release=(.*)/, content),
    red: (content) => matchFirst(/release ([^ ]+)/, content),
    suse: (content) => matchFirst(/VERSION = (.*)\n/, content),
    ubuntu: (content) => matchFirst(/distrib_release=(.*)/, content)
  };
  exports.Context = Context;
  exports.getDeviceContext = getDeviceContext;
  exports.nodeContextIntegration = nodeContextIntegration;
  exports.readDirAsync = readDirAsync;
  exports.readFileAsync = readFileAsync;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/integrations/contextlines.js
var require_contextlines = __commonJS((exports) => {
  var readTextFileAsync = function(path) {
    return new Promise((resolve, reject) => {
      fs.readFile(path, "utf8", (err, data) => {
        if (err)
          reject(err);
        else
          resolve(data);
      });
    });
  };
  async function addSourceContext(event, contextLines) {
    const enqueuedReadSourceFileTasks = {};
    const readSourceFileTasks = [];
    if (contextLines > 0 && _optionalChain([event, "access", (_2) => _2.exception, "optionalAccess", (_3) => _3.values])) {
      for (const exception of event.exception.values) {
        if (!_optionalChain([exception, "access", (_4) => _4.stacktrace, "optionalAccess", (_5) => _5.frames])) {
          continue;
        }
        for (let i = exception.stacktrace.frames.length - 1;i >= 0; i--) {
          const frame = exception.stacktrace.frames[i];
          if (frame.filename && !enqueuedReadSourceFileTasks[frame.filename] && !FILE_CONTENT_CACHE.get(frame.filename)) {
            readSourceFileTasks.push(_readSourceFile(frame.filename));
            enqueuedReadSourceFileTasks[frame.filename] = 1;
          }
        }
      }
    }
    if (readSourceFileTasks.length > 0) {
      await Promise.all(readSourceFileTasks);
    }
    if (contextLines > 0 && _optionalChain([event, "access", (_6) => _6.exception, "optionalAccess", (_7) => _7.values])) {
      for (const exception of event.exception.values) {
        if (exception.stacktrace && exception.stacktrace.frames) {
          await addSourceContextToFrames(exception.stacktrace.frames, contextLines);
        }
      }
    }
    return event;
  }
  var addSourceContextToFrames = function(frames, contextLines) {
    for (const frame of frames) {
      if (frame.filename && frame.context_line === undefined) {
        const sourceFileLines = FILE_CONTENT_CACHE.get(frame.filename);
        if (sourceFileLines) {
          try {
            utils.addContextToFrame(sourceFileLines, frame, contextLines);
          } catch (e) {
          }
        }
      }
    }
  };
  async function _readSourceFile(filename) {
    const cachedFile = FILE_CONTENT_CACHE.get(filename);
    if (cachedFile === null) {
      return null;
    }
    if (cachedFile !== undefined) {
      return cachedFile;
    }
    let content = null;
    try {
      const rawFileContents = await readTextFileAsync(filename);
      content = rawFileContents.split("\n");
    } catch (_) {
    }
    FILE_CONTENT_CACHE.set(filename, content);
    return content;
  }
  var {
    _optionalChain
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  var fs = __require("fs");
  var core = require_cjs2();
  var utils = require_cjs();
  var FILE_CONTENT_CACHE = new utils.LRUMap(100);
  var DEFAULT_LINES_OF_CONTEXT = 7;
  var INTEGRATION_NAME = "ContextLines";
  var _contextLinesIntegration = (options = {}) => {
    const contextLines = options.frameContextLines !== undefined ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;
    return {
      name: INTEGRATION_NAME,
      setupOnce() {
      },
      processEvent(event) {
        return addSourceContext(event, contextLines);
      }
    };
  };
  var contextLinesIntegration = core.defineIntegration(_contextLinesIntegration);
  var ContextLines = core.convertIntegrationFnToClass(INTEGRATION_NAME, contextLinesIntegration);
  exports.ContextLines = ContextLines;
  exports.contextLinesIntegration = contextLinesIntegration;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/debug-build.js
var require_debug_build4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
  exports.DEBUG_BUILD = DEBUG_BUILD;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/integrations/utils/http.js
var require_http2 = __commonJS((exports) => {
  var extractRawUrl = function(requestOptions) {
    const { protocol, hostname, port } = parseRequestOptions(requestOptions);
    const path = requestOptions.path ? requestOptions.path : "/";
    return `${protocol}//${hostname}${port}${path}`;
  };
  var extractUrl = function(requestOptions) {
    const { protocol, hostname, port } = parseRequestOptions(requestOptions);
    const path = requestOptions.pathname || "/";
    const authority = requestOptions.auth ? redactAuthority(requestOptions.auth) : "";
    return `${protocol}//${authority}${hostname}${port}${path}`;
  };
  var redactAuthority = function(auth) {
    const [user, password] = auth.split(":");
    return `${user ? "[Filtered]" : ""}:${password ? "[Filtered]" : ""}@`;
  };
  var cleanSpanDescription = function(description, requestOptions, request) {
    if (!description) {
      return description;
    }
    let [method, requestUrl] = description.split(" ");
    if (requestOptions.host && !requestOptions.protocol) {
      requestOptions.protocol = _optionalChain([request, "optionalAccess", (_) => _.agent, "optionalAccess", (_2) => _2.protocol]);
      requestUrl = extractUrl(requestOptions);
    }
    if (_optionalChain([requestUrl, "optionalAccess", (_3) => _3.startsWith, "call", (_4) => _4("///")])) {
      requestUrl = requestUrl.slice(2);
    }
    return `${method} ${requestUrl}`;
  };
  var urlToOptions = function(url2) {
    const options = {
      protocol: url2.protocol,
      hostname: typeof url2.hostname === "string" && url2.hostname.startsWith("[") ? url2.hostname.slice(1, -1) : url2.hostname,
      hash: url2.hash,
      search: url2.search,
      pathname: url2.pathname,
      path: `${url2.pathname || ""}${url2.search || ""}`,
      href: url2.href
    };
    if (url2.port !== "") {
      options.port = Number(url2.port);
    }
    if (url2.username || url2.password) {
      options.auth = `${url2.username}:${url2.password}`;
    }
    return options;
  };
  var normalizeRequestArgs = function(httpModule, requestArgs) {
    let callback, requestOptions;
    if (typeof requestArgs[requestArgs.length - 1] === "function") {
      callback = requestArgs.pop();
    }
    if (typeof requestArgs[0] === "string") {
      requestOptions = urlToOptions(new url.URL(requestArgs[0]));
    } else if (requestArgs[0] instanceof url.URL) {
      requestOptions = urlToOptions(requestArgs[0]);
    } else {
      requestOptions = requestArgs[0];
      try {
        const parsed = new url.URL(requestOptions.path || "", `${requestOptions.protocol || "http:"}//${requestOptions.hostname}`);
        requestOptions = {
          pathname: parsed.pathname,
          search: parsed.search,
          hash: parsed.hash,
          ...requestOptions
        };
      } catch (e) {
      }
    }
    if (requestArgs.length === 2) {
      requestOptions = { ...requestOptions, ...requestArgs[1] };
    }
    if (requestOptions.protocol === undefined) {
      if (nodeVersion.NODE_VERSION.major > 8) {
        requestOptions.protocol = _optionalChain([_optionalChain([httpModule, "optionalAccess", (_5) => _5.globalAgent]), "optionalAccess", (_6) => _6.protocol]) || _optionalChain([requestOptions.agent, "optionalAccess", (_7) => _7.protocol]) || _optionalChain([requestOptions._defaultAgent, "optionalAccess", (_8) => _8.protocol]);
      } else {
        requestOptions.protocol = _optionalChain([requestOptions.agent, "optionalAccess", (_9) => _9.protocol]) || _optionalChain([requestOptions._defaultAgent, "optionalAccess", (_10) => _10.protocol]) || _optionalChain([_optionalChain([httpModule, "optionalAccess", (_11) => _11.globalAgent]), "optionalAccess", (_12) => _12.protocol]);
      }
    }
    if (callback) {
      return [requestOptions, callback];
    } else {
      return [requestOptions];
    }
  };
  var parseRequestOptions = function(requestOptions) {
    const protocol = requestOptions.protocol || "";
    const hostname = requestOptions.hostname || requestOptions.host || "";
    const port = !requestOptions.port || requestOptions.port === 80 || requestOptions.port === 443 || /^(.*):(\d+)$/.test(hostname) ? "" : `:${requestOptions.port}`;
    return { protocol, hostname, port };
  };
  var {
    _optionalChain
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  var url = __require("url");
  var nodeVersion = require_nodeVersion();
  exports.cleanSpanDescription = cleanSpanDescription;
  exports.extractRawUrl = extractRawUrl;
  exports.extractUrl = extractUrl;
  exports.normalizeRequestArgs = normalizeRequestArgs;
  exports.urlToOptions = urlToOptions;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/integrations/http.js
var require_http3 = __commonJS((exports) => {
  var _createWrappedRequestMethodFactory = function(httpModule, breadcrumbsEnabled, shouldCreateSpanForRequest, tracePropagationTargets) {
    const createSpanUrlMap = new utils.LRUMap(100);
    const headersUrlMap = new utils.LRUMap(100);
    const shouldCreateSpan = (url) => {
      if (shouldCreateSpanForRequest === undefined) {
        return true;
      }
      const cachedDecision = createSpanUrlMap.get(url);
      if (cachedDecision !== undefined) {
        return cachedDecision;
      }
      const decision = shouldCreateSpanForRequest(url);
      createSpanUrlMap.set(url, decision);
      return decision;
    };
    const shouldAttachTraceData = (url) => {
      if (tracePropagationTargets === undefined) {
        return true;
      }
      const cachedDecision = headersUrlMap.get(url);
      if (cachedDecision !== undefined) {
        return cachedDecision;
      }
      const decision = utils.stringMatchesSomePattern(url, tracePropagationTargets);
      headersUrlMap.set(url, decision);
      return decision;
    };
    function addRequestBreadcrumb(event, requestSpanData, req, res) {
      if (!core.getCurrentHub().getIntegration(Http)) {
        return;
      }
      core.addBreadcrumb({
        category: "http",
        data: {
          status_code: res && res.statusCode,
          ...requestSpanData
        },
        type: "http"
      }, {
        event,
        request: req,
        response: res
      });
    }
    return function wrappedRequestMethodFactory(originalRequestMethod) {
      return function wrappedMethod(...args) {
        const requestArgs = http.normalizeRequestArgs(httpModule, args);
        const requestOptions = requestArgs[0];
        const rawRequestUrl = http.extractRawUrl(requestOptions);
        const requestUrl = http.extractUrl(requestOptions);
        const client = core.getClient();
        if (core.isSentryRequestUrl(requestUrl, client)) {
          return originalRequestMethod.apply(httpModule, requestArgs);
        }
        const scope = core.getCurrentScope();
        const isolationScope = core.getIsolationScope();
        const parentSpan = core.getActiveSpan();
        const data = getRequestSpanData(requestUrl, requestOptions);
        const requestSpan = shouldCreateSpan(rawRequestUrl) ? _optionalChain([parentSpan, "optionalAccess", (_9) => _9.startChild, "call", (_10) => _10({
          op: "http.client",
          origin: "auto.http.node.http",
          description: `${data["http.method"]} ${data.url}`,
          data
        })]) : undefined;
        if (client && shouldAttachTraceData(rawRequestUrl)) {
          const { traceId, spanId, sampled, dsc } = {
            ...isolationScope.getPropagationContext(),
            ...scope.getPropagationContext()
          };
          const sentryTraceHeader = requestSpan ? core.spanToTraceHeader(requestSpan) : utils.generateSentryTraceHeader(traceId, spanId, sampled);
          const sentryBaggageHeader = utils.dynamicSamplingContextToSentryBaggageHeader(dsc || (requestSpan ? core.getDynamicSamplingContextFromSpan(requestSpan) : core.getDynamicSamplingContextFromClient(traceId, client, scope)));
          addHeadersToRequestOptions(requestOptions, requestUrl, sentryTraceHeader, sentryBaggageHeader);
        } else {
          debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Not adding sentry-trace header to outgoing request (${requestUrl}) due to mismatching tracePropagationTargets option.`);
        }
        return originalRequestMethod.apply(httpModule, requestArgs).once("response", function(res) {
          const req = this;
          if (breadcrumbsEnabled) {
            addRequestBreadcrumb("response", data, req, res);
          }
          if (requestSpan) {
            if (res.statusCode) {
              core.setHttpStatus(requestSpan, res.statusCode);
            }
            requestSpan.updateName(http.cleanSpanDescription(core.spanToJSON(requestSpan).description || "", requestOptions, req) || "");
            requestSpan.end();
          }
        }).once("error", function() {
          const req = this;
          if (breadcrumbsEnabled) {
            addRequestBreadcrumb("error", data, req);
          }
          if (requestSpan) {
            core.setHttpStatus(requestSpan, 500);
            requestSpan.updateName(http.cleanSpanDescription(core.spanToJSON(requestSpan).description || "", requestOptions, req) || "");
            requestSpan.end();
          }
        });
      };
    };
  };
  var addHeadersToRequestOptions = function(requestOptions, requestUrl, sentryTraceHeader, sentryBaggageHeader) {
    const headers = requestOptions.headers || {};
    if (headers["sentry-trace"]) {
      return;
    }
    debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Adding sentry-trace header ${sentryTraceHeader} to outgoing request to "${requestUrl}": `);
    requestOptions.headers = {
      ...requestOptions.headers,
      "sentry-trace": sentryTraceHeader,
      ...sentryBaggageHeader && sentryBaggageHeader.length > 0 && { baggage: normalizeBaggageHeader(requestOptions, sentryBaggageHeader) }
    };
  };
  var getRequestSpanData = function(requestUrl, requestOptions) {
    const method = requestOptions.method || "GET";
    const data = {
      url: requestUrl,
      "http.method": method
    };
    if (requestOptions.hash) {
      data["http.fragment"] = requestOptions.hash.substring(1);
    }
    if (requestOptions.search) {
      data["http.query"] = requestOptions.search.substring(1);
    }
    return data;
  };
  var normalizeBaggageHeader = function(requestOptions, sentryBaggageHeader) {
    if (!requestOptions.headers || !requestOptions.headers.baggage) {
      return sentryBaggageHeader;
    } else if (!sentryBaggageHeader) {
      return requestOptions.headers.baggage;
    } else if (Array.isArray(requestOptions.headers.baggage)) {
      return [...requestOptions.headers.baggage, sentryBaggageHeader];
    }
    return [requestOptions.headers.baggage, sentryBaggageHeader];
  };
  var _shouldCreateSpans = function(tracingOptions, clientOptions) {
    return tracingOptions === undefined ? false : tracingOptions.enableIfHasTracingEnabled ? core.hasTracingEnabled(clientOptions) : true;
  };
  var _getShouldCreateSpanForRequest = function(shouldCreateSpans, tracingOptions, clientOptions) {
    const handler = shouldCreateSpans ? _optionalChain([tracingOptions, "optionalAccess", (_11) => _11.shouldCreateSpanForRequest]) || _optionalChain([clientOptions, "optionalAccess", (_12) => _12.shouldCreateSpanForRequest]) : () => false;
    return handler;
  };
  var {
    _optionalChain
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var utils = require_cjs();
  var debugBuild = require_debug_build4();
  var nodeVersion = require_nodeVersion();
  var http = require_http2();
  var _httpIntegration = (options = {}) => {
    const { breadcrumbs, tracing, shouldCreateSpanForRequest } = options;
    const convertedOptions = {
      breadcrumbs,
      tracing: tracing === false ? false : utils.dropUndefinedKeys({
        enableIfHasTracingEnabled: tracing === true ? undefined : true,
        shouldCreateSpanForRequest
      })
    };
    return new Http(convertedOptions);
  };
  var httpIntegration = core.defineIntegration(_httpIntegration);

  class Http {
    static __initStatic() {
      this.id = "Http";
    }
    __init() {
      this.name = Http.id;
    }
    constructor(options = {}) {
      Http.prototype.__init.call(this);
      this._breadcrumbs = typeof options.breadcrumbs === "undefined" ? true : options.breadcrumbs;
      this._tracing = !options.tracing ? undefined : options.tracing === true ? {} : options.tracing;
    }
    setupOnce(_addGlobalEventProcessor, setupOnceGetCurrentHub) {
      const clientOptions = _optionalChain([setupOnceGetCurrentHub, "call", (_) => _(), "access", (_2) => _2.getClient, "call", (_3) => _3(), "optionalAccess", (_4) => _4.getOptions, "call", (_5) => _5()]);
      const shouldCreateSpans = _shouldCreateSpans(this._tracing, clientOptions);
      if (!this._breadcrumbs && !shouldCreateSpans) {
        return;
      }
      if (clientOptions && clientOptions.instrumenter !== "sentry") {
        debugBuild.DEBUG_BUILD && utils.logger.log("HTTP Integration is skipped because of instrumenter configuration.");
        return;
      }
      const shouldCreateSpanForRequest = _getShouldCreateSpanForRequest(shouldCreateSpans, this._tracing, clientOptions);
      const tracePropagationTargets = _optionalChain([clientOptions, "optionalAccess", (_6) => _6.tracePropagationTargets]) || _optionalChain([this, "access", (_7) => _7._tracing, "optionalAccess", (_8) => _8.tracePropagationTargets]);
      const httpModule = __require("http");
      const wrappedHttpHandlerMaker = _createWrappedRequestMethodFactory(httpModule, this._breadcrumbs, shouldCreateSpanForRequest, tracePropagationTargets);
      utils.fill(httpModule, "get", wrappedHttpHandlerMaker);
      utils.fill(httpModule, "request", wrappedHttpHandlerMaker);
      if (nodeVersion.NODE_VERSION.major > 8) {
        const httpsModule = __require("https");
        const wrappedHttpsHandlerMaker = _createWrappedRequestMethodFactory(httpsModule, this._breadcrumbs, shouldCreateSpanForRequest, tracePropagationTargets);
        utils.fill(httpsModule, "get", wrappedHttpsHandlerMaker);
        utils.fill(httpsModule, "request", wrappedHttpsHandlerMaker);
      }
    }
  }
  Http.__initStatic();
  exports.Http = Http;
  exports._getShouldCreateSpanForRequest = _getShouldCreateSpanForRequest;
  exports._shouldCreateSpans = _shouldCreateSpans;
  exports.httpIntegration = httpIntegration;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/integrations/local-variables/common.js
var require_common = __commonJS((exports) => {
  var createRateLimiter = function(maxPerSecond, enable, disable) {
    let count = 0;
    let retrySeconds = 5;
    let disabledTimeout = 0;
    setInterval(() => {
      if (disabledTimeout === 0) {
        if (count > maxPerSecond) {
          retrySeconds *= 2;
          disable(retrySeconds);
          if (retrySeconds > 86400) {
            retrySeconds = 86400;
          }
          disabledTimeout = retrySeconds;
        }
      } else {
        disabledTimeout -= 1;
        if (disabledTimeout === 0) {
          enable();
        }
      }
      count = 0;
    }, 1000).unref();
    return () => {
      count += 1;
    };
  };
  var isAnonymous = function(name) {
    return name !== undefined && (name.length === 0 || name === "?" || name === "<anonymous>");
  };
  var functionNamesMatch = function(a, b) {
    return a === b || isAnonymous(a) && isAnonymous(b);
  };
  var hashFrames = function(frames) {
    if (frames === undefined) {
      return;
    }
    return frames.slice(-10).reduce((acc, frame) => `${acc},${frame.function},${frame.lineno},${frame.colno}`, "");
  };
  var hashFromStack = function(stackParser, stack) {
    if (stack === undefined) {
      return;
    }
    return hashFrames(stackParser(stack, 1));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createRateLimiter = createRateLimiter;
  exports.functionNamesMatch = functionNamesMatch;
  exports.hashFrames = hashFrames;
  exports.hashFromStack = hashFromStack;
  exports.isAnonymous = isAnonymous;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/integrations/local-variables/local-variables-sync.js
var require_local_variables_sync = __commonJS((exports) => {
  var createCallbackList = function(complete) {
    let callbacks = [];
    let completedCalled = false;
    function checkedComplete(result) {
      callbacks = [];
      if (completedCalled) {
        return;
      }
      completedCalled = true;
      complete(result);
    }
    callbacks.push(checkedComplete);
    function add(fn) {
      callbacks.push(fn);
    }
    function next(result) {
      const popped = callbacks.pop() || checkedComplete;
      try {
        popped(result);
      } catch (_) {
        checkedComplete(result);
      }
    }
    return { add, next };
  };
  var tryNewAsyncSession = function() {
    try {
      return new AsyncSession;
    } catch (e) {
      return;
    }
  };
  var {
    _optionalChain
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var utils = require_cjs();
  var nodeVersion = require_nodeVersion();
  var common = require_common();

  class AsyncSession {
    constructor() {
      const { Session } = __require("inspector");
      this._session = new Session;
    }
    configureAndConnect(onPause, captureAll) {
      this._session.connect();
      this._session.on("Debugger.paused", (event) => {
        onPause(event, () => {
          this._session.post("Debugger.resume");
        });
      });
      this._session.post("Debugger.enable");
      this._session.post("Debugger.setPauseOnExceptions", { state: captureAll ? "all" : "uncaught" });
    }
    setPauseOnExceptions(captureAll) {
      this._session.post("Debugger.setPauseOnExceptions", { state: captureAll ? "all" : "uncaught" });
    }
    getLocalVariables(objectId, complete) {
      this._getProperties(objectId, (props) => {
        const { add, next } = createCallbackList(complete);
        for (const prop of props) {
          if (_optionalChain([prop, "optionalAccess", (_2) => _2.value, "optionalAccess", (_3) => _3.objectId]) && _optionalChain([prop, "optionalAccess", (_4) => _4.value, "access", (_5) => _5.className]) === "Array") {
            const id = prop.value.objectId;
            add((vars) => this._unrollArray(id, prop.name, vars, next));
          } else if (_optionalChain([prop, "optionalAccess", (_6) => _6.value, "optionalAccess", (_7) => _7.objectId]) && _optionalChain([prop, "optionalAccess", (_8) => _8.value, "optionalAccess", (_9) => _9.className]) === "Object") {
            const id = prop.value.objectId;
            add((vars) => this._unrollObject(id, prop.name, vars, next));
          } else if (_optionalChain([prop, "optionalAccess", (_10) => _10.value, "optionalAccess", (_11) => _11.value]) || _optionalChain([prop, "optionalAccess", (_12) => _12.value, "optionalAccess", (_13) => _13.description])) {
            add((vars) => this._unrollOther(prop, vars, next));
          }
        }
        next({});
      });
    }
    _getProperties(objectId, next) {
      this._session.post("Runtime.getProperties", {
        objectId,
        ownProperties: true
      }, (err, params) => {
        if (err) {
          next([]);
        } else {
          next(params.result);
        }
      });
    }
    _unrollArray(objectId, name, vars, next) {
      this._getProperties(objectId, (props) => {
        vars[name] = props.filter((v) => v.name !== "length" && !isNaN(parseInt(v.name, 10))).sort((a, b) => parseInt(a.name, 10) - parseInt(b.name, 10)).map((v) => _optionalChain([v, "optionalAccess", (_14) => _14.value, "optionalAccess", (_15) => _15.value]));
        next(vars);
      });
    }
    _unrollObject(objectId, name, vars, next) {
      this._getProperties(objectId, (props) => {
        vars[name] = props.map((v) => [v.name, _optionalChain([v, "optionalAccess", (_16) => _16.value, "optionalAccess", (_17) => _17.value])]).reduce((obj, [key, val]) => {
          obj[key] = val;
          return obj;
        }, {});
        next(vars);
      });
    }
    _unrollOther(prop, vars, next) {
      if (_optionalChain([prop, "optionalAccess", (_18) => _18.value, "optionalAccess", (_19) => _19.value])) {
        vars[prop.name] = prop.value.value;
      } else if (_optionalChain([prop, "optionalAccess", (_20) => _20.value, "optionalAccess", (_21) => _21.description]) && _optionalChain([prop, "optionalAccess", (_22) => _22.value, "optionalAccess", (_23) => _23.type]) !== "function") {
        vars[prop.name] = `<${prop.value.description}>`;
      }
      next(vars);
    }
  }
  var INTEGRATION_NAME = "LocalVariables";
  var _localVariablesSyncIntegration = (options = {}, session = tryNewAsyncSession()) => {
    const cachedFrames = new utils.LRUMap(20);
    let rateLimiter;
    let shouldProcessEvent = false;
    function handlePaused(stackParser, { params: { reason, data, callFrames } }, complete) {
      if (reason !== "exception" && reason !== "promiseRejection") {
        complete();
        return;
      }
      _optionalChain([rateLimiter, "optionalCall", (_24) => _24()]);
      const exceptionHash = common.hashFromStack(stackParser, _optionalChain([data, "optionalAccess", (_25) => _25.description]));
      if (exceptionHash == undefined) {
        complete();
        return;
      }
      const { add, next } = createCallbackList((frames) => {
        cachedFrames.set(exceptionHash, frames);
        complete();
      });
      for (let i = 0;i < Math.min(callFrames.length, 5); i++) {
        const { scopeChain, functionName, this: obj } = callFrames[i];
        const localScope = scopeChain.find((scope) => scope.type === "local");
        const fn = obj.className === "global" || !obj.className ? functionName : `${obj.className}.${functionName}`;
        if (_optionalChain([localScope, "optionalAccess", (_26) => _26.object, "access", (_27) => _27.objectId]) === undefined) {
          add((frames) => {
            frames[i] = { function: fn };
            next(frames);
          });
        } else {
          const id = localScope.object.objectId;
          add((frames) => _optionalChain([session, "optionalAccess", (_28) => _28.getLocalVariables, "call", (_29) => _29(id, (vars) => {
            frames[i] = { function: fn, vars };
            next(frames);
          })]));
        }
      }
      next([]);
    }
    function addLocalVariablesToException(exception) {
      const hash = common.hashFrames(_optionalChain([exception, "optionalAccess", (_30) => _30.stacktrace, "optionalAccess", (_31) => _31.frames]));
      if (hash === undefined) {
        return;
      }
      const cachedFrame = cachedFrames.remove(hash);
      if (cachedFrame === undefined) {
        return;
      }
      const frameCount = _optionalChain([exception, "access", (_32) => _32.stacktrace, "optionalAccess", (_33) => _33.frames, "optionalAccess", (_34) => _34.length]) || 0;
      for (let i = 0;i < frameCount; i++) {
        const frameIndex = frameCount - i - 1;
        if (!_optionalChain([exception, "optionalAccess", (_35) => _35.stacktrace, "optionalAccess", (_36) => _36.frames, "optionalAccess", (_37) => _37[frameIndex]]) || !cachedFrame[i]) {
          break;
        }
        if (cachedFrame[i].vars === undefined || exception.stacktrace.frames[frameIndex].in_app === false || !common.functionNamesMatch(exception.stacktrace.frames[frameIndex].function, cachedFrame[i].function)) {
          continue;
        }
        exception.stacktrace.frames[frameIndex].vars = cachedFrame[i].vars;
      }
    }
    function addLocalVariablesToEvent(event) {
      for (const exception of _optionalChain([event, "optionalAccess", (_38) => _38.exception, "optionalAccess", (_39) => _39.values]) || []) {
        addLocalVariablesToException(exception);
      }
      return event;
    }
    return {
      name: INTEGRATION_NAME,
      setupOnce() {
        const client = core.getClient();
        const clientOptions = _optionalChain([client, "optionalAccess", (_40) => _40.getOptions, "call", (_41) => _41()]);
        if (session && _optionalChain([clientOptions, "optionalAccess", (_42) => _42.includeLocalVariables])) {
          const unsupportedNodeVersion = nodeVersion.NODE_VERSION.major < 18;
          if (unsupportedNodeVersion) {
            utils.logger.log("The `LocalVariables` integration is only supported on Node >= v18.");
            return;
          }
          const captureAll = options.captureAllExceptions !== false;
          session.configureAndConnect((ev, complete) => handlePaused(clientOptions.stackParser, ev, complete), captureAll);
          if (captureAll) {
            const max = options.maxExceptionsPerSecond || 50;
            rateLimiter = common.createRateLimiter(max, () => {
              utils.logger.log("Local variables rate-limit lifted.");
              _optionalChain([session, "optionalAccess", (_43) => _43.setPauseOnExceptions, "call", (_44) => _44(true)]);
            }, (seconds) => {
              utils.logger.log(`Local variables rate-limit exceeded. Disabling capturing of caught exceptions for ${seconds} seconds.`);
              _optionalChain([session, "optionalAccess", (_45) => _45.setPauseOnExceptions, "call", (_46) => _46(false)]);
            });
          }
          shouldProcessEvent = true;
        }
      },
      processEvent(event) {
        if (shouldProcessEvent) {
          return addLocalVariablesToEvent(event);
        }
        return event;
      },
      _getCachedFramesCount() {
        return cachedFrames.size;
      },
      _getFirstCachedFrame() {
        return cachedFrames.values()[0];
      }
    };
  };
  var localVariablesSyncIntegration = core.defineIntegration(_localVariablesSyncIntegration);
  var LocalVariablesSync = core.convertIntegrationFnToClass(INTEGRATION_NAME, localVariablesSyncIntegration);
  exports.LocalVariablesSync = LocalVariablesSync;
  exports.createCallbackList = createCallbackList;
  exports.localVariablesSyncIntegration = localVariablesSyncIntegration;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/integrations/local-variables/index.js
var require_local_variables = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var localVariablesSync = require_local_variables_sync();
  var LocalVariables = localVariablesSync.LocalVariablesSync;
  var localVariablesIntegration = localVariablesSync.localVariablesSyncIntegration;
  exports.LocalVariables = LocalVariables;
  exports.localVariablesIntegration = localVariablesIntegration;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/integrations/modules.js
var require_modules = __commonJS((exports) => {
  var getPaths = function() {
    try {
      return __require.cache ? Object.keys(__require.cache) : [];
    } catch (e) {
      return [];
    }
  };
  var collectModules = function() {
    const mainPaths = __require.main && __require.main.paths || [];
    const paths = getPaths();
    const infos = {};
    const seen = {};
    paths.forEach((path$1) => {
      let dir = path$1;
      const updir = () => {
        const orig = dir;
        dir = path.dirname(orig);
        if (!dir || orig === dir || seen[orig]) {
          return;
        }
        if (mainPaths.indexOf(dir) < 0) {
          return updir();
        }
        const pkgfile = path.join(orig, "package.json");
        seen[orig] = true;
        if (!fs.existsSync(pkgfile)) {
          return updir();
        }
        try {
          const info = JSON.parse(fs.readFileSync(pkgfile, "utf8"));
          infos[info.name] = info.version;
        } catch (_oO) {
        }
      };
      updir();
    });
    return infos;
  };
  var _getModules = function() {
    if (!moduleCache) {
      moduleCache = collectModules();
    }
    return moduleCache;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var fs = __require("fs");
  var path = __require("path");
  var core = require_cjs2();
  var moduleCache;
  var INTEGRATION_NAME = "Modules";
  var _modulesIntegration = () => {
    return {
      name: INTEGRATION_NAME,
      setupOnce() {
      },
      processEvent(event) {
        event.modules = {
          ...event.modules,
          ..._getModules()
        };
        return event;
      }
    };
  };
  var modulesIntegration = core.defineIntegration(_modulesIntegration);
  var Modules = core.convertIntegrationFnToClass(INTEGRATION_NAME, modulesIntegration);
  exports.Modules = Modules;
  exports.modulesIntegration = modulesIntegration;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/integrations/utils/errorhandling.js
var require_errorhandling = __commonJS((exports) => {
  var logAndExitProcess = function(error) {
    utils.consoleSandbox(() => {
      console.error(error);
    });
    const client = core.getClient();
    if (client === undefined) {
      debugBuild.DEBUG_BUILD && utils.logger.warn("No NodeClient was defined, we are exiting the process now.");
      global.process.exit(1);
    }
    const options = client.getOptions();
    const timeout = options && options.shutdownTimeout && options.shutdownTimeout > 0 && options.shutdownTimeout || DEFAULT_SHUTDOWN_TIMEOUT;
    client.close(timeout).then((result) => {
      if (!result) {
        debugBuild.DEBUG_BUILD && utils.logger.warn("We reached the timeout for emptying the request buffer, still exiting now!");
      }
      global.process.exit(1);
    }, (error2) => {
      debugBuild.DEBUG_BUILD && utils.logger.error(error2);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var utils = require_cjs();
  var debugBuild = require_debug_build4();
  var DEFAULT_SHUTDOWN_TIMEOUT = 2000;
  exports.logAndExitProcess = logAndExitProcess;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/integrations/onuncaughtexception.js
var require_onuncaughtexception = __commonJS((exports) => {
  var makeErrorHandler = function(client, options) {
    const timeout = 2000;
    let caughtFirstError = false;
    let caughtSecondError = false;
    let calledFatalError = false;
    let firstError;
    const clientOptions = client.getOptions();
    return Object.assign((error) => {
      let onFatalError = errorhandling.logAndExitProcess;
      if (options.onFatalError) {
        onFatalError = options.onFatalError;
      } else if (clientOptions.onFatalError) {
        onFatalError = clientOptions.onFatalError;
      }
      const userProvidedListenersCount = global.process.listeners("uncaughtException").reduce((acc, listener) => {
        if (listener.name === "domainUncaughtExceptionClear" || listener.tag && listener.tag === "sentry_tracingErrorCallback" || listener._errorHandler) {
          return acc;
        } else {
          return acc + 1;
        }
      }, 0);
      const processWouldExit = userProvidedListenersCount === 0;
      const shouldApplyFatalHandlingLogic = options.exitEvenIfOtherHandlersAreRegistered || processWouldExit;
      if (!caughtFirstError) {
        firstError = error;
        caughtFirstError = true;
        if (core.getClient() === client) {
          core.captureException(error, {
            originalException: error,
            captureContext: {
              level: "fatal"
            },
            mechanism: {
              handled: false,
              type: "onuncaughtexception"
            }
          });
        }
        if (!calledFatalError && shouldApplyFatalHandlingLogic) {
          calledFatalError = true;
          onFatalError(error);
        }
      } else {
        if (shouldApplyFatalHandlingLogic) {
          if (calledFatalError) {
            debugBuild.DEBUG_BUILD && utils.logger.warn("uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown");
            errorhandling.logAndExitProcess(error);
          } else if (!caughtSecondError) {
            caughtSecondError = true;
            setTimeout(() => {
              if (!calledFatalError) {
                calledFatalError = true;
                onFatalError(firstError, error);
              }
            }, timeout);
          }
        }
      }
    }, { _errorHandler: true });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var utils = require_cjs();
  var debugBuild = require_debug_build4();
  var errorhandling = require_errorhandling();
  var INTEGRATION_NAME = "OnUncaughtException";
  var _onUncaughtExceptionIntegration = (options = {}) => {
    const _options = {
      exitEvenIfOtherHandlersAreRegistered: true,
      ...options
    };
    return {
      name: INTEGRATION_NAME,
      setupOnce() {
      },
      setup(client) {
        global.process.on("uncaughtException", makeErrorHandler(client, _options));
      }
    };
  };
  var onUncaughtExceptionIntegration = core.defineIntegration(_onUncaughtExceptionIntegration);
  var OnUncaughtException = core.convertIntegrationFnToClass(INTEGRATION_NAME, onUncaughtExceptionIntegration);
  exports.OnUncaughtException = OnUncaughtException;
  exports.makeErrorHandler = makeErrorHandler;
  exports.onUncaughtExceptionIntegration = onUncaughtExceptionIntegration;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/integrations/onunhandledrejection.js
var require_onunhandledrejection = __commonJS((exports) => {
  var makeUnhandledPromiseHandler = function(client, options) {
    return function sendUnhandledPromise(reason, promise) {
      if (core.getClient() !== client) {
        return;
      }
      core.captureException(reason, {
        originalException: promise,
        captureContext: {
          extra: { unhandledPromiseRejection: true }
        },
        mechanism: {
          handled: false,
          type: "onunhandledrejection"
        }
      });
      handleRejection(reason, options);
    };
  };
  var handleRejection = function(reason, options) {
    const rejectionWarning = "This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason:";
    if (options.mode === "warn") {
      utils.consoleSandbox(() => {
        console.warn(rejectionWarning);
        console.error(reason && reason.stack ? reason.stack : reason);
      });
    } else if (options.mode === "strict") {
      utils.consoleSandbox(() => {
        console.warn(rejectionWarning);
      });
      errorhandling.logAndExitProcess(reason);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var utils = require_cjs();
  var errorhandling = require_errorhandling();
  var INTEGRATION_NAME = "OnUnhandledRejection";
  var _onUnhandledRejectionIntegration = (options = {}) => {
    const mode = options.mode || "warn";
    return {
      name: INTEGRATION_NAME,
      setupOnce() {
      },
      setup(client) {
        global.process.on("unhandledRejection", makeUnhandledPromiseHandler(client, { mode }));
      }
    };
  };
  var onUnhandledRejectionIntegration = core.defineIntegration(_onUnhandledRejectionIntegration);
  var OnUnhandledRejection = core.convertIntegrationFnToClass(INTEGRATION_NAME, onUnhandledRejectionIntegration);
  exports.OnUnhandledRejection = OnUnhandledRejection;
  exports.makeUnhandledPromiseHandler = makeUnhandledPromiseHandler;
  exports.onUnhandledRejectionIntegration = onUnhandledRejectionIntegration;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/integrations/spotlight.js
var require_spotlight = __commonJS((exports) => {
  var connectToSpotlight = function(client, options) {
    const spotlightUrl = parseSidecarUrl(options.sidecarUrl);
    if (!spotlightUrl) {
      return;
    }
    let failedRequests = 0;
    if (typeof client.on !== "function") {
      utils.logger.warn("[Spotlight] Cannot connect to spotlight due to missing method on SDK client (`client.on`)");
      return;
    }
    client.on("beforeEnvelope", (envelope) => {
      if (failedRequests > 3) {
        utils.logger.warn("[Spotlight] Disabled Sentry -> Spotlight integration due to too many failed requests");
        return;
      }
      const serializedEnvelope = utils.serializeEnvelope(envelope);
      const request = getNativeHttpRequest();
      const req = request({
        method: "POST",
        path: spotlightUrl.pathname,
        hostname: spotlightUrl.hostname,
        port: spotlightUrl.port,
        headers: {
          "Content-Type": "application/x-sentry-envelope"
        }
      }, (res) => {
        res.on("data", () => {
        });
        res.on("end", () => {
        });
        res.setEncoding("utf8");
      });
      req.on("error", () => {
        failedRequests++;
        utils.logger.warn("[Spotlight] Failed to send envelope to Spotlight Sidecar");
      });
      req.write(serializedEnvelope);
      req.end();
    });
  };
  var parseSidecarUrl = function(url$1) {
    try {
      return new url.URL(`${url$1}`);
    } catch (e) {
      utils.logger.warn(`[Spotlight] Invalid sidecar URL: ${url$1}`);
      return;
    }
  };
  var getNativeHttpRequest = function() {
    const { request } = http;
    if (isWrapped(request)) {
      return request.__sentry_original__;
    }
    return request;
  };
  var isWrapped = function(impl) {
    return "__sentry_original__" in impl;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var http = __require("http");
  var url = __require("url");
  var core = require_cjs2();
  var utils = require_cjs();
  var INTEGRATION_NAME = "Spotlight";
  var _spotlightIntegration = (options = {}) => {
    const _options = {
      sidecarUrl: options.sidecarUrl || "http://localhost:8969/stream"
    };
    return {
      name: INTEGRATION_NAME,
      setupOnce() {
      },
      setup(client) {
        if (typeof process === "object" && process.env && false) {
        }
        connectToSpotlight(client, _options);
      }
    };
  };
  var spotlightIntegration = core.defineIntegration(_spotlightIntegration);
  var Spotlight = core.convertIntegrationFnToClass(INTEGRATION_NAME, spotlightIntegration);
  exports.Spotlight = Spotlight;
  exports.getNativeHttpRequest = getNativeHttpRequest;
  exports.spotlightIntegration = spotlightIntegration;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/integrations/undici/index.js
var require_undici = __commonJS((exports) => {
  var setHeadersOnRequest = function(request, sentryTrace, sentryBaggageHeader) {
    const headerLines = request.headers.split("\r\n");
    const hasSentryHeaders = headerLines.some((headerLine) => headerLine.startsWith("sentry-trace:"));
    if (hasSentryHeaders) {
      return;
    }
    request.addHeader("sentry-trace", sentryTrace);
    if (sentryBaggageHeader) {
      request.addHeader("baggage", sentryBaggageHeader);
    }
  };
  var createRequestSpan = function(activeSpan, request, stringUrl) {
    const url = utils.parseUrl(stringUrl);
    const method = request.method || "GET";
    const data = {
      "http.method": method
    };
    if (url.search) {
      data["http.query"] = url.search;
    }
    if (url.hash) {
      data["http.fragment"] = url.hash;
    }
    return _optionalChain([activeSpan, "optionalAccess", (_19) => _19.startChild, "call", (_20) => _20({
      op: "http.client",
      origin: "auto.http.node.undici",
      description: `${method} ${utils.getSanitizedUrlString(url)}`,
      data
    })]);
  };
  var {
    _optionalChain
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var utils = require_cjs();
  var nodeVersion = require_nodeVersion();
  exports.ChannelName = undefined;
  (function(ChannelName) {
    const RequestCreate = "undici:request:create";
    ChannelName["RequestCreate"] = RequestCreate;
    const RequestEnd = "undici:request:headers";
    ChannelName["RequestEnd"] = RequestEnd;
    const RequestError = "undici:request:error";
    ChannelName["RequestError"] = RequestError;
  })(exports.ChannelName || (exports.ChannelName = {}));
  var _nativeNodeFetchintegration = (options) => {
    return new Undici(options);
  };
  var nativeNodeFetchintegration = core.defineIntegration(_nativeNodeFetchintegration);

  class Undici {
    static __initStatic() {
      this.id = "Undici";
    }
    __init() {
      this.name = Undici.id;
    }
    __init2() {
      this._createSpanUrlMap = new utils.LRUMap(100);
    }
    __init3() {
      this._headersUrlMap = new utils.LRUMap(100);
    }
    constructor(_options = {}) {
      Undici.prototype.__init.call(this);
      Undici.prototype.__init2.call(this);
      Undici.prototype.__init3.call(this);
      Undici.prototype.__init4.call(this);
      Undici.prototype.__init5.call(this);
      Undici.prototype.__init6.call(this);
      this._options = {
        breadcrumbs: _options.breadcrumbs === undefined ? true : _options.breadcrumbs,
        tracing: _options.tracing,
        shouldCreateSpanForRequest: _options.shouldCreateSpanForRequest
      };
    }
    setupOnce(_addGlobalEventProcessor) {
      if (nodeVersion.NODE_VERSION.major < 16) {
        return;
      }
      let ds;
      try {
        ds = __require("diagnostics_channel");
      } catch (e) {
      }
      if (!ds || !ds.subscribe) {
        return;
      }
      ds.subscribe(exports.ChannelName.RequestCreate, this._onRequestCreate);
      ds.subscribe(exports.ChannelName.RequestEnd, this._onRequestEnd);
      ds.subscribe(exports.ChannelName.RequestError, this._onRequestError);
    }
    _shouldCreateSpan(url) {
      if (this._options.tracing === false || this._options.tracing === undefined && !core.hasTracingEnabled()) {
        return false;
      }
      if (this._options.shouldCreateSpanForRequest === undefined) {
        return true;
      }
      const cachedDecision = this._createSpanUrlMap.get(url);
      if (cachedDecision !== undefined) {
        return cachedDecision;
      }
      const decision = this._options.shouldCreateSpanForRequest(url);
      this._createSpanUrlMap.set(url, decision);
      return decision;
    }
    __init4() {
      this._onRequestCreate = (message) => {
        if (!_optionalChain([core.getClient, "call", (_10) => _10(), "optionalAccess", (_11) => _11.getIntegration, "call", (_12) => _12(Undici)])) {
          return;
        }
        const { request } = message;
        const stringUrl = request.origin ? request.origin.toString() + request.path : request.path;
        const client = core.getClient();
        if (!client) {
          return;
        }
        if (core.isSentryRequestUrl(stringUrl, client) || request.__sentry_span__ !== undefined) {
          return;
        }
        const clientOptions = client.getOptions();
        const scope = core.getCurrentScope();
        const isolationScope = core.getIsolationScope();
        const parentSpan = core.getActiveSpan();
        const span = this._shouldCreateSpan(stringUrl) ? createRequestSpan(parentSpan, request, stringUrl) : undefined;
        if (span) {
          request.__sentry_span__ = span;
        }
        const shouldAttachTraceData = (url) => {
          if (clientOptions.tracePropagationTargets === undefined) {
            return true;
          }
          const cachedDecision = this._headersUrlMap.get(url);
          if (cachedDecision !== undefined) {
            return cachedDecision;
          }
          const decision = utils.stringMatchesSomePattern(url, clientOptions.tracePropagationTargets);
          this._headersUrlMap.set(url, decision);
          return decision;
        };
        if (shouldAttachTraceData(stringUrl)) {
          const { traceId, spanId, sampled, dsc } = {
            ...isolationScope.getPropagationContext(),
            ...scope.getPropagationContext()
          };
          const sentryTraceHeader = span ? core.spanToTraceHeader(span) : utils.generateSentryTraceHeader(traceId, spanId, sampled);
          const sentryBaggageHeader = utils.dynamicSamplingContextToSentryBaggageHeader(dsc || (span ? core.getDynamicSamplingContextFromSpan(span) : core.getDynamicSamplingContextFromClient(traceId, client, scope)));
          setHeadersOnRequest(request, sentryTraceHeader, sentryBaggageHeader);
        }
      };
    }
    __init5() {
      this._onRequestEnd = (message) => {
        if (!_optionalChain([core.getClient, "call", (_13) => _13(), "optionalAccess", (_14) => _14.getIntegration, "call", (_15) => _15(Undici)])) {
          return;
        }
        const { request, response } = message;
        const stringUrl = request.origin ? request.origin.toString() + request.path : request.path;
        if (core.isSentryRequestUrl(stringUrl, core.getClient())) {
          return;
        }
        const span = request.__sentry_span__;
        if (span) {
          core.setHttpStatus(span, response.statusCode);
          span.end();
        }
        if (this._options.breadcrumbs) {
          core.addBreadcrumb({
            category: "http",
            data: {
              method: request.method,
              status_code: response.statusCode,
              url: stringUrl
            },
            type: "http"
          }, {
            event: "response",
            request,
            response
          });
        }
      };
    }
    __init6() {
      this._onRequestError = (message) => {
        if (!_optionalChain([core.getClient, "call", (_16) => _16(), "optionalAccess", (_17) => _17.getIntegration, "call", (_18) => _18(Undici)])) {
          return;
        }
        const { request } = message;
        const stringUrl = request.origin ? request.origin.toString() + request.path : request.path;
        if (core.isSentryRequestUrl(stringUrl, core.getClient())) {
          return;
        }
        const span = request.__sentry_span__;
        if (span) {
          span.setStatus("internal_error");
          span.end();
        }
        if (this._options.breadcrumbs) {
          core.addBreadcrumb({
            category: "http",
            data: {
              method: request.method,
              url: stringUrl
            },
            level: "error",
            type: "http"
          }, {
            event: "error",
            request
          });
        }
      };
    }
  }
  Undici.__initStatic();
  exports.Undici = Undici;
  exports.nativeNodeFetchintegration = nativeNodeFetchintegration;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/module.js
var require_module = __commonJS((exports) => {
  var normalizeWindowsPath = function(path2) {
    return path2.replace(/^[A-Z]:/, "").replace(/\\/g, "/");
  };
  var createGetModuleFromFilename = function(basePath = process.argv[1] ? utils.dirname(process.argv[1]) : process.cwd(), isWindows = path.sep === "\\") {
    const normalizedBase = isWindows ? normalizeWindowsPath(basePath) : basePath;
    return (filename) => {
      if (!filename) {
        return;
      }
      const normalizedFilename = isWindows ? normalizeWindowsPath(filename) : filename;
      let { dir, base: file, ext } = path.posix.parse(normalizedFilename);
      if (ext === ".js" || ext === ".mjs" || ext === ".cjs") {
        file = file.slice(0, ext.length * -1);
      }
      if (!dir) {
        dir = ".";
      }
      const n = dir.lastIndexOf("/node_modules");
      if (n > -1) {
        return `${dir.slice(n + 14).replace(/\//g, ".")}:${file}`;
      }
      if (dir.startsWith(normalizedBase)) {
        let moduleName = dir.slice(normalizedBase.length + 1).replace(/\//g, ".");
        if (moduleName) {
          moduleName += ":";
        }
        moduleName += file;
        return moduleName;
      }
      return file;
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var path = __require("path");
  var utils = require_cjs();
  exports.createGetModuleFromFilename = createGetModuleFromFilename;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/sdk.js
var require_sdk2 = __commonJS((exports) => {
  var getDefaultIntegrations = function(_options) {
    const carrier = core.getMainCarrier();
    const autoloadedIntegrations = _optionalChain([carrier, "access", (_) => _.__SENTRY__, "optionalAccess", (_2) => _2.integrations]) || [];
    return [
      ...defaultIntegrations,
      ...autoloadedIntegrations
    ];
  };
  var init = function(options = {}) {
    index$2.setNodeAsyncContextStrategy();
    if (options.defaultIntegrations === undefined) {
      options.defaultIntegrations = getDefaultIntegrations();
    }
    if (options.dsn === undefined && process.env.SENTRY_DSN) {
      options.dsn = process.env.SENTRY_DSN;
    }
    const sentryTracesSampleRate = process.env.SENTRY_TRACES_SAMPLE_RATE;
    if (options.tracesSampleRate === undefined && sentryTracesSampleRate) {
      const tracesSampleRate = parseFloat(sentryTracesSampleRate);
      if (isFinite(tracesSampleRate)) {
        options.tracesSampleRate = tracesSampleRate;
      }
    }
    if (options.release === undefined) {
      const detectedRelease = getSentryRelease();
      if (detectedRelease !== undefined) {
        options.release = detectedRelease;
      } else {
        options.autoSessionTracking = false;
      }
    }
    if (options.environment === undefined && process.env.SENTRY_ENVIRONMENT) {
      options.environment = process.env.SENTRY_ENVIRONMENT;
    }
    if (options.autoSessionTracking === undefined && options.dsn !== undefined) {
      options.autoSessionTracking = true;
    }
    if (options.instrumenter === undefined) {
      options.instrumenter = "sentry";
    }
    const clientOptions = {
      ...options,
      stackParser: utils.stackParserFromStackParserOptions(options.stackParser || defaultStackParser),
      integrations: core.getIntegrationsToSetup(options),
      transport: options.transport || http$1.makeNodeTransport
    };
    core.initAndBind(options.clientClass || client.NodeClient, clientOptions);
    if (options.autoSessionTracking) {
      startSessionTracking();
    }
    updateScopeFromEnvVariables();
    if (options.spotlight) {
      const client2 = core.getClient();
      if (client2 && client2.addIntegration) {
        const integrations = client2.getOptions().integrations;
        for (const integration of integrations) {
          client2.addIntegration(integration);
        }
        client2.addIntegration(spotlight.spotlightIntegration({ sidecarUrl: typeof options.spotlight === "string" ? options.spotlight : undefined }));
      }
    }
  };
  var isAutoSessionTrackingEnabled = function(client2) {
    if (client2 === undefined) {
      return false;
    }
    const clientOptions = client2 && client2.getOptions();
    if (clientOptions && clientOptions.autoSessionTracking !== undefined) {
      return clientOptions.autoSessionTracking;
    }
    return false;
  };
  var getSentryRelease = function(fallback) {
    if (process.env.SENTRY_RELEASE) {
      return process.env.SENTRY_RELEASE;
    }
    if (utils.GLOBAL_OBJ.SENTRY_RELEASE && utils.GLOBAL_OBJ.SENTRY_RELEASE.id) {
      return utils.GLOBAL_OBJ.SENTRY_RELEASE.id;
    }
    return process.env.GITHUB_SHA || process.env.COMMIT_REF || process.env.VERCEL_GIT_COMMIT_SHA || process.env.VERCEL_GITHUB_COMMIT_SHA || process.env.VERCEL_GITLAB_COMMIT_SHA || process.env.VERCEL_BITBUCKET_COMMIT_SHA || process.env.ZEIT_GITHUB_COMMIT_SHA || process.env.ZEIT_GITLAB_COMMIT_SHA || process.env.ZEIT_BITBUCKET_COMMIT_SHA || process.env.CF_PAGES_COMMIT_SHA || fallback;
  };
  var startSessionTracking = function() {
    core.startSession();
    process.on("beforeExit", () => {
      const session = core.getIsolationScope().getSession();
      const terminalStates = ["exited", "crashed"];
      if (session && !terminalStates.includes(session.status)) {
        core.endSession();
      }
    });
  };
  var updateScopeFromEnvVariables = function() {
    const sentryUseEnvironment = (process.env.SENTRY_USE_ENVIRONMENT || "").toLowerCase();
    if (!["false", "n", "no", "off", "0"].includes(sentryUseEnvironment)) {
      const sentryTraceEnv = process.env.SENTRY_TRACE;
      const baggageEnv = process.env.SENTRY_BAGGAGE;
      const propagationContext = utils.propagationContextFromHeaders(sentryTraceEnv, baggageEnv);
      core.getCurrentScope().setPropagationContext(propagationContext);
    }
  };
  var {
    _optionalChain
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var utils = require_cjs();
  var index$2 = require_async();
  var client = require_client();
  var console2 = require_console2();
  var context = require_context();
  var contextlines = require_contextlines();
  var http = require_http3();
  var index$1 = require_local_variables();
  var modules = require_modules();
  var onuncaughtexception = require_onuncaughtexception();
  var onunhandledrejection = require_onunhandledrejection();
  var spotlight = require_spotlight();
  var index = require_undici();
  var module$1 = require_module();
  var http$1 = require_http();
  var defaultIntegrations = [
    core.inboundFiltersIntegration(),
    core.functionToStringIntegration(),
    core.linkedErrorsIntegration(),
    core.requestDataIntegration(),
    console2.consoleIntegration(),
    http.httpIntegration(),
    index.nativeNodeFetchintegration(),
    onuncaughtexception.onUncaughtExceptionIntegration(),
    onunhandledrejection.onUnhandledRejectionIntegration(),
    contextlines.contextLinesIntegration(),
    index$1.localVariablesIntegration(),
    context.nodeContextIntegration(),
    modules.modulesIntegration()
  ];
  var defaultStackParser = utils.createStackParser(utils.nodeStackLineParser(module$1.createGetModuleFromFilename()));
  exports.defaultIntegrations = defaultIntegrations;
  exports.defaultStackParser = defaultStackParser;
  exports.getDefaultIntegrations = getDefaultIntegrations;
  exports.getSentryRelease = getSentryRelease;
  exports.init = init;
  exports.isAutoSessionTrackingEnabled = isAutoSessionTrackingEnabled;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/utils.js
var require_utils4 = __commonJS((exports) => {
  var deepReadDirSync = function(targetDir) {
    const targetDirAbsPath = path.resolve(targetDir);
    if (!fs.existsSync(targetDirAbsPath)) {
      throw new Error(`Cannot read contents of ${targetDirAbsPath}. Directory does not exist.`);
    }
    if (!fs.statSync(targetDirAbsPath).isDirectory()) {
      throw new Error(`Cannot read contents of ${targetDirAbsPath}, because it is not a directory.`);
    }
    const deepReadCurrentDir = (currentDirAbsPath) => {
      return fs.readdirSync(currentDirAbsPath).reduce((absPaths, itemName) => {
        const itemAbsPath = path.join(currentDirAbsPath, itemName);
        if (fs.statSync(itemAbsPath).isDirectory()) {
          return absPaths.concat(deepReadCurrentDir(itemAbsPath));
        }
        absPaths.push(itemAbsPath);
        return absPaths;
      }, []);
    };
    return deepReadCurrentDir(targetDirAbsPath).map((absPath) => path.relative(targetDirAbsPath, absPath));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var fs = __require("fs");
  var path = __require("path");
  exports.deepReadDirSync = deepReadDirSync;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/integrations/anr/worker-script.js
var require_worker_script = __commonJS((exports) => {
  /*! @sentry/node 7.100.1 (424a9c1) | https://github.com/getsentry/sentry-javascript */
  exports.base64WorkerScript = "aW1wb3J0IHsgU2Vzc2lvbiB9IGZyb20gJ2luc3BlY3Rvcic7CmltcG9ydCB7IHdvcmtlckRhdGEsIHBhcmVudFBvcnQgfSBmcm9tICd3b3JrZXJfdGhyZWFkcyc7CmltcG9ydCB7IHBvc2l4LCBzZXAgfSBmcm9tICdwYXRoJzsKaW1wb3J0ICogYXMgaHR0cCBmcm9tICdodHRwJzsKaW1wb3J0ICogYXMgaHR0cHMgZnJvbSAnaHR0cHMnOwppbXBvcnQgeyBSZWFkYWJsZSB9IGZyb20gJ3N0cmVhbSc7CmltcG9ydCB7IFVSTCB9IGZyb20gJ3VybCc7CmltcG9ydCB7IGNyZWF0ZUd6aXAgfSBmcm9tICd6bGliJzsKaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnOwppbXBvcnQgKiBhcyBuZXQgZnJvbSAnbmV0JzsKaW1wb3J0ICogYXMgdGxzIGZyb20gJ3Rscyc7CgovLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kCmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzsKCi8qKgogKiBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSdzIHR5cGUgaXMgb25lIG9mIGEgZmV3IEVycm9yIG9yIEVycm9yLWxpa2UKICoge0BsaW5rIGlzRXJyb3J9LgogKgogKiBAcGFyYW0gd2F0IEEgdmFsdWUgdG8gYmUgY2hlY2tlZC4KICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LgogKi8KZnVuY3Rpb24gaXNFcnJvcih3YXQpIHsKICBzd2l0Y2ggKG9iamVjdFRvU3RyaW5nLmNhbGwod2F0KSkgewogICAgY2FzZSAnW29iamVjdCBFcnJvcl0nOgogICAgY2FzZSAnW29iamVjdCBFeGNlcHRpb25dJzoKICAgIGNhc2UgJ1tvYmplY3QgRE9NRXhjZXB0aW9uXSc6CiAgICAgIHJldHVybiB0cnVlOwogICAgZGVmYXVsdDoKICAgICAgcmV0dXJuIGlzSW5zdGFuY2VPZih3YXQsIEVycm9yKTsKICB9Cn0KLyoqCiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIHRoZSBnaXZlbiBidWlsdC1pbiBjbGFzcy4KICoKICogQHBhcmFtIHdhdCBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZAogKiBAcGFyYW0gY2xhc3NOYW1lCiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC4KICovCmZ1bmN0aW9uIGlzQnVpbHRpbih3YXQsIGNsYXNzTmFtZSkgewogIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKHdhdCkgPT09IGBbb2JqZWN0ICR7Y2xhc3NOYW1lfV1gOwp9CgovKioKICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUncyB0eXBlIGlzIGEgc3RyaW5nCiAqIHtAbGluayBpc1N0cmluZ30uCiAqCiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLgogKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuCiAqLwpmdW5jdGlvbiBpc1N0cmluZyh3YXQpIHsKICByZXR1cm4gaXNCdWlsdGluKHdhdCwgJ1N0cmluZycpOwp9CgovKioKICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUncyB0eXBlIGlzIGFuIG9iamVjdCBsaXRlcmFsLCBvciBhIGNsYXNzIGluc3RhbmNlLgogKiB7QGxpbmsgaXNQbGFpbk9iamVjdH0uCiAqCiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLgogKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuCiAqLwpmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHdhdCkgewogIHJldHVybiBpc0J1aWx0aW4od2F0LCAnT2JqZWN0Jyk7Cn0KCi8qKgogKiBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSdzIHR5cGUgaXMgYW4gRXZlbnQgaW5zdGFuY2UKICoge0BsaW5rIGlzRXZlbnR9LgogKgogKiBAcGFyYW0gd2F0IEEgdmFsdWUgdG8gYmUgY2hlY2tlZC4KICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LgogKi8KZnVuY3Rpb24gaXNFdmVudCh3YXQpIHsKICByZXR1cm4gdHlwZW9mIEV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpc0luc3RhbmNlT2Yod2F0LCBFdmVudCk7Cn0KCi8qKgogKiBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSdzIHR5cGUgaXMgYW4gRWxlbWVudCBpbnN0YW5jZQogKiB7QGxpbmsgaXNFbGVtZW50fS4KICoKICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuCiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC4KICovCmZ1bmN0aW9uIGlzRWxlbWVudCh3YXQpIHsKICByZXR1cm4gdHlwZW9mIEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGlzSW5zdGFuY2VPZih3YXQsIEVsZW1lbnQpOwp9CgovKioKICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUgaGFzIGEgdGhlbiBmdW5jdGlvbi4KICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuCiAqLwpmdW5jdGlvbiBpc1RoZW5hYmxlKHdhdCkgewogIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MKICByZXR1cm4gQm9vbGVhbih3YXQgJiYgd2F0LnRoZW4gJiYgdHlwZW9mIHdhdC50aGVuID09PSAnZnVuY3Rpb24nKTsKfQoKLyoqCiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlJ3MgdHlwZSBpcyBhIFN5bnRoZXRpY0V2ZW50CiAqIHtAbGluayBpc1N5bnRoZXRpY0V2ZW50fS4KICoKICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuCiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC4KICovCmZ1bmN0aW9uIGlzU3ludGhldGljRXZlbnQod2F0KSB7CiAgcmV0dXJuIGlzUGxhaW5PYmplY3Qod2F0KSAmJiAnbmF0aXZlRXZlbnQnIGluIHdhdCAmJiAncHJldmVudERlZmF1bHQnIGluIHdhdCAmJiAnc3RvcFByb3BhZ2F0aW9uJyBpbiB3YXQ7Cn0KCi8qKgogKiBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSBpcyBOYU4KICoge0BsaW5rIGlzTmFOfS4KICoKICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuCiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC4KICovCmZ1bmN0aW9uIGlzTmFOJDEod2F0KSB7CiAgcmV0dXJuIHR5cGVvZiB3YXQgPT09ICdudW1iZXInICYmIHdhdCAhPT0gd2F0Owp9CgovKioKICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUncyB0eXBlIGlzIGFuIGluc3RhbmNlIG9mIHByb3ZpZGVkIGNvbnN0cnVjdG9yLgogKiB7QGxpbmsgaXNJbnN0YW5jZU9mfS4KICoKICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuCiAqIEBwYXJhbSBiYXNlIEEgY29uc3RydWN0b3IgdG8gYmUgdXNlZCBpbiBhIGNoZWNrLgogKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuCiAqLwpmdW5jdGlvbiBpc0luc3RhbmNlT2Yod2F0LCBiYXNlKSB7CiAgdHJ5IHsKICAgIHJldHVybiB3YXQgaW5zdGFuY2VvZiBiYXNlOwogIH0gY2F0Y2ggKF9lKSB7CiAgICByZXR1cm4gZmFsc2U7CiAgfQp9CgovKioKICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUncyB0eXBlIGlzIGEgVnVlIFZpZXdNb2RlbC4KICoKICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuCiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC4KICovCmZ1bmN0aW9uIGlzVnVlVmlld01vZGVsKHdhdCkgewogIC8vIE5vdCB1c2luZyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIGJlY2F1c2UgaW4gVnVlIDMgaXQgd291bGQgcmVhZCB0aGUgaW5zdGFuY2UncyBTeW1ib2woU3ltYm9sLnRvU3RyaW5nVGFnKSBwcm9wZXJ0eS4KICByZXR1cm4gISEodHlwZW9mIHdhdCA9PT0gJ29iamVjdCcgJiYgd2F0ICE9PSBudWxsICYmICgod2F0ICkuX19pc1Z1ZSB8fCAod2F0ICkuX2lzVnVlKSk7Cn0KCi8qKiBJbnRlcm5hbCBnbG9iYWwgd2l0aCBjb21tb24gcHJvcGVydGllcyBhbmQgU2VudHJ5IGV4dGVuc2lvbnMgICovCgovLyBUaGUgY29kZSBiZWxvdyBmb3IgJ2lzR2xvYmFsT2JqJyBhbmQgJ0dMT0JBTF9PQkonIHdhcyBjb3BpZWQgZnJvbSBjb3JlLWpzIGJlZm9yZSBtb2RpZmljYXRpb24KLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi8xYjk0NGRmNTUyODJjZGM5OWM5MGRiNWY0OWViMGI2ZWRhMmNjMGEzL3BhY2thZ2VzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qcwovLyBjb3JlLWpzIGhhcyB0aGUgZm9sbG93aW5nIGxpY2VuY2U6Ci8vCi8vIENvcHlyaWdodCAoYykgMjAxNC0yMDIyIERlbmlzIFB1c2hrYXJldgovLwovLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5Ci8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICJTb2Z0d2FyZSIpLCB0byBkZWFsCi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMKLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbAovLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMKLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczoKLy8KLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4KLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCi8vCi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SCi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLAovLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUKLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUgovLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLAovLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOCi8vIFRIRSBTT0ZUV0FSRS4KCi8qKiBSZXR1cm5zICdvYmonIGlmIGl0J3MgdGhlIGdsb2JhbCBvYmplY3QsIG90aGVyd2lzZSByZXR1cm5zIHVuZGVmaW5lZCAqLwpmdW5jdGlvbiBpc0dsb2JhbE9iaihvYmopIHsKICByZXR1cm4gb2JqICYmIG9iai5NYXRoID09IE1hdGggPyBvYmogOiB1bmRlZmluZWQ7Cn0KCi8qKiBHZXQncyB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgdGhlIGN1cnJlbnQgSmF2YVNjcmlwdCBydW50aW1lICovCmNvbnN0IEdMT0JBTF9PQkogPQogICh0eXBlb2YgZ2xvYmFsVGhpcyA9PSAnb2JqZWN0JyAmJiBpc0dsb2JhbE9iaihnbG9iYWxUaGlzKSkgfHwKICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzCiAgKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgaXNHbG9iYWxPYmood2luZG93KSkgfHwKICAodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgaXNHbG9iYWxPYmooc2VsZikpIHx8CiAgKHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgaXNHbG9iYWxPYmooZ2xvYmFsKSkgfHwKICAoZnVuY3Rpb24gKCkgewogICAgcmV0dXJuIHRoaXM7CiAgfSkoKSB8fAogIHt9OwoKLyoqCiAqIEBkZXByZWNhdGVkIFVzZSBHTE9CQUxfT0JKIGluc3RlYWQgb3IgV0lORE9XIGZyb20gQHNlbnRyeS9icm93c2VyLiBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiB2OAogKi8KZnVuY3Rpb24gZ2V0R2xvYmFsT2JqZWN0KCkgewogIHJldHVybiBHTE9CQUxfT0JKIDsKfQoKLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCmNvbnN0IFdJTkRPVyA9IGdldEdsb2JhbE9iamVjdCgpOwoKY29uc3QgREVGQVVMVF9NQVhfU1RSSU5HX0xFTkdUSCA9IDgwOwoKLyoqCiAqIEdpdmVuIGEgY2hpbGQgRE9NIGVsZW1lbnQsIHJldHVybnMgYSBxdWVyeS1zZWxlY3RvciBzdGF0ZW1lbnQgZGVzY3JpYmluZyB0aGF0CiAqIGFuZCBpdHMgYW5jZXN0b3JzCiAqIGUuZy4gW0hUTUxFbGVtZW50XSA9PiBib2R5ID4gZGl2ID4gaW5wdXQjZm9vLmJ0bltuYW1lPWJhel0KICogQHJldHVybnMgZ2VuZXJhdGVkIERPTSBwYXRoCiAqLwpmdW5jdGlvbiBodG1sVHJlZUFzU3RyaW5nKAogIGVsZW0sCiAgb3B0aW9ucyA9IHt9LAopIHsKICBpZiAoIWVsZW0pIHsKICAgIHJldHVybiAnPHVua25vd24+JzsKICB9CgogIC8vIHRyeS9jYXRjaCBib3RoOgogIC8vIC0gYWNjZXNzaW5nIGV2ZW50LnRhcmdldCAoc2VlIGdldHNlbnRyeS9yYXZlbi1qcyM4MzgsICM3NjgpCiAgLy8gLSBgaHRtbFRyZWVBc1N0cmluZ2AgYmVjYXVzZSBpdCdzIGNvbXBsZXgsIGFuZCBqdXN0IGFjY2Vzc2luZyB0aGUgRE9NIGluY29ycmVjdGx5CiAgLy8gLSBjYW4gdGhyb3cgYW4gZXhjZXB0aW9uIGluIHNvbWUgY2lyY3Vtc3RhbmNlcy4KICB0cnkgewogICAgbGV0IGN1cnJlbnRFbGVtID0gZWxlbSA7CiAgICBjb25zdCBNQVhfVFJBVkVSU0VfSEVJR0hUID0gNTsKICAgIGNvbnN0IG91dCA9IFtdOwogICAgbGV0IGhlaWdodCA9IDA7CiAgICBsZXQgbGVuID0gMDsKICAgIGNvbnN0IHNlcGFyYXRvciA9ICcgPiAnOwogICAgY29uc3Qgc2VwTGVuZ3RoID0gc2VwYXJhdG9yLmxlbmd0aDsKICAgIGxldCBuZXh0U3RyOwogICAgY29uc3Qga2V5QXR0cnMgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMpID8gb3B0aW9ucyA6IG9wdGlvbnMua2V5QXR0cnM7CiAgICBjb25zdCBtYXhTdHJpbmdMZW5ndGggPSAoIUFycmF5LmlzQXJyYXkob3B0aW9ucykgJiYgb3B0aW9ucy5tYXhTdHJpbmdMZW5ndGgpIHx8IERFRkFVTFRfTUFYX1NUUklOR19MRU5HVEg7CgogICAgd2hpbGUgKGN1cnJlbnRFbGVtICYmIGhlaWdodCsrIDwgTUFYX1RSQVZFUlNFX0hFSUdIVCkgewogICAgICBuZXh0U3RyID0gX2h0bWxFbGVtZW50QXNTdHJpbmcoY3VycmVudEVsZW0sIGtleUF0dHJzKTsKICAgICAgLy8gYmFpbCBvdXQgaWYKICAgICAgLy8gLSBuZXh0U3RyIGlzIHRoZSAnaHRtbCcgZWxlbWVudAogICAgICAvLyAtIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZyB0aGF0IHdvdWxkIGJlIGNyZWF0ZWQgZXhjZWVkcyBtYXhTdHJpbmdMZW5ndGgKICAgICAgLy8gICAoaWdub3JlIHRoaXMgbGltaXQgaWYgd2UgYXJlIG9uIHRoZSBmaXJzdCBpdGVyYXRpb24pCiAgICAgIGlmIChuZXh0U3RyID09PSAnaHRtbCcgfHwgKGhlaWdodCA+IDEgJiYgbGVuICsgb3V0Lmxlbmd0aCAqIHNlcExlbmd0aCArIG5leHRTdHIubGVuZ3RoID49IG1heFN0cmluZ0xlbmd0aCkpIHsKICAgICAgICBicmVhazsKICAgICAgfQoKICAgICAgb3V0LnB1c2gobmV4dFN0cik7CgogICAgICBsZW4gKz0gbmV4dFN0ci5sZW5ndGg7CiAgICAgIGN1cnJlbnRFbGVtID0gY3VycmVudEVsZW0ucGFyZW50Tm9kZTsKICAgIH0KCiAgICByZXR1cm4gb3V0LnJldmVyc2UoKS5qb2luKHNlcGFyYXRvcik7CiAgfSBjYXRjaCAoX29PKSB7CiAgICByZXR1cm4gJzx1bmtub3duPic7CiAgfQp9CgovKioKICogUmV0dXJucyBhIHNpbXBsZSwgcXVlcnktc2VsZWN0b3IgcmVwcmVzZW50YXRpb24gb2YgYSBET00gZWxlbWVudAogKiBlLmcuIFtIVE1MRWxlbWVudF0gPT4gaW5wdXQjZm9vLmJ0bltuYW1lPWJhel0KICogQHJldHVybnMgZ2VuZXJhdGVkIERPTSBwYXRoCiAqLwpmdW5jdGlvbiBfaHRtbEVsZW1lbnRBc1N0cmluZyhlbCwga2V5QXR0cnMpIHsKICBjb25zdCBlbGVtID0gZWwKCjsKCiAgY29uc3Qgb3V0ID0gW107CiAgbGV0IGNsYXNzTmFtZTsKICBsZXQgY2xhc3NlczsKICBsZXQga2V5OwogIGxldCBhdHRyOwogIGxldCBpOwoKICBpZiAoIWVsZW0gfHwgIWVsZW0udGFnTmFtZSkgewogICAgcmV0dXJuICcnOwogIH0KCiAgLy8gQHRzLWV4cGVjdC1lcnJvciBXSU5ET1cgaGFzIEhUTUxFbGVtZW50CiAgaWYgKFdJTkRPVy5IVE1MRWxlbWVudCkgewogICAgLy8gSWYgdXNpbmcgdGhlIGNvbXBvbmVudCBuYW1lIGFubm90YXRpb24gcGx1Z2luLCB0aGlzIHZhbHVlIG1heSBiZSBhdmFpbGFibGUgb24gdGhlIERPTSBub2RlCiAgICBpZiAoZWxlbSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGVsZW0uZGF0YXNldCAmJiBlbGVtLmRhdGFzZXRbJ3NlbnRyeUNvbXBvbmVudCddKSB7CiAgICAgIHJldHVybiBlbGVtLmRhdGFzZXRbJ3NlbnRyeUNvbXBvbmVudCddOwogICAgfQogIH0KCiAgb3V0LnB1c2goZWxlbS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpOwoKICAvLyBQYWlycyBvZiBhdHRyaWJ1dGUga2V5cyBkZWZpbmVkIGluIGBzZXJpYWxpemVBdHRyaWJ1dGVgIGFuZCB0aGVpciB2YWx1ZXMgb24gZWxlbWVudC4KICBjb25zdCBrZXlBdHRyUGFpcnMgPQogICAga2V5QXR0cnMgJiYga2V5QXR0cnMubGVuZ3RoCiAgICAgID8ga2V5QXR0cnMuZmlsdGVyKGtleUF0dHIgPT4gZWxlbS5nZXRBdHRyaWJ1dGUoa2V5QXR0cikpLm1hcChrZXlBdHRyID0+IFtrZXlBdHRyLCBlbGVtLmdldEF0dHJpYnV0ZShrZXlBdHRyKV0pCiAgICAgIDogbnVsbDsKCiAgaWYgKGtleUF0dHJQYWlycyAmJiBrZXlBdHRyUGFpcnMubGVuZ3RoKSB7CiAgICBrZXlBdHRyUGFpcnMuZm9yRWFjaChrZXlBdHRyUGFpciA9PiB7CiAgICAgIG91dC5wdXNoKGBbJHtrZXlBdHRyUGFpclswXX09IiR7a2V5QXR0clBhaXJbMV19Il1gKTsKICAgIH0pOwogIH0gZWxzZSB7CiAgICBpZiAoZWxlbS5pZCkgewogICAgICBvdXQucHVzaChgIyR7ZWxlbS5pZH1gKTsKICAgIH0KCiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0CiAgICBjbGFzc05hbWUgPSBlbGVtLmNsYXNzTmFtZTsKICAgIGlmIChjbGFzc05hbWUgJiYgaXNTdHJpbmcoY2xhc3NOYW1lKSkgewogICAgICBjbGFzc2VzID0gY2xhc3NOYW1lLnNwbGl0KC9ccysvKTsKICAgICAgZm9yIChpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBvdXQucHVzaChgLiR7Y2xhc3Nlc1tpXX1gKTsKICAgICAgfQogICAgfQogIH0KICBjb25zdCBhbGxvd2VkQXR0cnMgPSBbJ2FyaWEtbGFiZWwnLCAndHlwZScsICduYW1lJywgJ3RpdGxlJywgJ2FsdCddOwogIGZvciAoaSA9IDA7IGkgPCBhbGxvd2VkQXR0cnMubGVuZ3RoOyBpKyspIHsKICAgIGtleSA9IGFsbG93ZWRBdHRyc1tpXTsKICAgIGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShrZXkpOwogICAgaWYgKGF0dHIpIHsKICAgICAgb3V0LnB1c2goYFske2tleX09IiR7YXR0cn0iXWApOwogICAgfQogIH0KICByZXR1cm4gb3V0LmpvaW4oJycpOwp9CgovKioKICogVGhpcyBzZXJ2ZXMgYXMgYSBidWlsZCB0aW1lIGZsYWcgdGhhdCB3aWxsIGJlIHRydWUgYnkgZGVmYXVsdCwgYnV0IGZhbHNlIGluIG5vbi1kZWJ1ZyBidWlsZHMgb3IgaWYgdXNlcnMgcmVwbGFjZSBgX19TRU5UUllfREVCVUdfX2AgaW4gdGhlaXIgZ2VuZXJhdGVkIGNvZGUuCiAqCiAqIEFUVEVOVElPTjogVGhpcyBjb25zdGFudCBtdXN0IG5ldmVyIGNyb3NzIHBhY2thZ2UgYm91bmRhcmllcyAoaS5lLiBiZSBleHBvcnRlZCkgdG8gZ3VhcmFudGVlIHRoYXQgaXQgY2FuIGJlIHVzZWQgZm9yIHRyZWUgc2hha2luZy4KICovCmNvbnN0IERFQlVHX0JVSUxEJDEgPSAodHlwZW9mIF9fU0VOVFJZX0RFQlVHX18gPT09ICd1bmRlZmluZWQnIHx8IF9fU0VOVFJZX0RFQlVHX18pOwoKLyoqIFByZWZpeCBmb3IgbG9nZ2luZyBzdHJpbmdzICovCmNvbnN0IFBSRUZJWCA9ICdTZW50cnkgTG9nZ2VyICc7Cgpjb25zdCBDT05TT0xFX0xFVkVMUyA9IFsKICAnZGVidWcnLAogICdpbmZvJywKICAnd2FybicsCiAgJ2Vycm9yJywKICAnbG9nJywKICAnYXNzZXJ0JywKICAndHJhY2UnLApdIDsKCi8qKiBUaGlzIG1heSBiZSBtdXRhdGVkIGJ5IHRoZSBjb25zb2xlIGluc3RydW1lbnRhdGlvbi4gKi8KY29uc3Qgb3JpZ2luYWxDb25zb2xlTWV0aG9kcwoKID0ge307CgovKiogSlNEb2MgKi8KCi8qKgogKiBUZW1wb3JhcmlseSBkaXNhYmxlIHNlbnRyeSBjb25zb2xlIGluc3RydW1lbnRhdGlvbnMuCiAqCiAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gcnVuIGFnYWluc3QgdGhlIG9yaWdpbmFsIGBjb25zb2xlYCBtZXNzYWdlcwogKiBAcmV0dXJucyBUaGUgcmVzdWx0cyBvZiB0aGUgY2FsbGJhY2sKICovCmZ1bmN0aW9uIGNvbnNvbGVTYW5kYm94KGNhbGxiYWNrKSB7CiAgaWYgKCEoJ2NvbnNvbGUnIGluIEdMT0JBTF9PQkopKSB7CiAgICByZXR1cm4gY2FsbGJhY2soKTsKICB9CgogIGNvbnN0IGNvbnNvbGUgPSBHTE9CQUxfT0JKLmNvbnNvbGUgOwogIGNvbnN0IHdyYXBwZWRGdW5jcyA9IHt9OwoKICBjb25zdCB3cmFwcGVkTGV2ZWxzID0gT2JqZWN0LmtleXMob3JpZ2luYWxDb25zb2xlTWV0aG9kcykgOwoKICAvLyBSZXN0b3JlIGFsbCB3cmFwcGVkIGNvbnNvbGUgbWV0aG9kcwogIHdyYXBwZWRMZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7CiAgICBjb25zdCBvcmlnaW5hbENvbnNvbGVNZXRob2QgPSBvcmlnaW5hbENvbnNvbGVNZXRob2RzW2xldmVsXSA7CiAgICB3cmFwcGVkRnVuY3NbbGV2ZWxdID0gY29uc29sZVtsZXZlbF0gOwogICAgY29uc29sZVtsZXZlbF0gPSBvcmlnaW5hbENvbnNvbGVNZXRob2Q7CiAgfSk7CgogIHRyeSB7CiAgICByZXR1cm4gY2FsbGJhY2soKTsKICB9IGZpbmFsbHkgewogICAgLy8gUmV2ZXJ0IHJlc3RvcmF0aW9uIHRvIHdyYXBwZWQgc3RhdGUKICAgIHdyYXBwZWRMZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7CiAgICAgIGNvbnNvbGVbbGV2ZWxdID0gd3JhcHBlZEZ1bmNzW2xldmVsXSA7CiAgICB9KTsKICB9Cn0KCmZ1bmN0aW9uIG1ha2VMb2dnZXIoKSB7CiAgbGV0IGVuYWJsZWQgPSBmYWxzZTsKICBjb25zdCBsb2dnZXIgPSB7CiAgICBlbmFibGU6ICgpID0+IHsKICAgICAgZW5hYmxlZCA9IHRydWU7CiAgICB9LAogICAgZGlzYWJsZTogKCkgPT4gewogICAgICBlbmFibGVkID0gZmFsc2U7CiAgICB9LAogICAgaXNFbmFibGVkOiAoKSA9PiBlbmFibGVkLAogIH07CgogIGlmIChERUJVR19CVUlMRCQxKSB7CiAgICBDT05TT0xFX0xFVkVMUy5mb3JFYWNoKG5hbWUgPT4gewogICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueQogICAgICBsb2dnZXJbbmFtZV0gPSAoLi4uYXJncykgPT4gewogICAgICAgIGlmIChlbmFibGVkKSB7CiAgICAgICAgICBjb25zb2xlU2FuZGJveCgoKSA9PiB7CiAgICAgICAgICAgIEdMT0JBTF9PQkouY29uc29sZVtuYW1lXShgJHtQUkVGSVh9WyR7bmFtZX1dOmAsIC4uLmFyZ3MpOwogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICB9OwogICAgfSk7CiAgfSBlbHNlIHsKICAgIENPTlNPTEVfTEVWRUxTLmZvckVhY2gobmFtZSA9PiB7CiAgICAgIGxvZ2dlcltuYW1lXSA9ICgpID0+IHVuZGVmaW5lZDsKICAgIH0pOwogIH0KCiAgcmV0dXJuIGxvZ2dlciA7Cn0KCmNvbnN0IGxvZ2dlciA9IG1ha2VMb2dnZXIoKTsKCi8qKgogKiBSZW5kZXJzIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEc24uCiAqCiAqIEJ5IGRlZmF1bHQsIHRoaXMgd2lsbCByZW5kZXIgdGhlIHB1YmxpYyByZXByZXNlbnRhdGlvbiB3aXRob3V0IHRoZSBwYXNzd29yZAogKiBjb21wb25lbnQuIFRvIGdldCB0aGUgZGVwcmVjYXRlZCBwcml2YXRlIHJlcHJlc2VudGF0aW9uLCBzZXQgYHdpdGhQYXNzd29yZGAKICogdG8gdHJ1ZS4KICoKICogQHBhcmFtIHdpdGhQYXNzd29yZCBXaGVuIHNldCB0byB0cnVlLCB0aGUgcGFzc3dvcmQgd2lsbCBiZSBpbmNsdWRlZC4KICovCmZ1bmN0aW9uIGRzblRvU3RyaW5nKGRzbiwgd2l0aFBhc3N3b3JkID0gZmFsc2UpIHsKICBjb25zdCB7IGhvc3QsIHBhdGgsIHBhc3MsIHBvcnQsIHByb2plY3RJZCwgcHJvdG9jb2wsIHB1YmxpY0tleSB9ID0gZHNuOwogIHJldHVybiAoCiAgICBgJHtwcm90b2NvbH06Ly8ke3B1YmxpY0tleX0ke3dpdGhQYXNzd29yZCAmJiBwYXNzID8gYDoke3Bhc3N9YCA6ICcnfWAgKwogICAgYEAke2hvc3R9JHtwb3J0ID8gYDoke3BvcnR9YCA6ICcnfS8ke3BhdGggPyBgJHtwYXRofS9gIDogcGF0aH0ke3Byb2plY3RJZH1gCiAgKTsKfQoKLyoqIEFuIGVycm9yIGVtaXR0ZWQgYnkgU2VudHJ5IFNES3MgYW5kIHJlbGF0ZWQgdXRpbGl0aWVzLiAqLwpjbGFzcyBTZW50cnlFcnJvciBleHRlbmRzIEVycm9yIHsKICAvKiogRGlzcGxheSBuYW1lIG9mIHRoaXMgZXJyb3IgaW5zdGFuY2UuICovCgogICBjb25zdHJ1Y3RvciggbWVzc2FnZSwgbG9nTGV2ZWwgPSAnd2FybicpIHsKICAgIHN1cGVyKG1lc3NhZ2UpO3RoaXMubWVzc2FnZSA9IG1lc3NhZ2U7CiAgICB0aGlzLm5hbWUgPSBuZXcudGFyZ2V0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lOwogICAgLy8gVGhpcyBzZXRzIHRoZSBwcm90b3R5cGUgdG8gYmUgYEVycm9yYCwgbm90IGBTZW50cnlFcnJvcmAuIEl0J3MgdW5jbGVhciB3aHkgd2UgZG8gdGhpcywgYnV0IGNvbW1lbnRpbmcgdGhpcyBsaW5lCiAgICAvLyBvdXQgY2F1c2VzIHZhcmlvdXMgKHNlZW1pbmdseSB0b3RhbGx5IHVucmVsYXRlZCkgcGxheXdyaWdodCB0ZXN0cyBjb25zaXN0ZW50bHkgdGltZSBvdXQuIEZZSSwgdGhpcyBtYWtlcwogICAgLy8gaW5zdGFuY2VzIG9mIGBTZW50cnlFcnJvcmAgZmFpbCBgb2JqIGluc3RhbmNlb2YgU2VudHJ5RXJyb3JgIGNoZWNrcy4KICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7CiAgICB0aGlzLmxvZ0xldmVsID0gbG9nTGV2ZWw7CiAgfQp9CgovKioKICogRW5jb2RlcyBnaXZlbiBvYmplY3QgaW50byB1cmwtZnJpZW5kbHkgZm9ybWF0CiAqCiAqIEBwYXJhbSBvYmplY3QgQW4gb2JqZWN0IHRoYXQgY29udGFpbnMgc2VyaWFsaXphYmxlIHZhbHVlcwogKiBAcmV0dXJucyBzdHJpbmcgRW5jb2RlZAogKi8KZnVuY3Rpb24gdXJsRW5jb2RlKG9iamVjdCkgewogIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpCiAgICAubWFwKGtleSA9PiBgJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX09JHtlbmNvZGVVUklDb21wb25lbnQob2JqZWN0W2tleV0pfWApCiAgICAuam9pbignJicpOwp9CgovKioKICogVHJhbnNmb3JtcyBhbnkgYEVycm9yYCBvciBgRXZlbnRgIGludG8gYSBwbGFpbiBvYmplY3Qgd2l0aCBhbGwgb2YgdGhlaXIgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLCBhbmQgc29tZSBvZiB0aGVpcgogKiBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGF0dGFjaGVkLgogKgogKiBAcGFyYW0gdmFsdWUgSW5pdGlhbCBzb3VyY2UgdGhhdCB3ZSBoYXZlIHRvIHRyYW5zZm9ybSBpbiBvcmRlciBmb3IgaXQgdG8gYmUgdXNhYmxlIGJ5IHRoZSBzZXJpYWxpemVyCiAqIEByZXR1cm5zIEFuIEV2ZW50IG9yIEVycm9yIHR1cm5lZCBpbnRvIGFuIG9iamVjdCAtIG9yIHRoZSB2YWx1ZSBhcmd1cm1lbnQgaXRzZWxmLCB3aGVuIHZhbHVlIGlzIG5laXRoZXIgYW4gRXZlbnQgbm9yCiAqICBhbiBFcnJvci4KICovCmZ1bmN0aW9uIGNvbnZlcnRUb1BsYWluT2JqZWN0KAogIHZhbHVlLAopCgogewogIGlmIChpc0Vycm9yKHZhbHVlKSkgewogICAgcmV0dXJuIHsKICAgICAgbWVzc2FnZTogdmFsdWUubWVzc2FnZSwKICAgICAgbmFtZTogdmFsdWUubmFtZSwKICAgICAgc3RhY2s6IHZhbHVlLnN0YWNrLAogICAgICAuLi5nZXRPd25Qcm9wZXJ0aWVzKHZhbHVlKSwKICAgIH07CiAgfSBlbHNlIGlmIChpc0V2ZW50KHZhbHVlKSkgewogICAgY29uc3QgbmV3T2JqCgogPSB7CiAgICAgIHR5cGU6IHZhbHVlLnR5cGUsCiAgICAgIHRhcmdldDogc2VyaWFsaXplRXZlbnRUYXJnZXQodmFsdWUudGFyZ2V0KSwKICAgICAgY3VycmVudFRhcmdldDogc2VyaWFsaXplRXZlbnRUYXJnZXQodmFsdWUuY3VycmVudFRhcmdldCksCiAgICAgIC4uLmdldE93blByb3BlcnRpZXModmFsdWUpLAogICAgfTsKCiAgICBpZiAodHlwZW9mIEN1c3RvbUV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpc0luc3RhbmNlT2YodmFsdWUsIEN1c3RvbUV2ZW50KSkgewogICAgICBuZXdPYmouZGV0YWlsID0gdmFsdWUuZGV0YWlsOwogICAgfQoKICAgIHJldHVybiBuZXdPYmo7CiAgfSBlbHNlIHsKICAgIHJldHVybiB2YWx1ZTsKICB9Cn0KCi8qKiBDcmVhdGVzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0YXJnZXQgb2YgYW4gYEV2ZW50YCBvYmplY3QgKi8KZnVuY3Rpb24gc2VyaWFsaXplRXZlbnRUYXJnZXQodGFyZ2V0KSB7CiAgdHJ5IHsKICAgIHJldHVybiBpc0VsZW1lbnQodGFyZ2V0KSA/IGh0bWxUcmVlQXNTdHJpbmcodGFyZ2V0KSA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YXJnZXQpOwogIH0gY2F0Y2ggKF9vTykgewogICAgcmV0dXJuICc8dW5rbm93bj4nOwogIH0KfQoKLyoqIEZpbHRlcnMgb3V0IGFsbCBidXQgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMgKi8KZnVuY3Rpb24gZ2V0T3duUHJvcGVydGllcyhvYmopIHsKICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7CiAgICBjb25zdCBleHRyYWN0ZWRQcm9wcyA9IHt9OwogICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBvYmopIHsKICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3BlcnR5KSkgewogICAgICAgIGV4dHJhY3RlZFByb3BzW3Byb3BlcnR5XSA9IChvYmogKVtwcm9wZXJ0eV07CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBleHRyYWN0ZWRQcm9wczsKICB9IGVsc2UgewogICAgcmV0dXJuIHt9OwogIH0KfQoKLyoqCiAqIEdpdmVuIGFueSBvYmplY3QsIHJldHVybiBhIG5ldyBvYmplY3QgaGF2aW5nIHJlbW92ZWQgYWxsIGZpZWxkcyB3aG9zZSB2YWx1ZSB3YXMgYHVuZGVmaW5lZGAuCiAqIFdvcmtzIHJlY3Vyc2l2ZWx5IG9uIG9iamVjdHMgYW5kIGFycmF5cy4KICoKICogQXR0ZW50aW9uOiBUaGlzIGZ1bmN0aW9uIGtlZXBzIGNpcmN1bGFyIHJlZmVyZW5jZXMgaW4gdGhlIHJldHVybmVkIG9iamVjdC4KICovCmZ1bmN0aW9uIGRyb3BVbmRlZmluZWRLZXlzKGlucHV0VmFsdWUpIHsKICAvLyBUaGlzIG1hcCBrZWVwcyB0cmFjayBvZiB3aGF0IGFscmVhZHkgdmlzaXRlZCBub2RlcyBtYXAgdG8uCiAgLy8gT3VyIFNldCAtIGJhc2VkIG1lbW9CdWlsZGVyIGRvZXNuJ3Qgd29yayBoZXJlIGJlY2F1c2Ugd2Ugd2FudCB0byB0aGUgb3V0cHV0IG9iamVjdCB0byBoYXZlIHRoZSBzYW1lIGNpcmN1bGFyCiAgLy8gcmVmZXJlbmNlcyBhcyB0aGUgaW5wdXQgb2JqZWN0LgogIGNvbnN0IG1lbW9pemF0aW9uTWFwID0gbmV3IE1hcCgpOwoKICAvLyBUaGlzIGZ1bmN0aW9uIGp1c3QgcHJveGllcyBgX2Ryb3BVbmRlZmluZWRLZXlzYCB0byBrZWVwIHRoZSBgbWVtb0J1aWxkZXJgIG91dCBvZiB0aGlzIGZ1bmN0aW9uJ3MgQVBJCiAgcmV0dXJuIF9kcm9wVW5kZWZpbmVkS2V5cyhpbnB1dFZhbHVlLCBtZW1vaXphdGlvbk1hcCk7Cn0KCmZ1bmN0aW9uIF9kcm9wVW5kZWZpbmVkS2V5cyhpbnB1dFZhbHVlLCBtZW1vaXphdGlvbk1hcCkgewogIGlmIChpc1Bvam8oaW5wdXRWYWx1ZSkpIHsKICAgIC8vIElmIHRoaXMgbm9kZSBoYXMgYWxyZWFkeSBiZWVuIHZpc2l0ZWQgZHVlIHRvIGEgY2lyY3VsYXIgcmVmZXJlbmNlLCByZXR1cm4gdGhlIG9iamVjdCBpdCB3YXMgbWFwcGVkIHRvIGluIHRoZSBuZXcgb2JqZWN0CiAgICBjb25zdCBtZW1vVmFsID0gbWVtb2l6YXRpb25NYXAuZ2V0KGlucHV0VmFsdWUpOwogICAgaWYgKG1lbW9WYWwgIT09IHVuZGVmaW5lZCkgewogICAgICByZXR1cm4gbWVtb1ZhbCA7CiAgICB9CgogICAgY29uc3QgcmV0dXJuVmFsdWUgPSB7fTsKICAgIC8vIFN0b3JlIHRoZSBtYXBwaW5nIG9mIHRoaXMgdmFsdWUgaW4gY2FzZSB3ZSB2aXNpdCBpdCBhZ2FpbiwgaW4gY2FzZSBvZiBjaXJjdWxhciBkYXRhCiAgICBtZW1vaXphdGlvbk1hcC5zZXQoaW5wdXRWYWx1ZSwgcmV0dXJuVmFsdWUpOwoKICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGlucHV0VmFsdWUpKSB7CiAgICAgIGlmICh0eXBlb2YgaW5wdXRWYWx1ZVtrZXldICE9PSAndW5kZWZpbmVkJykgewogICAgICAgIHJldHVyblZhbHVlW2tleV0gPSBfZHJvcFVuZGVmaW5lZEtleXMoaW5wdXRWYWx1ZVtrZXldLCBtZW1vaXphdGlvbk1hcCk7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gcmV0dXJuVmFsdWUgOwogIH0KCiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXRWYWx1ZSkpIHsKICAgIC8vIElmIHRoaXMgbm9kZSBoYXMgYWxyZWFkeSBiZWVuIHZpc2l0ZWQgZHVlIHRvIGEgY2lyY3VsYXIgcmVmZXJlbmNlLCByZXR1cm4gdGhlIGFycmF5IGl0IHdhcyBtYXBwZWQgdG8gaW4gdGhlIG5ldyBvYmplY3QKICAgIGNvbnN0IG1lbW9WYWwgPSBtZW1vaXphdGlvbk1hcC5nZXQoaW5wdXRWYWx1ZSk7CiAgICBpZiAobWVtb1ZhbCAhPT0gdW5kZWZpbmVkKSB7CiAgICAgIHJldHVybiBtZW1vVmFsIDsKICAgIH0KCiAgICBjb25zdCByZXR1cm5WYWx1ZSA9IFtdOwogICAgLy8gU3RvcmUgdGhlIG1hcHBpbmcgb2YgdGhpcyB2YWx1ZSBpbiBjYXNlIHdlIHZpc2l0IGl0IGFnYWluLCBpbiBjYXNlIG9mIGNpcmN1bGFyIGRhdGEKICAgIG1lbW9pemF0aW9uTWFwLnNldChpbnB1dFZhbHVlLCByZXR1cm5WYWx1ZSk7CgogICAgaW5wdXRWYWx1ZS5mb3JFYWNoKChpdGVtKSA9PiB7CiAgICAgIHJldHVyblZhbHVlLnB1c2goX2Ryb3BVbmRlZmluZWRLZXlzKGl0ZW0sIG1lbW9pemF0aW9uTWFwKSk7CiAgICB9KTsKCiAgICByZXR1cm4gcmV0dXJuVmFsdWUgOwogIH0KCiAgcmV0dXJuIGlucHV0VmFsdWU7Cn0KCmZ1bmN0aW9uIGlzUG9qbyhpbnB1dCkgewogIGlmICghaXNQbGFpbk9iamVjdChpbnB1dCkpIHsKICAgIHJldHVybiBmYWxzZTsKICB9CgogIHRyeSB7CiAgICBjb25zdCBuYW1lID0gKE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnB1dCkgKS5jb25zdHJ1Y3Rvci5uYW1lOwogICAgcmV0dXJuICFuYW1lIHx8IG5hbWUgPT09ICdPYmplY3QnOwogIH0gY2F0Y2ggKGUpIHsKICAgIHJldHVybiB0cnVlOwogIH0KfQoKLyoqCiAqIERvZXMgdGhpcyBmaWxlbmFtZSBsb29rIGxpa2UgaXQncyBwYXJ0IG9mIHRoZSBhcHAgY29kZT8KICovCmZ1bmN0aW9uIGZpbGVuYW1lSXNJbkFwcChmaWxlbmFtZSwgaXNOYXRpdmUgPSBmYWxzZSkgewogIGNvbnN0IGlzSW50ZXJuYWwgPQogICAgaXNOYXRpdmUgfHwKICAgIChmaWxlbmFtZSAmJgogICAgICAvLyBJdCdzIG5vdCBpbnRlcm5hbCBpZiBpdCdzIGFuIGFic29sdXRlIGxpbnV4IHBhdGgKICAgICAgIWZpbGVuYW1lLnN0YXJ0c1dpdGgoJy8nKSAmJgogICAgICAvLyBJdCdzIG5vdCBpbnRlcm5hbCBpZiBpdCdzIGFuIGFic29sdXRlIHdpbmRvd3MgcGF0aAogICAgICAhZmlsZW5hbWUubWF0Y2goL15bQS1aXTovKSAmJgogICAgICAvLyBJdCdzIG5vdCBpbnRlcm5hbCBpZiB0aGUgcGF0aCBpcyBzdGFydGluZyB3aXRoIGEgZG90CiAgICAgICFmaWxlbmFtZS5zdGFydHNXaXRoKCcuJykgJiYKICAgICAgLy8gSXQncyBub3QgaW50ZXJuYWwgaWYgdGhlIGZyYW1lIGhhcyBhIHByb3RvY29sLiBJbiBub2RlLCB0aGlzIGlzIHVzdWFsbHkgdGhlIGNhc2UgaWYgdGhlIGZpbGUgZ290IHByZS1wcm9jZXNzZWQgd2l0aCBhIGJ1bmRsZXIgbGlrZSB3ZWJwYWNrCiAgICAgICFmaWxlbmFtZS5tYXRjaCgvXlthLXpBLVpdKFthLXpBLVowLTkuXC0rXSkqOlwvXC8vKSk7IC8vIFNjaGVtYSBmcm9tOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzY0MTc4MgoKICAvLyBpbl9hcHAgaXMgYWxsIHRoYXQncyBub3QgYW4gaW50ZXJuYWwgTm9kZSBmdW5jdGlvbiBvciBhIG1vZHVsZSB3aXRoaW4gbm9kZV9tb2R1bGVzCiAgLy8gbm90ZSB0aGF0IGlzTmF0aXZlIGFwcGVhcnMgdG8gcmV0dXJuIHRydWUgZXZlbiBmb3Igbm9kZSBjb3JlIGxpYnJhcmllcwogIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3JhdmVuLW5vZGUvaXNzdWVzLzE3NgoKICByZXR1cm4gIWlzSW50ZXJuYWwgJiYgZmlsZW5hbWUgIT09IHVuZGVmaW5lZCAmJiAhZmlsZW5hbWUuaW5jbHVkZXMoJ25vZGVfbW9kdWxlcy8nKTsKfQoKY29uc3QgU1RBQ0tUUkFDRV9GUkFNRV9MSU1JVCA9IDUwOwpjb25zdCBTVFJJUF9GUkFNRV9SRUdFWFAgPSAvY2FwdHVyZU1lc3NhZ2V8Y2FwdHVyZUV4Y2VwdGlvbi87CgovKioKICogUmVtb3ZlcyBTZW50cnkgZnJhbWVzIGZyb20gdGhlIHRvcCBhbmQgYm90dG9tIG9mIHRoZSBzdGFjayBpZiBwcmVzZW50IGFuZCBlbmZvcmNlcyBhIGxpbWl0IG9mIG1heCBudW1iZXIgb2YgZnJhbWVzLgogKiBBc3N1bWVzIHN0YWNrIGlucHV0IGlzIG9yZGVyZWQgZnJvbSB0b3AgdG8gYm90dG9tIGFuZCByZXR1cm5zIHRoZSByZXZlcnNlIHJlcHJlc2VudGF0aW9uIHNvIGNhbGwgc2l0ZSBvZiB0aGUKICogZnVuY3Rpb24gdGhhdCBjYXVzZWQgdGhlIGNyYXNoIGlzIHRoZSBsYXN0IGZyYW1lIGluIHRoZSBhcnJheS4KICogQGhpZGRlbgogKi8KZnVuY3Rpb24gc3RyaXBTZW50cnlGcmFtZXNBbmRSZXZlcnNlKHN0YWNrKSB7CiAgaWYgKCFzdGFjay5sZW5ndGgpIHsKICAgIHJldHVybiBbXTsKICB9CgogIGNvbnN0IGxvY2FsU3RhY2sgPSBBcnJheS5mcm9tKHN0YWNrKTsKCiAgLy8gSWYgc3RhY2sgc3RhcnRzIHdpdGggb25lIG9mIG91ciBBUEkgY2FsbHMsIHJlbW92ZSBpdCAoc3RhcnRzLCBtZWFuaW5nIGl0J3MgdGhlIHRvcCBvZiB0aGUgc3RhY2sgLSBha2EgbGFzdCBjYWxsKQogIGlmICgvc2VudHJ5V3JhcHBlZC8udGVzdChsb2NhbFN0YWNrW2xvY2FsU3RhY2subGVuZ3RoIC0gMV0uZnVuY3Rpb24gfHwgJycpKSB7CiAgICBsb2NhbFN0YWNrLnBvcCgpOwogIH0KCiAgLy8gUmV2ZXJzaW5nIGluIHRoZSBtaWRkbGUgb2YgdGhlIHByb2NlZHVyZSBhbGxvd3MgdXMgdG8ganVzdCBwb3AgdGhlIHZhbHVlcyBvZmYgdGhlIHN0YWNrCiAgbG9jYWxTdGFjay5yZXZlcnNlKCk7CgogIC8vIElmIHN0YWNrIGVuZHMgd2l0aCBvbmUgb2Ygb3VyIGludGVybmFsIEFQSSBjYWxscywgcmVtb3ZlIGl0IChlbmRzLCBtZWFuaW5nIGl0J3MgdGhlIGJvdHRvbSBvZiB0aGUgc3RhY2sgLSBha2EgdG9wLW1vc3QgY2FsbCkKICBpZiAoU1RSSVBfRlJBTUVfUkVHRVhQLnRlc3QobG9jYWxTdGFja1tsb2NhbFN0YWNrLmxlbmd0aCAtIDFdLmZ1bmN0aW9uIHx8ICcnKSkgewogICAgbG9jYWxTdGFjay5wb3AoKTsKCiAgICAvLyBXaGVuIHVzaW5nIHN5bnRoZXRpYyBldmVudHMsIHdlIHdpbGwgaGF2ZSBhIDIgbGV2ZWxzIGRlZXAgc3RhY2ssIGFzIGBuZXcgRXJyb3IoJ1NlbnRyeSBzeW50aGV0aWNFeGNlcHRpb24nKWAKICAgIC8vIGlzIHByb2R1Y2VkIHdpdGhpbiB0aGUgaHViIGl0c2VsZiwgbWFraW5nIGl0OgogICAgLy8KICAgIC8vICAgU2VudHJ5LmNhcHR1cmVFeGNlcHRpb24oKQogICAgLy8gICBnZXRDdXJyZW50SHViKCkuY2FwdHVyZUV4Y2VwdGlvbigpCiAgICAvLwogICAgLy8gaW5zdGVhZCBvZiBqdXN0IHRoZSB0b3AgYFNlbnRyeWAgY2FsbCBpdHNlbGYuCiAgICAvLyBUaGlzIGZvcmNlcyB1cyB0byBwb3NzaWJseSBzdHJpcCBhbiBhZGRpdGlvbmFsIGZyYW1lIGluIHRoZSBleGFjdCBzYW1lIHdhcyBhcyBhYm92ZS4KICAgIGlmIChTVFJJUF9GUkFNRV9SRUdFWFAudGVzdChsb2NhbFN0YWNrW2xvY2FsU3RhY2subGVuZ3RoIC0gMV0uZnVuY3Rpb24gfHwgJycpKSB7CiAgICAgIGxvY2FsU3RhY2sucG9wKCk7CiAgICB9CiAgfQoKICByZXR1cm4gbG9jYWxTdGFjay5zbGljZSgwLCBTVEFDS1RSQUNFX0ZSQU1FX0xJTUlUKS5tYXAoZnJhbWUgPT4gKHsKICAgIC4uLmZyYW1lLAogICAgZmlsZW5hbWU6IGZyYW1lLmZpbGVuYW1lIHx8IGxvY2FsU3RhY2tbbG9jYWxTdGFjay5sZW5ndGggLSAxXS5maWxlbmFtZSwKICAgIGZ1bmN0aW9uOiBmcmFtZS5mdW5jdGlvbiB8fCAnPycsCiAgfSkpOwp9Cgpjb25zdCBkZWZhdWx0RnVuY3Rpb25OYW1lID0gJzxhbm9ueW1vdXM+JzsKCi8qKgogKiBTYWZlbHkgZXh0cmFjdCBmdW5jdGlvbiBuYW1lIGZyb20gaXRzZWxmCiAqLwpmdW5jdGlvbiBnZXRGdW5jdGlvbk5hbWUoZm4pIHsKICB0cnkgewogICAgaWYgKCFmbiB8fCB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHsKICAgICAgcmV0dXJuIGRlZmF1bHRGdW5jdGlvbk5hbWU7CiAgICB9CiAgICByZXR1cm4gZm4ubmFtZSB8fCBkZWZhdWx0RnVuY3Rpb25OYW1lOwogIH0gY2F0Y2ggKGUpIHsKICAgIC8vIEp1c3QgYWNjZXNzaW5nIGN1c3RvbSBwcm9wcyBpbiBzb21lIFNlbGVuaXVtIGVudmlyb25tZW50cwogICAgLy8gY2FuIGNhdXNlIGEgIlBlcm1pc3Npb24gZGVuaWVkIiBleGNlcHRpb24gKHNlZSByYXZlbi1qcyM0OTUpLgogICAgcmV0dXJuIGRlZmF1bHRGdW5jdGlvbk5hbWU7CiAgfQp9CgovKioKICogVVVJRDQgZ2VuZXJhdG9yCiAqCiAqIEByZXR1cm5zIHN0cmluZyBHZW5lcmF0ZWQgVVVJRDQuCiAqLwpmdW5jdGlvbiB1dWlkNCgpIHsKICBjb25zdCBnYmwgPSBHTE9CQUxfT0JKIDsKICBjb25zdCBjcnlwdG8gPSBnYmwuY3J5cHRvIHx8IGdibC5tc0NyeXB0bzsKCiAgbGV0IGdldFJhbmRvbUJ5dGUgPSAoKSA9PiBNYXRoLnJhbmRvbSgpICogMTY7CiAgdHJ5IHsKICAgIGlmIChjcnlwdG8gJiYgY3J5cHRvLnJhbmRvbVVVSUQpIHsKICAgICAgcmV0dXJuIGNyeXB0by5yYW5kb21VVUlEKCkucmVwbGFjZSgvLS9nLCAnJyk7CiAgICB9CiAgICBpZiAoY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHsKICAgICAgZ2V0UmFuZG9tQnl0ZSA9ICgpID0+IHsKICAgICAgICAvLyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG1pZ2h0IHJldHVybiB1bmRlZmluZWQgaW5zdGVhZCBvZiB0aGUgdHlwZWQgYXJyYXkKICAgICAgICAvLyBpbiBvbGQgQ2hyb21pdW0gdmVyc2lvbnMgKGUuZy4gMjMuMC4xMjM1LjAgKDE1MTQyMikpCiAgICAgICAgLy8gSG93ZXZlciwgYHR5cGVkQXJyYXlgIGlzIHN0aWxsIGZpbGxlZCBpbi1wbGFjZS4KICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DcnlwdG8vZ2V0UmFuZG9tVmFsdWVzI3R5cGVkYXJyYXkKICAgICAgICBjb25zdCB0eXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMSk7CiAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh0eXBlZEFycmF5KTsKICAgICAgICByZXR1cm4gdHlwZWRBcnJheVswXTsKICAgICAgfTsKICAgIH0KICB9IGNhdGNoIChfKSB7CiAgICAvLyBzb21lIHJ1bnRpbWVzIGNhbiBjcmFzaCBpbnZva2luZyBjcnlwdG8KICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvaXNzdWVzLzg5MzUKICB9CgogIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2hvdy10by1jcmVhdGUtYS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdC8yMTE3NTIzIzIxMTc1MjMKICAvLyBDb25jYXRlbmF0aW5nIHRoZSBmb2xsb3dpbmcgbnVtYmVycyBhcyBzdHJpbmdzIHJlc3VsdHMgaW4gJzEwMDAwMDAwMTAwMDQwMDA4MDAwMTAwMDAwMDAwMDAwJwogIHJldHVybiAoKFsxZTddICkgKyAxZTMgKyA0ZTMgKyA4ZTMgKyAxZTExKS5yZXBsYWNlKC9bMDE4XS9nLCBjID0+CiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZQogICAgKChjICkgXiAoKGdldFJhbmRvbUJ5dGUoKSAmIDE1KSA+PiAoKGMgKSAvIDQpKSkudG9TdHJpbmcoMTYpLAogICk7Cn0KCi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyAqLwovKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovCgovKioKICogSGVscGVyIHRvIGRlY3ljbGUganNvbiBvYmplY3RzCiAqLwpmdW5jdGlvbiBtZW1vQnVpbGRlcigpIHsKICBjb25zdCBoYXNXZWFrU2V0ID0gdHlwZW9mIFdlYWtTZXQgPT09ICdmdW5jdGlvbic7CiAgY29uc3QgaW5uZXIgPSBoYXNXZWFrU2V0ID8gbmV3IFdlYWtTZXQoKSA6IFtdOwogIGZ1bmN0aW9uIG1lbW9pemUob2JqKSB7CiAgICBpZiAoaGFzV2Vha1NldCkgewogICAgICBpZiAoaW5uZXIuaGFzKG9iaikpIHsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQogICAgICBpbm5lci5hZGQob2JqKTsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItZm9yLW9mCiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlubmVyLmxlbmd0aDsgaSsrKSB7CiAgICAgIGNvbnN0IHZhbHVlID0gaW5uZXJbaV07CiAgICAgIGlmICh2YWx1ZSA9PT0gb2JqKSB7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KICAgIH0KICAgIGlubmVyLnB1c2gob2JqKTsKICAgIHJldHVybiBmYWxzZTsKICB9CgogIGZ1bmN0aW9uIHVubWVtb2l6ZShvYmopIHsKICAgIGlmIChoYXNXZWFrU2V0KSB7CiAgICAgIGlubmVyLmRlbGV0ZShvYmopOwogICAgfSBlbHNlIHsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbm5lci5sZW5ndGg7IGkrKykgewogICAgICAgIGlmIChpbm5lcltpXSA9PT0gb2JqKSB7CiAgICAgICAgICBpbm5lci5zcGxpY2UoaSwgMSk7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9CiAgcmV0dXJuIFttZW1vaXplLCB1bm1lbW9pemVdOwp9CgovKioKICogUmVjdXJzaXZlbHkgbm9ybWFsaXplcyB0aGUgZ2l2ZW4gb2JqZWN0LgogKgogKiAtIENyZWF0ZXMgYSBjb3B5IHRvIHByZXZlbnQgb3JpZ2luYWwgaW5wdXQgbXV0YXRpb24KICogLSBTa2lwcyBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzCiAqIC0gV2hlbiBzdHJpbmdpZnlpbmcsIGNhbGxzIGB0b0pTT05gIGlmIGltcGxlbWVudGVkCiAqIC0gUmVtb3ZlcyBjaXJjdWxhciByZWZlcmVuY2VzCiAqIC0gVHJhbnNsYXRlcyBub24tc2VyaWFsaXphYmxlIHZhbHVlcyAoYHVuZGVmaW5lZGAvYE5hTmAvZnVuY3Rpb25zKSB0byBzZXJpYWxpemFibGUgZm9ybWF0CiAqIC0gVHJhbnNsYXRlcyBrbm93biBnbG9iYWwgb2JqZWN0cy9jbGFzc2VzIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9ucwogKiAtIFRha2VzIGNhcmUgb2YgYEVycm9yYCBvYmplY3Qgc2VyaWFsaXphdGlvbgogKiAtIE9wdGlvbmFsbHkgbGltaXRzIGRlcHRoIG9mIGZpbmFsIG91dHB1dAogKiAtIE9wdGlvbmFsbHkgbGltaXRzIG51bWJlciBvZiBwcm9wZXJ0aWVzL2VsZW1lbnRzIGluY2x1ZGVkIGluIGFueSBzaW5nbGUgb2JqZWN0L2FycmF5CiAqCiAqIEBwYXJhbSBpbnB1dCBUaGUgb2JqZWN0IHRvIGJlIG5vcm1hbGl6ZWQuCiAqIEBwYXJhbSBkZXB0aCBUaGUgbWF4IGRlcHRoIHRvIHdoaWNoIHRvIG5vcm1hbGl6ZSB0aGUgb2JqZWN0LiAoQW55dGhpbmcgZGVlcGVyIHN0cmluZ2lmaWVkIHdob2xlLikKICogQHBhcmFtIG1heFByb3BlcnRpZXMgVGhlIG1heCBudW1iZXIgb2YgZWxlbWVudHMgb3IgcHJvcGVydGllcyB0byBiZSBpbmNsdWRlZCBpbiBhbnkgc2luZ2xlIGFycmF5IG9yCiAqIG9iamVjdCBpbiB0aGUgbm9ybWFsbGl6ZWQgb3V0cHV0LgogKiBAcmV0dXJucyBBIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgb2JqZWN0LCBvciBgIioqbm9uLXNlcmlhbGl6YWJsZSoqImAgaWYgYW55IGVycm9ycyBhcmUgdGhyb3duIGR1cmluZyBub3JtYWxpemF0aW9uLgogKi8KLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkKZnVuY3Rpb24gbm9ybWFsaXplKGlucHV0LCBkZXB0aCA9IDEwMCwgbWF4UHJvcGVydGllcyA9ICtJbmZpbml0eSkgewogIHRyeSB7CiAgICAvLyBzaW5jZSB3ZSdyZSBhdCB0aGUgb3V0ZXJtb3N0IGxldmVsLCB3ZSBkb24ndCBwcm92aWRlIGEga2V5CiAgICByZXR1cm4gdmlzaXQoJycsIGlucHV0LCBkZXB0aCwgbWF4UHJvcGVydGllcyk7CiAgfSBjYXRjaCAoZXJyKSB7CiAgICByZXR1cm4geyBFUlJPUjogYCoqbm9uLXNlcmlhbGl6YWJsZSoqICgke2Vycn0pYCB9OwogIH0KfQoKLyoqCiAqIFZpc2l0cyBhIG5vZGUgdG8gcGVyZm9ybSBub3JtYWxpemF0aW9uIG9uIGl0CiAqCiAqIEBwYXJhbSBrZXkgVGhlIGtleSBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBub2RlCiAqIEBwYXJhbSB2YWx1ZSBUaGUgbm9kZSB0byBiZSB2aXNpdGVkCiAqIEBwYXJhbSBkZXB0aCBPcHRpb25hbCBudW1iZXIgaW5kaWNhdGluZyB0aGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGgKICogQHBhcmFtIG1heFByb3BlcnRpZXMgT3B0aW9uYWwgbWF4aW11bSBudW1iZXIgb2YgcHJvcGVydGllcy9lbGVtZW50cyBpbmNsdWRlZCBpbiBhbnkgc2luZ2xlIG9iamVjdC9hcnJheQogKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBNZW1vIGNsYXNzIGhhbmRsaW5nIGRlY3ljbGluZwogKi8KZnVuY3Rpb24gdmlzaXQoCiAga2V5LAogIHZhbHVlLAogIGRlcHRoID0gK0luZmluaXR5LAogIG1heFByb3BlcnRpZXMgPSArSW5maW5pdHksCiAgbWVtbyA9IG1lbW9CdWlsZGVyKCksCikgewogIGNvbnN0IFttZW1vaXplLCB1bm1lbW9pemVdID0gbWVtbzsKCiAgLy8gR2V0IHRoZSBzaW1wbGUgY2FzZXMgb3V0IG9mIHRoZSB3YXkgZmlyc3QKICBpZiAoCiAgICB2YWx1ZSA9PSBudWxsIHx8IC8vIHRoaXMgbWF0Y2hlcyBudWxsIGFuZCB1bmRlZmluZWQgLT4gZXFlcSBub3QgZXFlcWVxCiAgICAoWydudW1iZXInLCAnYm9vbGVhbicsICdzdHJpbmcnXS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpICYmICFpc05hTiQxKHZhbHVlKSkKICApIHsKICAgIHJldHVybiB2YWx1ZSA7CiAgfQoKICBjb25zdCBzdHJpbmdpZmllZCA9IHN0cmluZ2lmeVZhbHVlKGtleSwgdmFsdWUpOwoKICAvLyBBbnl0aGluZyB3ZSBjb3VsZCBwb3RlbnRpYWxseSBkaWcgaW50byBtb3JlIChvYmplY3RzIG9yIGFycmF5cykgd2lsbCBoYXZlIGNvbWUgYmFjayBhcyBgIltvYmplY3QgWFhYWF0iYC4KICAvLyBFdmVyeXRoaW5nIGVsc2Ugd2lsbCBoYXZlIGFscmVhZHkgYmVlbiBzZXJpYWxpemVkLCBzbyBpZiB3ZSBkb24ndCBzZWUgdGhhdCBwYXR0ZXJuLCB3ZSdyZSBkb25lLgogIGlmICghc3RyaW5naWZpZWQuc3RhcnRzV2l0aCgnW29iamVjdCAnKSkgewogICAgcmV0dXJuIHN0cmluZ2lmaWVkOwogIH0KCiAgLy8gRnJvbSBoZXJlIG9uLCB3ZSBjYW4gYXNzZXJ0IHRoYXQgYHZhbHVlYCBpcyBlaXRoZXIgYW4gb2JqZWN0IG9yIGFuIGFycmF5LgoKICAvLyBEbyBub3Qgbm9ybWFsaXplIG9iamVjdHMgdGhhdCB3ZSBrbm93IGhhdmUgYWxyZWFkeSBiZWVuIG5vcm1hbGl6ZWQuIEFzIGEgZ2VuZXJhbCBydWxlLCB0aGUKICAvLyAiX19zZW50cnlfc2tpcF9ub3JtYWxpemF0aW9uX18iIHByb3BlcnR5IHNob3VsZCBvbmx5IGJlIHVzZWQgc3BhcmluZ2x5IGFuZCBvbmx5IHNob3VsZCBvbmx5IGJlIHNldCBvbiBvYmplY3RzIHRoYXQKICAvLyBoYXZlIGFscmVhZHkgYmVlbiBub3JtYWxpemVkLgogIGlmICgodmFsdWUgKVsnX19zZW50cnlfc2tpcF9ub3JtYWxpemF0aW9uX18nXSkgewogICAgcmV0dXJuIHZhbHVlIDsKICB9CgogIC8vIFdlIGNhbiBzZXQgYF9fc2VudHJ5X292ZXJyaWRlX25vcm1hbGl6YXRpb25fZGVwdGhfX2Agb24gYW4gb2JqZWN0IHRvIGVuc3VyZSB0aGF0IGZyb20gdGhlcmUKICAvLyBXZSBrZWVwIGEgY2VydGFpbiBhbW91bnQgb2YgZGVwdGguCiAgLy8gVGhpcyBzaG91bGQgYmUgdXNlZCBzcGFyaW5nbHksIGUuZy4gd2UgdXNlIGl0IGZvciB0aGUgcmVkdXggaW50ZWdyYXRpb24gdG8gZW5zdXJlIHdlIGdldCBhIGNlcnRhaW4gYW1vdW50IG9mIHN0YXRlLgogIGNvbnN0IHJlbWFpbmluZ0RlcHRoID0KICAgIHR5cGVvZiAodmFsdWUgKVsnX19zZW50cnlfb3ZlcnJpZGVfbm9ybWFsaXphdGlvbl9kZXB0aF9fJ10gPT09ICdudW1iZXInCiAgICAgID8gKCh2YWx1ZSApWydfX3NlbnRyeV9vdmVycmlkZV9ub3JtYWxpemF0aW9uX2RlcHRoX18nXSApCiAgICAgIDogZGVwdGg7CgogIC8vIFdlJ3JlIGFsc28gZG9uZSBpZiB3ZSd2ZSByZWFjaGVkIHRoZSBtYXggZGVwdGgKICBpZiAocmVtYWluaW5nRGVwdGggPT09IDApIHsKICAgIC8vIEF0IHRoaXMgcG9pbnQgd2Uga25vdyBgc2VyaWFsaXplZGAgaXMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gYCJbb2JqZWN0IFhYWFhdImAuIENsZWFuIGl0IHVwIHNvIGl0J3MganVzdCBgIltYWFhYXSJgLgogICAgcmV0dXJuIHN0cmluZ2lmaWVkLnJlcGxhY2UoJ29iamVjdCAnLCAnJyk7CiAgfQoKICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHZpc2l0ZWQgdGhpcyBicmFuY2gsIGJhaWwgb3V0LCBhcyBpdCdzIGNpcmN1bGFyIHJlZmVyZW5jZS4gSWYgbm90LCBub3RlIHRoYXQgd2UncmUgc2VlaW5nIGl0IG5vdy4KICBpZiAobWVtb2l6ZSh2YWx1ZSkpIHsKICAgIHJldHVybiAnW0NpcmN1bGFyIH5dJzsKICB9CgogIC8vIElmIHRoZSB2YWx1ZSBoYXMgYSBgdG9KU09OYCBtZXRob2QsIHdlIGNhbGwgaXQgdG8gZXh0cmFjdCBtb3JlIGluZm9ybWF0aW9uCiAgY29uc3QgdmFsdWVXaXRoVG9KU09OID0gdmFsdWUgOwogIGlmICh2YWx1ZVdpdGhUb0pTT04gJiYgdHlwZW9mIHZhbHVlV2l0aFRvSlNPTi50b0pTT04gPT09ICdmdW5jdGlvbicpIHsKICAgIHRyeSB7CiAgICAgIGNvbnN0IGpzb25WYWx1ZSA9IHZhbHVlV2l0aFRvSlNPTi50b0pTT04oKTsKICAgICAgLy8gV2UgbmVlZCB0byBub3JtYWxpemUgdGhlIHJldHVybiB2YWx1ZSBvZiBgLnRvSlNPTigpYCBpbiBjYXNlIGl0IGhhcyBjaXJjdWxhciByZWZlcmVuY2VzCiAgICAgIHJldHVybiB2aXNpdCgnJywganNvblZhbHVlLCByZW1haW5pbmdEZXB0aCAtIDEsIG1heFByb3BlcnRpZXMsIG1lbW8pOwogICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgIC8vIHBhc3MgKFRoZSBidWlsdC1pbiBgdG9KU09OYCBmYWlsZWQsIGJ1dCB3ZSBjYW4gc3RpbGwgdHJ5IHRvIGRvIGl0IG91cnNlbHZlcykKICAgIH0KICB9CgogIC8vIEF0IHRoaXMgcG9pbnQgd2Uga25vdyB3ZSBlaXRoZXIgaGF2ZSBhbiBvYmplY3Qgb3IgYW4gYXJyYXksIHdlIGhhdmVuJ3Qgc2VlbiBpdCBiZWZvcmUsIGFuZCB3ZSdyZSBnb2luZyB0byByZWN1cnNlCiAgLy8gYmVjYXVzZSB3ZSBoYXZlbid0IHlldCByZWFjaGVkIHRoZSBtYXggZGVwdGguIENyZWF0ZSBhbiBhY2N1bXVsYXRvciB0byBob2xkIHRoZSByZXN1bHRzIG9mIHZpc2l0aW5nIGVhY2gKICAvLyBwcm9wZXJ0eS9lbnRyeSwgYW5kIGtlZXAgdHJhY2sgb2YgdGhlIG51bWJlciBvZiBpdGVtcyB3ZSBhZGQgdG8gaXQuCiAgY29uc3Qgbm9ybWFsaXplZCA9IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IFtdIDoge30pIDsKICBsZXQgbnVtQWRkZWQgPSAwOwoKICAvLyBCZWZvcmUgd2UgYmVnaW4sIGNvbnZlcnRgRXJyb3JgIGFuZGBFdmVudGAgaW5zdGFuY2VzIGludG8gcGxhaW4gb2JqZWN0cywgc2luY2Ugc29tZSBvZiBlYWNoIG9mIHRoZWlyIHJlbGV2YW50CiAgLy8gcHJvcGVydGllcyBhcmUgbm9uLWVudW1lcmFibGUgYW5kIG90aGVyd2lzZSB3b3VsZCBnZXQgbWlzc2VkLgogIGNvbnN0IHZpc2l0YWJsZSA9IGNvbnZlcnRUb1BsYWluT2JqZWN0KHZhbHVlICk7CgogIGZvciAoY29uc3QgdmlzaXRLZXkgaW4gdmlzaXRhYmxlKSB7CiAgICAvLyBBdm9pZCBpdGVyYXRpbmcgb3ZlciBmaWVsZHMgaW4gdGhlIHByb3RvdHlwZSBpZiB0aGV5J3ZlIHNvbWVob3cgYmVlbiBleHBvc2VkIHRvIGVudW1lcmF0aW9uLgogICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmlzaXRhYmxlLCB2aXNpdEtleSkpIHsKICAgICAgY29udGludWU7CiAgICB9CgogICAgaWYgKG51bUFkZGVkID49IG1heFByb3BlcnRpZXMpIHsKICAgICAgbm9ybWFsaXplZFt2aXNpdEtleV0gPSAnW01heFByb3BlcnRpZXMgfl0nOwogICAgICBicmVhazsKICAgIH0KCiAgICAvLyBSZWN1cnNpdmVseSB2aXNpdCBhbGwgdGhlIGNoaWxkIG5vZGVzCiAgICBjb25zdCB2aXNpdFZhbHVlID0gdmlzaXRhYmxlW3Zpc2l0S2V5XTsKICAgIG5vcm1hbGl6ZWRbdmlzaXRLZXldID0gdmlzaXQodmlzaXRLZXksIHZpc2l0VmFsdWUsIHJlbWFpbmluZ0RlcHRoIC0gMSwgbWF4UHJvcGVydGllcywgbWVtbyk7CgogICAgbnVtQWRkZWQrKzsKICB9CgogIC8vIE9uY2Ugd2UndmUgdmlzaXRlZCBhbGwgdGhlIGJyYW5jaGVzLCByZW1vdmUgdGhlIHBhcmVudCBmcm9tIG1lbW8gc3RvcmFnZQogIHVubWVtb2l6ZSh2YWx1ZSk7CgogIC8vIFJldHVybiBhY2N1bXVsYXRlZCB2YWx1ZXMKICByZXR1cm4gbm9ybWFsaXplZDsKfQoKLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqLwovKioKICogU3RyaW5naWZ5IHRoZSBnaXZlbiB2YWx1ZS4gSGFuZGxlcyB2YXJpb3VzIGtub3duIHNwZWNpYWwgdmFsdWVzIGFuZCB0eXBlcy4KICoKICogTm90IG1lYW50IHRvIGJlIHVzZWQgb24gc2ltcGxlIHByaW1pdGl2ZXMgd2hpY2ggYWxyZWFkeSBoYXZlIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLCBhcyBpdCB3aWxsLCBmb3IgZXhhbXBsZSwgdHVybgogKiB0aGUgbnVtYmVyIDEyMzEgaW50byAiW09iamVjdCBOdW1iZXJdIiwgbm9yIG9uIGBudWxsYCwgYXMgaXQgd2lsbCB0aHJvdy4KICoKICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBzdHJpbmdpZnkKICogQHJldHVybnMgQSBzdHJpbmdpZmllZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gdmFsdWUKICovCmZ1bmN0aW9uIHN0cmluZ2lmeVZhbHVlKAogIGtleSwKICAvLyB0aGlzIHR5cGUgaXMgYSB0aW55IGJpdCBvZiBhIGNoZWF0LCBzaW5jZSB0aGlzIGZ1bmN0aW9uIGRvZXMgaGFuZGxlIE5hTiAod2hpY2ggaXMgdGVjaG5pY2FsbHkgYSBudW1iZXIpLCBidXQgZm9yCiAgLy8gb3VyIGludGVybmFsIHVzZSwgaXQnbGwgZG8KICB2YWx1ZSwKKSB7CiAgdHJ5IHsKICAgIGlmIChrZXkgPT09ICdkb21haW4nICYmIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgKHZhbHVlICkuX2V2ZW50cykgewogICAgICByZXR1cm4gJ1tEb21haW5dJzsKICAgIH0KCiAgICBpZiAoa2V5ID09PSAnZG9tYWluRW1pdHRlcicpIHsKICAgICAgcmV0dXJuICdbRG9tYWluRW1pdHRlcl0nOwogICAgfQoKICAgIC8vIEl0J3Mgc2FmZSB0byB1c2UgYGdsb2JhbGAsIGB3aW5kb3dgLCBhbmQgYGRvY3VtZW50YCBoZXJlIGluIHRoaXMgbWFubmVyLCBhcyB3ZSBhcmUgYXNzZXJ0aW5nIHVzaW5nIGB0eXBlb2ZgIGZpcnN0CiAgICAvLyB3aGljaCB3b24ndCB0aHJvdyBpZiB0aGV5IGFyZSBub3QgcHJlc2VudC4KCiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgPT09IGdsb2JhbCkgewogICAgICByZXR1cm4gJ1tHbG9iYWxdJzsKICAgIH0KCiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzCiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgPT09IHdpbmRvdykgewogICAgICByZXR1cm4gJ1tXaW5kb3ddJzsKICAgIH0KCiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzCiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSA9PT0gZG9jdW1lbnQpIHsKICAgICAgcmV0dXJuICdbRG9jdW1lbnRdJzsKICAgIH0KCiAgICBpZiAoaXNWdWVWaWV3TW9kZWwodmFsdWUpKSB7CiAgICAgIHJldHVybiAnW1Z1ZVZpZXdNb2RlbF0nOwogICAgfQoKICAgIC8vIFJlYWN0J3MgU3ludGhldGljRXZlbnQgdGhpbmd5CiAgICBpZiAoaXNTeW50aGV0aWNFdmVudCh2YWx1ZSkpIHsKICAgICAgcmV0dXJuICdbU3ludGhldGljRXZlbnRdJzsKICAgIH0KCiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gdmFsdWUpIHsKICAgICAgcmV0dXJuICdbTmFOXSc7CiAgICB9CgogICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgewogICAgICByZXR1cm4gYFtGdW5jdGlvbjogJHtnZXRGdW5jdGlvbk5hbWUodmFsdWUpfV1gOwogICAgfQoKICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7CiAgICAgIHJldHVybiBgWyR7U3RyaW5nKHZhbHVlKX1dYDsKICAgIH0KCiAgICAvLyBzdHJpbmdpZmllZCBCaWdJbnRzIGFyZSBpbmRpc3Rpbmd1aXNoYWJsZSBmcm9tIHJlZ3VsYXIgbnVtYmVycywgc28gd2UgbmVlZCB0byBsYWJlbCB0aGVtIHRvIGF2b2lkIGNvbmZ1c2lvbgogICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHsKICAgICAgcmV0dXJuIGBbQmlnSW50OiAke1N0cmluZyh2YWx1ZSl9XWA7CiAgICB9CgogICAgLy8gTm93IHRoYXQgd2UndmUga25vY2tlZCBvdXQgYWxsIHRoZSBzcGVjaWFsIGNhc2VzIGFuZCB0aGUgcHJpbWl0aXZlcywgYWxsIHdlIGhhdmUgbGVmdCBhcmUgb2JqZWN0cy4gU2ltcGx5IGNhc3RpbmcKICAgIC8vIHRoZW0gdG8gc3RyaW5ncyBtZWFucyB0aGF0IGluc3RhbmNlcyBvZiBjbGFzc2VzIHdoaWNoIGhhdmVuJ3QgZGVmaW5lZCB0aGVpciBgdG9TdHJpbmdUYWdgIHdpbGwganVzdCBjb21lIG91dCBhcwogICAgLy8gYCJbb2JqZWN0IE9iamVjdF0iYC4gSWYgd2UgaW5zdGVhZCBsb29rIGF0IHRoZSBjb25zdHJ1Y3RvcidzIG5hbWUgKHdoaWNoIGlzIHRoZSBzYW1lIGFzIHRoZSBuYW1lIG9mIHRoZSBjbGFzcyksCiAgICAvLyB3ZSBjYW4gbWFrZSBzdXJlIHRoYXQgb25seSBwbGFpbiBvYmplY3RzIGNvbWUgb3V0IHRoYXQgd2F5LgogICAgY29uc3Qgb2JqTmFtZSA9IGdldENvbnN0cnVjdG9yTmFtZSh2YWx1ZSk7CgogICAgLy8gSGFuZGxlIEhUTUwgRWxlbWVudHMKICAgIGlmICgvXkhUTUwoXHcqKUVsZW1lbnQkLy50ZXN0KG9iak5hbWUpKSB7CiAgICAgIHJldHVybiBgW0hUTUxFbGVtZW50OiAke29iak5hbWV9XWA7CiAgICB9CgogICAgcmV0dXJuIGBbb2JqZWN0ICR7b2JqTmFtZX1dYDsKICB9IGNhdGNoIChlcnIpIHsKICAgIHJldHVybiBgKipub24tc2VyaWFsaXphYmxlKiogKCR7ZXJyfSlgOwogIH0KfQovKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHkgKi8KCmZ1bmN0aW9uIGdldENvbnN0cnVjdG9yTmFtZSh2YWx1ZSkgewogIGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7CgogIHJldHVybiBwcm90b3R5cGUgPyBwcm90b3R5cGUuY29uc3RydWN0b3IubmFtZSA6ICdudWxsIHByb3RvdHlwZSc7Cn0KCi8qKgogKiBOb3JtYWxpemVzIFVSTHMgaW4gZXhjZXB0aW9ucyBhbmQgc3RhY2t0cmFjZXMgdG8gYSBiYXNlIHBhdGggc28gU2VudHJ5IGNhbiBmaW5nZXJwcmludAogKiBhY3Jvc3MgcGxhdGZvcm1zIGFuZCB3b3JraW5nIGRpcmVjdG9yeS4KICoKICogQHBhcmFtIHVybCBUaGUgVVJMIHRvIGJlIG5vcm1hbGl6ZWQuCiAqIEBwYXJhbSBiYXNlUGF0aCBUaGUgYXBwbGljYXRpb24gYmFzZSBwYXRoLgogKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCBVUkwuCiAqLwpmdW5jdGlvbiBub3JtYWxpemVVcmxUb0Jhc2UodXJsLCBiYXNlUGF0aCkgewogIGNvbnN0IGVzY2FwZWRCYXNlID0gYmFzZVBhdGgKICAgIC8vIEJhY2tzbGFzaCB0byBmb3J3YXJkCiAgICAucmVwbGFjZSgvXFwvZywgJy8nKQogICAgLy8gRXNjYXBlIFJlZ0V4cCBzcGVjaWFsIGNoYXJhY3RlcnMKICAgIC5yZXBsYWNlKC9bfFxce30oKVtcXV4kKyo/Ll0vZywgJ1xcJCYnKTsKCiAgbGV0IG5ld1VybCA9IHVybDsKICB0cnkgewogICAgbmV3VXJsID0gZGVjb2RlVVJJKHVybCk7CiAgfSBjYXRjaCAoX09vKSB7CiAgICAvLyBTb21ldGltZSB0aGlzIGJyZWFrcwogIH0KICByZXR1cm4gKAogICAgbmV3VXJsCiAgICAgIC5yZXBsYWNlKC9cXC9nLCAnLycpCiAgICAgIC5yZXBsYWNlKC93ZWJwYWNrOlwvPy9nLCAnJykgLy8gUmVtb3ZlIGludGVybWVkaWF0ZSBiYXNlIHBhdGgKICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBzZW50cnktaW50ZXJuYWwvc2RrL25vLXJlZ2V4cC1jb25zdHJ1Y3RvcgogICAgICAucmVwbGFjZShuZXcgUmVnRXhwKGAoZmlsZTovLyk/Lyoke2VzY2FwZWRCYXNlfS8qYCwgJ2lnJyksICdhcHA6Ly8vJykKICApOwp9CgovLyBTbGlnaHRseSBtb2RpZmllZCAobm8gSUU4IHN1cHBvcnQsIEVTNikgYW5kIHRyYW5zY3JpYmVkIHRvIFR5cGVTY3JpcHQKCi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uCi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuCmNvbnN0IHNwbGl0UGF0aFJlID0gL14oXFMrOlxcfFwvPykoW1xzXFNdKj8pKCg/OlwuezEsMn18W14vXFxdKz98KShcLlteLi9cXF0qfCkpKD86Wy9cXF0qKSQvOwovKiogSlNEb2MgKi8KZnVuY3Rpb24gc3BsaXRQYXRoKGZpbGVuYW1lKSB7CiAgLy8gVHJ1bmNhdGUgZmlsZXMgbmFtZXMgZ3JlYXRlciB0aGFuIDEwMjQgY2hhcmFjdGVycyB0byBhdm9pZCByZWdleCBkb3MKICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L3B1bGwvODczNyNkaXNjdXNzaW9uX3IxMjg1NzE5MTcyCiAgY29uc3QgdHJ1bmNhdGVkID0gZmlsZW5hbWUubGVuZ3RoID4gMTAyNCA/IGA8dHJ1bmNhdGVkPiR7ZmlsZW5hbWUuc2xpY2UoLTEwMjQpfWAgOiBmaWxlbmFtZTsKICBjb25zdCBwYXJ0cyA9IHNwbGl0UGF0aFJlLmV4ZWModHJ1bmNhdGVkKTsKICByZXR1cm4gcGFydHMgPyBwYXJ0cy5zbGljZSgxKSA6IFtdOwp9CgovKiogSlNEb2MgKi8KZnVuY3Rpb24gZGlybmFtZShwYXRoKSB7CiAgY29uc3QgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpOwogIGNvbnN0IHJvb3QgPSByZXN1bHRbMF07CiAgbGV0IGRpciA9IHJlc3VsdFsxXTsKCiAgaWYgKCFyb290ICYmICFkaXIpIHsKICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlcgogICAgcmV0dXJuICcuJzsKICB9CgogIGlmIChkaXIpIHsKICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoCiAgICBkaXIgPSBkaXIuc2xpY2UoMCwgZGlyLmxlbmd0aCAtIDEpOwogIH0KCiAgcmV0dXJuIHJvb3QgKyBkaXI7Cn0KCi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1mdW5jdGlvbi1yZXR1cm4tdHlwZSAqLwoKLyoqIFN5bmNQcm9taXNlIGludGVybmFsIHN0YXRlcyAqLwp2YXIgU3RhdGVzOyAoZnVuY3Rpb24gKFN0YXRlcykgewogIC8qKiBQZW5kaW5nICovCiAgY29uc3QgUEVORElORyA9IDA7IFN0YXRlc1tTdGF0ZXNbIlBFTkRJTkciXSA9IFBFTkRJTkddID0gIlBFTkRJTkciOwogIC8qKiBSZXNvbHZlZCAvIE9LICovCiAgY29uc3QgUkVTT0xWRUQgPSAxOyBTdGF0ZXNbU3RhdGVzWyJSRVNPTFZFRCJdID0gUkVTT0xWRURdID0gIlJFU09MVkVEIjsKICAvKiogUmVqZWN0ZWQgLyBFcnJvciAqLwogIGNvbnN0IFJFSkVDVEVEID0gMjsgU3RhdGVzW1N0YXRlc1siUkVKRUNURUQiXSA9IFJFSkVDVEVEXSA9ICJSRUpFQ1RFRCI7Cn0pKFN0YXRlcyB8fCAoU3RhdGVzID0ge30pKTsKCi8vIE92ZXJsb2FkcyBzbyB3ZSBjYW4gY2FsbCByZXNvbHZlZFN5bmNQcm9taXNlIHdpdGhvdXQgYXJndW1lbnRzIGFuZCBnZW5lcmljIGFyZ3VtZW50CgovKioKICogQ3JlYXRlcyBhIHJlc29sdmVkIHN5bmMgcHJvbWlzZS4KICoKICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byByZXNvbHZlIHRoZSBwcm9taXNlIHdpdGgKICogQHJldHVybnMgdGhlIHJlc29sdmVkIHN5bmMgcHJvbWlzZQogKi8KZnVuY3Rpb24gcmVzb2x2ZWRTeW5jUHJvbWlzZSh2YWx1ZSkgewogIHJldHVybiBuZXcgU3luY1Byb21pc2UocmVzb2x2ZSA9PiB7CiAgICByZXNvbHZlKHZhbHVlKTsKICB9KTsKfQoKLyoqCiAqIENyZWF0ZXMgYSByZWplY3RlZCBzeW5jIHByb21pc2UuCiAqCiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gcmVqZWN0IHRoZSBwcm9taXNlIHdpdGgKICogQHJldHVybnMgdGhlIHJlamVjdGVkIHN5bmMgcHJvbWlzZQogKi8KZnVuY3Rpb24gcmVqZWN0ZWRTeW5jUHJvbWlzZShyZWFzb24pIHsKICByZXR1cm4gbmV3IFN5bmNQcm9taXNlKChfLCByZWplY3QpID0+IHsKICAgIHJlamVjdChyZWFzb24pOwogIH0pOwp9CgovKioKICogVGhlbmFibGUgY2xhc3MgdGhhdCBiZWhhdmVzIGxpa2UgYSBQcm9taXNlIGFuZCBmb2xsb3dzIGl0J3MgaW50ZXJmYWNlCiAqIGJ1dCBpcyBub3QgYXN5bmMgaW50ZXJuYWxseQogKi8KY2xhc3MgU3luY1Byb21pc2UgewoKICAgY29uc3RydWN0b3IoCiAgICBleGVjdXRvciwKICApIHtTeW5jUHJvbWlzZS5wcm90b3R5cGUuX19pbml0LmNhbGwodGhpcyk7U3luY1Byb21pc2UucHJvdG90eXBlLl9faW5pdDIuY2FsbCh0aGlzKTtTeW5jUHJvbWlzZS5wcm90b3R5cGUuX19pbml0My5jYWxsKHRoaXMpO1N5bmNQcm9taXNlLnByb3RvdHlwZS5fX2luaXQ0LmNhbGwodGhpcyk7CiAgICB0aGlzLl9zdGF0ZSA9IFN0YXRlcy5QRU5ESU5HOwogICAgdGhpcy5faGFuZGxlcnMgPSBbXTsKCiAgICB0cnkgewogICAgICBleGVjdXRvcih0aGlzLl9yZXNvbHZlLCB0aGlzLl9yZWplY3QpOwogICAgfSBjYXRjaCAoZSkgewogICAgICB0aGlzLl9yZWplY3QoZSk7CiAgICB9CiAgfQoKICAvKiogSlNEb2MgKi8KICAgdGhlbigKICAgIG9uZnVsZmlsbGVkLAogICAgb25yZWplY3RlZCwKICApIHsKICAgIHJldHVybiBuZXcgU3luY1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gewogICAgICB0aGlzLl9oYW5kbGVycy5wdXNoKFsKICAgICAgICBmYWxzZSwKICAgICAgICByZXN1bHQgPT4gewogICAgICAgICAgaWYgKCFvbmZ1bGZpbGxlZCkgewogICAgICAgICAgICAvLyBUT0RPOiDCr1xfKOODhClfL8KvCiAgICAgICAgICAgIC8vIFRPRE86IEZJWE1FCiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0ICk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIHJlc29sdmUob25mdWxmaWxsZWQocmVzdWx0KSk7CiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICByZWplY3QoZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHJlYXNvbiA9PiB7CiAgICAgICAgICBpZiAoIW9ucmVqZWN0ZWQpIHsKICAgICAgICAgICAgcmVqZWN0KHJlYXNvbik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIHJlc29sdmUob25yZWplY3RlZChyZWFzb24pKTsKICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgIHJlamVjdChlKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgIF0pOwogICAgICB0aGlzLl9leGVjdXRlSGFuZGxlcnMoKTsKICAgIH0pOwogIH0KCiAgLyoqIEpTRG9jICovCiAgIGNhdGNoKAogICAgb25yZWplY3RlZCwKICApIHsKICAgIHJldHVybiB0aGlzLnRoZW4odmFsID0+IHZhbCwgb25yZWplY3RlZCk7CiAgfQoKICAvKiogSlNEb2MgKi8KICAgZmluYWxseShvbmZpbmFsbHkpIHsKICAgIHJldHVybiBuZXcgU3luY1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gewogICAgICBsZXQgdmFsOwogICAgICBsZXQgaXNSZWplY3RlZDsKCiAgICAgIHJldHVybiB0aGlzLnRoZW4oCiAgICAgICAgdmFsdWUgPT4gewogICAgICAgICAgaXNSZWplY3RlZCA9IGZhbHNlOwogICAgICAgICAgdmFsID0gdmFsdWU7CiAgICAgICAgICBpZiAob25maW5hbGx5KSB7CiAgICAgICAgICAgIG9uZmluYWxseSgpOwogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgcmVhc29uID0+IHsKICAgICAgICAgIGlzUmVqZWN0ZWQgPSB0cnVlOwogICAgICAgICAgdmFsID0gcmVhc29uOwogICAgICAgICAgaWYgKG9uZmluYWxseSkgewogICAgICAgICAgICBvbmZpbmFsbHkoKTsKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICApLnRoZW4oKCkgPT4gewogICAgICAgIGlmIChpc1JlamVjdGVkKSB7CiAgICAgICAgICByZWplY3QodmFsKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CgogICAgICAgIHJlc29sdmUodmFsICk7CiAgICAgIH0pOwogICAgfSk7CiAgfQoKICAvKiogSlNEb2MgKi8KICAgIF9faW5pdCgpIHt0aGlzLl9yZXNvbHZlID0gKHZhbHVlKSA9PiB7CiAgICB0aGlzLl9zZXRSZXN1bHQoU3RhdGVzLlJFU09MVkVELCB2YWx1ZSk7CiAgfTt9CgogIC8qKiBKU0RvYyAqLwogICAgX19pbml0MigpIHt0aGlzLl9yZWplY3QgPSAocmVhc29uKSA9PiB7CiAgICB0aGlzLl9zZXRSZXN1bHQoU3RhdGVzLlJFSkVDVEVELCByZWFzb24pOwogIH07fQoKICAvKiogSlNEb2MgKi8KICAgIF9faW5pdDMoKSB7dGhpcy5fc2V0UmVzdWx0ID0gKHN0YXRlLCB2YWx1ZSkgPT4gewogICAgaWYgKHRoaXMuX3N0YXRlICE9PSBTdGF0ZXMuUEVORElORykgewogICAgICByZXR1cm47CiAgICB9CgogICAgaWYgKGlzVGhlbmFibGUodmFsdWUpKSB7CiAgICAgIHZvaWQgKHZhbHVlICkudGhlbih0aGlzLl9yZXNvbHZlLCB0aGlzLl9yZWplY3QpOwogICAgICByZXR1cm47CiAgICB9CgogICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTsKICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7CgogICAgdGhpcy5fZXhlY3V0ZUhhbmRsZXJzKCk7CiAgfTt9CgogIC8qKiBKU0RvYyAqLwogICAgX19pbml0NCgpIHt0aGlzLl9leGVjdXRlSGFuZGxlcnMgPSAoKSA9PiB7CiAgICBpZiAodGhpcy5fc3RhdGUgPT09IFN0YXRlcy5QRU5ESU5HKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICBjb25zdCBjYWNoZWRIYW5kbGVycyA9IHRoaXMuX2hhbmRsZXJzLnNsaWNlKCk7CiAgICB0aGlzLl9oYW5kbGVycyA9IFtdOwoKICAgIGNhY2hlZEhhbmRsZXJzLmZvckVhY2goaGFuZGxlciA9PiB7CiAgICAgIGlmIChoYW5kbGVyWzBdKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBpZiAodGhpcy5fc3RhdGUgPT09IFN0YXRlcy5SRVNPTFZFRCkgewogICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXMKICAgICAgICBoYW5kbGVyWzFdKHRoaXMuX3ZhbHVlICk7CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gU3RhdGVzLlJFSkVDVEVEKSB7CiAgICAgICAgaGFuZGxlclsyXSh0aGlzLl92YWx1ZSk7CiAgICAgIH0KCiAgICAgIGhhbmRsZXJbMF0gPSB0cnVlOwogICAgfSk7CiAgfTt9Cn0KCi8qKgogKiBDcmVhdGVzIGFuIG5ldyBQcm9taXNlQnVmZmVyIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgbGltaXQKICogQHBhcmFtIGxpbWl0IG1heCBudW1iZXIgb2YgcHJvbWlzZXMgdGhhdCBjYW4gYmUgc3RvcmVkIGluIHRoZSBidWZmZXIKICovCmZ1bmN0aW9uIG1ha2VQcm9taXNlQnVmZmVyKGxpbWl0KSB7CiAgY29uc3QgYnVmZmVyID0gW107CgogIGZ1bmN0aW9uIGlzUmVhZHkoKSB7CiAgICByZXR1cm4gbGltaXQgPT09IHVuZGVmaW5lZCB8fCBidWZmZXIubGVuZ3RoIDwgbGltaXQ7CiAgfQoKICAvKioKICAgKiBSZW1vdmUgYSBwcm9taXNlIGZyb20gdGhlIHF1ZXVlLgogICAqCiAgICogQHBhcmFtIHRhc2sgQ2FuIGJlIGFueSBQcm9taXNlTGlrZTxUPgogICAqIEByZXR1cm5zIFJlbW92ZWQgcHJvbWlzZS4KICAgKi8KICBmdW5jdGlvbiByZW1vdmUodGFzaykgewogICAgcmV0dXJuIGJ1ZmZlci5zcGxpY2UoYnVmZmVyLmluZGV4T2YodGFzayksIDEpWzBdOwogIH0KCiAgLyoqCiAgICogQWRkIGEgcHJvbWlzZSAocmVwcmVzZW50aW5nIGFuIGluLWZsaWdodCBhY3Rpb24pIHRvIHRoZSBxdWV1ZSwgYW5kIHNldCBpdCB0byByZW1vdmUgaXRzZWxmIG9uIGZ1bGZpbGxtZW50LgogICAqCiAgICogQHBhcmFtIHRhc2tQcm9kdWNlciBBIGZ1bmN0aW9uIHByb2R1Y2luZyBhbnkgUHJvbWlzZUxpa2U8VD47IEluIHByZXZpb3VzIHZlcnNpb25zIHRoaXMgdXNlZCB0byBiZSBgdGFzazoKICAgKiAgICAgICAgUHJvbWlzZUxpa2U8VD5gLCBidXQgdW5kZXIgdGhhdCBtb2RlbCwgUHJvbWlzZXMgd2VyZSBpbnN0YW50bHkgY3JlYXRlZCBvbiB0aGUgY2FsbC1zaXRlIGFuZCB0aGVpciBleGVjdXRvcgogICAqICAgICAgICBmdW5jdGlvbnMgdGhlcmVmb3JlIHJhbiBpbW1lZGlhdGVseS4gVGh1cywgZXZlbiBpZiB0aGUgYnVmZmVyIHdhcyBmdWxsLCB0aGUgYWN0aW9uIHN0aWxsIGhhcHBlbmVkLiBCeQogICAqICAgICAgICByZXF1aXJpbmcgdGhlIHByb21pc2UgdG8gYmUgd3JhcHBlZCBpbiBhIGZ1bmN0aW9uLCB3ZSBjYW4gZGVmZXIgcHJvbWlzZSBjcmVhdGlvbiB1bnRpbCBhZnRlciB0aGUgYnVmZmVyCiAgICogICAgICAgIGxpbWl0IGNoZWNrLgogICAqIEByZXR1cm5zIFRoZSBvcmlnaW5hbCBwcm9taXNlLgogICAqLwogIGZ1bmN0aW9uIGFkZCh0YXNrUHJvZHVjZXIpIHsKICAgIGlmICghaXNSZWFkeSgpKSB7CiAgICAgIHJldHVybiByZWplY3RlZFN5bmNQcm9taXNlKG5ldyBTZW50cnlFcnJvcignTm90IGFkZGluZyBQcm9taXNlIGJlY2F1c2UgYnVmZmVyIGxpbWl0IHdhcyByZWFjaGVkLicpKTsKICAgIH0KCiAgICAvLyBzdGFydCB0aGUgdGFzayBhbmQgYWRkIGl0cyBwcm9taXNlIHRvIHRoZSBxdWV1ZQogICAgY29uc3QgdGFzayA9IHRhc2tQcm9kdWNlcigpOwogICAgaWYgKGJ1ZmZlci5pbmRleE9mKHRhc2spID09PSAtMSkgewogICAgICBidWZmZXIucHVzaCh0YXNrKTsKICAgIH0KICAgIHZvaWQgdGFzawogICAgICAudGhlbigoKSA9PiByZW1vdmUodGFzaykpCiAgICAgIC8vIFVzZSBgdGhlbihudWxsLCByZWplY3Rpb25IYW5kbGVyKWAgcmF0aGVyIHRoYW4gYGNhdGNoKHJlamVjdGlvbkhhbmRsZXIpYCBzbyB0aGF0IHdlIGNhbiB1c2UgYFByb21pc2VMaWtlYAogICAgICAvLyByYXRoZXIgdGhhbiBgUHJvbWlzZWAuIGBQcm9taXNlTGlrZWAgZG9lc24ndCBoYXZlIGEgYC5jYXRjaGAgbWV0aG9kLCBtYWtpbmcgaXRzIHBvbHlmaWxsIHNtYWxsZXIuIChFUzUgZGlkbid0CiAgICAgIC8vIGhhdmUgcHJvbWlzZXMsIHNvIFRTIGhhcyB0byBwb2x5ZmlsbCB3aGVuIGRvd24tY29tcGlsaW5nLikKICAgICAgLnRoZW4obnVsbCwgKCkgPT4KICAgICAgICByZW1vdmUodGFzaykudGhlbihudWxsLCAoKSA9PiB7CiAgICAgICAgICAvLyBXZSBoYXZlIHRvIGFkZCBhbm90aGVyIGNhdGNoIGhlcmUgYmVjYXVzZSBgcmVtb3ZlKClgIHN0YXJ0cyBhIG5ldyBwcm9taXNlIGNoYWluLgogICAgICAgIH0pLAogICAgICApOwogICAgcmV0dXJuIHRhc2s7CiAgfQoKICAvKioKICAgKiBXYWl0IGZvciBhbGwgcHJvbWlzZXMgaW4gdGhlIHF1ZXVlIHRvIHJlc29sdmUgb3IgZm9yIHRpbWVvdXQgdG8gZXhwaXJlLCB3aGljaGV2ZXIgY29tZXMgZmlyc3QuCiAgICoKICAgKiBAcGFyYW0gdGltZW91dCBUaGUgdGltZSwgaW4gbXMsIGFmdGVyIHdoaWNoIHRvIHJlc29sdmUgdG8gYGZhbHNlYCBpZiB0aGUgcXVldWUgaXMgc3RpbGwgbm9uLWVtcHR5LiBQYXNzaW5nIGAwYCAob3IKICAgKiBub3QgcGFzc2luZyBhbnl0aGluZykgd2lsbCBtYWtlIHRoZSBwcm9taXNlIHdhaXQgYXMgbG9uZyBhcyBpdCB0YWtlcyBmb3IgdGhlIHF1ZXVlIHRvIGRyYWluIGJlZm9yZSByZXNvbHZpbmcgdG8KICAgKiBgdHJ1ZWAuCiAgICogQHJldHVybnMgQSBwcm9taXNlIHdoaWNoIHdpbGwgcmVzb2x2ZSB0byBgdHJ1ZWAgaWYgdGhlIHF1ZXVlIGlzIGFscmVhZHkgZW1wdHkgb3IgZHJhaW5zIGJlZm9yZSB0aGUgdGltZW91dCwgYW5kCiAgICogYGZhbHNlYCBvdGhlcndpc2UKICAgKi8KICBmdW5jdGlvbiBkcmFpbih0aW1lb3V0KSB7CiAgICByZXR1cm4gbmV3IFN5bmNQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHsKICAgICAgbGV0IGNvdW50ZXIgPSBidWZmZXIubGVuZ3RoOwoKICAgICAgaWYgKCFjb3VudGVyKSB7CiAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSk7CiAgICAgIH0KCiAgICAgIC8vIHdhaXQgZm9yIGB0aW1lb3V0YCBtcyBhbmQgdGhlbiByZXNvbHZlIHRvIGBmYWxzZWAgKGlmIG5vdCBjYW5jZWxsZWQgZmlyc3QpCiAgICAgIGNvbnN0IGNhcHR1cmVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gewogICAgICAgIGlmICh0aW1lb3V0ICYmIHRpbWVvdXQgPiAwKSB7CiAgICAgICAgICByZXNvbHZlKGZhbHNlKTsKICAgICAgICB9CiAgICAgIH0sIHRpbWVvdXQpOwoKICAgICAgLy8gaWYgYWxsIHByb21pc2VzIHJlc29sdmUgaW4gdGltZSwgY2FuY2VsIHRoZSB0aW1lciBhbmQgcmVzb2x2ZSB0byBgdHJ1ZWAKICAgICAgYnVmZmVyLmZvckVhY2goaXRlbSA9PiB7CiAgICAgICAgdm9pZCByZXNvbHZlZFN5bmNQcm9taXNlKGl0ZW0pLnRoZW4oKCkgPT4gewogICAgICAgICAgaWYgKCEtLWNvdW50ZXIpIHsKICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNhcHR1cmVkU2V0VGltZW91dCk7CiAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7CiAgICAgICAgICB9CiAgICAgICAgfSwgcmVqZWN0KTsKICAgICAgfSk7CiAgICB9KTsKICB9CgogIHJldHVybiB7CiAgICAkOiBidWZmZXIsCiAgICBhZGQsCiAgICBkcmFpbiwKICB9Owp9Cgpjb25zdCBPTkVfU0VDT05EX0lOX01TID0gMTAwMDsKCi8qKgogKiBBIHBhcnRpYWwgZGVmaW5pdGlvbiBvZiB0aGUgW1BlcmZvcm1hbmNlIFdlYiBBUElde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QZXJmb3JtYW5jZX0KICogZm9yIGFjY2Vzc2luZyBhIGhpZ2gtcmVzb2x1dGlvbiBtb25vdG9uaWMgY2xvY2suCiAqLwoKLyoqCiAqIFJldHVybnMgYSB0aW1lc3RhbXAgaW4gc2Vjb25kcyBzaW5jZSB0aGUgVU5JWCBlcG9jaCB1c2luZyB0aGUgRGF0ZSBBUEkuCiAqCiAqIFRPRE8odjgpOiBSZXR1cm4gdHlwZSBzaG91bGQgYmUgcm91bmRlZC4KICovCmZ1bmN0aW9uIGRhdGVUaW1lc3RhbXBJblNlY29uZHMoKSB7CiAgcmV0dXJuIERhdGUubm93KCkgLyBPTkVfU0VDT05EX0lOX01TOwp9CgovKioKICogUmV0dXJucyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBuYXRpdmUgUGVyZm9ybWFuY2UgQVBJIGJyb3dzZXIgaW1wbGVtZW50YXRpb24sIG9yIHVuZGVmaW5lZCBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QKICogc3VwcG9ydCB0aGUgQVBJLgogKgogKiBXcmFwcGluZyB0aGUgbmF0aXZlIEFQSSB3b3JrcyBhcm91bmQgZGlmZmVyZW5jZXMgaW4gYmVoYXZpb3IgZnJvbSBkaWZmZXJlbnQgYnJvd3NlcnMuCiAqLwpmdW5jdGlvbiBjcmVhdGVVbml4VGltZXN0YW1wSW5TZWNvbmRzRnVuYygpIHsKICBjb25zdCB7IHBlcmZvcm1hbmNlIH0gPSBHTE9CQUxfT0JKIDsKICBpZiAoIXBlcmZvcm1hbmNlIHx8ICFwZXJmb3JtYW5jZS5ub3cpIHsKICAgIHJldHVybiBkYXRlVGltZXN0YW1wSW5TZWNvbmRzOwogIH0KCiAgLy8gU29tZSBicm93c2VyIGFuZCBlbnZpcm9ubWVudHMgZG9uJ3QgaGF2ZSBhIHRpbWVPcmlnaW4sIHNvIHdlIGZhbGxiYWNrIHRvCiAgLy8gdXNpbmcgRGF0ZS5ub3coKSB0byBjb21wdXRlIHRoZSBzdGFydGluZyB0aW1lLgogIGNvbnN0IGFwcHJveFN0YXJ0aW5nVGltZU9yaWdpbiA9IERhdGUubm93KCkgLSBwZXJmb3JtYW5jZS5ub3coKTsKICBjb25zdCB0aW1lT3JpZ2luID0gcGVyZm9ybWFuY2UudGltZU9yaWdpbiA9PSB1bmRlZmluZWQgPyBhcHByb3hTdGFydGluZ1RpbWVPcmlnaW4gOiBwZXJmb3JtYW5jZS50aW1lT3JpZ2luOwoKICAvLyBwZXJmb3JtYW5jZS5ub3coKSBpcyBhIG1vbm90b25pYyBjbG9jaywgd2hpY2ggbWVhbnMgaXQgc3RhcnRzIGF0IDAgd2hlbiB0aGUgcHJvY2VzcyBiZWdpbnMuIFRvIGdldCB0aGUgY3VycmVudAogIC8vIHdhbGwgY2xvY2sgdGltZSAoYWN0dWFsIFVOSVggdGltZXN0YW1wKSwgd2UgbmVlZCB0byBhZGQgdGhlIHN0YXJ0aW5nIHRpbWUgb3JpZ2luIGFuZCB0aGUgY3VycmVudCB0aW1lIGVsYXBzZWQuCiAgLy8KICAvLyBUT0RPOiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHRoZSBjYXNlIHdoZXJlIHRoZSBtb25vdG9uaWMgY2xvY2sgdGhhdCBwb3dlcnMgcGVyZm9ybWFuY2Uubm93KCkgZHJpZnRzIGZyb20gdGhlCiAgLy8gd2FsbCBjbG9jayB0aW1lLCB3aGljaCBjYXVzZXMgdGhlIHJldHVybmVkIHRpbWVzdGFtcCB0byBiZSBpbmFjY3VyYXRlLiBXZSBzaG91bGQgaW52ZXN0aWdhdGUgaG93IHRvIGRldGVjdCBhbmQKICAvLyBjb3JyZWN0IGZvciB0aGlzLgogIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdC9pc3N1ZXMvMjU5MAogIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21kbi9jb250ZW50L2lzc3Vlcy80NzEzCiAgLy8gU2VlOiBodHRwczovL2Rldi50by9ub2Ftci93aGVuLWEtbWlsbGlzZWNvbmQtaXMtbm90LWEtbWlsbGlzZWNvbmQtM2g2CiAgcmV0dXJuICgpID0+IHsKICAgIHJldHVybiAodGltZU9yaWdpbiArIHBlcmZvcm1hbmNlLm5vdygpKSAvIE9ORV9TRUNPTkRfSU5fTVM7CiAgfTsKfQoKLyoqCiAqIFJldHVybnMgYSB0aW1lc3RhbXAgaW4gc2Vjb25kcyBzaW5jZSB0aGUgVU5JWCBlcG9jaCB1c2luZyBlaXRoZXIgdGhlIFBlcmZvcm1hbmNlIG9yIERhdGUgQVBJcywgZGVwZW5kaW5nIG9uIHRoZQogKiBhdmFpbGFiaWxpdHkgb2YgdGhlIFBlcmZvcm1hbmNlIEFQSS4KICoKICogQlVHOiBOb3RlIHRoYXQgYmVjYXVzZSBvZiBob3cgYnJvd3NlcnMgaW1wbGVtZW50IHRoZSBQZXJmb3JtYW5jZSBBUEksIHRoZSBjbG9jayBtaWdodCBzdG9wIHdoZW4gdGhlIGNvbXB1dGVyIGlzCiAqIGFzbGVlcC4gVGhpcyBjcmVhdGVzIGEgc2tldyBiZXR3ZWVuIGBkYXRlVGltZXN0YW1wSW5TZWNvbmRzYCBhbmQgYHRpbWVzdGFtcEluU2Vjb25kc2AuIFRoZQogKiBza2V3IGNhbiBncm93IHRvIGFyYml0cmFyeSBhbW91bnRzIGxpa2UgZGF5cywgd2Vla3Mgb3IgbW9udGhzLgogKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdC9pc3N1ZXMvMjU5MC4KICovCmNvbnN0IHRpbWVzdGFtcEluU2Vjb25kcyA9IGNyZWF0ZVVuaXhUaW1lc3RhbXBJblNlY29uZHNGdW5jKCk7CgovKioKICogVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIFVOSVggZXBvY2guIFRoaXMgdmFsdWUgaXMgb25seSB1c2FibGUgaW4gYSBicm93c2VyLCBhbmQgb25seSB3aGVuIHRoZQogKiBwZXJmb3JtYW5jZSBBUEkgaXMgYXZhaWxhYmxlLgogKi8KKCgpID0+IHsKICAvLyBVbmZvcnR1bmF0ZWx5IGJyb3dzZXJzIG1heSByZXBvcnQgYW4gaW5hY2N1cmF0ZSB0aW1lIG9yaWdpbiBkYXRhLCB0aHJvdWdoIGVpdGhlciBwZXJmb3JtYW5jZS50aW1lT3JpZ2luIG9yCiAgLy8gcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCwgd2hpY2ggcmVzdWx0cyBpbiBwb29yIHJlc3VsdHMgaW4gcGVyZm9ybWFuY2UgZGF0YS4gV2Ugb25seSB0cmVhdCB0aW1lIG9yaWdpbgogIC8vIGRhdGEgYXMgcmVsaWFibGUgaWYgdGhleSBhcmUgd2l0aGluIGEgcmVhc29uYWJsZSB0aHJlc2hvbGQgb2YgdGhlIGN1cnJlbnQgdGltZS4KCiAgY29uc3QgeyBwZXJmb3JtYW5jZSB9ID0gR0xPQkFMX09CSiA7CiAgaWYgKCFwZXJmb3JtYW5jZSB8fCAhcGVyZm9ybWFuY2Uubm93KSB7CiAgICByZXR1cm4gdW5kZWZpbmVkOwogIH0KCiAgY29uc3QgdGhyZXNob2xkID0gMzYwMCAqIDEwMDA7CiAgY29uc3QgcGVyZm9ybWFuY2VOb3cgPSBwZXJmb3JtYW5jZS5ub3coKTsKICBjb25zdCBkYXRlTm93ID0gRGF0ZS5ub3coKTsKCiAgLy8gaWYgdGltZU9yaWdpbiBpc24ndCBhdmFpbGFibGUgc2V0IGRlbHRhIHRvIHRocmVzaG9sZCBzbyBpdCBpc24ndCB1c2VkCiAgY29uc3QgdGltZU9yaWdpbkRlbHRhID0gcGVyZm9ybWFuY2UudGltZU9yaWdpbgogICAgPyBNYXRoLmFicyhwZXJmb3JtYW5jZS50aW1lT3JpZ2luICsgcGVyZm9ybWFuY2VOb3cgLSBkYXRlTm93KQogICAgOiB0aHJlc2hvbGQ7CiAgY29uc3QgdGltZU9yaWdpbklzUmVsaWFibGUgPSB0aW1lT3JpZ2luRGVsdGEgPCB0aHJlc2hvbGQ7CgogIC8vIFdoaWxlIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQgaXMgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBwZXJmb3JtYW5jZS50aW1lT3JpZ2luLCBwZXJmb3JtYW5jZS50aW1lT3JpZ2luCiAgLy8gaXMgbm90IGFzIHdpZGVseSBzdXBwb3J0ZWQuIE5hbWVseSwgcGVyZm9ybWFuY2UudGltZU9yaWdpbiBpcyB1bmRlZmluZWQgaW4gU2FmYXJpIGFzIG9mIHdyaXRpbmcuCiAgLy8gQWxzbyBhcyBvZiB3cml0aW5nLCBwZXJmb3JtYW5jZS50aW1pbmcgaXMgbm90IGF2YWlsYWJsZSBpbiBXZWIgV29ya2VycyBpbiBtYWluc3RyZWFtIGJyb3dzZXJzLCBzbyBpdCBpcyBub3QgYWx3YXlzCiAgLy8gYSB2YWxpZCBmYWxsYmFjay4gSW4gdGhlIGFic2VuY2Ugb2YgYW4gaW5pdGlhbCB0aW1lIHByb3ZpZGVkIGJ5IHRoZSBicm93c2VyLCBmYWxsYmFjayB0byB0aGUgY3VycmVudCB0aW1lIGZyb20gdGhlCiAgLy8gRGF0ZSBBUEkuCiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCiAgY29uc3QgbmF2aWdhdGlvblN0YXJ0ID0gcGVyZm9ybWFuY2UudGltaW5nICYmIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQ7CiAgY29uc3QgaGFzTmF2aWdhdGlvblN0YXJ0ID0gdHlwZW9mIG5hdmlnYXRpb25TdGFydCA9PT0gJ251bWJlcic7CiAgLy8gaWYgbmF2aWdhdGlvblN0YXJ0IGlzbid0IGF2YWlsYWJsZSBzZXQgZGVsdGEgdG8gdGhyZXNob2xkIHNvIGl0IGlzbid0IHVzZWQKICBjb25zdCBuYXZpZ2F0aW9uU3RhcnREZWx0YSA9IGhhc05hdmlnYXRpb25TdGFydCA/IE1hdGguYWJzKG5hdmlnYXRpb25TdGFydCArIHBlcmZvcm1hbmNlTm93IC0gZGF0ZU5vdykgOiB0aHJlc2hvbGQ7CiAgY29uc3QgbmF2aWdhdGlvblN0YXJ0SXNSZWxpYWJsZSA9IG5hdmlnYXRpb25TdGFydERlbHRhIDwgdGhyZXNob2xkOwoKICBpZiAodGltZU9yaWdpbklzUmVsaWFibGUgfHwgbmF2aWdhdGlvblN0YXJ0SXNSZWxpYWJsZSkgewogICAgLy8gVXNlIHRoZSBtb3JlIHJlbGlhYmxlIHRpbWUgb3JpZ2luCiAgICBpZiAodGltZU9yaWdpbkRlbHRhIDw9IG5hdmlnYXRpb25TdGFydERlbHRhKSB7CiAgICAgIHJldHVybiBwZXJmb3JtYW5jZS50aW1lT3JpZ2luOwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIG5hdmlnYXRpb25TdGFydDsKICAgIH0KICB9CiAgcmV0dXJuIGRhdGVOb3c7Cn0pKCk7CgovKioKICogQ3JlYXRlcyBhbiBlbnZlbG9wZS4KICogTWFrZSBzdXJlIHRvIGFsd2F5cyBleHBsaWNpdGx5IHByb3ZpZGUgdGhlIGdlbmVyaWMgdG8gdGhpcyBmdW5jdGlvbgogKiBzbyB0aGF0IHRoZSBlbnZlbG9wZSB0eXBlcyByZXNvbHZlIGNvcnJlY3RseS4KICovCmZ1bmN0aW9uIGNyZWF0ZUVudmVsb3BlKGhlYWRlcnMsIGl0ZW1zID0gW10pIHsKICByZXR1cm4gW2hlYWRlcnMsIGl0ZW1zXSA7Cn0KCi8qKgogKiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBsb29wIHRocm91Z2ggdGhlIGl0ZW1zIGFuZCBpdGVtIHR5cGVzIG9mIGFuIGVudmVsb3BlLgogKiAoVGhpcyBmdW5jdGlvbiB3YXMgbW9zdGx5IGNyZWF0ZWQgYmVjYXVzZSB3b3JraW5nIHdpdGggZW52ZWxvcGUgdHlwZXMgaXMgcGFpbmZ1bCBhdCB0aGUgbW9tZW50KQogKgogKiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVlLCB0aGUgcmVzdCBvZiB0aGUgaXRlbXMgd2lsbCBiZSBza2lwcGVkLgogKi8KZnVuY3Rpb24gZm9yRWFjaEVudmVsb3BlSXRlbSgKICBlbnZlbG9wZSwKICBjYWxsYmFjaywKKSB7CiAgY29uc3QgZW52ZWxvcGVJdGVtcyA9IGVudmVsb3BlWzFdOwoKICBmb3IgKGNvbnN0IGVudmVsb3BlSXRlbSBvZiBlbnZlbG9wZUl0ZW1zKSB7CiAgICBjb25zdCBlbnZlbG9wZUl0ZW1UeXBlID0gZW52ZWxvcGVJdGVtWzBdLnR5cGU7CiAgICBjb25zdCByZXN1bHQgPSBjYWxsYmFjayhlbnZlbG9wZUl0ZW0sIGVudmVsb3BlSXRlbVR5cGUpOwoKICAgIGlmIChyZXN1bHQpIHsKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgfQoKICByZXR1cm4gZmFsc2U7Cn0KCi8qKgogKiBFbmNvZGUgYSBzdHJpbmcgdG8gVVRGOC4KICovCmZ1bmN0aW9uIGVuY29kZVVURjgoaW5wdXQsIHRleHRFbmNvZGVyKSB7CiAgY29uc3QgdXRmOCA9IHRleHRFbmNvZGVyIHx8IG5ldyBUZXh0RW5jb2RlcigpOwogIHJldHVybiB1dGY4LmVuY29kZShpbnB1dCk7Cn0KCi8qKgogKiBTZXJpYWxpemVzIGFuIGVudmVsb3BlLgogKi8KZnVuY3Rpb24gc2VyaWFsaXplRW52ZWxvcGUoZW52ZWxvcGUsIHRleHRFbmNvZGVyKSB7CiAgY29uc3QgW2VudkhlYWRlcnMsIGl0ZW1zXSA9IGVudmVsb3BlOwoKICAvLyBJbml0aWFsbHkgd2UgY29uc3RydWN0IG91ciBlbnZlbG9wZSBhcyBhIHN0cmluZyBhbmQgb25seSBjb252ZXJ0IHRvIGJpbmFyeSBjaHVua3MgaWYgd2UgZW5jb3VudGVyIGJpbmFyeSBkYXRhCiAgbGV0IHBhcnRzID0gSlNPTi5zdHJpbmdpZnkoZW52SGVhZGVycyk7CgogIGZ1bmN0aW9uIGFwcGVuZChuZXh0KSB7CiAgICBpZiAodHlwZW9mIHBhcnRzID09PSAnc3RyaW5nJykgewogICAgICBwYXJ0cyA9IHR5cGVvZiBuZXh0ID09PSAnc3RyaW5nJyA/IHBhcnRzICsgbmV4dCA6IFtlbmNvZGVVVEY4KHBhcnRzLCB0ZXh0RW5jb2RlciksIG5leHRdOwogICAgfSBlbHNlIHsKICAgICAgcGFydHMucHVzaCh0eXBlb2YgbmV4dCA9PT0gJ3N0cmluZycgPyBlbmNvZGVVVEY4KG5leHQsIHRleHRFbmNvZGVyKSA6IG5leHQpOwogICAgfQogIH0KCiAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7CiAgICBjb25zdCBbaXRlbUhlYWRlcnMsIHBheWxvYWRdID0gaXRlbTsKCiAgICBhcHBlbmQoYFxuJHtKU09OLnN0cmluZ2lmeShpdGVtSGVhZGVycyl9XG5gKTsKCiAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnIHx8IHBheWxvYWQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7CiAgICAgIGFwcGVuZChwYXlsb2FkKTsKICAgIH0gZWxzZSB7CiAgICAgIGxldCBzdHJpbmdpZmllZFBheWxvYWQ7CiAgICAgIHRyeSB7CiAgICAgICAgc3RyaW5naWZpZWRQYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAvLyBJbiBjYXNlLCBkZXNwaXRlIGFsbCBvdXIgZWZmb3J0cyB0byBrZWVwIGBwYXlsb2FkYCBjaXJjdWxhci1kZXBlbmRlbmN5LWZyZWUsIGBKU09OLnN0cmluaWZ5KClgIHN0aWxsCiAgICAgICAgLy8gZmFpbHMsIHdlIHRyeSBhZ2FpbiBhZnRlciBub3JtYWxpemluZyBpdCBhZ2FpbiB3aXRoIGluZmluaXRlIG5vcm1hbGl6YXRpb24gZGVwdGguIFRoaXMgb2YgY291cnNlIGhhcyBhCiAgICAgICAgLy8gcGVyZm9ybWFuY2UgaW1wYWN0IGJ1dCBpbiB0aGlzIGNhc2UgYSBwZXJmb3JtYW5jZSBoaXQgaXMgYmV0dGVyIHRoYW4gdGhyb3dpbmcuCiAgICAgICAgc3RyaW5naWZpZWRQYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplKHBheWxvYWQpKTsKICAgICAgfQogICAgICBhcHBlbmQoc3RyaW5naWZpZWRQYXlsb2FkKTsKICAgIH0KICB9CgogIHJldHVybiB0eXBlb2YgcGFydHMgPT09ICdzdHJpbmcnID8gcGFydHMgOiBjb25jYXRCdWZmZXJzKHBhcnRzKTsKfQoKZnVuY3Rpb24gY29uY2F0QnVmZmVycyhidWZmZXJzKSB7CiAgY29uc3QgdG90YWxMZW5ndGggPSBidWZmZXJzLnJlZHVjZSgoYWNjLCBidWYpID0+IGFjYyArIGJ1Zi5sZW5ndGgsIDApOwoKICBjb25zdCBtZXJnZWQgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7CiAgbGV0IG9mZnNldCA9IDA7CiAgZm9yIChjb25zdCBidWZmZXIgb2YgYnVmZmVycykgewogICAgbWVyZ2VkLnNldChidWZmZXIsIG9mZnNldCk7CiAgICBvZmZzZXQgKz0gYnVmZmVyLmxlbmd0aDsKICB9CgogIHJldHVybiBtZXJnZWQ7Cn0KCmNvbnN0IElURU1fVFlQRV9UT19EQVRBX0NBVEVHT1JZX01BUCA9IHsKICBzZXNzaW9uOiAnc2Vzc2lvbicsCiAgc2Vzc2lvbnM6ICdzZXNzaW9uJywKICBhdHRhY2htZW50OiAnYXR0YWNobWVudCcsCiAgdHJhbnNhY3Rpb246ICd0cmFuc2FjdGlvbicsCiAgZXZlbnQ6ICdlcnJvcicsCiAgY2xpZW50X3JlcG9ydDogJ2ludGVybmFsJywKICB1c2VyX3JlcG9ydDogJ2RlZmF1bHQnLAogIHByb2ZpbGU6ICdwcm9maWxlJywKICByZXBsYXlfZXZlbnQ6ICdyZXBsYXknLAogIHJlcGxheV9yZWNvcmRpbmc6ICdyZXBsYXknLAogIGNoZWNrX2luOiAnbW9uaXRvcicsCiAgZmVlZGJhY2s6ICdmZWVkYmFjaycsCiAgLy8gVE9ETzogVGhpcyBpcyBhIHRlbXBvcmFyeSB3b3JrYXJvdW5kIHVudGlsIHdlIGhhdmUgYSBwcm9wZXIgZGF0YSBjYXRlZ29yeSBmb3IgbWV0cmljcwogIHN0YXRzZDogJ3Vua25vd24nLAp9OwoKLyoqCiAqIE1hcHMgdGhlIHR5cGUgb2YgYW4gZW52ZWxvcGUgaXRlbSB0byBhIGRhdGEgY2F0ZWdvcnkuCiAqLwpmdW5jdGlvbiBlbnZlbG9wZUl0ZW1UeXBlVG9EYXRhQ2F0ZWdvcnkodHlwZSkgewogIHJldHVybiBJVEVNX1RZUEVfVE9fREFUQV9DQVRFR09SWV9NQVBbdHlwZV07Cn0KCi8qKiBFeHRyYWN0cyB0aGUgbWluaW1hbCBTREsgaW5mbyBmcm9tIGZyb20gdGhlIG1ldGFkYXRhIG9yIGFuIGV2ZW50cyAqLwpmdW5jdGlvbiBnZXRTZGtNZXRhZGF0YUZvckVudmVsb3BlSGVhZGVyKG1ldGFkYXRhT3JFdmVudCkgewogIGlmICghbWV0YWRhdGFPckV2ZW50IHx8ICFtZXRhZGF0YU9yRXZlbnQuc2RrKSB7CiAgICByZXR1cm47CiAgfQogIGNvbnN0IHsgbmFtZSwgdmVyc2lvbiB9ID0gbWV0YWRhdGFPckV2ZW50LnNkazsKICByZXR1cm4geyBuYW1lLCB2ZXJzaW9uIH07Cn0KCi8qKgogKiBDcmVhdGVzIGV2ZW50IGVudmVsb3BlIGhlYWRlcnMsIGJhc2VkIG9uIGV2ZW50LCBzZGsgaW5mbyBhbmQgdHVubmVsCiAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBmcm9tIHRoZSBjb3JlIHBhY2thZ2UgdG8gbWFrZSBpdCBhdmFpbGFibGUgaW4gUmVwbGF5CiAqLwpmdW5jdGlvbiBjcmVhdGVFdmVudEVudmVsb3BlSGVhZGVycygKICBldmVudCwKICBzZGtJbmZvLAogIHR1bm5lbCwKICBkc24sCikgewogIGNvbnN0IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQgPSBldmVudC5zZGtQcm9jZXNzaW5nTWV0YWRhdGEgJiYgZXZlbnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhLmR5bmFtaWNTYW1wbGluZ0NvbnRleHQ7CiAgcmV0dXJuIHsKICAgIGV2ZW50X2lkOiBldmVudC5ldmVudF9pZCAsCiAgICBzZW50X2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksCiAgICAuLi4oc2RrSW5mbyAmJiB7IHNkazogc2RrSW5mbyB9KSwKICAgIC4uLighIXR1bm5lbCAmJiBkc24gJiYgeyBkc246IGRzblRvU3RyaW5nKGRzbikgfSksCiAgICAuLi4oZHluYW1pY1NhbXBsaW5nQ29udGV4dCAmJiB7CiAgICAgIHRyYWNlOiBkcm9wVW5kZWZpbmVkS2V5cyh7IC4uLmR5bmFtaWNTYW1wbGluZ0NvbnRleHQgfSksCiAgICB9KSwKICB9Owp9CgovLyBJbnRlbnRpb25hbGx5IGtlZXBpbmcgdGhlIGtleSBicm9hZCwgYXMgd2UgZG9uJ3Qga25vdyBmb3Igc3VyZSB3aGF0IHJhdGUgbGltaXQgaGVhZGVycyBnZXQgcmV0dXJuZWQgZnJvbSBiYWNrZW5kCgpjb25zdCBERUZBVUxUX1JFVFJZX0FGVEVSID0gNjAgKiAxMDAwOyAvLyA2MCBzZWNvbmRzCgovKioKICogRXh0cmFjdHMgUmV0cnktQWZ0ZXIgdmFsdWUgZnJvbSB0aGUgcmVxdWVzdCBoZWFkZXIgb3IgcmV0dXJucyBkZWZhdWx0IHZhbHVlCiAqIEBwYXJhbSBoZWFkZXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mICdSZXRyeS1BZnRlcicgaGVhZGVyCiAqIEBwYXJhbSBub3cgY3VycmVudCB1bml4IHRpbWVzdGFtcAogKgogKi8KZnVuY3Rpb24gcGFyc2VSZXRyeUFmdGVySGVhZGVyKGhlYWRlciwgbm93ID0gRGF0ZS5ub3coKSkgewogIGNvbnN0IGhlYWRlckRlbGF5ID0gcGFyc2VJbnQoYCR7aGVhZGVyfWAsIDEwKTsKICBpZiAoIWlzTmFOKGhlYWRlckRlbGF5KSkgewogICAgcmV0dXJuIGhlYWRlckRlbGF5ICogMTAwMDsKICB9CgogIGNvbnN0IGhlYWRlckRhdGUgPSBEYXRlLnBhcnNlKGAke2hlYWRlcn1gKTsKICBpZiAoIWlzTmFOKGhlYWRlckRhdGUpKSB7CiAgICByZXR1cm4gaGVhZGVyRGF0ZSAtIG5vdzsKICB9CgogIHJldHVybiBERUZBVUxUX1JFVFJZX0FGVEVSOwp9CgovKioKICogR2V0cyB0aGUgdGltZSB0aGF0IHRoZSBnaXZlbiBjYXRlZ29yeSBpcyBkaXNhYmxlZCB1bnRpbCBmb3IgcmF0ZSBsaW1pdGluZy4KICogSW4gY2FzZSBubyBjYXRlZ29yeS1zcGVjaWZpYyBsaW1pdCBpcyBzZXQgYnV0IGEgZ2VuZXJhbCByYXRlIGxpbWl0IGFjcm9zcyBhbGwgY2F0ZWdvcmllcyBpcyBhY3RpdmUsCiAqIHRoYXQgdGltZSBpcyByZXR1cm5lZC4KICoKICogQHJldHVybiB0aGUgdGltZSBpbiBtcyB0aGF0IHRoZSBjYXRlZ29yeSBpcyBkaXNhYmxlZCB1bnRpbCBvciAwIGlmIHRoZXJlJ3Mgbm8gYWN0aXZlIHJhdGUgbGltaXQuCiAqLwpmdW5jdGlvbiBkaXNhYmxlZFVudGlsKGxpbWl0cywgY2F0ZWdvcnkpIHsKICByZXR1cm4gbGltaXRzW2NhdGVnb3J5XSB8fCBsaW1pdHMuYWxsIHx8IDA7Cn0KCi8qKgogKiBDaGVja3MgaWYgYSBjYXRlZ29yeSBpcyByYXRlIGxpbWl0ZWQKICovCmZ1bmN0aW9uIGlzUmF0ZUxpbWl0ZWQobGltaXRzLCBjYXRlZ29yeSwgbm93ID0gRGF0ZS5ub3coKSkgewogIHJldHVybiBkaXNhYmxlZFVudGlsKGxpbWl0cywgY2F0ZWdvcnkpID4gbm93Owp9CgovKioKICogVXBkYXRlIHJhdGVsaW1pdHMgZnJvbSBpbmNvbWluZyBoZWFkZXJzLgogKgogKiBAcmV0dXJuIHRoZSB1cGRhdGVkIFJhdGVMaW1pdHMgb2JqZWN0LgogKi8KZnVuY3Rpb24gdXBkYXRlUmF0ZUxpbWl0cygKICBsaW1pdHMsCiAgeyBzdGF0dXNDb2RlLCBoZWFkZXJzIH0sCiAgbm93ID0gRGF0ZS5ub3coKSwKKSB7CiAgY29uc3QgdXBkYXRlZFJhdGVMaW1pdHMgPSB7CiAgICAuLi5saW1pdHMsCiAgfTsKCiAgLy8gIlRoZSBuYW1lIGlzIGNhc2UtaW5zZW5zaXRpdmUuIgogIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IZWFkZXJzL2dldAogIGNvbnN0IHJhdGVMaW1pdEhlYWRlciA9IGhlYWRlcnMgJiYgaGVhZGVyc1sneC1zZW50cnktcmF0ZS1saW1pdHMnXTsKICBjb25zdCByZXRyeUFmdGVySGVhZGVyID0gaGVhZGVycyAmJiBoZWFkZXJzWydyZXRyeS1hZnRlciddOwoKICBpZiAocmF0ZUxpbWl0SGVhZGVyKSB7CiAgICAvKioKICAgICAqIHJhdGUgbGltaXQgaGVhZGVycyBhcmUgb2YgdGhlIGZvcm0KICAgICAqICAgICA8aGVhZGVyPiw8aGVhZGVyPiwuLgogICAgICogd2hlcmUgZWFjaCA8aGVhZGVyPiBpcyBvZiB0aGUgZm9ybQogICAgICogICAgIDxyZXRyeV9hZnRlcj46IDxjYXRlZ29yaWVzPjogPHNjb3BlPjogPHJlYXNvbl9jb2RlPgogICAgICogd2hlcmUKICAgICAqICAgICA8cmV0cnlfYWZ0ZXI+IGlzIGEgZGVsYXkgaW4gc2Vjb25kcwogICAgICogICAgIDxjYXRlZ29yaWVzPiBpcyB0aGUgZXZlbnQgdHlwZShzKSAoZXJyb3IsIHRyYW5zYWN0aW9uLCBldGMpIGJlaW5nIHJhdGUgbGltaXRlZCBhbmQgaXMgb2YgdGhlIGZvcm0KICAgICAqICAgICAgICAgPGNhdGVnb3J5Pjs8Y2F0ZWdvcnk+Oy4uLgogICAgICogICAgIDxzY29wZT4gaXMgd2hhdCdzIGJlaW5nIGxpbWl0ZWQgKG9yZywgcHJvamVjdCwgb3Iga2V5KSAtIGlnbm9yZWQgYnkgU0RLCiAgICAgKiAgICAgPHJlYXNvbl9jb2RlPiBpcyBhbiBhcmJpdHJhcnkgc3RyaW5nIGxpa2UgIm9yZ19xdW90YSIgLSBpZ25vcmVkIGJ5IFNESwogICAgICovCiAgICBmb3IgKGNvbnN0IGxpbWl0IG9mIHJhdGVMaW1pdEhlYWRlci50cmltKCkuc3BsaXQoJywnKSkgewogICAgICBjb25zdCBbcmV0cnlBZnRlciwgY2F0ZWdvcmllc10gPSBsaW1pdC5zcGxpdCgnOicsIDIpOwogICAgICBjb25zdCBoZWFkZXJEZWxheSA9IHBhcnNlSW50KHJldHJ5QWZ0ZXIsIDEwKTsKICAgICAgY29uc3QgZGVsYXkgPSAoIWlzTmFOKGhlYWRlckRlbGF5KSA/IGhlYWRlckRlbGF5IDogNjApICogMTAwMDsgLy8gNjBzZWMgZGVmYXVsdAogICAgICBpZiAoIWNhdGVnb3JpZXMpIHsKICAgICAgICB1cGRhdGVkUmF0ZUxpbWl0cy5hbGwgPSBub3cgKyBkZWxheTsKICAgICAgfSBlbHNlIHsKICAgICAgICBmb3IgKGNvbnN0IGNhdGVnb3J5IG9mIGNhdGVnb3JpZXMuc3BsaXQoJzsnKSkgewogICAgICAgICAgdXBkYXRlZFJhdGVMaW1pdHNbY2F0ZWdvcnldID0gbm93ICsgZGVsYXk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfSBlbHNlIGlmIChyZXRyeUFmdGVySGVhZGVyKSB7CiAgICB1cGRhdGVkUmF0ZUxpbWl0cy5hbGwgPSBub3cgKyBwYXJzZVJldHJ5QWZ0ZXJIZWFkZXIocmV0cnlBZnRlckhlYWRlciwgbm93KTsKICB9IGVsc2UgaWYgKHN0YXR1c0NvZGUgPT09IDQyOSkgewogICAgdXBkYXRlZFJhdGVMaW1pdHMuYWxsID0gbm93ICsgNjAgKiAxMDAwOwogIH0KCiAgcmV0dXJuIHVwZGF0ZWRSYXRlTGltaXRzOwp9CgovKioKICogQSBub2RlLmpzIHdhdGNoZG9nIHRpbWVyCiAqIEBwYXJhbSBwb2xsSW50ZXJ2YWwgVGhlIGludGVydmFsIHRoYXQgd2UgZXhwZWN0IHRvIGdldCBwb2xsZWQgYXQKICogQHBhcmFtIGFuclRocmVzaG9sZCBUaGUgdGhyZXNob2xkIGZvciB3aGVuIHdlIGNvbnNpZGVyIEFOUgogKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGNhbGwgZm9yIEFOUgogKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCBgcG9sbGAgYW5kIGBlbmFibGVkYCBmdW5jdGlvbnMge0BsaW5rIFdhdGNoZG9nUmV0dXJufQogKi8KZnVuY3Rpb24gd2F0Y2hkb2dUaW1lcigKICBjcmVhdGVUaW1lciwKICBwb2xsSW50ZXJ2YWwsCiAgYW5yVGhyZXNob2xkLAogIGNhbGxiYWNrLAopIHsKICBjb25zdCB0aW1lciA9IGNyZWF0ZVRpbWVyKCk7CiAgbGV0IHRyaWdnZXJlZCA9IGZhbHNlOwogIGxldCBlbmFibGVkID0gdHJ1ZTsKCiAgc2V0SW50ZXJ2YWwoKCkgPT4gewogICAgY29uc3QgZGlmZk1zID0gdGltZXIuZ2V0VGltZU1zKCk7CgogICAgaWYgKHRyaWdnZXJlZCA9PT0gZmFsc2UgJiYgZGlmZk1zID4gcG9sbEludGVydmFsICsgYW5yVGhyZXNob2xkKSB7CiAgICAgIHRyaWdnZXJlZCA9IHRydWU7CiAgICAgIGlmIChlbmFibGVkKSB7CiAgICAgICAgY2FsbGJhY2soKTsKICAgICAgfQogICAgfQoKICAgIGlmIChkaWZmTXMgPCBwb2xsSW50ZXJ2YWwgKyBhbnJUaHJlc2hvbGQpIHsKICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7CiAgICB9CiAgfSwgMjApOwoKICByZXR1cm4gewogICAgcG9sbDogKCkgPT4gewogICAgICB0aW1lci5yZXNldCgpOwogICAgfSwKICAgIGVuYWJsZWQ6IChzdGF0ZSkgPT4gewogICAgICBlbmFibGVkID0gc3RhdGU7CiAgICB9LAogIH07Cn0KCi8vIHR5cGVzIGNvcGllZCBmcm9tIGluc3BlY3Rvci5kLnRzCgovKioKICogQ29udmVydHMgRGVidWdnZXIuQ2FsbEZyYW1lIHRvIFNlbnRyeSBTdGFja0ZyYW1lCiAqLwpmdW5jdGlvbiBjYWxsRnJhbWVUb1N0YWNrRnJhbWUoCiAgZnJhbWUsCiAgdXJsLAogIGdldE1vZHVsZUZyb21GaWxlbmFtZSwKKSB7CiAgY29uc3QgZmlsZW5hbWUgPSB1cmwgPyB1cmwucmVwbGFjZSgvXmZpbGU6XC9cLy8sICcnKSA6IHVuZGVmaW5lZDsKCiAgLy8gQ2FsbEZyYW1lIHJvdy9jb2wgYXJlIDAgYmFzZWQsIHdoZXJlYXMgU3RhY2tGcmFtZSBhcmUgMSBiYXNlZAogIGNvbnN0IGNvbG5vID0gZnJhbWUubG9jYXRpb24uY29sdW1uTnVtYmVyID8gZnJhbWUubG9jYXRpb24uY29sdW1uTnVtYmVyICsgMSA6IHVuZGVmaW5lZDsKICBjb25zdCBsaW5lbm8gPSBmcmFtZS5sb2NhdGlvbi5saW5lTnVtYmVyID8gZnJhbWUubG9jYXRpb24ubGluZU51bWJlciArIDEgOiB1bmRlZmluZWQ7CgogIHJldHVybiBkcm9wVW5kZWZpbmVkS2V5cyh7CiAgICBmaWxlbmFtZSwKICAgIG1vZHVsZTogZ2V0TW9kdWxlRnJvbUZpbGVuYW1lKGZpbGVuYW1lKSwKICAgIGZ1bmN0aW9uOiBmcmFtZS5mdW5jdGlvbk5hbWUgfHwgJz8nLAogICAgY29sbm8sCiAgICBsaW5lbm8sCiAgICBpbl9hcHA6IGZpbGVuYW1lID8gZmlsZW5hbWVJc0luQXBwKGZpbGVuYW1lKSA6IHVuZGVmaW5lZCwKICB9KTsKfQoKLyoqCiAqIFRoaXMgc2VydmVzIGFzIGEgYnVpbGQgdGltZSBmbGFnIHRoYXQgd2lsbCBiZSB0cnVlIGJ5IGRlZmF1bHQsIGJ1dCBmYWxzZSBpbiBub24tZGVidWcgYnVpbGRzIG9yIGlmIHVzZXJzIHJlcGxhY2UgYF9fU0VOVFJZX0RFQlVHX19gIGluIHRoZWlyIGdlbmVyYXRlZCBjb2RlLgogKgogKiBBVFRFTlRJT046IFRoaXMgY29uc3RhbnQgbXVzdCBuZXZlciBjcm9zcyBwYWNrYWdlIGJvdW5kYXJpZXMgKGkuZS4gYmUgZXhwb3J0ZWQpIHRvIGd1YXJhbnRlZSB0aGF0IGl0IGNhbiBiZSB1c2VkIGZvciB0cmVlIHNoYWtpbmcuCiAqLwpjb25zdCBERUJVR19CVUlMRCA9ICh0eXBlb2YgX19TRU5UUllfREVCVUdfXyA9PT0gJ3VuZGVmaW5lZCcgfHwgX19TRU5UUllfREVCVUdfXyk7CgovKioKICogQ3JlYXRlcyBhIG5ldyBgU2Vzc2lvbmAgb2JqZWN0IGJ5IHNldHRpbmcgY2VydGFpbiBkZWZhdWx0IHBhcmFtZXRlcnMuIElmIG9wdGlvbmFsIEBwYXJhbSBjb250ZXh0CiAqIGlzIHBhc3NlZCwgdGhlIHBhc3NlZCBwcm9wZXJ0aWVzIGFyZSBhcHBsaWVkIHRvIHRoZSBzZXNzaW9uIG9iamVjdC4KICoKICogQHBhcmFtIGNvbnRleHQgKG9wdGlvbmFsKSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gYmUgYXBwbGllZCB0byB0aGUgcmV0dXJuZWQgc2Vzc2lvbiBvYmplY3QKICoKICogQHJldHVybnMgYSBuZXcgYFNlc3Npb25gIG9iamVjdAogKi8KZnVuY3Rpb24gbWFrZVNlc3Npb24oY29udGV4dCkgewogIC8vIEJvdGggdGltZXN0YW1wIGFuZCBzdGFydGVkIGFyZSBpbiBzZWNvbmRzIHNpbmNlIHRoZSBVTklYIGVwb2NoLgogIGNvbnN0IHN0YXJ0aW5nVGltZSA9IHRpbWVzdGFtcEluU2Vjb25kcygpOwoKICBjb25zdCBzZXNzaW9uID0gewogICAgc2lkOiB1dWlkNCgpLAogICAgaW5pdDogdHJ1ZSwKICAgIHRpbWVzdGFtcDogc3RhcnRpbmdUaW1lLAogICAgc3RhcnRlZDogc3RhcnRpbmdUaW1lLAogICAgZHVyYXRpb246IDAsCiAgICBzdGF0dXM6ICdvaycsCiAgICBlcnJvcnM6IDAsCiAgICBpZ25vcmVEdXJhdGlvbjogZmFsc2UsCiAgICB0b0pTT046ICgpID0+IHNlc3Npb25Ub0pTT04oc2Vzc2lvbiksCiAgfTsKCiAgaWYgKGNvbnRleHQpIHsKICAgIHVwZGF0ZVNlc3Npb24oc2Vzc2lvbiwgY29udGV4dCk7CiAgfQoKICByZXR1cm4gc2Vzc2lvbjsKfQoKLyoqCiAqIFVwZGF0ZXMgYSBzZXNzaW9uIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIHBhc3NlZCBpbiB0aGUgY29udGV4dC4KICoKICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gbXV0YXRlcyB0aGUgcGFzc2VkIG9iamVjdCBhbmQgcmV0dXJucyB2b2lkLgogKiAoSGFkIHRvIGRvIHRoaXMgaW5zdGVhZCBvZiByZXR1cm5pbmcgYSBuZXcgYW5kIHVwZGF0ZWQgc2Vzc2lvbiBiZWNhdXNlIGNsb3NpbmcgYW5kIHNlbmRpbmcgYSBzZXNzaW9uCiAqIG1ha2VzIGFuIHVwZGF0ZSB0byB0aGUgc2Vzc2lvbiBhZnRlciBpdCB3YXMgcGFzc2VkIHRvIHRoZSBzZW5kaW5nIGxvZ2ljLgogKiBAc2VlIEJhc2VDbGllbnQuY2FwdHVyZVNlc3Npb24gKQogKgogKiBAcGFyYW0gc2Vzc2lvbiB0aGUgYFNlc3Npb25gIHRvIHVwZGF0ZQogKiBAcGFyYW0gY29udGV4dCB0aGUgYFNlc3Npb25Db250ZXh0YCBob2xkaW5nIHRoZSBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHVwZGF0ZWQgaW4gQHBhcmFtIHNlc3Npb24KICovCi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5CmZ1bmN0aW9uIHVwZGF0ZVNlc3Npb24oc2Vzc2lvbiwgY29udGV4dCA9IHt9KSB7CiAgaWYgKGNvbnRleHQudXNlcikgewogICAgaWYgKCFzZXNzaW9uLmlwQWRkcmVzcyAmJiBjb250ZXh0LnVzZXIuaXBfYWRkcmVzcykgewogICAgICBzZXNzaW9uLmlwQWRkcmVzcyA9IGNvbnRleHQudXNlci5pcF9hZGRyZXNzOwogICAgfQoKICAgIGlmICghc2Vzc2lvbi5kaWQgJiYgIWNvbnRleHQuZGlkKSB7CiAgICAgIHNlc3Npb24uZGlkID0gY29udGV4dC51c2VyLmlkIHx8IGNvbnRleHQudXNlci5lbWFpbCB8fCBjb250ZXh0LnVzZXIudXNlcm5hbWU7CiAgICB9CiAgfQoKICBzZXNzaW9uLnRpbWVzdGFtcCA9IGNvbnRleHQudGltZXN0YW1wIHx8IHRpbWVzdGFtcEluU2Vjb25kcygpOwoKICBpZiAoY29udGV4dC5hYm5vcm1hbF9tZWNoYW5pc20pIHsKICAgIHNlc3Npb24uYWJub3JtYWxfbWVjaGFuaXNtID0gY29udGV4dC5hYm5vcm1hbF9tZWNoYW5pc207CiAgfQoKICBpZiAoY29udGV4dC5pZ25vcmVEdXJhdGlvbikgewogICAgc2Vzc2lvbi5pZ25vcmVEdXJhdGlvbiA9IGNvbnRleHQuaWdub3JlRHVyYXRpb247CiAgfQogIGlmIChjb250ZXh0LnNpZCkgewogICAgLy8gR29vZCBlbm91Z2ggdXVpZCB2YWxpZGF0aW9uLiDigJQgS2FtaWwKICAgIHNlc3Npb24uc2lkID0gY29udGV4dC5zaWQubGVuZ3RoID09PSAzMiA/IGNvbnRleHQuc2lkIDogdXVpZDQoKTsKICB9CiAgaWYgKGNvbnRleHQuaW5pdCAhPT0gdW5kZWZpbmVkKSB7CiAgICBzZXNzaW9uLmluaXQgPSBjb250ZXh0LmluaXQ7CiAgfQogIGlmICghc2Vzc2lvbi5kaWQgJiYgY29udGV4dC5kaWQpIHsKICAgIHNlc3Npb24uZGlkID0gYCR7Y29udGV4dC5kaWR9YDsKICB9CiAgaWYgKHR5cGVvZiBjb250ZXh0LnN0YXJ0ZWQgPT09ICdudW1iZXInKSB7CiAgICBzZXNzaW9uLnN0YXJ0ZWQgPSBjb250ZXh0LnN0YXJ0ZWQ7CiAgfQogIGlmIChzZXNzaW9uLmlnbm9yZUR1cmF0aW9uKSB7CiAgICBzZXNzaW9uLmR1cmF0aW9uID0gdW5kZWZpbmVkOwogIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHQuZHVyYXRpb24gPT09ICdudW1iZXInKSB7CiAgICBzZXNzaW9uLmR1cmF0aW9uID0gY29udGV4dC5kdXJhdGlvbjsKICB9IGVsc2UgewogICAgY29uc3QgZHVyYXRpb24gPSBzZXNzaW9uLnRpbWVzdGFtcCAtIHNlc3Npb24uc3RhcnRlZDsKICAgIHNlc3Npb24uZHVyYXRpb24gPSBkdXJhdGlvbiA+PSAwID8gZHVyYXRpb24gOiAwOwogIH0KICBpZiAoY29udGV4dC5yZWxlYXNlKSB7CiAgICBzZXNzaW9uLnJlbGVhc2UgPSBjb250ZXh0LnJlbGVhc2U7CiAgfQogIGlmIChjb250ZXh0LmVudmlyb25tZW50KSB7CiAgICBzZXNzaW9uLmVudmlyb25tZW50ID0gY29udGV4dC5lbnZpcm9ubWVudDsKICB9CiAgaWYgKCFzZXNzaW9uLmlwQWRkcmVzcyAmJiBjb250ZXh0LmlwQWRkcmVzcykgewogICAgc2Vzc2lvbi5pcEFkZHJlc3MgPSBjb250ZXh0LmlwQWRkcmVzczsKICB9CiAgaWYgKCFzZXNzaW9uLnVzZXJBZ2VudCAmJiBjb250ZXh0LnVzZXJBZ2VudCkgewogICAgc2Vzc2lvbi51c2VyQWdlbnQgPSBjb250ZXh0LnVzZXJBZ2VudDsKICB9CiAgaWYgKHR5cGVvZiBjb250ZXh0LmVycm9ycyA9PT0gJ251bWJlcicpIHsKICAgIHNlc3Npb24uZXJyb3JzID0gY29udGV4dC5lcnJvcnM7CiAgfQogIGlmIChjb250ZXh0LnN0YXR1cykgewogICAgc2Vzc2lvbi5zdGF0dXMgPSBjb250ZXh0LnN0YXR1czsKICB9Cn0KCi8qKgogKiBTZXJpYWxpemVzIGEgcGFzc2VkIHNlc3Npb24gb2JqZWN0IHRvIGEgSlNPTiBvYmplY3Qgd2l0aCBhIHNsaWdodGx5IGRpZmZlcmVudCBzdHJ1Y3R1cmUuCiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIFNlbnRyeSBiYWNrZW5kIHJlcXVpcmVzIGEgc2xpZ2h0bHkgZGlmZmVyZW50IHNjaGVtYSBvZiBhIHNlc3Npb24KICogdGhhbiB0aGUgb25lIHRoZSBKUyBTREtzIHVzZSBpbnRlcm5hbGx5LgogKgogKiBAcGFyYW0gc2Vzc2lvbiB0aGUgc2Vzc2lvbiB0byBiZSBjb252ZXJ0ZWQKICoKICogQHJldHVybnMgYSBKU09OIG9iamVjdCBvZiB0aGUgcGFzc2VkIHNlc3Npb24KICovCmZ1bmN0aW9uIHNlc3Npb25Ub0pTT04oc2Vzc2lvbikgewogIHJldHVybiBkcm9wVW5kZWZpbmVkS2V5cyh7CiAgICBzaWQ6IGAke3Nlc3Npb24uc2lkfWAsCiAgICBpbml0OiBzZXNzaW9uLmluaXQsCiAgICAvLyBNYWtlIHN1cmUgdGhhdCBzZWMgaXMgY29udmVydGVkIHRvIG1zIGZvciBkYXRlIGNvbnN0cnVjdG9yCiAgICBzdGFydGVkOiBuZXcgRGF0ZShzZXNzaW9uLnN0YXJ0ZWQgKiAxMDAwKS50b0lTT1N0cmluZygpLAogICAgdGltZXN0YW1wOiBuZXcgRGF0ZShzZXNzaW9uLnRpbWVzdGFtcCAqIDEwMDApLnRvSVNPU3RyaW5nKCksCiAgICBzdGF0dXM6IHNlc3Npb24uc3RhdHVzLAogICAgZXJyb3JzOiBzZXNzaW9uLmVycm9ycywKICAgIGRpZDogdHlwZW9mIHNlc3Npb24uZGlkID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygc2Vzc2lvbi5kaWQgPT09ICdzdHJpbmcnID8gYCR7c2Vzc2lvbi5kaWR9YCA6IHVuZGVmaW5lZCwKICAgIGR1cmF0aW9uOiBzZXNzaW9uLmR1cmF0aW9uLAogICAgYWJub3JtYWxfbWVjaGFuaXNtOiBzZXNzaW9uLmFibm9ybWFsX21lY2hhbmlzbSwKICAgIGF0dHJzOiB7CiAgICAgIHJlbGVhc2U6IHNlc3Npb24ucmVsZWFzZSwKICAgICAgZW52aXJvbm1lbnQ6IHNlc3Npb24uZW52aXJvbm1lbnQsCiAgICAgIGlwX2FkZHJlc3M6IHNlc3Npb24uaXBBZGRyZXNzLAogICAgICB1c2VyX2FnZW50OiBzZXNzaW9uLnVzZXJBZ2VudCwKICAgIH0sCiAgfSk7Cn0KCi8qKgogKiBBcHBseSBTZGtJbmZvIChuYW1lLCB2ZXJzaW9uLCBwYWNrYWdlcywgaW50ZWdyYXRpb25zKSB0byB0aGUgY29ycmVzcG9uZGluZyBldmVudCBrZXkuCiAqIE1lcmdlIHdpdGggZXhpc3RpbmcgZGF0YSBpZiBhbnkuCiAqKi8KZnVuY3Rpb24gZW5oYW5jZUV2ZW50V2l0aFNka0luZm8oZXZlbnQsIHNka0luZm8pIHsKICBpZiAoIXNka0luZm8pIHsKICAgIHJldHVybiBldmVudDsKICB9CiAgZXZlbnQuc2RrID0gZXZlbnQuc2RrIHx8IHt9OwogIGV2ZW50LnNkay5uYW1lID0gZXZlbnQuc2RrLm5hbWUgfHwgc2RrSW5mby5uYW1lOwogIGV2ZW50LnNkay52ZXJzaW9uID0gZXZlbnQuc2RrLnZlcnNpb24gfHwgc2RrSW5mby52ZXJzaW9uOwogIGV2ZW50LnNkay5pbnRlZ3JhdGlvbnMgPSBbLi4uKGV2ZW50LnNkay5pbnRlZ3JhdGlvbnMgfHwgW10pLCAuLi4oc2RrSW5mby5pbnRlZ3JhdGlvbnMgfHwgW10pXTsKICBldmVudC5zZGsucGFja2FnZXMgPSBbLi4uKGV2ZW50LnNkay5wYWNrYWdlcyB8fCBbXSksIC4uLihzZGtJbmZvLnBhY2thZ2VzIHx8IFtdKV07CiAgcmV0dXJuIGV2ZW50Owp9CgovKiogQ3JlYXRlcyBhbiBlbnZlbG9wZSBmcm9tIGEgU2Vzc2lvbiAqLwpmdW5jdGlvbiBjcmVhdGVTZXNzaW9uRW52ZWxvcGUoCiAgc2Vzc2lvbiwKICBkc24sCiAgbWV0YWRhdGEsCiAgdHVubmVsLAopIHsKICBjb25zdCBzZGtJbmZvID0gZ2V0U2RrTWV0YWRhdGFGb3JFbnZlbG9wZUhlYWRlcihtZXRhZGF0YSk7CiAgY29uc3QgZW52ZWxvcGVIZWFkZXJzID0gewogICAgc2VudF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLAogICAgLi4uKHNka0luZm8gJiYgeyBzZGs6IHNka0luZm8gfSksCiAgICAuLi4oISF0dW5uZWwgJiYgZHNuICYmIHsgZHNuOiBkc25Ub1N0cmluZyhkc24pIH0pLAogIH07CgogIGNvbnN0IGVudmVsb3BlSXRlbSA9CiAgICAnYWdncmVnYXRlcycgaW4gc2Vzc2lvbiA/IFt7IHR5cGU6ICdzZXNzaW9ucycgfSwgc2Vzc2lvbl0gOiBbeyB0eXBlOiAnc2Vzc2lvbicgfSwgc2Vzc2lvbi50b0pTT04oKV07CgogIHJldHVybiBjcmVhdGVFbnZlbG9wZShlbnZlbG9wZUhlYWRlcnMsIFtlbnZlbG9wZUl0ZW1dKTsKfQoKLyoqCiAqIENyZWF0ZSBhbiBFbnZlbG9wZSBmcm9tIGFuIGV2ZW50LgogKi8KZnVuY3Rpb24gY3JlYXRlRXZlbnRFbnZlbG9wZSgKICBldmVudCwKICBkc24sCiAgbWV0YWRhdGEsCiAgdHVubmVsLAopIHsKICBjb25zdCBzZGtJbmZvID0gZ2V0U2RrTWV0YWRhdGFGb3JFbnZlbG9wZUhlYWRlcihtZXRhZGF0YSk7CgogIC8qCiAgICBOb3RlOiBEdWUgdG8gVFMsIGV2ZW50LnR5cGUgbWF5IGJlIGByZXBsYXlfZXZlbnRgLCB0aGVvcmV0aWNhbGx5LgogICAgSW4gcHJhY3RpY2UsIHdlIG5ldmVyIGNhbGwgYGNyZWF0ZUV2ZW50RW52ZWxvcGVgIHdpdGggYHJlcGxheV9ldmVudGAgdHlwZSwKICAgIGFuZCB3ZSdkIGhhdmUgdG8gYWRqdXQgYSBsb29vdCBvZiB0eXBlcyB0byBtYWtlIHRoaXMgd29yayBwcm9wZXJseS4KICAgIFdlIHdhbnQgdG8gYXZvaWQgY2FzdGluZyB0aGlzIGFyb3VuZCwgYXMgdGhhdCBjb3VsZCBsZWFkIHRvIGJ1Z3MgKGUuZy4gd2hlbiB3ZSBhZGQgYW5vdGhlciB0eXBlKQogICAgU28gdGhlIHNhZmUgY2hvaWNlIGlzIHRvIHJlYWxseSBndWFyZCBhZ2FpbnN0IHRoZSByZXBsYXlfZXZlbnQgdHlwZSBoZXJlLgogICovCiAgY29uc3QgZXZlbnRUeXBlID0gZXZlbnQudHlwZSAmJiBldmVudC50eXBlICE9PSAncmVwbGF5X2V2ZW50JyA/IGV2ZW50LnR5cGUgOiAnZXZlbnQnOwoKICBlbmhhbmNlRXZlbnRXaXRoU2RrSW5mbyhldmVudCwgbWV0YWRhdGEgJiYgbWV0YWRhdGEuc2RrKTsKCiAgY29uc3QgZW52ZWxvcGVIZWFkZXJzID0gY3JlYXRlRXZlbnRFbnZlbG9wZUhlYWRlcnMoZXZlbnQsIHNka0luZm8sIHR1bm5lbCwgZHNuKTsKCiAgLy8gUHJldmVudCB0aGlzIGRhdGEgKHdoaWNoLCBpZiBpdCBleGlzdHMsIHdhcyB1c2VkIGluIGVhcmxpZXIgc3RlcHMgaW4gdGhlIHByb2Nlc3NpbmcgcGlwZWxpbmUpIGZyb20gYmVpbmcgc2VudCB0bwogIC8vIHNlbnRyeS4gKE5vdGU6IE91ciB1c2Ugb2YgdGhpcyBwcm9wZXJ0eSBjb21lcyBhbmQgZ29lcyB3aXRoIHdoYXRldmVyIHdlIG1pZ2h0IGJlIGRlYnVnZ2luZywgd2hhdGV2ZXIgaGFja3Mgd2UgbWF5CiAgLy8gaGF2ZSB0ZW1wb3JhcmlseSBhZGRlZCwgZXRjLiBFdmVuIGlmIHdlIGRvbid0IGhhcHBlbiB0byBiZSB1c2luZyBpdCBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUsIGxldCdzIG5vdCBnZXQgcmlkCiAgLy8gb2YgdGhpcyBgZGVsZXRlYCwgbGVzdCB3ZSBtaXNzIHB1dHRpbmcgaXQgYmFjayBpbiB0aGUgbmV4dCB0aW1lIHRoZSBwcm9wZXJ0eSBpcyBpbiB1c2UuKQogIGRlbGV0ZSBldmVudC5zZGtQcm9jZXNzaW5nTWV0YWRhdGE7CgogIGNvbnN0IGV2ZW50SXRlbSA9IFt7IHR5cGU6IGV2ZW50VHlwZSB9LCBldmVudF07CiAgcmV0dXJuIGNyZWF0ZUVudmVsb3BlKGVudmVsb3BlSGVhZGVycywgW2V2ZW50SXRlbV0pOwp9Cgpjb25zdCBTRU5UUllfQVBJX1ZFUlNJT04gPSAnNyc7CgovKiogUmV0dXJucyB0aGUgcHJlZml4IHRvIGNvbnN0cnVjdCBTZW50cnkgaW5nZXN0aW9uIEFQSSBlbmRwb2ludHMuICovCmZ1bmN0aW9uIGdldEJhc2VBcGlFbmRwb2ludChkc24pIHsKICBjb25zdCBwcm90b2NvbCA9IGRzbi5wcm90b2NvbCA/IGAke2Rzbi5wcm90b2NvbH06YCA6ICcnOwogIGNvbnN0IHBvcnQgPSBkc24ucG9ydCA/IGA6JHtkc24ucG9ydH1gIDogJyc7CiAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtkc24uaG9zdH0ke3BvcnR9JHtkc24ucGF0aCA/IGAvJHtkc24ucGF0aH1gIDogJyd9L2FwaS9gOwp9CgovKiogUmV0dXJucyB0aGUgaW5nZXN0IEFQSSBlbmRwb2ludCBmb3IgdGFyZ2V0LiAqLwpmdW5jdGlvbiBfZ2V0SW5nZXN0RW5kcG9pbnQoZHNuKSB7CiAgcmV0dXJuIGAke2dldEJhc2VBcGlFbmRwb2ludChkc24pfSR7ZHNuLnByb2plY3RJZH0vZW52ZWxvcGUvYDsKfQoKLyoqIFJldHVybnMgYSBVUkwtZW5jb2RlZCBzdHJpbmcgd2l0aCBhdXRoIGNvbmZpZyBzdWl0YWJsZSBmb3IgYSBxdWVyeSBzdHJpbmcuICovCmZ1bmN0aW9uIF9lbmNvZGVkQXV0aChkc24sIHNka0luZm8pIHsKICByZXR1cm4gdXJsRW5jb2RlKHsKICAgIC8vIFdlIHNlbmQgb25seSB0aGUgbWluaW11bSBzZXQgb2YgcmVxdWlyZWQgaW5mb3JtYXRpb24uIFNlZQogICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdC9pc3N1ZXMvMjU3Mi4KICAgIHNlbnRyeV9rZXk6IGRzbi5wdWJsaWNLZXksCiAgICBzZW50cnlfdmVyc2lvbjogU0VOVFJZX0FQSV9WRVJTSU9OLAogICAgLi4uKHNka0luZm8gJiYgeyBzZW50cnlfY2xpZW50OiBgJHtzZGtJbmZvLm5hbWV9LyR7c2RrSW5mby52ZXJzaW9ufWAgfSksCiAgfSk7Cn0KCi8qKgogKiBSZXR1cm5zIHRoZSBlbnZlbG9wZSBlbmRwb2ludCBVUkwgd2l0aCBhdXRoIGluIHRoZSBxdWVyeSBzdHJpbmcuCiAqCiAqIFNlbmRpbmcgYXV0aCBhcyBwYXJ0IG9mIHRoZSBxdWVyeSBzdHJpbmcgYW5kIG5vdCBhcyBjdXN0b20gSFRUUCBoZWFkZXJzIGF2b2lkcyBDT1JTIHByZWZsaWdodCByZXF1ZXN0cy4KICovCmZ1bmN0aW9uIGdldEVudmVsb3BlRW5kcG9pbnRXaXRoVXJsRW5jb2RlZEF1dGgoCiAgZHNuLAogIC8vIFRPRE8gKHY4KTogUmVtb3ZlIGB0dW5uZWxPck9wdGlvbnNgIGluIGZhdm9yIG9mIGBvcHRpb25zYCwgYW5kIHVzZSB0aGUgc3Vic3RpdHV0ZSBjb2RlIGJlbG93CiAgLy8gb3B0aW9uczogQ2xpZW50T3B0aW9ucyA9IHt9IGFzIENsaWVudE9wdGlvbnMsCiAgdHVubmVsT3JPcHRpb25zID0ge30gLAopIHsKICAvLyBUT0RPICh2OCk6IFVzZSB0aGlzIGNvZGUgaW5zdGVhZAogIC8vIGNvbnN0IHsgdHVubmVsLCBfbWV0YWRhdGEgPSB7fSB9ID0gb3B0aW9uczsKICAvLyByZXR1cm4gdHVubmVsID8gdHVubmVsIDogYCR7X2dldEluZ2VzdEVuZHBvaW50KGRzbil9PyR7X2VuY29kZWRBdXRoKGRzbiwgX21ldGFkYXRhLnNkayl9YDsKCiAgY29uc3QgdHVubmVsID0gdHlwZW9mIHR1bm5lbE9yT3B0aW9ucyA9PT0gJ3N0cmluZycgPyB0dW5uZWxPck9wdGlvbnMgOiB0dW5uZWxPck9wdGlvbnMudHVubmVsOwogIGNvbnN0IHNka0luZm8gPQogICAgdHlwZW9mIHR1bm5lbE9yT3B0aW9ucyA9PT0gJ3N0cmluZycgfHwgIXR1bm5lbE9yT3B0aW9ucy5fbWV0YWRhdGEgPyB1bmRlZmluZWQgOiB0dW5uZWxPck9wdGlvbnMuX21ldGFkYXRhLnNkazsKCiAgcmV0dXJuIHR1bm5lbCA/IHR1bm5lbCA6IGAke19nZXRJbmdlc3RFbmRwb2ludChkc24pfT8ke19lbmNvZGVkQXV0aChkc24sIHNka0luZm8pfWA7Cn0KCmNvbnN0IERFRkFVTFRfVFJBTlNQT1JUX0JVRkZFUl9TSVpFID0gMzA7CgovKioKICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhIFNlbnRyeSBgVHJhbnNwb3J0YAogKgogKiBAcGFyYW0gb3B0aW9ucwogKiBAcGFyYW0gbWFrZVJlcXVlc3QKICovCmZ1bmN0aW9uIGNyZWF0ZVRyYW5zcG9ydCgKICBvcHRpb25zLAogIG1ha2VSZXF1ZXN0LAogIGJ1ZmZlciA9IG1ha2VQcm9taXNlQnVmZmVyKAogICAgb3B0aW9ucy5idWZmZXJTaXplIHx8IERFRkFVTFRfVFJBTlNQT1JUX0JVRkZFUl9TSVpFLAogICksCikgewogIGxldCByYXRlTGltaXRzID0ge307CiAgY29uc3QgZmx1c2ggPSAodGltZW91dCkgPT4gYnVmZmVyLmRyYWluKHRpbWVvdXQpOwoKICBmdW5jdGlvbiBzZW5kKGVudmVsb3BlKSB7CiAgICBjb25zdCBmaWx0ZXJlZEVudmVsb3BlSXRlbXMgPSBbXTsKCiAgICAvLyBEcm9wIHJhdGUgbGltaXRlZCBpdGVtcyBmcm9tIGVudmVsb3BlCiAgICBmb3JFYWNoRW52ZWxvcGVJdGVtKGVudmVsb3BlLCAoaXRlbSwgdHlwZSkgPT4gewogICAgICBjb25zdCBlbnZlbG9wZUl0ZW1EYXRhQ2F0ZWdvcnkgPSBlbnZlbG9wZUl0ZW1UeXBlVG9EYXRhQ2F0ZWdvcnkodHlwZSk7CiAgICAgIGlmIChpc1JhdGVMaW1pdGVkKHJhdGVMaW1pdHMsIGVudmVsb3BlSXRlbURhdGFDYXRlZ29yeSkpIHsKICAgICAgICBjb25zdCBldmVudCA9IGdldEV2ZW50Rm9yRW52ZWxvcGVJdGVtKGl0ZW0sIHR5cGUpOwogICAgICAgIG9wdGlvbnMucmVjb3JkRHJvcHBlZEV2ZW50KCdyYXRlbGltaXRfYmFja29mZicsIGVudmVsb3BlSXRlbURhdGFDYXRlZ29yeSwgZXZlbnQpOwogICAgICB9IGVsc2UgewogICAgICAgIGZpbHRlcmVkRW52ZWxvcGVJdGVtcy5wdXNoKGl0ZW0pOwogICAgICB9CiAgICB9KTsKCiAgICAvLyBTa2lwIHNlbmRpbmcgaWYgZW52ZWxvcGUgaXMgZW1wdHkgYWZ0ZXIgZmlsdGVyaW5nIG91dCByYXRlIGxpbWl0ZWQgZXZlbnRzCiAgICBpZiAoZmlsdGVyZWRFbnZlbG9wZUl0ZW1zLmxlbmd0aCA9PT0gMCkgewogICAgICByZXR1cm4gcmVzb2x2ZWRTeW5jUHJvbWlzZSgpOwogICAgfQoKICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55CiAgICBjb25zdCBmaWx0ZXJlZEVudmVsb3BlID0gY3JlYXRlRW52ZWxvcGUoZW52ZWxvcGVbMF0sIGZpbHRlcmVkRW52ZWxvcGVJdGVtcyApOwoKICAgIC8vIENyZWF0ZXMgY2xpZW50IHJlcG9ydCBmb3IgZWFjaCBpdGVtIGluIGFuIGVudmVsb3BlCiAgICBjb25zdCByZWNvcmRFbnZlbG9wZUxvc3MgPSAocmVhc29uKSA9PiB7CiAgICAgIGZvckVhY2hFbnZlbG9wZUl0ZW0oZmlsdGVyZWRFbnZlbG9wZSwgKGl0ZW0sIHR5cGUpID0+IHsKICAgICAgICBjb25zdCBldmVudCA9IGdldEV2ZW50Rm9yRW52ZWxvcGVJdGVtKGl0ZW0sIHR5cGUpOwogICAgICAgIG9wdGlvbnMucmVjb3JkRHJvcHBlZEV2ZW50KHJlYXNvbiwgZW52ZWxvcGVJdGVtVHlwZVRvRGF0YUNhdGVnb3J5KHR5cGUpLCBldmVudCk7CiAgICAgIH0pOwogICAgfTsKCiAgICBjb25zdCByZXF1ZXN0VGFzayA9ICgpID0+CiAgICAgIG1ha2VSZXF1ZXN0KHsgYm9keTogc2VyaWFsaXplRW52ZWxvcGUoZmlsdGVyZWRFbnZlbG9wZSwgb3B0aW9ucy50ZXh0RW5jb2RlcikgfSkudGhlbigKICAgICAgICByZXNwb25zZSA9PiB7CiAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHRocm93IG9uIE5PSyByZXNwb25zZXMsIGJ1dCB3ZSB3YW50IHRvIGF0IGxlYXN0IGxvZyB0aGVtCiAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gdW5kZWZpbmVkICYmIChyZXNwb25zZS5zdGF0dXNDb2RlIDwgMjAwIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gMzAwKSkgewogICAgICAgICAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIud2FybihgU2VudHJ5IHJlc3BvbmRlZCB3aXRoIHN0YXR1cyBjb2RlICR7cmVzcG9uc2Uuc3RhdHVzQ29kZX0gdG8gc2VudCBldmVudC5gKTsKICAgICAgICAgIH0KCiAgICAgICAgICByYXRlTGltaXRzID0gdXBkYXRlUmF0ZUxpbWl0cyhyYXRlTGltaXRzLCByZXNwb25zZSk7CiAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7CiAgICAgICAgfSwKICAgICAgICBlcnJvciA9PiB7CiAgICAgICAgICByZWNvcmRFbnZlbG9wZUxvc3MoJ25ldHdvcmtfZXJyb3InKTsKICAgICAgICAgIHRocm93IGVycm9yOwogICAgICAgIH0sCiAgICAgICk7CgogICAgcmV0dXJuIGJ1ZmZlci5hZGQocmVxdWVzdFRhc2spLnRoZW4oCiAgICAgIHJlc3VsdCA9PiByZXN1bHQsCiAgICAgIGVycm9yID0+IHsKICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBTZW50cnlFcnJvcikgewogICAgICAgICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmVycm9yKCdTa2lwcGVkIHNlbmRpbmcgZXZlbnQgYmVjYXVzZSBidWZmZXIgaXMgZnVsbC4nKTsKICAgICAgICAgIHJlY29yZEVudmVsb3BlTG9zcygncXVldWVfb3ZlcmZsb3cnKTsKICAgICAgICAgIHJldHVybiByZXNvbHZlZFN5bmNQcm9taXNlKCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRocm93IGVycm9yOwogICAgICAgIH0KICAgICAgfSwKICAgICk7CiAgfQoKICAvLyBXZSB1c2UgdGhpcyB0byBpZGVudGlmaWZ5IGlmIHRoZSB0cmFuc3BvcnQgaXMgdGhlIGJhc2UgdHJhbnNwb3J0CiAgLy8gVE9ETyAodjgpOiBSZW1vdmUgdGhpcyBhZ2FpbiBhcyB3ZSdsbCBubyBsb25nZXIgbmVlZCBpdAogIHNlbmQuX19zZW50cnlfX2Jhc2VUcmFuc3BvcnRfXyA9IHRydWU7CgogIHJldHVybiB7CiAgICBzZW5kLAogICAgZmx1c2gsCiAgfTsKfQoKZnVuY3Rpb24gZ2V0RXZlbnRGb3JFbnZlbG9wZUl0ZW0oaXRlbSwgdHlwZSkgewogIGlmICh0eXBlICE9PSAnZXZlbnQnICYmIHR5cGUgIT09ICd0cmFuc2FjdGlvbicpIHsKICAgIHJldHVybiB1bmRlZmluZWQ7CiAgfQoKICByZXR1cm4gQXJyYXkuaXNBcnJheShpdGVtKSA/IChpdGVtIClbMV0gOiB1bmRlZmluZWQ7Cn0KCi8qKiBub3JtYWxpemVzIFdpbmRvd3MgcGF0aHMgKi8KZnVuY3Rpb24gbm9ybWFsaXplV2luZG93c1BhdGgocGF0aCkgewogIHJldHVybiBwYXRoCiAgICAucmVwbGFjZSgvXltBLVpdOi8sICcnKSAvLyByZW1vdmUgV2luZG93cy1zdHlsZSBwcmVmaXgKICAgIC5yZXBsYWNlKC9cXC9nLCAnLycpOyAvLyByZXBsYWNlIGFsbCBgXGAgaW5zdGFuY2VzIHdpdGggYC9gCn0KCi8qKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBnZXRzIHRoZSBtb2R1bGUgbmFtZSBmcm9tIGEgZmlsZW5hbWUgKi8KZnVuY3Rpb24gY3JlYXRlR2V0TW9kdWxlRnJvbUZpbGVuYW1lKAogIGJhc2VQYXRoID0gcHJvY2Vzcy5hcmd2WzFdID8gZGlybmFtZShwcm9jZXNzLmFyZ3ZbMV0pIDogcHJvY2Vzcy5jd2QoKSwKICBpc1dpbmRvd3MgPSBzZXAgPT09ICdcXCcsCikgewogIGNvbnN0IG5vcm1hbGl6ZWRCYXNlID0gaXNXaW5kb3dzID8gbm9ybWFsaXplV2luZG93c1BhdGgoYmFzZVBhdGgpIDogYmFzZVBhdGg7CgogIHJldHVybiAoZmlsZW5hbWUpID0+IHsKICAgIGlmICghZmlsZW5hbWUpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIGNvbnN0IG5vcm1hbGl6ZWRGaWxlbmFtZSA9IGlzV2luZG93cyA/IG5vcm1hbGl6ZVdpbmRvd3NQYXRoKGZpbGVuYW1lKSA6IGZpbGVuYW1lOwoKICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3QKICAgIGxldCB7IGRpciwgYmFzZTogZmlsZSwgZXh0IH0gPSBwb3NpeC5wYXJzZShub3JtYWxpemVkRmlsZW5hbWUpOwoKICAgIGlmIChleHQgPT09ICcuanMnIHx8IGV4dCA9PT0gJy5tanMnIHx8IGV4dCA9PT0gJy5janMnKSB7CiAgICAgIGZpbGUgPSBmaWxlLnNsaWNlKDAsIGV4dC5sZW5ndGggKiAtMSk7CiAgICB9CgogICAgaWYgKCFkaXIpIHsKICAgICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyCiAgICAgIGRpciA9ICcuJzsKICAgIH0KCiAgICBjb25zdCBuID0gZGlyLmxhc3RJbmRleE9mKCcvbm9kZV9tb2R1bGVzJyk7CiAgICBpZiAobiA+IC0xKSB7CiAgICAgIHJldHVybiBgJHtkaXIuc2xpY2UobiArIDE0KS5yZXBsYWNlKC9cLy9nLCAnLicpfToke2ZpbGV9YDsKICAgIH0KCiAgICAvLyBMZXQncyBzZWUgaWYgaXQncyBhIHBhcnQgb2YgdGhlIG1haW4gbW9kdWxlCiAgICAvLyBUbyBiZSBhIHBhcnQgb2YgbWFpbiBtb2R1bGUsIGl0IGhhcyB0byBzaGFyZSB0aGUgc2FtZSBiYXNlCiAgICBpZiAoZGlyLnN0YXJ0c1dpdGgobm9ybWFsaXplZEJhc2UpKSB7CiAgICAgIGxldCBtb2R1bGVOYW1lID0gZGlyLnNsaWNlKG5vcm1hbGl6ZWRCYXNlLmxlbmd0aCArIDEpLnJlcGxhY2UoL1wvL2csICcuJyk7CgogICAgICBpZiAobW9kdWxlTmFtZSkgewogICAgICAgIG1vZHVsZU5hbWUgKz0gJzonOwogICAgICB9CiAgICAgIG1vZHVsZU5hbWUgKz0gZmlsZTsKCiAgICAgIHJldHVybiBtb2R1bGVOYW1lOwogICAgfQoKICAgIHJldHVybiBmaWxlOwogIH07Cn0KCmZ1bmN0aW9uIF9udWxsaXNoQ29hbGVzY2UkMihsaHMsIHJoc0ZuKSB7IGlmIChsaHMgIT0gbnVsbCkgeyByZXR1cm4gbGhzOyB9IGVsc2UgeyByZXR1cm4gcmhzRm4oKTsgfSB9LyoqCiAqIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSBmb3JrZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vVG9vVGFsbE5hdGUvcHJveHktYWdlbnRzL3RyZWUvYjEzMzI5NWZkMTZmNjQ3NTU3OGI2YjE1YmQ5YjRlMzNlY2IwZDBiNwogKiBXaXRoIHRoZSBmb2xsb3dpbmcgbGljZW5jZToKICoKICogKFRoZSBNSVQgTGljZW5zZSkKICoKICogQ29weXJpZ2h0IChjKSAyMDEzIE5hdGhhbiBSYWpsaWNoIDxuYXRoYW5AdG9vdGFsbG5hdGUubmV0PioKICoKICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nCiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZQogKiAnU29mdHdhcmUnKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nCiAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwKICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvCiAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0bwogKiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6KgogKgogKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZQogKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4qCiAqCiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELAogKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULgogKiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWQogKiBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULAogKiBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRQogKiBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4KICovCgpjb25zdCBJTlRFUk5BTCA9IFN5bWJvbCgnQWdlbnRCYXNlSW50ZXJuYWxTdGF0ZScpOwoKY2xhc3MgQWdlbnQgZXh0ZW5kcyBodHRwLkFnZW50IHsKCiAgLy8gU2V0IGJ5IGBodHRwLkFnZW50YCAtIG1pc3NpbmcgZnJvbSBgQHR5cGVzL25vZGVgCgogIGNvbnN0cnVjdG9yKG9wdHMpIHsKICAgIHN1cGVyKG9wdHMpOwogICAgdGhpc1tJTlRFUk5BTF0gPSB7fTsKICB9CgogIC8qKgogICAqIERldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYW4gYGh0dHBgIG9yIGBodHRwc2AgcmVxdWVzdC4KICAgKi8KICBpc1NlY3VyZUVuZHBvaW50KG9wdGlvbnMpIHsKICAgIGlmIChvcHRpb25zKSB7CiAgICAgIC8vIEZpcnN0IGNoZWNrIHRoZSBgc2VjdXJlRW5kcG9pbnRgIHByb3BlcnR5IGV4cGxpY2l0bHksIHNpbmNlIHRoaXMKICAgICAgLy8gbWVhbnMgdGhhdCBhIHBhcmVudCBgQWdlbnRgIGlzICJwYXNzaW5nIHRocm91Z2giIHRvIHRoaXMgaW5zdGFuY2UuCiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MKICAgICAgaWYgKHR5cGVvZiAob3B0aW9ucyApLnNlY3VyZUVuZHBvaW50ID09PSAnYm9vbGVhbicpIHsKICAgICAgICByZXR1cm4gb3B0aW9ucy5zZWN1cmVFbmRwb2ludDsKICAgICAgfQoKICAgICAgLy8gSWYgbm8gZXhwbGljaXQgYHNlY3VyZWAgZW5kcG9pbnQsIGNoZWNrIGlmIGBwcm90b2NvbGAgcHJvcGVydHkgaXMKICAgICAgLy8gc2V0LiBUaGlzIHdpbGwgdXN1YWxseSBiZSB0aGUgY2FzZSBzaW5jZSB1c2luZyBhIGZ1bGwgc3RyaW5nIFVSTAogICAgICAvLyBvciBgVVJMYCBpbnN0YW5jZSBzaG91bGQgYmUgdGhlIG1vc3QgY29tbW9uIHVzYWdlLgogICAgICBpZiAodHlwZW9mIG9wdGlvbnMucHJvdG9jb2wgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgcmV0dXJuIG9wdGlvbnMucHJvdG9jb2wgPT09ICdodHRwczonOwogICAgICB9CiAgICB9CgogICAgLy8gRmluYWxseSwgaWYgbm8gYHByb3RvY29sYCBwcm9wZXJ0eSB3YXMgc2V0LCB0aGVuIGZhbGwgYmFjayB0bwogICAgLy8gY2hlY2tpbmcgdGhlIHN0YWNrIHRyYWNlIG9mIHRoZSBjdXJyZW50IGNhbGwgc3RhY2ssIGFuZCB0cnkgdG8KICAgIC8vIGRldGVjdCB0aGUgImh0dHBzIiBtb2R1bGUuCiAgICBjb25zdCB7IHN0YWNrIH0gPSBuZXcgRXJyb3IoKTsKICAgIGlmICh0eXBlb2Ygc3RhY2sgIT09ICdzdHJpbmcnKSByZXR1cm4gZmFsc2U7CiAgICByZXR1cm4gc3RhY2suc3BsaXQoJ1xuJykuc29tZShsID0+IGwuaW5kZXhPZignKGh0dHBzLmpzOicpICE9PSAtMSB8fCBsLmluZGV4T2YoJ25vZGU6aHR0cHM6JykgIT09IC0xKTsKICB9CgogIGNyZWF0ZVNvY2tldChyZXEsIG9wdGlvbnMsIGNiKSB7CiAgICBjb25zdCBjb25uZWN0T3B0cyA9IHsKICAgICAgLi4ub3B0aW9ucywKICAgICAgc2VjdXJlRW5kcG9pbnQ6IHRoaXMuaXNTZWN1cmVFbmRwb2ludChvcHRpb25zKSwKICAgIH07CiAgICBQcm9taXNlLnJlc29sdmUoKQogICAgICAudGhlbigoKSA9PiB0aGlzLmNvbm5lY3QocmVxLCBjb25uZWN0T3B0cykpCiAgICAgIC50aGVuKHNvY2tldCA9PiB7CiAgICAgICAgaWYgKHNvY2tldCBpbnN0YW5jZW9mIGh0dHAuQWdlbnQpIHsKICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYGFkZFJlcXVlc3QoKWAgaXNuJ3QgZGVmaW5lZCBpbiBgQHR5cGVzL25vZGVgCiAgICAgICAgICByZXR1cm4gc29ja2V0LmFkZFJlcXVlc3QocmVxLCBjb25uZWN0T3B0cyk7CiAgICAgICAgfQogICAgICAgIHRoaXNbSU5URVJOQUxdLmN1cnJlbnRTb2NrZXQgPSBzb2NrZXQ7CiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgY3JlYXRlU29ja2V0KClgIGlzbid0IGRlZmluZWQgaW4gYEB0eXBlcy9ub2RlYAogICAgICAgIHN1cGVyLmNyZWF0ZVNvY2tldChyZXEsIG9wdGlvbnMsIGNiKTsKICAgICAgfSwgY2IpOwogIH0KCiAgY3JlYXRlQ29ubmVjdGlvbigpIHsKICAgIGNvbnN0IHNvY2tldCA9IHRoaXNbSU5URVJOQUxdLmN1cnJlbnRTb2NrZXQ7CiAgICB0aGlzW0lOVEVSTkFMXS5jdXJyZW50U29ja2V0ID0gdW5kZWZpbmVkOwogICAgaWYgKCFzb2NrZXQpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzb2NrZXQgd2FzIHJldHVybmVkIGluIHRoZSBgY29ubmVjdCgpYCBmdW5jdGlvbicpOwogICAgfQogICAgcmV0dXJuIHNvY2tldDsKICB9CgogIGdldCBkZWZhdWx0UG9ydCgpIHsKICAgIHJldHVybiBfbnVsbGlzaENvYWxlc2NlJDIodGhpc1tJTlRFUk5BTF0uZGVmYXVsdFBvcnQsICgpID0+ICggKHRoaXMucHJvdG9jb2wgPT09ICdodHRwczonID8gNDQzIDogODApKSk7CiAgfQoKICBzZXQgZGVmYXVsdFBvcnQodikgewogICAgaWYgKHRoaXNbSU5URVJOQUxdKSB7CiAgICAgIHRoaXNbSU5URVJOQUxdLmRlZmF1bHRQb3J0ID0gdjsKICAgIH0KICB9CgogIGdldCBwcm90b2NvbCgpIHsKICAgIHJldHVybiBfbnVsbGlzaENvYWxlc2NlJDIodGhpc1tJTlRFUk5BTF0ucHJvdG9jb2wsICgpID0+ICggKHRoaXMuaXNTZWN1cmVFbmRwb2ludCgpID8gJ2h0dHBzOicgOiAnaHR0cDonKSkpOwogIH0KCiAgc2V0IHByb3RvY29sKHYpIHsKICAgIGlmICh0aGlzW0lOVEVSTkFMXSkgewogICAgICB0aGlzW0lOVEVSTkFMXS5wcm90b2NvbCA9IHY7CiAgICB9CiAgfQp9CgpmdW5jdGlvbiBkZWJ1ZyQxKC4uLmFyZ3MpIHsKICBsb2dnZXIubG9nKCdbaHR0cHMtcHJveHktYWdlbnQ6cGFyc2UtcHJveHktcmVzcG9uc2VdJywgLi4uYXJncyk7Cn0KCmZ1bmN0aW9uIHBhcnNlUHJveHlSZXNwb25zZShzb2NrZXQpIHsKICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gewogICAgLy8gd2UgbmVlZCB0byBidWZmZXIgYW55IEhUVFAgdHJhZmZpYyB0aGF0IGhhcHBlbnMgd2l0aCB0aGUgcHJveHkgYmVmb3JlIHdlIGdldAogICAgLy8gdGhlIENPTk5FQ1QgcmVzcG9uc2UsIHNvIHRoYXQgaWYgdGhlIHJlc3BvbnNlIGlzIGFueXRoaW5nIG90aGVyIHRoYW4gYW4gIjIwMCIKICAgIC8vIHJlc3BvbnNlIGNvZGUsIHRoZW4gd2UgY2FuIHJlLXBsYXkgdGhlICJkYXRhIiBldmVudHMgb24gdGhlIHNvY2tldCBvbmNlIHRoZQogICAgLy8gSFRUUCBwYXJzZXIgaXMgaG9va2VkIHVwLi4uCiAgICBsZXQgYnVmZmVyc0xlbmd0aCA9IDA7CiAgICBjb25zdCBidWZmZXJzID0gW107CgogICAgZnVuY3Rpb24gcmVhZCgpIHsKICAgICAgY29uc3QgYiA9IHNvY2tldC5yZWFkKCk7CiAgICAgIGlmIChiKSBvbmRhdGEoYik7CiAgICAgIGVsc2Ugc29ja2V0Lm9uY2UoJ3JlYWRhYmxlJywgcmVhZCk7CiAgICB9CgogICAgZnVuY3Rpb24gY2xlYW51cCgpIHsKICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7CiAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTsKICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIHJlYWQpOwogICAgfQoKICAgIGZ1bmN0aW9uIG9uZW5kKCkgewogICAgICBjbGVhbnVwKCk7CiAgICAgIGRlYnVnJDEoJ29uZW5kJyk7CiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1Byb3h5IGNvbm5lY3Rpb24gZW5kZWQgYmVmb3JlIHJlY2VpdmluZyBDT05ORUNUIHJlc3BvbnNlJykpOwogICAgfQoKICAgIGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7CiAgICAgIGNsZWFudXAoKTsKICAgICAgZGVidWckMSgnb25lcnJvciAlbycsIGVycik7CiAgICAgIHJlamVjdChlcnIpOwogICAgfQoKICAgIGZ1bmN0aW9uIG9uZGF0YShiKSB7CiAgICAgIGJ1ZmZlcnMucHVzaChiKTsKICAgICAgYnVmZmVyc0xlbmd0aCArPSBiLmxlbmd0aDsKCiAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gQnVmZmVyLmNvbmNhdChidWZmZXJzLCBidWZmZXJzTGVuZ3RoKTsKICAgICAgY29uc3QgZW5kT2ZIZWFkZXJzID0gYnVmZmVyZWQuaW5kZXhPZignXHJcblxyXG4nKTsKCiAgICAgIGlmIChlbmRPZkhlYWRlcnMgPT09IC0xKSB7CiAgICAgICAgLy8ga2VlcCBidWZmZXJpbmcKICAgICAgICBkZWJ1ZyQxKCdoYXZlIG5vdCByZWNlaXZlZCBlbmQgb2YgSFRUUCBoZWFkZXJzIHlldC4uLicpOwogICAgICAgIHJlYWQoKTsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IGhlYWRlclBhcnRzID0gYnVmZmVyZWQuc2xpY2UoMCwgZW5kT2ZIZWFkZXJzKS50b1N0cmluZygnYXNjaWknKS5zcGxpdCgnXHJcbicpOwogICAgICBjb25zdCBmaXJzdExpbmUgPSBoZWFkZXJQYXJ0cy5zaGlmdCgpOwogICAgICBpZiAoIWZpcnN0TGluZSkgewogICAgICAgIHNvY2tldC5kZXN0cm95KCk7CiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05vIGhlYWRlciByZWNlaXZlZCBmcm9tIHByb3h5IENPTk5FQ1QgcmVzcG9uc2UnKSk7CiAgICAgIH0KICAgICAgY29uc3QgZmlyc3RMaW5lUGFydHMgPSBmaXJzdExpbmUuc3BsaXQoJyAnKTsKICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9ICtmaXJzdExpbmVQYXJ0c1sxXTsKICAgICAgY29uc3Qgc3RhdHVzVGV4dCA9IGZpcnN0TGluZVBhcnRzLnNsaWNlKDIpLmpvaW4oJyAnKTsKICAgICAgY29uc3QgaGVhZGVycyA9IHt9OwogICAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBoZWFkZXJQYXJ0cykgewogICAgICAgIGlmICghaGVhZGVyKSBjb250aW51ZTsKICAgICAgICBjb25zdCBmaXJzdENvbG9uID0gaGVhZGVyLmluZGV4T2YoJzonKTsKICAgICAgICBpZiAoZmlyc3RDb2xvbiA9PT0gLTEpIHsKICAgICAgICAgIHNvY2tldC5kZXN0cm95KCk7CiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihgSW52YWxpZCBoZWFkZXIgZnJvbSBwcm94eSBDT05ORUNUIHJlc3BvbnNlOiAiJHtoZWFkZXJ9ImApKTsKICAgICAgICB9CiAgICAgICAgY29uc3Qga2V5ID0gaGVhZGVyLnNsaWNlKDAsIGZpcnN0Q29sb24pLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgY29uc3QgdmFsdWUgPSBoZWFkZXIuc2xpY2UoZmlyc3RDb2xvbiArIDEpLnRyaW1TdGFydCgpOwogICAgICAgIGNvbnN0IGN1cnJlbnQgPSBoZWFkZXJzW2tleV07CiAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50ID09PSAnc3RyaW5nJykgewogICAgICAgICAgaGVhZGVyc1trZXldID0gW2N1cnJlbnQsIHZhbHVlXTsKICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHsKICAgICAgICAgIGN1cnJlbnQucHVzaCh2YWx1ZSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlOwogICAgICAgIH0KICAgICAgfQogICAgICBkZWJ1ZyQxKCdnb3QgcHJveHkgc2VydmVyIHJlc3BvbnNlOiAlbyAlbycsIGZpcnN0TGluZSwgaGVhZGVycyk7CiAgICAgIGNsZWFudXAoKTsKICAgICAgcmVzb2x2ZSh7CiAgICAgICAgY29ubmVjdDogewogICAgICAgICAgc3RhdHVzQ29kZSwKICAgICAgICAgIHN0YXR1c1RleHQsCiAgICAgICAgICBoZWFkZXJzLAogICAgICAgIH0sCiAgICAgICAgYnVmZmVyZWQsCiAgICAgIH0pOwogICAgfQoKICAgIHNvY2tldC5vbignZXJyb3InLCBvbmVycm9yKTsKICAgIHNvY2tldC5vbignZW5kJywgb25lbmQpOwoKICAgIHJlYWQoKTsKICB9KTsKfQoKZnVuY3Rpb24gX251bGxpc2hDb2FsZXNjZSQxKGxocywgcmhzRm4pIHsgaWYgKGxocyAhPSBudWxsKSB7IHJldHVybiBsaHM7IH0gZWxzZSB7IHJldHVybiByaHNGbigpOyB9IH0gZnVuY3Rpb24gX29wdGlvbmFsQ2hhaW4kMShvcHMpIHsgbGV0IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IGxldCB2YWx1ZSA9IG9wc1swXTsgbGV0IGkgPSAxOyB3aGlsZSAoaSA8IG9wcy5sZW5ndGgpIHsgY29uc3Qgb3AgPSBvcHNbaV07IGNvbnN0IGZuID0gb3BzW2kgKyAxXTsgaSArPSAyOyBpZiAoKG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxDYWxsJykgJiYgdmFsdWUgPT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGlmIChvcCA9PT0gJ2FjY2VzcycgfHwgb3AgPT09ICdvcHRpb25hbEFjY2VzcycpIHsgbGFzdEFjY2Vzc0xIUyA9IHZhbHVlOyB2YWx1ZSA9IGZuKHZhbHVlKTsgfSBlbHNlIGlmIChvcCA9PT0gJ2NhbGwnIHx8IG9wID09PSAnb3B0aW9uYWxDYWxsJykgeyB2YWx1ZSA9IGZuKCguLi5hcmdzKSA9PiB2YWx1ZS5jYWxsKGxhc3RBY2Nlc3NMSFMsIC4uLmFyZ3MpKTsgbGFzdEFjY2Vzc0xIUyA9IHVuZGVmaW5lZDsgfSB9IHJldHVybiB2YWx1ZTsgfS8qKgogKiBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgZm9ya2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL1Rvb1RhbGxOYXRlL3Byb3h5LWFnZW50cy90cmVlL2IxMzMyOTVmZDE2ZjY0NzU1NzhiNmIxNWJkOWI0ZTMzZWNiMGQwYjcKICogV2l0aCB0aGUgZm9sbG93aW5nIGxpY2VuY2U6CiAqCiAqIChUaGUgTUlUIExpY2Vuc2UpCiAqCiAqIENvcHlyaWdodCAoYykgMjAxMyBOYXRoYW4gUmFqbGljaCA8bmF0aGFuQHRvb3RhbGxuYXRlLm5ldD4qCiAqCiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZwogKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKICogJ1NvZnR3YXJlJyksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwogKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsCiAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0bwogKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8KICogdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOioKICoKICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUKICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuKgogKgogKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwKICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GCiAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4KICogSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkKICogQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwKICogVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUKICogU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCiAqLwoKZnVuY3Rpb24gZGVidWcoLi4uYXJncykgewogIGxvZ2dlci5sb2coJ1todHRwcy1wcm94eS1hZ2VudF0nLCAuLi5hcmdzKTsKfQoKLyoqCiAqIFRoZSBgSHR0cHNQcm94eUFnZW50YCBpbXBsZW1lbnRzIGFuIEhUVFAgQWdlbnQgc3ViY2xhc3MgdGhhdCBjb25uZWN0cyB0bwogKiB0aGUgc3BlY2lmaWVkICJIVFRQKHMpIHByb3h5IHNlcnZlciIgaW4gb3JkZXIgdG8gcHJveHkgSFRUUFMgcmVxdWVzdHMuCiAqCiAqIE91dGdvaW5nIEhUVFAgcmVxdWVzdHMgYXJlIGZpcnN0IHR1bm5lbGVkIHRocm91Z2ggdGhlIHByb3h5IHNlcnZlciB1c2luZyB0aGUKICogYENPTk5FQ1RgIEhUVFAgcmVxdWVzdCBtZXRob2QgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiB0byB0aGUgcHJveHkgc2VydmVyLAogKiBhbmQgdGhlbiB0aGUgcHJveHkgc2VydmVyIGNvbm5lY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiB0YXJnZXQgYW5kIGlzc3VlcyB0aGUKICogSFRUUCByZXF1ZXN0IGZyb20gdGhlIHByb3h5IHNlcnZlci4KICoKICogYGh0dHBzOmAgcmVxdWVzdHMgaGF2ZSB0aGVpciBzb2NrZXQgY29ubmVjdGlvbiB1cGdyYWRlZCB0byBUTFMgb25jZQogKiB0aGUgY29ubmVjdGlvbiB0byB0aGUgcHJveHkgc2VydmVyIGhhcyBiZWVuIGVzdGFibGlzaGVkLgogKi8KY2xhc3MgSHR0cHNQcm94eUFnZW50IGV4dGVuZHMgQWdlbnQgewogIHN0YXRpYyBfX2luaXRTdGF0aWMoKSB7dGhpcy5wcm90b2NvbHMgPSBbJ2h0dHAnLCAnaHR0cHMnXTsgfQoKICBjb25zdHJ1Y3Rvcihwcm94eSwgb3B0cykgewogICAgc3VwZXIob3B0cyk7CiAgICB0aGlzLm9wdGlvbnMgPSB7fTsKICAgIHRoaXMucHJveHkgPSB0eXBlb2YgcHJveHkgPT09ICdzdHJpbmcnID8gbmV3IFVSTChwcm94eSkgOiBwcm94eTsKICAgIHRoaXMucHJveHlIZWFkZXJzID0gX251bGxpc2hDb2FsZXNjZSQxKF9vcHRpb25hbENoYWluJDEoW29wdHMsICdvcHRpb25hbEFjY2VzcycsIF8yID0+IF8yLmhlYWRlcnNdKSwgKCkgPT4gKCB7fSkpOwogICAgZGVidWcoJ0NyZWF0aW5nIG5ldyBIdHRwc1Byb3h5QWdlbnQgaW5zdGFuY2U6ICVvJywgdGhpcy5wcm94eS5ocmVmKTsKCiAgICAvLyBUcmltIG9mZiB0aGUgYnJhY2tldHMgZnJvbSBJUHY2IGFkZHJlc3NlcwogICAgY29uc3QgaG9zdCA9ICh0aGlzLnByb3h5Lmhvc3RuYW1lIHx8IHRoaXMucHJveHkuaG9zdCkucmVwbGFjZSgvXlxbfFxdJC9nLCAnJyk7CiAgICBjb25zdCBwb3J0ID0gdGhpcy5wcm94eS5wb3J0ID8gcGFyc2VJbnQodGhpcy5wcm94eS5wb3J0LCAxMCkgOiB0aGlzLnByb3h5LnByb3RvY29sID09PSAnaHR0cHM6JyA/IDQ0MyA6IDgwOwogICAgdGhpcy5jb25uZWN0T3B0cyA9IHsKICAgICAgLy8gQXR0ZW1wdCB0byBuZWdvdGlhdGUgaHR0cC8xLjEgZm9yIHByb3h5IHNlcnZlcnMgdGhhdCBzdXBwb3J0IGh0dHAvMgogICAgICBBTFBOUHJvdG9jb2xzOiBbJ2h0dHAvMS4xJ10sCiAgICAgIC4uLihvcHRzID8gb21pdChvcHRzLCAnaGVhZGVycycpIDogbnVsbCksCiAgICAgIGhvc3QsCiAgICAgIHBvcnQsCiAgICB9OwogIH0KCiAgLyoqCiAgICogQ2FsbGVkIHdoZW4gdGhlIG5vZGUtY29yZSBIVFRQIGNsaWVudCBsaWJyYXJ5IGlzIGNyZWF0aW5nIGEKICAgKiBuZXcgSFRUUCByZXF1ZXN0LgogICAqLwogIGFzeW5jIGNvbm5lY3QocmVxLCBvcHRzKSB7CiAgICBjb25zdCB7IHByb3h5IH0gPSB0aGlzOwoKICAgIGlmICghb3B0cy5ob3N0KSB7CiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vICJob3N0IiBwcm92aWRlZCcpOwogICAgfQoKICAgIC8vIENyZWF0ZSBhIHNvY2tldCBjb25uZWN0aW9uIHRvIHRoZSBwcm94eSBzZXJ2ZXIuCiAgICBsZXQgc29ja2V0OwogICAgaWYgKHByb3h5LnByb3RvY29sID09PSAnaHR0cHM6JykgewogICAgICBkZWJ1ZygnQ3JlYXRpbmcgYHRscy5Tb2NrZXRgOiAlbycsIHRoaXMuY29ubmVjdE9wdHMpOwogICAgICBjb25zdCBzZXJ2ZXJuYW1lID0gdGhpcy5jb25uZWN0T3B0cy5zZXJ2ZXJuYW1lIHx8IHRoaXMuY29ubmVjdE9wdHMuaG9zdDsKICAgICAgc29ja2V0ID0gdGxzLmNvbm5lY3QoewogICAgICAgIC4uLnRoaXMuY29ubmVjdE9wdHMsCiAgICAgICAgc2VydmVybmFtZTogc2VydmVybmFtZSAmJiBuZXQuaXNJUChzZXJ2ZXJuYW1lKSA/IHVuZGVmaW5lZCA6IHNlcnZlcm5hbWUsCiAgICAgIH0pOwogICAgfSBlbHNlIHsKICAgICAgZGVidWcoJ0NyZWF0aW5nIGBuZXQuU29ja2V0YDogJW8nLCB0aGlzLmNvbm5lY3RPcHRzKTsKICAgICAgc29ja2V0ID0gbmV0LmNvbm5lY3QodGhpcy5jb25uZWN0T3B0cyk7CiAgICB9CgogICAgY29uc3QgaGVhZGVycyA9CiAgICAgIHR5cGVvZiB0aGlzLnByb3h5SGVhZGVycyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMucHJveHlIZWFkZXJzKCkgOiB7IC4uLnRoaXMucHJveHlIZWFkZXJzIH07CiAgICBjb25zdCBob3N0ID0gbmV0LmlzSVB2NihvcHRzLmhvc3QpID8gYFske29wdHMuaG9zdH1dYCA6IG9wdHMuaG9zdDsKICAgIGxldCBwYXlsb2FkID0gYENPTk5FQ1QgJHtob3N0fToke29wdHMucG9ydH0gSFRUUC8xLjFcclxuYDsKCiAgICAvLyBJbmplY3QgdGhlIGBQcm94eS1BdXRob3JpemF0aW9uYCBoZWFkZXIgaWYgbmVjZXNzYXJ5LgogICAgaWYgKHByb3h5LnVzZXJuYW1lIHx8IHByb3h5LnBhc3N3b3JkKSB7CiAgICAgIGNvbnN0IGF1dGggPSBgJHtkZWNvZGVVUklDb21wb25lbnQocHJveHkudXNlcm5hbWUpfToke2RlY29kZVVSSUNvbXBvbmVudChwcm94eS5wYXNzd29yZCl9YDsKICAgICAgaGVhZGVyc1snUHJveHktQXV0aG9yaXphdGlvbiddID0gYEJhc2ljICR7QnVmZmVyLmZyb20oYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpfWA7CiAgICB9CgogICAgaGVhZGVycy5Ib3N0ID0gYCR7aG9zdH06JHtvcHRzLnBvcnR9YDsKCiAgICBpZiAoIWhlYWRlcnNbJ1Byb3h5LUNvbm5lY3Rpb24nXSkgewogICAgICBoZWFkZXJzWydQcm94eS1Db25uZWN0aW9uJ10gPSB0aGlzLmtlZXBBbGl2ZSA/ICdLZWVwLUFsaXZlJyA6ICdjbG9zZSc7CiAgICB9CiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHsKICAgICAgcGF5bG9hZCArPSBgJHtuYW1lfTogJHtoZWFkZXJzW25hbWVdfVxyXG5gOwogICAgfQoKICAgIGNvbnN0IHByb3h5UmVzcG9uc2VQcm9taXNlID0gcGFyc2VQcm94eVJlc3BvbnNlKHNvY2tldCk7CgogICAgc29ja2V0LndyaXRlKGAke3BheWxvYWR9XHJcbmApOwoKICAgIGNvbnN0IHsgY29ubmVjdCwgYnVmZmVyZWQgfSA9IGF3YWl0IHByb3h5UmVzcG9uc2VQcm9taXNlOwogICAgcmVxLmVtaXQoJ3Byb3h5Q29ubmVjdCcsIGNvbm5lY3QpOwogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudAogICAgLy8gQHRzLWlnbm9yZSBOb3QgRXZlbnRFbWl0dGVyIGluIE5vZGUgdHlwZXMKICAgIHRoaXMuZW1pdCgncHJveHlDb25uZWN0JywgY29ubmVjdCwgcmVxKTsKCiAgICBpZiAoY29ubmVjdC5zdGF0dXNDb2RlID09PSAyMDApIHsKICAgICAgcmVxLm9uY2UoJ3NvY2tldCcsIHJlc3VtZSk7CgogICAgICBpZiAob3B0cy5zZWN1cmVFbmRwb2ludCkgewogICAgICAgIC8vIFRoZSBwcm94eSBpcyBjb25uZWN0aW5nIHRvIGEgVExTIHNlcnZlciwgc28gdXBncmFkZQogICAgICAgIC8vIHRoaXMgc29ja2V0IGNvbm5lY3Rpb24gdG8gYSBUTFMgY29ubmVjdGlvbi4KICAgICAgICBkZWJ1ZygnVXBncmFkaW5nIHNvY2tldCBjb25uZWN0aW9uIHRvIFRMUycpOwogICAgICAgIGNvbnN0IHNlcnZlcm5hbWUgPSBvcHRzLnNlcnZlcm5hbWUgfHwgb3B0cy5ob3N0OwogICAgICAgIHJldHVybiB0bHMuY29ubmVjdCh7CiAgICAgICAgICAuLi5vbWl0KG9wdHMsICdob3N0JywgJ3BhdGgnLCAncG9ydCcpLAogICAgICAgICAgc29ja2V0LAogICAgICAgICAgc2VydmVybmFtZTogbmV0LmlzSVAoc2VydmVybmFtZSkgPyB1bmRlZmluZWQgOiBzZXJ2ZXJuYW1lLAogICAgICAgIH0pOwogICAgICB9CgogICAgICByZXR1cm4gc29ja2V0OwogICAgfQoKICAgIC8vIFNvbWUgb3RoZXIgc3RhdHVzIGNvZGUgdGhhdCdzIG5vdCAyMDAuLi4gbmVlZCB0byByZS1wbGF5IHRoZSBIVFRQCiAgICAvLyBoZWFkZXIgImRhdGEiIGV2ZW50cyBvbnRvIHRoZSBzb2NrZXQgb25jZSB0aGUgSFRUUCBtYWNoaW5lcnkgaXMKICAgIC8vIGF0dGFjaGVkIHNvIHRoYXQgdGhlIG5vZGUgY29yZSBgaHR0cGAgY2FuIHBhcnNlIGFuZCBoYW5kbGUgdGhlCiAgICAvLyBlcnJvciBzdGF0dXMgY29kZS4KCiAgICAvLyBDbG9zZSB0aGUgb3JpZ2luYWwgc29ja2V0LCBhbmQgYSBuZXcgImZha2UiIHNvY2tldCBpcyByZXR1cm5lZAogICAgLy8gaW5zdGVhZCwgc28gdGhhdCB0aGUgcHJveHkgZG9lc24ndCBnZXQgdGhlIEhUVFAgcmVxdWVzdAogICAgLy8gd3JpdHRlbiB0byBpdCAod2hpY2ggbWF5IGNvbnRhaW4gYEF1dGhvcml6YXRpb25gIGhlYWRlcnMgb3Igb3RoZXIKICAgIC8vIHNlbnNpdGl2ZSBkYXRhKS4KICAgIC8vCiAgICAvLyBTZWU6IGh0dHBzOi8vaGFja2Vyb25lLmNvbS9yZXBvcnRzLzU0MTUwMgogICAgc29ja2V0LmRlc3Ryb3koKTsKCiAgICBjb25zdCBmYWtlU29ja2V0ID0gbmV3IG5ldC5Tb2NrZXQoeyB3cml0YWJsZTogZmFsc2UgfSk7CiAgICBmYWtlU29ja2V0LnJlYWRhYmxlID0gdHJ1ZTsKCiAgICAvLyBOZWVkIHRvIHdhaXQgZm9yIHRoZSAic29ja2V0IiBldmVudCB0byByZS1wbGF5IHRoZSAiZGF0YSIgZXZlbnRzLgogICAgcmVxLm9uY2UoJ3NvY2tldCcsIChzKSA9PiB7CiAgICAgIGRlYnVnKCdSZXBsYXlpbmcgcHJveHkgYnVmZmVyIGZvciBmYWlsZWQgcmVxdWVzdCcpOwogICAgICBhc3NlcnQocy5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwKTsKCiAgICAgIC8vIFJlcGxheSB0aGUgImJ1ZmZlcmVkIiBCdWZmZXIgb250byB0aGUgZmFrZSBgc29ja2V0YCwgc2luY2UgYXQKICAgICAgLy8gdGhpcyBwb2ludCB0aGUgSFRUUCBtb2R1bGUgbWFjaGluZXJ5IGhhcyBiZWVuIGhvb2tlZCB1cCBmb3IKICAgICAgLy8gdGhlIHVzZXIuCiAgICAgIHMucHVzaChidWZmZXJlZCk7CiAgICAgIHMucHVzaChudWxsKTsKICAgIH0pOwoKICAgIHJldHVybiBmYWtlU29ja2V0OwogIH0KfSBIdHRwc1Byb3h5QWdlbnQuX19pbml0U3RhdGljKCk7CgpmdW5jdGlvbiByZXN1bWUoc29ja2V0KSB7CiAgc29ja2V0LnJlc3VtZSgpOwp9CgpmdW5jdGlvbiBvbWl0KAogIG9iaiwKICAuLi5rZXlzCikKCiB7CiAgY29uc3QgcmV0ID0ge30KCjsKICBsZXQga2V5OwogIGZvciAoa2V5IGluIG9iaikgewogICAgaWYgKCFrZXlzLmluY2x1ZGVzKGtleSkpIHsKICAgICAgcmV0W2tleV0gPSBvYmpba2V5XTsKICAgIH0KICB9CiAgcmV0dXJuIHJldDsKfQoKZnVuY3Rpb24gX251bGxpc2hDb2FsZXNjZShsaHMsIHJoc0ZuKSB7IGlmIChsaHMgIT0gbnVsbCkgeyByZXR1cm4gbGhzOyB9IGVsc2UgeyByZXR1cm4gcmhzRm4oKTsgfSB9Ci8vIEVzdGltYXRlZCBtYXhpbXVtIHNpemUgZm9yIHJlYXNvbmFibGUgc3RhbmRhbG9uZSBldmVudApjb25zdCBHWklQX1RIUkVTSE9MRCA9IDEwMjQgKiAzMjsKCi8qKgogKiBHZXRzIGEgc3RyZWFtIGZyb20gYSBVaW50OEFycmF5IG9yIHN0cmluZwogKiBSZWFkYWJsZS5mcm9tIGlzIGlkZWFsIGJ1dCB3YXMgYWRkZWQgaW4gbm9kZS5qcyB2MTIuMy4wIGFuZCB2MTAuMTcuMAogKi8KZnVuY3Rpb24gc3RyZWFtRnJvbUJvZHkoYm9keSkgewogIHJldHVybiBuZXcgUmVhZGFibGUoewogICAgcmVhZCgpIHsKICAgICAgdGhpcy5wdXNoKGJvZHkpOwogICAgICB0aGlzLnB1c2gobnVsbCk7CiAgICB9LAogIH0pOwp9CgovKioKICogQ3JlYXRlcyBhIFRyYW5zcG9ydCB0aGF0IHVzZXMgbmF0aXZlIHRoZSBuYXRpdmUgJ2h0dHAnIGFuZCAnaHR0cHMnIG1vZHVsZXMgdG8gc2VuZCBldmVudHMgdG8gU2VudHJ5LgogKi8KZnVuY3Rpb24gbWFrZU5vZGVUcmFuc3BvcnQob3B0aW9ucykgewogIGxldCB1cmxTZWdtZW50czsKCiAgdHJ5IHsKICAgIHVybFNlZ21lbnRzID0gbmV3IFVSTChvcHRpb25zLnVybCk7CiAgfSBjYXRjaCAoZSkgewogICAgY29uc29sZVNhbmRib3goKCkgPT4gewogICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZQogICAgICBjb25zb2xlLndhcm4oCiAgICAgICAgJ1tAc2VudHJ5L25vZGVdOiBJbnZhbGlkIGRzbiBvciB0dW5uZWwgb3B0aW9uLCB3aWxsIG5vdCBzZW5kIGFueSBldmVudHMuIFRoZSB0dW5uZWwgb3B0aW9uIG11c3QgYmUgYSBmdWxsIFVSTCB3aGVuIHVzZWQuJywKICAgICAgKTsKICAgIH0pOwogICAgcmV0dXJuIGNyZWF0ZVRyYW5zcG9ydChvcHRpb25zLCAoKSA9PiBQcm9taXNlLnJlc29sdmUoe30pKTsKICB9CgogIGNvbnN0IGlzSHR0cHMgPSB1cmxTZWdtZW50cy5wcm90b2NvbCA9PT0gJ2h0dHBzOic7CgogIC8vIFByb3h5IHByaW9yaXRpemF0aW9uOiBodHRwID0+IGBvcHRpb25zLnByb3h5YCB8IGBwcm9jZXNzLmVudi5odHRwX3Byb3h5YAogIC8vIFByb3h5IHByaW9yaXRpemF0aW9uOiBodHRwcyA9PiBgb3B0aW9ucy5wcm94eWAgfCBgcHJvY2Vzcy5lbnYuaHR0cHNfcHJveHlgIHwgYHByb2Nlc3MuZW52Lmh0dHBfcHJveHlgCiAgY29uc3QgcHJveHkgPSBhcHBseU5vUHJveHlPcHRpb24oCiAgICB1cmxTZWdtZW50cywKICAgIG9wdGlvbnMucHJveHkgfHwgKGlzSHR0cHMgPyBwcm9jZXNzLmVudi5odHRwc19wcm94eSA6IHVuZGVmaW5lZCkgfHwgcHJvY2Vzcy5lbnYuaHR0cF9wcm94eSwKICApOwoKICBjb25zdCBuYXRpdmVIdHRwTW9kdWxlID0gaXNIdHRwcyA/IGh0dHBzIDogaHR0cDsKICBjb25zdCBrZWVwQWxpdmUgPSBvcHRpb25zLmtlZXBBbGl2ZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRpb25zLmtlZXBBbGl2ZTsKCiAgLy8gVE9ETyh2Nyk6IEV2YWx1YXRlIGlmIHdlIGNhbiBzZXQga2VlcEFsaXZlIHRvIHRydWUuIFRoaXMgd291bGQgaW52b2x2ZSB0ZXN0aW5nIGZvciBtZW1vcnkgbGVha3MgaW4gb2xkZXIgbm9kZQogIC8vIHZlcnNpb25zKD49IDgpIGFzIHRoZXkgaGFkIG1lbW9yeSBsZWFrcyB3aGVuIHVzaW5nIGl0OiAjMjU1NQogIGNvbnN0IGFnZW50ID0gcHJveHkKICAgID8gKG5ldyBIdHRwc1Byb3h5QWdlbnQocHJveHkpICkKICAgIDogbmV3IG5hdGl2ZUh0dHBNb2R1bGUuQWdlbnQoeyBrZWVwQWxpdmUsIG1heFNvY2tldHM6IDMwLCB0aW1lb3V0OiAyMDAwIH0pOwoKICBjb25zdCByZXF1ZXN0RXhlY3V0b3IgPSBjcmVhdGVSZXF1ZXN0RXhlY3V0b3Iob3B0aW9ucywgX251bGxpc2hDb2FsZXNjZShvcHRpb25zLmh0dHBNb2R1bGUsICgpID0+ICggbmF0aXZlSHR0cE1vZHVsZSkpLCBhZ2VudCk7CiAgcmV0dXJuIGNyZWF0ZVRyYW5zcG9ydChvcHRpb25zLCByZXF1ZXN0RXhlY3V0b3IpOwp9CgovKioKICogSG9ub3JzIHRoZSBgbm9fcHJveHlgIGVudiB2YXJpYWJsZSB3aXRoIHRoZSBoaWdoZXN0IHByaW9yaXR5IHRvIGFsbG93IGZvciBob3N0cyBleGNsdXNpb24uCiAqCiAqIEBwYXJhbSB0cmFuc3BvcnRVcmwgVGhlIFVSTCB0aGUgdHJhbnNwb3J0IGludGVuZHMgdG8gc2VuZCBldmVudHMgdG8uCiAqIEBwYXJhbSBwcm94eSBUaGUgY2xpZW50IGNvbmZpZ3VyZWQgcHJveHkuCiAqIEByZXR1cm5zIEEgcHJveHkgdGhlIHRyYW5zcG9ydCBzaG91bGQgdXNlLgogKi8KZnVuY3Rpb24gYXBwbHlOb1Byb3h5T3B0aW9uKHRyYW5zcG9ydFVybFNlZ21lbnRzLCBwcm94eSkgewogIGNvbnN0IHsgbm9fcHJveHkgfSA9IHByb2Nlc3MuZW52OwoKICBjb25zdCB1cmxJc0V4ZW1wdEZyb21Qcm94eSA9CiAgICBub19wcm94eSAmJgogICAgbm9fcHJveHkKICAgICAgLnNwbGl0KCcsJykKICAgICAgLnNvbWUoCiAgICAgICAgZXhlbXB0aW9uID0+IHRyYW5zcG9ydFVybFNlZ21lbnRzLmhvc3QuZW5kc1dpdGgoZXhlbXB0aW9uKSB8fCB0cmFuc3BvcnRVcmxTZWdtZW50cy5ob3N0bmFtZS5lbmRzV2l0aChleGVtcHRpb24pLAogICAgICApOwoKICBpZiAodXJsSXNFeGVtcHRGcm9tUHJveHkpIHsKICAgIHJldHVybiB1bmRlZmluZWQ7CiAgfSBlbHNlIHsKICAgIHJldHVybiBwcm94eTsKICB9Cn0KCi8qKgogKiBDcmVhdGVzIGEgUmVxdWVzdEV4ZWN1dG9yIHRvIGJlIHVzZWQgd2l0aCBgY3JlYXRlVHJhbnNwb3J0YC4KICovCmZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3RFeGVjdXRvcigKICBvcHRpb25zLAogIGh0dHBNb2R1bGUsCiAgYWdlbnQsCikgewogIGNvbnN0IHsgaG9zdG5hbWUsIHBhdGhuYW1lLCBwb3J0LCBwcm90b2NvbCwgc2VhcmNoIH0gPSBuZXcgVVJMKG9wdGlvbnMudXJsKTsKICByZXR1cm4gZnVuY3Rpb24gbWFrZVJlcXVlc3QocmVxdWVzdCkgewogICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHsKICAgICAgbGV0IGJvZHkgPSBzdHJlYW1Gcm9tQm9keShyZXF1ZXN0LmJvZHkpOwoKICAgICAgY29uc3QgaGVhZGVycyA9IHsgLi4ub3B0aW9ucy5oZWFkZXJzIH07CgogICAgICBpZiAocmVxdWVzdC5ib2R5Lmxlbmd0aCA+IEdaSVBfVEhSRVNIT0xEKSB7CiAgICAgICAgaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddID0gJ2d6aXAnOwogICAgICAgIGJvZHkgPSBib2R5LnBpcGUoY3JlYXRlR3ppcCgpKTsKICAgICAgfQoKICAgICAgY29uc3QgcmVxID0gaHR0cE1vZHVsZS5yZXF1ZXN0KAogICAgICAgIHsKICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLAogICAgICAgICAgYWdlbnQsCiAgICAgICAgICBoZWFkZXJzLAogICAgICAgICAgaG9zdG5hbWUsCiAgICAgICAgICBwYXRoOiBgJHtwYXRobmFtZX0ke3NlYXJjaH1gLAogICAgICAgICAgcG9ydCwKICAgICAgICAgIHByb3RvY29sLAogICAgICAgICAgY2E6IG9wdGlvbnMuY2FDZXJ0cywKICAgICAgICB9LAogICAgICAgIHJlcyA9PiB7CiAgICAgICAgICByZXMub24oJ2RhdGEnLCAoKSA9PiB7CiAgICAgICAgICAgIC8vIERyYWluIHNvY2tldAogICAgICAgICAgfSk7CgogICAgICAgICAgcmVzLm9uKCdlbmQnLCAoKSA9PiB7CiAgICAgICAgICAgIC8vIERyYWluIHNvY2tldAogICAgICAgICAgfSk7CgogICAgICAgICAgcmVzLnNldEVuY29kaW5nKCd1dGY4Jyk7CgogICAgICAgICAgLy8gIktleS12YWx1ZSBwYWlycyBvZiBoZWFkZXIgbmFtZXMgYW5kIHZhbHVlcy4gSGVhZGVyIG5hbWVzIGFyZSBsb3dlci1jYXNlZC4iCiAgICAgICAgICAvLyBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX21lc3NhZ2VfaGVhZGVycwogICAgICAgICAgY29uc3QgcmV0cnlBZnRlckhlYWRlciA9IF9udWxsaXNoQ29hbGVzY2UocmVzLmhlYWRlcnNbJ3JldHJ5LWFmdGVyJ10sICgpID0+ICggbnVsbCkpOwogICAgICAgICAgY29uc3QgcmF0ZUxpbWl0c0hlYWRlciA9IF9udWxsaXNoQ29hbGVzY2UocmVzLmhlYWRlcnNbJ3gtc2VudHJ5LXJhdGUtbGltaXRzJ10sICgpID0+ICggbnVsbCkpOwoKICAgICAgICAgIHJlc29sdmUoewogICAgICAgICAgICBzdGF0dXNDb2RlOiByZXMuc3RhdHVzQ29kZSwKICAgICAgICAgICAgaGVhZGVyczogewogICAgICAgICAgICAgICdyZXRyeS1hZnRlcic6IHJldHJ5QWZ0ZXJIZWFkZXIsCiAgICAgICAgICAgICAgJ3gtc2VudHJ5LXJhdGUtbGltaXRzJzogQXJyYXkuaXNBcnJheShyYXRlTGltaXRzSGVhZGVyKSA/IHJhdGVMaW1pdHNIZWFkZXJbMF0gOiByYXRlTGltaXRzSGVhZGVyLAogICAgICAgICAgICB9LAogICAgICAgICAgfSk7CiAgICAgICAgfSwKICAgICAgKTsKCiAgICAgIHJlcS5vbignZXJyb3InLCByZWplY3QpOwogICAgICBib2R5LnBpcGUocmVxKTsKICAgIH0pOwogIH07Cn0KCmZ1bmN0aW9uIF9vcHRpb25hbENoYWluKG9wcykgeyBsZXQgbGFzdEFjY2Vzc0xIUyA9IHVuZGVmaW5lZDsgbGV0IHZhbHVlID0gb3BzWzBdOyBsZXQgaSA9IDE7IHdoaWxlIChpIDwgb3BzLmxlbmd0aCkgeyBjb25zdCBvcCA9IG9wc1tpXTsgY29uc3QgZm4gPSBvcHNbaSArIDFdOyBpICs9IDI7IGlmICgob3AgPT09ICdvcHRpb25hbEFjY2VzcycgfHwgb3AgPT09ICdvcHRpb25hbENhbGwnKSAmJiB2YWx1ZSA9PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gaWYgKG9wID09PSAnYWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJykgeyBsYXN0QWNjZXNzTEhTID0gdmFsdWU7IHZhbHVlID0gZm4odmFsdWUpOyB9IGVsc2UgaWYgKG9wID09PSAnY2FsbCcgfHwgb3AgPT09ICdvcHRpb25hbENhbGwnKSB7IHZhbHVlID0gZm4oKC4uLmFyZ3MpID0+IHZhbHVlLmNhbGwobGFzdEFjY2Vzc0xIUywgLi4uYXJncykpOyBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyB9IH0gcmV0dXJuIHZhbHVlOyB9CmNvbnN0IG9wdGlvbnMgPSB3b3JrZXJEYXRhOwpsZXQgc2Vzc2lvbjsKbGV0IGhhc1NlbnRBbnJFdmVudCA9IGZhbHNlOwoKZnVuY3Rpb24gbG9nKG1zZykgewogIGlmIChvcHRpb25zLmRlYnVnKSB7CiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZQogICAgY29uc29sZS5sb2coYFtBTlIgV29ya2VyXSAke21zZ31gKTsKICB9Cn0KCmNvbnN0IHVybCA9IGdldEVudmVsb3BlRW5kcG9pbnRXaXRoVXJsRW5jb2RlZEF1dGgob3B0aW9ucy5kc24pOwpjb25zdCB0cmFuc3BvcnQgPSBtYWtlTm9kZVRyYW5zcG9ydCh7CiAgdXJsLAogIHJlY29yZERyb3BwZWRFdmVudDogKCkgPT4gewogICAgLy8KICB9LAp9KTsKCmFzeW5jIGZ1bmN0aW9uIHNlbmRBYm5vcm1hbFNlc3Npb24oKSB7CiAgLy8gb2Ygd2UgaGF2ZSBhbiBleGlzdGluZyBzZXNzaW9uIHBhc3NlZCBmcm9tIHRoZSBtYWluIHRocmVhZCwgc2VuZCBpdCBhcyBhYm5vcm1hbAogIGlmIChzZXNzaW9uKSB7CiAgICBsb2coJ1NlbmRpbmcgYWJub3JtYWwgc2Vzc2lvbicpOwogICAgdXBkYXRlU2Vzc2lvbihzZXNzaW9uLCB7IHN0YXR1czogJ2Fibm9ybWFsJywgYWJub3JtYWxfbWVjaGFuaXNtOiAnYW5yX2ZvcmVncm91bmQnIH0pOwoKICAgIGNvbnN0IGVudmVsb3BlID0gY3JlYXRlU2Vzc2lvbkVudmVsb3BlKHNlc3Npb24sIG9wdGlvbnMuZHNuLCBvcHRpb25zLnNka01ldGFkYXRhKTsKICAgIC8vIExvZyB0aGUgZW52ZWxvcGUgc28gdG8gYWlkIGluIHRlc3RpbmcKICAgIGxvZyhKU09OLnN0cmluZ2lmeShlbnZlbG9wZSkpOwoKICAgIGF3YWl0IHRyYW5zcG9ydC5zZW5kKGVudmVsb3BlKTsKCiAgICB0cnkgewogICAgICAvLyBOb3RpZnkgdGhlIG1haW4gcHJvY2VzcyB0aGF0IHRoZSBzZXNzaW9uIGhhcyBlbmRlZCBzbyB0aGUgc2Vzc2lvbiBjYW4gYmUgY2xlYXJlZCBmcm9tIHRoZSBzY29wZQogICAgICBfb3B0aW9uYWxDaGFpbihbcGFyZW50UG9ydCwgJ29wdGlvbmFsQWNjZXNzJywgXzIgPT4gXzIucG9zdE1lc3NhZ2UsICdjYWxsJywgXzMgPT4gXzMoJ3Nlc3Npb24tZW5kZWQnKV0pOwogICAgfSBjYXRjaCAoXykgewogICAgICAvLyBpZ25vcmUKICAgIH0KICB9Cn0KCmxvZygnU3RhcnRlZCcpOwoKZnVuY3Rpb24gcHJlcGFyZVN0YWNrRnJhbWVzKHN0YWNrRnJhbWVzKSB7CiAgaWYgKCFzdGFja0ZyYW1lcykgewogICAgcmV0dXJuIHVuZGVmaW5lZDsKICB9CgogIC8vIFN0cmlwIFNlbnRyeSBmcmFtZXMgYW5kIHJldmVyc2UgdGhlIHN0YWNrIGZyYW1lcyBzbyB0aGV5IGFyZSBpbiB0aGUgY29ycmVjdCBvcmRlcgogIGNvbnN0IHN0cmlwcGVkRnJhbWVzID0gc3RyaXBTZW50cnlGcmFtZXNBbmRSZXZlcnNlKHN0YWNrRnJhbWVzKTsKCiAgLy8gSWYgd2UgaGF2ZSBhbiBhcHAgcm9vdCBwYXRoLCByZXdyaXRlIHRoZSBmaWxlbmFtZXMgdG8gYmUgcmVsYXRpdmUgdG8gdGhlIGFwcCByb290CiAgaWYgKG9wdGlvbnMuYXBwUm9vdFBhdGgpIHsKICAgIGZvciAoY29uc3QgZnJhbWUgb2Ygc3RyaXBwZWRGcmFtZXMpIHsKICAgICAgaWYgKCFmcmFtZS5maWxlbmFtZSkgewogICAgICAgIGNvbnRpbnVlOwogICAgICB9CgogICAgICBmcmFtZS5maWxlbmFtZSA9IG5vcm1hbGl6ZVVybFRvQmFzZShmcmFtZS5maWxlbmFtZSwgb3B0aW9ucy5hcHBSb290UGF0aCk7CiAgICB9CiAgfQoKICByZXR1cm4gc3RyaXBwZWRGcmFtZXM7Cn0KCmFzeW5jIGZ1bmN0aW9uIHNlbmRBbnJFdmVudChmcmFtZXMsIHRyYWNlQ29udGV4dCkgewogIGlmIChoYXNTZW50QW5yRXZlbnQpIHsKICAgIHJldHVybjsKICB9CgogIGhhc1NlbnRBbnJFdmVudCA9IHRydWU7CgogIGF3YWl0IHNlbmRBYm5vcm1hbFNlc3Npb24oKTsKCiAgbG9nKCdTZW5kaW5nIGV2ZW50Jyk7CgogIGNvbnN0IGV2ZW50ID0gewogICAgZXZlbnRfaWQ6IHV1aWQ0KCksCiAgICBjb250ZXh0czogeyAuLi5vcHRpb25zLmNvbnRleHRzLCB0cmFjZTogdHJhY2VDb250ZXh0IH0sCiAgICByZWxlYXNlOiBvcHRpb25zLnJlbGVhc2UsCiAgICBlbnZpcm9ubWVudDogb3B0aW9ucy5lbnZpcm9ubWVudCwKICAgIGRpc3Q6IG9wdGlvbnMuZGlzdCwKICAgIHBsYXRmb3JtOiAnbm9kZScsCiAgICBsZXZlbDogJ2Vycm9yJywKICAgIGV4Y2VwdGlvbjogewogICAgICB2YWx1ZXM6IFsKICAgICAgICB7CiAgICAgICAgICB0eXBlOiAnQXBwbGljYXRpb25Ob3RSZXNwb25kaW5nJywKICAgICAgICAgIHZhbHVlOiBgQXBwbGljYXRpb24gTm90IFJlc3BvbmRpbmcgZm9yIGF0IGxlYXN0ICR7b3B0aW9ucy5hbnJUaHJlc2hvbGR9IG1zYCwKICAgICAgICAgIHN0YWNrdHJhY2U6IHsgZnJhbWVzOiBwcmVwYXJlU3RhY2tGcmFtZXMoZnJhbWVzKSB9LAogICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoZSBVSSBkb2Vzbid0IHNheSAnQ3Jhc2hlZCBpbicgZm9yIHRoZSBzdGFjayB0cmFjZQogICAgICAgICAgbWVjaGFuaXNtOiB7IHR5cGU6ICdBTlInIH0sCiAgICAgICAgfSwKICAgICAgXSwKICAgIH0sCiAgICB0YWdzOiBvcHRpb25zLnN0YXRpY1RhZ3MsCiAgfTsKCiAgY29uc3QgZW52ZWxvcGUgPSBjcmVhdGVFdmVudEVudmVsb3BlKGV2ZW50LCBvcHRpb25zLmRzbiwgb3B0aW9ucy5zZGtNZXRhZGF0YSk7CiAgLy8gTG9nIHRoZSBlbnZlbG9wZSBzbyB0byBhaWQgaW4gdGVzdGluZwogIGxvZyhKU09OLnN0cmluZ2lmeShlbnZlbG9wZSkpOwoKICBhd2FpdCB0cmFuc3BvcnQuc2VuZChlbnZlbG9wZSk7CiAgYXdhaXQgdHJhbnNwb3J0LmZsdXNoKDIwMDApOwoKICAvLyBEZWxheSBmb3IgNSBzZWNvbmRzIHNvIHRoYXQgc3RkaW8gY2FuIGZsdXNoIGluIHRoZSBtYWluIGV2ZW50IGxvb3AgZXZlciByZXN0YXJ0cy4KICAvLyBUaGlzIGlzIG1haW5seSBmb3IgdGhlIGJlbmVmaXQgb2YgbG9nZ2luZy9kZWJ1Z2dpbmcgaXNzdWVzLgogIHNldFRpbWVvdXQoKCkgPT4gewogICAgcHJvY2Vzcy5leGl0KDApOwogIH0sIDUwMDApOwp9CgpsZXQgZGVidWdnZXJQYXVzZTsKCmlmIChvcHRpb25zLmNhcHR1cmVTdGFja1RyYWNlKSB7CiAgbG9nKCdDb25uZWN0aW5nIHRvIGRlYnVnZ2VyJyk7CgogIGNvbnN0IHNlc3Npb24gPSBuZXcgU2Vzc2lvbigpIDsKICBzZXNzaW9uLmNvbm5lY3RUb01haW5UaHJlYWQoKTsKCiAgbG9nKCdDb25uZWN0ZWQgdG8gZGVidWdnZXInKTsKCiAgLy8gQ29sbGVjdCBzY3JpcHRJZCAtPiB1cmwgbWFwIHNvIHdlIGNhbiBsb29rIHVwIHRoZSBmaWxlbmFtZXMgbGF0ZXIKICBjb25zdCBzY3JpcHRzID0gbmV3IE1hcCgpOwoKICBzZXNzaW9uLm9uKCdEZWJ1Z2dlci5zY3JpcHRQYXJzZWQnLCBldmVudCA9PiB7CiAgICBzY3JpcHRzLnNldChldmVudC5wYXJhbXMuc2NyaXB0SWQsIGV2ZW50LnBhcmFtcy51cmwpOwogIH0pOwoKICBzZXNzaW9uLm9uKCdEZWJ1Z2dlci5wYXVzZWQnLCBldmVudCA9PiB7CiAgICBpZiAoZXZlbnQucGFyYW1zLnJlYXNvbiAhPT0gJ290aGVyJykgewogICAgICByZXR1cm47CiAgICB9CgogICAgdHJ5IHsKICAgICAgbG9nKCdEZWJ1Z2dlciBwYXVzZWQnKTsKCiAgICAgIC8vIGNvcHkgdGhlIGZyYW1lcwogICAgICBjb25zdCBjYWxsRnJhbWVzID0gWy4uLmV2ZW50LnBhcmFtcy5jYWxsRnJhbWVzXTsKCiAgICAgIGNvbnN0IGdldE1vZHVsZU5hbWUgPSBvcHRpb25zLmFwcFJvb3RQYXRoID8gY3JlYXRlR2V0TW9kdWxlRnJvbUZpbGVuYW1lKG9wdGlvbnMuYXBwUm9vdFBhdGgpIDogKCkgPT4gdW5kZWZpbmVkOwogICAgICBjb25zdCBzdGFja0ZyYW1lcyA9IGNhbGxGcmFtZXMubWFwKGZyYW1lID0+CiAgICAgICAgY2FsbEZyYW1lVG9TdGFja0ZyYW1lKGZyYW1lLCBzY3JpcHRzLmdldChmcmFtZS5sb2NhdGlvbi5zY3JpcHRJZCksIGdldE1vZHVsZU5hbWUpLAogICAgICApOwoKICAgICAgLy8gRXZhbHVhdGUgYSBzY3JpcHQgaW4gdGhlIGN1cnJlbnRseSBwYXVzZWQgY29udGV4dAogICAgICBzZXNzaW9uLnBvc3QoCiAgICAgICAgJ1J1bnRpbWUuZXZhbHVhdGUnLAogICAgICAgIHsKICAgICAgICAgIC8vIEdyYWIgdGhlIHRyYWNlIGNvbnRleHQgZnJvbSB0aGUgY3VycmVudCBzY29wZQogICAgICAgICAgZXhwcmVzc2lvbjoKICAgICAgICAgICAgJ2NvbnN0IGN0eCA9IF9fU0VOVFJZX18uaHViLmdldFNjb3BlKCkuZ2V0UHJvcGFnYXRpb25Db250ZXh0KCk7IGN0eC50cmFjZUlkICsgIi0iICsgY3R4LnNwYW5JZCArICItIiArIGN0eC5wYXJlbnRTcGFuSWQnLAogICAgICAgICAgLy8gRG9uJ3QgcmUtdHJpZ2dlciB0aGUgZGVidWdnZXIgaWYgdGhpcyBjYXVzZXMgYW4gZXJyb3IKICAgICAgICAgIHNpbGVudDogdHJ1ZSwKICAgICAgICB9LAogICAgICAgIChfLCBwYXJhbSkgPT4gewogICAgICAgICAgY29uc3QgdHJhY2VJZCA9IHBhcmFtICYmIHBhcmFtLnJlc3VsdCA/IChwYXJhbS5yZXN1bHQudmFsdWUgKSA6ICctLSc7CiAgICAgICAgICBjb25zdCBbdHJhY2VfaWQsIHNwYW5faWQsIHBhcmVudF9zcGFuX2lkXSA9IHRyYWNlSWQuc3BsaXQoJy0nKSA7CgogICAgICAgICAgc2Vzc2lvbi5wb3N0KCdEZWJ1Z2dlci5yZXN1bWUnKTsKICAgICAgICAgIHNlc3Npb24ucG9zdCgnRGVidWdnZXIuZGlzYWJsZScpOwoKICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBfb3B0aW9uYWxDaGFpbihbdHJhY2VfaWQsICdvcHRpb25hbEFjY2VzcycsIF80ID0+IF80Lmxlbmd0aF0pICYmIF9vcHRpb25hbENoYWluKFtzcGFuX2lkLCAnb3B0aW9uYWxBY2Nlc3MnLCBfNSA9PiBfNS5sZW5ndGhdKSA/IHsgdHJhY2VfaWQsIHNwYW5faWQsIHBhcmVudF9zcGFuX2lkIH0gOiB1bmRlZmluZWQ7CiAgICAgICAgICBzZW5kQW5yRXZlbnQoc3RhY2tGcmFtZXMsIGNvbnRleHQpLnRoZW4obnVsbCwgKCkgPT4gewogICAgICAgICAgICBsb2coJ1NlbmRpbmcgQU5SIGV2ZW50IGZhaWxlZC4nKTsKICAgICAgICAgIH0pOwogICAgICAgIH0sCiAgICAgICk7CiAgICB9IGNhdGNoIChlKSB7CiAgICAgIHNlc3Npb24ucG9zdCgnRGVidWdnZXIucmVzdW1lJyk7CiAgICAgIHNlc3Npb24ucG9zdCgnRGVidWdnZXIuZGlzYWJsZScpOwogICAgICB0aHJvdyBlOwogICAgfQogIH0pOwoKICBkZWJ1Z2dlclBhdXNlID0gKCkgPT4gewogICAgdHJ5IHsKICAgICAgc2Vzc2lvbi5wb3N0KCdEZWJ1Z2dlci5lbmFibGUnLCAoKSA9PiB7CiAgICAgICAgc2Vzc2lvbi5wb3N0KCdEZWJ1Z2dlci5wYXVzZScpOwogICAgICB9KTsKICAgIH0gY2F0Y2ggKF8pIHsKICAgICAgLy8KICAgIH0KICB9Owp9CgpmdW5jdGlvbiBjcmVhdGVIclRpbWVyKCkgewogIC8vIFRPRE8gKHY4KTogV2UgY2FuIHVzZSBwcm9jZXNzLmhydGltZS5iaWdpbnQoKSBhZnRlciB3ZSBkcm9wIG5vZGUgdjgKICBsZXQgbGFzdFBvbGwgPSBwcm9jZXNzLmhydGltZSgpOwoKICByZXR1cm4gewogICAgZ2V0VGltZU1zOiAoKSA9PiB7CiAgICAgIGNvbnN0IFtzZWNvbmRzLCBuYW5vU2Vjb25kc10gPSBwcm9jZXNzLmhydGltZShsYXN0UG9sbCk7CiAgICAgIHJldHVybiBNYXRoLmZsb29yKHNlY29uZHMgKiAxZTMgKyBuYW5vU2Vjb25kcyAvIDFlNik7CiAgICB9LAogICAgcmVzZXQ6ICgpID0+IHsKICAgICAgbGFzdFBvbGwgPSBwcm9jZXNzLmhydGltZSgpOwogICAgfSwKICB9Owp9CgpmdW5jdGlvbiB3YXRjaGRvZ1RpbWVvdXQoKSB7CiAgbG9nKCdXYXRjaGRvZyB0aW1lb3V0Jyk7CgogIGlmIChkZWJ1Z2dlclBhdXNlKSB7CiAgICBsb2coJ1BhdXNpbmcgZGVidWdnZXIgdG8gY2FwdHVyZSBzdGFjayB0cmFjZScpOwogICAgZGVidWdnZXJQYXVzZSgpOwogIH0gZWxzZSB7CiAgICBsb2coJ0NhcHR1cmluZyBldmVudCB3aXRob3V0IGEgc3RhY2sgdHJhY2UnKTsKICAgIHNlbmRBbnJFdmVudCgpLnRoZW4obnVsbCwgKCkgPT4gewogICAgICBsb2coJ1NlbmRpbmcgQU5SIGV2ZW50IGZhaWxlZCBvbiB3YXRjaGRvZyB0aW1lb3V0LicpOwogICAgfSk7CiAgfQp9Cgpjb25zdCB7IHBvbGwgfSA9IHdhdGNoZG9nVGltZXIoY3JlYXRlSHJUaW1lciwgb3B0aW9ucy5wb2xsSW50ZXJ2YWwsIG9wdGlvbnMuYW5yVGhyZXNob2xkLCB3YXRjaGRvZ1RpbWVvdXQpOwoKX29wdGlvbmFsQ2hhaW4oW3BhcmVudFBvcnQsICdvcHRpb25hbEFjY2VzcycsIF82ID0+IF82Lm9uLCAnY2FsbCcsIF83ID0+IF83KCdtZXNzYWdlJywgKG1zZykgPT4gewogIGlmIChtc2cuc2Vzc2lvbikgewogICAgc2Vzc2lvbiA9IG1ha2VTZXNzaW9uKG1zZy5zZXNzaW9uKTsKICB9CgogIHBvbGwoKTsKfSldKTs=";
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/integrations/anr/index.js
var require_anr2 = __commonJS((exports, module) => {
  var log = function(message, ...args) {
    utils.logger.log(`[ANR] ${message}`, ...args);
  };
  var getWorkerThreads = function() {
    return utils.dynamicRequire(module, "worker_threads");
  };
  async function getContexts(client) {
    let event = { message: "ANR" };
    const eventHint = {};
    for (const processor of client.getEventProcessors()) {
      if (event === null)
        break;
      event = await processor(event, eventHint);
    }
    return _optionalChain([event, "optionalAccess", (_2) => _2.contexts]) || {};
  }
  async function _startWorker(client, _options) {
    const contexts = await getContexts(client);
    const dsn = client.getDsn();
    if (!dsn) {
      return;
    }
    _optionalChainDelete([contexts, "access", (_3) => _3.app, "optionalAccess", (_4) => delete _4.app_memory]);
    _optionalChainDelete([contexts, "access", (_5) => _5.device, "optionalAccess", (_6) => delete _6.free_memory]);
    const initOptions = client.getOptions();
    const sdkMetadata = client.getSdkMetadata() || {};
    if (sdkMetadata.sdk) {
      sdkMetadata.sdk.integrations = initOptions.integrations.map((i) => i.name);
    }
    const options = {
      debug: utils.logger.isEnabled(),
      dsn,
      environment: initOptions.environment || "production",
      release: initOptions.release,
      dist: initOptions.dist,
      sdkMetadata,
      appRootPath: _options.appRootPath,
      pollInterval: _options.pollInterval || DEFAULT_INTERVAL,
      anrThreshold: _options.anrThreshold || DEFAULT_HANG_THRESHOLD,
      captureStackTrace: !!_options.captureStackTrace,
      staticTags: _options.staticTags || {},
      contexts
    };
    if (options.captureStackTrace) {
      const inspector = __require("inspector");
      if (!inspector.url()) {
        inspector.open(0);
      }
    }
    const { Worker } = getWorkerThreads();
    const worker = new Worker(new url.URL(`data:application/javascript;base64,${workerScript.base64WorkerScript}`), {
      workerData: options
    });
    process.on("exit", () => {
      worker.terminate();
    });
    const timer = setInterval(() => {
      try {
        const currentSession = core.getCurrentScope().getSession();
        const session = currentSession ? { ...currentSession, toJSON: undefined } : undefined;
        worker.postMessage({ session });
      } catch (_) {
      }
    }, options.pollInterval);
    timer.unref();
    worker.on("message", (msg) => {
      if (msg === "session-ended") {
        log("ANR event sent from ANR worker. Clearing session in this thread.");
        core.getCurrentScope().setSession(undefined);
      }
    });
    worker.once("error", (err) => {
      clearInterval(timer);
      log("ANR worker error", err);
    });
    worker.once("exit", (code) => {
      clearInterval(timer);
      log("ANR worker exit", code);
    });
    worker.unref();
  }
  var {
    _optionalChain,
    _optionalChainDelete
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  var url = __require("url");
  var core = require_cjs2();
  var utils = require_cjs();
  var nodeVersion = require_nodeVersion();
  var workerScript = require_worker_script();
  var DEFAULT_INTERVAL = 50;
  var DEFAULT_HANG_THRESHOLD = 5000;
  var INTEGRATION_NAME = "Anr";
  var _anrIntegration = (options = {}) => {
    return {
      name: INTEGRATION_NAME,
      setupOnce() {
      },
      setup(client) {
        if (nodeVersion.NODE_VERSION.major < 16 || nodeVersion.NODE_VERSION.major === 16 && nodeVersion.NODE_VERSION.minor < 17) {
          throw new Error("ANR detection requires Node 16.17.0 or later");
        }
        setImmediate(() => _startWorker(client, options));
      }
    };
  };
  var anrIntegration = core.defineIntegration(_anrIntegration);
  var Anr = core.convertIntegrationFnToClass(INTEGRATION_NAME, anrIntegration);
  exports.Anr = Anr;
  exports.anrIntegration = anrIntegration;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/integrations/anr/legacy.js
var require_legacy = __commonJS((exports) => {
  var enableAnrDetection = function(options) {
    const client = core.getClient();
    const integration = new index.Anr(options);
    integration.setup(client);
    return Promise.resolve();
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var index = require_anr2();
  exports.enableAnrDetection = enableAnrDetection;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/requestDataDeprecated.js
var require_requestDataDeprecated = __commonJS((exports) => {
  var extractRequestData = function(req, keys) {
    return utils.extractRequestData(req, { include: keys });
  };
  var parseRequest = function(event, req, options = {}) {
    return utils.addRequestDataToEvent(event, req, { include: options });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_cjs();
  exports.extractRequestData = extractRequestData;
  exports.parseRequest = parseRequest;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/handlers.js
var require_handlers = __commonJS((exports) => {
  var tracingHandler = function() {
    return function sentryTracingMiddleware(req, res, next) {
      const options = _optionalChain([core.getClient, "call", (_) => _(), "optionalAccess", (_2) => _2.getOptions, "call", (_3) => _3()]);
      if (!options || options.instrumenter !== "sentry" || _optionalChain([req, "access", (_4) => _4.method, "optionalAccess", (_5) => _5.toUpperCase, "call", (_6) => _6()]) === "OPTIONS" || _optionalChain([req, "access", (_7) => _7.method, "optionalAccess", (_8) => _8.toUpperCase, "call", (_9) => _9()]) === "HEAD") {
        return next();
      }
      const sentryTrace = req.headers && utils.isString(req.headers["sentry-trace"]) ? req.headers["sentry-trace"] : undefined;
      const baggage = _optionalChain([req, "access", (_10) => _10.headers, "optionalAccess", (_11) => _11.baggage]);
      if (!core.hasTracingEnabled(options)) {
        return next();
      }
      const [name, source] = utils.extractPathForTransaction(req, { path: true, method: true });
      const transaction = core.continueTrace({ sentryTrace, baggage }, (ctx) => core.startTransaction({
        name,
        op: "http.server",
        origin: "auto.http.node.tracingHandler",
        ...ctx,
        data: {
          [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source
        },
        metadata: {
          ...ctx.metadata,
          request: req
        }
      }, { request: utils.extractRequestData(req) }));
      core.getCurrentScope().setSpan(transaction);
      res.__sentry_transaction = transaction;
      res.once("finish", () => {
        setImmediate(() => {
          utils.addRequestDataToTransaction(transaction, req);
          core.setHttpStatus(transaction, res.statusCode);
          transaction.end();
        });
      });
      next();
    };
  };
  var convertReqHandlerOptsToAddReqDataOpts = function(reqHandlerOptions = {}) {
    let addRequestDataOptions;
    if ("include" in reqHandlerOptions) {
      addRequestDataOptions = { include: reqHandlerOptions.include };
    } else {
      const { ip, request, transaction, user } = reqHandlerOptions;
      if (ip || request || transaction || user) {
        addRequestDataOptions = { include: utils.dropUndefinedKeys({ ip, request, transaction, user }) };
      }
    }
    return addRequestDataOptions;
  };
  var requestHandler = function(options) {
    const requestDataOptions = convertReqHandlerOptsToAddReqDataOpts(options);
    const client = core.getClient();
    if (client && sdk.isAutoSessionTrackingEnabled(client)) {
      client.initSessionFlusher();
      const scope = core.getCurrentScope();
      if (scope.getSession()) {
        scope.setSession();
      }
    }
    return function sentryRequestMiddleware(req, res, next) {
      if (options && options.flushTimeout && options.flushTimeout > 0) {
        const _end = res.end;
        res.end = function(chunk, encoding, cb) {
          core.flush(options.flushTimeout).then(() => {
            _end.call(this, chunk, encoding, cb);
          }).then(null, (e) => {
            debugBuild.DEBUG_BUILD && utils.logger.error(e);
            _end.call(this, chunk, encoding, cb);
          });
        };
      }
      core.runWithAsyncContext(() => {
        const scope = core.getCurrentScope();
        scope.setSDKProcessingMetadata({
          request: req,
          requestDataOptionsFromExpressHandler: requestDataOptions
        });
        const client2 = core.getClient();
        if (sdk.isAutoSessionTrackingEnabled(client2)) {
          scope.setRequestSession({ status: "ok" });
        }
        res.once("finish", () => {
          const client3 = core.getClient();
          if (sdk.isAutoSessionTrackingEnabled(client3)) {
            setImmediate(() => {
              if (client3 && client3._captureRequestSession) {
                client3._captureRequestSession();
              }
            });
          }
        });
        next();
      });
    };
  };
  var getStatusCodeFromResponse = function(error) {
    const statusCode = error.status || error.statusCode || error.status_code || error.output && error.output.statusCode;
    return statusCode ? parseInt(statusCode, 10) : 500;
  };
  var defaultShouldHandleError = function(error) {
    const status = getStatusCodeFromResponse(error);
    return status >= 500;
  };
  var errorHandler = function(options) {
    return function sentryErrorMiddleware(error, _req, res, next) {
      const shouldHandleError = options && options.shouldHandleError || defaultShouldHandleError;
      if (shouldHandleError(error)) {
        core.withScope((_scope) => {
          _scope.setSDKProcessingMetadata({ request: _req });
          const transaction = res.__sentry_transaction;
          if (transaction && !core.getActiveSpan()) {
            _scope.setSpan(transaction);
          }
          const client = core.getClient();
          if (client && sdk.isAutoSessionTrackingEnabled(client)) {
            const isSessionAggregatesMode = client._sessionFlusher !== undefined;
            if (isSessionAggregatesMode) {
              const requestSession = _scope.getRequestSession();
              if (requestSession && requestSession.status !== undefined) {
                requestSession.status = "crashed";
              }
            }
          }
          const eventId = core.captureException(error, { mechanism: { type: "middleware", handled: false } });
          res.sentry = eventId;
          next(error);
        });
        return;
      }
      next(error);
    };
  };
  var trpcMiddleware = function(options = {}) {
    return function({ path, type, next, rawInput }) {
      const clientOptions = _optionalChain([core.getClient, "call", (_12) => _12(), "optionalAccess", (_13) => _13.getOptions, "call", (_14) => _14()]);
      const sentryTransaction = core.getCurrentScope().getTransaction();
      if (sentryTransaction) {
        sentryTransaction.updateName(`trpc/${path}`);
        sentryTransaction.setAttribute(core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, "route");
        sentryTransaction.op = "rpc.server";
        const trpcContext = {
          procedure_type: type
        };
        if (options.attachRpcInput !== undefined ? options.attachRpcInput : _optionalChain([clientOptions, "optionalAccess", (_15) => _15.sendDefaultPii])) {
          trpcContext.input = utils.normalize(rawInput);
        }
        sentryTransaction.setContext("trpc", trpcContext);
      }
      function captureIfError(nextResult) {
        if (!nextResult.ok) {
          core.captureException(nextResult.error, { mechanism: { handled: false, data: { function: "trpcMiddleware" } } });
        }
      }
      let maybePromiseResult;
      try {
        maybePromiseResult = next();
      } catch (e) {
        core.captureException(e, { mechanism: { handled: false, data: { function: "trpcMiddleware" } } });
        throw e;
      }
      if (utils.isThenable(maybePromiseResult)) {
        Promise.resolve(maybePromiseResult).then((nextResult) => {
          captureIfError(nextResult);
        }, (e) => {
          core.captureException(e, { mechanism: { handled: false, data: { function: "trpcMiddleware" } } });
        });
      } else {
        captureIfError(maybePromiseResult);
      }
      return maybePromiseResult;
    };
  };
  var {
    _optionalChain
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var utils = require_cjs();
  var debugBuild = require_debug_build4();
  var sdk = require_sdk2();
  var requestDataDeprecated = require_requestDataDeprecated();
  exports.extractRequestData = requestDataDeprecated.extractRequestData;
  exports.parseRequest = requestDataDeprecated.parseRequest;
  exports.errorHandler = errorHandler;
  exports.requestHandler = requestHandler;
  exports.tracingHandler = tracingHandler;
  exports.trpcMiddleware = trpcMiddleware;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/integrations/hapi/index.js
var require_hapi = __commonJS((exports) => {
  var isResponseObject = function(response) {
    return response && response.statusCode !== undefined;
  };
  var isBoomObject = function(response) {
    return response && response.isBoom !== undefined;
  };
  var isErrorEvent = function(event) {
    return event && event.error !== undefined;
  };
  var sendErrorToSentry = function(errorData) {
    core.captureException(errorData, {
      mechanism: {
        type: "hapi",
        handled: false,
        data: {
          function: "hapiErrorPlugin"
        }
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var utils = require_cjs();
  var hapiErrorPlugin = {
    name: "SentryHapiErrorPlugin",
    version: core.SDK_VERSION,
    register: async function(serverArg) {
      const server = serverArg;
      server.events.on("request", (request, event) => {
        const transaction = core.getActiveTransaction();
        if (request.response && isBoomObject(request.response)) {
          sendErrorToSentry(request.response);
        } else if (isErrorEvent(event)) {
          sendErrorToSentry(event.error);
        }
        if (transaction) {
          transaction.setStatus("internal_error");
          transaction.end();
        }
      });
    }
  };
  var hapiTracingPlugin = {
    name: "SentryHapiTracingPlugin",
    version: core.SDK_VERSION,
    register: async function(serverArg) {
      const server = serverArg;
      server.ext("onPreHandler", (request, h) => {
        const transaction = core.continueTrace({
          sentryTrace: request.headers["sentry-trace"] || undefined,
          baggage: request.headers["baggage"] || undefined
        }, (transactionContext) => {
          return core.startTransaction({
            ...transactionContext,
            op: "hapi.request",
            name: request.route.path,
            description: `${request.route.method} ${request.path}`
          });
        });
        core.getCurrentScope().setSpan(transaction);
        return h.continue;
      });
      server.ext("onPreResponse", (request, h) => {
        const transaction = core.getActiveTransaction();
        if (request.response && isResponseObject(request.response) && transaction) {
          const response = request.response;
          response.header("sentry-trace", core.spanToTraceHeader(transaction));
          const dynamicSamplingContext = utils.dynamicSamplingContextToSentryBaggageHeader(core.getDynamicSamplingContextFromSpan(transaction));
          if (dynamicSamplingContext) {
            response.header("baggage", dynamicSamplingContext);
          }
        }
        return h.continue;
      });
      server.ext("onPostHandler", (request, h) => {
        const transaction = core.getActiveTransaction();
        if (transaction) {
          if (request.response && isResponseObject(request.response)) {
            core.setHttpStatus(transaction, request.response.statusCode);
          }
          transaction.end();
        }
        return h.continue;
      });
    }
  };
  var INTEGRATION_NAME = "Hapi";
  var _hapiIntegration = (options = {}) => {
    const server = options.server;
    return {
      name: INTEGRATION_NAME,
      setupOnce() {
        if (!server) {
          return;
        }
        utils.fill(server, "start", (originalStart) => {
          return async function() {
            await this.register(hapiTracingPlugin);
            await this.register(hapiErrorPlugin);
            const result = originalStart.apply(this);
            return result;
          };
        });
      }
    };
  };
  var hapiIntegration = core.defineIntegration(_hapiIntegration);
  var Hapi = core.convertIntegrationFnToClass(INTEGRATION_NAME, hapiIntegration);
  exports.Hapi = Hapi;
  exports.hapiErrorPlugin = hapiErrorPlugin;
  exports.hapiIntegration = hapiIntegration;
  exports.hapiTracingPlugin = hapiTracingPlugin;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/integrations/index.js
var require_integrations2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var console2 = require_console2();
  var http = require_http3();
  var onuncaughtexception = require_onuncaughtexception();
  var onunhandledrejection = require_onunhandledrejection();
  var modules = require_modules();
  var contextlines = require_contextlines();
  var context = require_context();
  var core = require_cjs2();
  var index = require_local_variables();
  var index$1 = require_undici();
  var spotlight = require_spotlight();
  var index$2 = require_anr2();
  var index$3 = require_hapi();
  exports.Console = console2.Console;
  exports.Http = http.Http;
  exports.OnUncaughtException = onuncaughtexception.OnUncaughtException;
  exports.OnUnhandledRejection = onunhandledrejection.OnUnhandledRejection;
  exports.Modules = modules.Modules;
  exports.ContextLines = contextlines.ContextLines;
  exports.Context = context.Context;
  exports.RequestData = core.RequestData;
  exports.LocalVariables = index.LocalVariables;
  exports.Undici = index$1.Undici;
  exports.Spotlight = spotlight.Spotlight;
  exports.Anr = index$2.Anr;
  exports.Hapi = index$3.Hapi;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/tracing/integrations.js
var require_integrations3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tracing = require_cjs3();
  exports.Apollo = tracing.Apollo;
  exports.Express = tracing.Express;
  exports.GraphQL = tracing.GraphQL;
  exports.Mongo = tracing.Mongo;
  exports.Mysql = tracing.Mysql;
  exports.Postgres = tracing.Postgres;
  exports.Prisma = tracing.Prisma;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/cron/common.js
var require_common2 = __commonJS((exports) => {
  var replaceCronNames = function(cronExpression) {
    return replacements.reduce((acc, [name, replacement]) => acc.replace(new RegExp(name, "gi"), replacement), cronExpression);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var replacements = [
    ["january", "1"],
    ["february", "2"],
    ["march", "3"],
    ["april", "4"],
    ["may", "5"],
    ["june", "6"],
    ["july", "7"],
    ["august", "8"],
    ["september", "9"],
    ["october", "10"],
    ["november", "11"],
    ["december", "12"],
    ["jan", "1"],
    ["feb", "2"],
    ["mar", "3"],
    ["apr", "4"],
    ["may", "5"],
    ["jun", "6"],
    ["jul", "7"],
    ["aug", "8"],
    ["sep", "9"],
    ["oct", "10"],
    ["nov", "11"],
    ["dec", "12"],
    ["sunday", "0"],
    ["monday", "1"],
    ["tuesday", "2"],
    ["wednesday", "3"],
    ["thursday", "4"],
    ["friday", "5"],
    ["saturday", "6"],
    ["sun", "0"],
    ["mon", "1"],
    ["tue", "2"],
    ["wed", "3"],
    ["thu", "4"],
    ["fri", "5"],
    ["sat", "6"]
  ];
  exports.replaceCronNames = replaceCronNames;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/cron/cron.js
var require_cron = __commonJS((exports) => {
  var instrumentCron = function(lib, monitorSlug) {
    let jobScheduled = false;
    return new Proxy(lib, {
      construct(target, args) {
        const [cronTime, onTick, onComplete, start, timeZone, ...rest] = args;
        if (typeof cronTime !== "string") {
          throw new Error(ERROR_TEXT);
        }
        if (jobScheduled) {
          throw new Error(`A job named '${monitorSlug}' has already been scheduled`);
        }
        jobScheduled = true;
        const cronString = common.replaceCronNames(cronTime);
        function monitoredTick(context, onComplete2) {
          return core.withMonitor(monitorSlug, () => {
            return onTick(context, onComplete2);
          }, {
            schedule: { type: "crontab", value: cronString },
            ...timeZone ? { timeZone } : {}
          });
        }
        return new target(cronTime, monitoredTick, onComplete, start, timeZone, ...rest);
      },
      get(target, prop) {
        if (prop === "from") {
          return (param) => {
            const { cronTime, onTick, timeZone } = param;
            if (typeof cronTime !== "string") {
              throw new Error(ERROR_TEXT);
            }
            if (jobScheduled) {
              throw new Error(`A job named '${monitorSlug}' has already been scheduled`);
            }
            jobScheduled = true;
            const cronString = common.replaceCronNames(cronTime);
            param.onTick = (context, onComplete) => {
              return core.withMonitor(monitorSlug, () => {
                return onTick(context, onComplete);
              }, {
                schedule: { type: "crontab", value: cronString },
                ...timeZone ? { timeZone } : {}
              });
            };
            return target.from(param);
          };
        } else {
          return target[prop];
        }
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var common = require_common2();
  var ERROR_TEXT = "Automatic instrumentation of CronJob only supports crontab string";
  exports.instrumentCron = instrumentCron;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/cron/node-cron.js
var require_node_cron = __commonJS((exports) => {
  var instrumentNodeCron = function(lib) {
    return new Proxy(lib, {
      get(target, prop) {
        if (prop === "schedule" && target.schedule) {
          return new Proxy(target.schedule, {
            apply(target2, thisArg, argArray) {
              const [expression, , options] = argArray;
              if (!_optionalChain([options, "optionalAccess", (_) => _.name])) {
                throw new Error('Missing "name" for scheduled job. A name is required for Sentry check-in monitoring.');
              }
              return core.withMonitor(options.name, () => {
                return target2.apply(thisArg, argArray);
              }, {
                schedule: { type: "crontab", value: common.replaceCronNames(expression) },
                timezone: _optionalChain([options, "optionalAccess", (_2) => _2.timezone])
              });
            }
          });
        } else {
          return target[prop];
        }
      }
    });
  };
  var {
    _optionalChain
  } = require_cjs();
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var common = require_common2();
  exports.instrumentNodeCron = instrumentNodeCron;
});

// ../node_modules/.pnpm/@sentry+node@7.100.1/node_modules/@sentry/node/cjs/cron/node-schedule.js
var require_node_schedule = __commonJS((exports) => {
  var instrumentNodeSchedule = function(lib) {
    return new Proxy(lib, {
      get(target, prop) {
        if (prop === "scheduleJob") {
          return new Proxy(target.scheduleJob, {
            apply(target2, thisArg, argArray) {
              const [nameOrExpression, expressionOrCallback] = argArray;
              if (typeof nameOrExpression !== "string" || typeof expressionOrCallback !== "string") {
                throw new Error("Automatic instrumentation of 'node-schedule' requires the first parameter of 'scheduleJob' to be a job name string and the second parameter to be a crontab string");
              }
              const monitorSlug = nameOrExpression;
              const expression = expressionOrCallback;
              return core.withMonitor(monitorSlug, () => {
                return target2.apply(thisArg, argArray);
              }, {
                schedule: { type: "crontab", value: common.replaceCronNames(expression) }
              });
            }
          });
        }
        return target[prop];
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var common = require_common2();
  exports.instrumentNodeSchedule = instrumentNodeSchedule;
});

// /home/mous/work/pimlico/alto/src/node_modules/@sentry/node/cjs/index.js
var require_cjs4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_cjs2();
  var index = require_tracing2();
  var client = require_client();
  var http = require_http();
  var sdk = require_sdk2();
  var utils = require_cjs();
  var utils$1 = require_utils4();
  var module$1 = require_module();
  var legacy = require_legacy();
  var handlers = require_handlers();
  var index$5 = require_integrations2();
  var integrations = require_integrations3();
  var console2 = require_console2();
  var onuncaughtexception = require_onuncaughtexception();
  var onunhandledrejection = require_onunhandledrejection();
  var modules = require_modules();
  var contextlines = require_contextlines();
  var context = require_context();
  var index$1 = require_local_variables();
  var spotlight = require_spotlight();
  var index$2 = require_anr2();
  var index$3 = require_hapi();
  var index$4 = require_undici();
  var http$1 = require_http3();
  var cron$1 = require_cron();
  var nodeCron = require_node_cron();
  var nodeSchedule = require_node_schedule();
  var getModuleFromFilename = module$1.createGetModuleFromFilename();
  var Integrations = {
    ...core.Integrations,
    ...index$5,
    ...integrations
  };
  var cron = {
    instrumentCron: cron$1.instrumentCron,
    instrumentNodeCron: nodeCron.instrumentNodeCron,
    instrumentNodeSchedule: nodeSchedule.instrumentNodeSchedule
  };
  exports.Hub = core.Hub;
  exports.SDK_VERSION = core.SDK_VERSION;
  exports.Scope = core.Scope;
  exports.addBreadcrumb = core.addBreadcrumb;
  exports.addEventProcessor = core.addEventProcessor;
  exports.addGlobalEventProcessor = core.addGlobalEventProcessor;
  exports.addIntegration = core.addIntegration;
  exports.captureCheckIn = core.captureCheckIn;
  exports.captureEvent = core.captureEvent;
  exports.captureException = core.captureException;
  exports.captureMessage = core.captureMessage;
  exports.close = core.close;
  exports.configureScope = core.configureScope;
  exports.continueTrace = core.continueTrace;
  exports.createTransport = core.createTransport;
  exports.extractTraceparentData = core.extractTraceparentData;
  exports.flush = core.flush;
  exports.functionToStringIntegration = core.functionToStringIntegration;
  exports.getActiveSpan = core.getActiveSpan;
  exports.getActiveTransaction = core.getActiveTransaction;
  exports.getClient = core.getClient;
  exports.getCurrentHub = core.getCurrentHub;
  exports.getCurrentScope = core.getCurrentScope;
  exports.getGlobalScope = core.getGlobalScope;
  exports.getHubFromCarrier = core.getHubFromCarrier;
  exports.getIsolationScope = core.getIsolationScope;
  exports.getSpanStatusFromHttpCode = core.getSpanStatusFromHttpCode;
  exports.inboundFiltersIntegration = core.inboundFiltersIntegration;
  exports.isInitialized = core.isInitialized;
  exports.lastEventId = core.lastEventId;
  exports.linkedErrorsIntegration = core.linkedErrorsIntegration;
  exports.makeMain = core.makeMain;
  exports.metrics = core.metrics;
  exports.parameterize = core.parameterize;
  exports.requestDataIntegration = core.requestDataIntegration;
  exports.runWithAsyncContext = core.runWithAsyncContext;
  exports.setContext = core.setContext;
  exports.setCurrentClient = core.setCurrentClient;
  exports.setExtra = core.setExtra;
  exports.setExtras = core.setExtras;
  exports.setHttpStatus = core.setHttpStatus;
  exports.setMeasurement = core.setMeasurement;
  exports.setTag = core.setTag;
  exports.setTags = core.setTags;
  exports.setUser = core.setUser;
  exports.spanStatusfromHttpCode = core.spanStatusfromHttpCode;
  exports.startActiveSpan = core.startActiveSpan;
  exports.startInactiveSpan = core.startInactiveSpan;
  exports.startSpan = core.startSpan;
  exports.startSpanManual = core.startSpanManual;
  exports.startTransaction = core.startTransaction;
  exports.trace = core.trace;
  exports.withIsolationScope = core.withIsolationScope;
  exports.withMonitor = core.withMonitor;
  exports.withScope = core.withScope;
  exports.autoDiscoverNodePerformanceMonitoringIntegrations = index.autoDiscoverNodePerformanceMonitoringIntegrations;
  exports.NodeClient = client.NodeClient;
  exports.makeNodeTransport = http.makeNodeTransport;
  exports.defaultIntegrations = sdk.defaultIntegrations;
  exports.defaultStackParser = sdk.defaultStackParser;
  exports.getDefaultIntegrations = sdk.getDefaultIntegrations;
  exports.getSentryRelease = sdk.getSentryRelease;
  exports.init = sdk.init;
  exports.DEFAULT_USER_INCLUDES = utils.DEFAULT_USER_INCLUDES;
  exports.addRequestDataToEvent = utils.addRequestDataToEvent;
  exports.extractRequestData = utils.extractRequestData;
  exports.deepReadDirSync = utils$1.deepReadDirSync;
  exports.createGetModuleFromFilename = module$1.createGetModuleFromFilename;
  exports.enableAnrDetection = legacy.enableAnrDetection;
  exports.Handlers = handlers;
  exports.consoleIntegration = console2.consoleIntegration;
  exports.onUncaughtExceptionIntegration = onuncaughtexception.onUncaughtExceptionIntegration;
  exports.onUnhandledRejectionIntegration = onunhandledrejection.onUnhandledRejectionIntegration;
  exports.modulesIntegration = modules.modulesIntegration;
  exports.contextLinesIntegration = contextlines.contextLinesIntegration;
  exports.nodeContextIntegration = context.nodeContextIntegration;
  exports.localVariablesIntegration = index$1.localVariablesIntegration;
  exports.spotlightIntegration = spotlight.spotlightIntegration;
  exports.anrIntegration = index$2.anrIntegration;
  exports.hapiErrorPlugin = index$3.hapiErrorPlugin;
  exports.hapiIntegration = index$3.hapiIntegration;
  exports.Undici = index$4.Undici;
  exports.nativeNodeFetchintegration = index$4.nativeNodeFetchintegration;
  exports.Http = http$1.Http;
  exports.httpIntegration = http$1.httpIntegration;
  exports.Integrations = Integrations;
  exports.cron = cron;
  exports.getModuleFromFilename = getModuleFromFilename;
});

// ../node_modules/.pnpm/dotenv@16.4.1/node_modules/dotenv/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "dotenv",
    version: "16.4.1",
    description: "Loads environment variables from .env file",
    main: "lib/main.js",
    types: "lib/main.d.ts",
    exports: {
      ".": {
        types: "./lib/main.d.ts",
        require: "./lib/main.js",
        default: "./lib/main.js"
      },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json"
    },
    scripts: {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      "lint-readme": "standard-markdown",
      pretest: "npm run lint && npm run dts-check",
      test: "tap tests/*.js --100 -Rspec",
      prerelease: "npm test",
      release: "standard-version"
    },
    repository: {
      type: "git",
      url: "git://github.com/motdotla/dotenv.git"
    },
    funding: "https://github.com/motdotla/dotenv?sponsor=1",
    keywords: [
      "dotenv",
      "env",
      ".env",
      "environment",
      "variables",
      "config",
      "settings"
    ],
    readmeFilename: "README.md",
    license: "BSD-2-Clause",
    devDependencies: {
      "@definitelytyped/dtslint": "^0.0.133",
      "@types/node": "^18.11.3",
      decache: "^4.6.1",
      sinon: "^14.0.1",
      standard: "^17.0.0",
      "standard-markdown": "^7.1.0",
      "standard-version": "^9.5.0",
      tap: "^16.3.0",
      tar: "^6.1.11",
      typescript: "^4.8.4"
    },
    engines: {
      node: ">=12"
    },
    browser: {
      fs: false
    }
  };
});

// /home/mous/work/pimlico/alto/src/node_modules/dotenv/lib/main.js
var require_main = __commonJS((exports, module) => {
  var parse = function(src) {
    const obj = {};
    let lines = src.toString();
    lines = lines.replace(/\r\n?/mg, "\n");
    let match;
    while ((match = LINE.exec(lines)) != null) {
      const key = match[1];
      let value = match[2] || "";
      value = value.trim();
      const maybeQuote = value[0];
      value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value = value.replace(/\\n/g, "\n");
        value = value.replace(/\\r/g, "\r");
      }
      obj[key] = value;
    }
    return obj;
  };
  var _parseVault = function(options) {
    const vaultPath = _vaultPath(options);
    const result = DotenvModule.configDotenv({ path: vaultPath });
    if (!result.parsed) {
      const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      err.code = "MISSING_DATA";
      throw err;
    }
    const keys = _dotenvKey(options).split(",");
    const length = keys.length;
    let decrypted;
    for (let i = 0;i < length; i++) {
      try {
        const key = keys[i].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error) {
        if (i + 1 >= length) {
          throw error;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  };
  var _log = function(message) {
    console.log(`[dotenv@${version}][INFO] ${message}`);
  };
  var _warn = function(message) {
    console.log(`[dotenv@${version}][WARN] ${message}`);
  };
  var _debug = function(message) {
    console.log(`[dotenv@${version}][DEBUG] ${message}`);
  };
  var _dotenvKey = function(options) {
    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
      return options.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  };
  var _instructions = function(result, dotenvKey) {
    let uri;
    try {
      uri = new URL(dotenvKey);
    } catch (error) {
      if (error.code === "ERR_INVALID_URL") {
        const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=development");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      throw error;
    }
    const key = uri.password;
    if (!key) {
      const err = new Error("INVALID_DOTENV_KEY: Missing key part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environment = uri.searchParams.get("environment");
    if (!environment) {
      const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
      throw err;
    }
    return { ciphertext, key };
  };
  var _vaultPath = function(options) {
    let possibleVaultPath = null;
    if (options && options.path && options.path.length > 0) {
      if (Array.isArray(options.path)) {
        for (const filepath of options.path) {
          if (fs.existsSync(filepath)) {
            possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
          }
        }
      } else {
        possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
      }
    } else {
      possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
    }
    if (fs.existsSync(possibleVaultPath)) {
      return possibleVaultPath;
    }
    return null;
  };
  var _resolveHome = function(envPath) {
    return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
  };
  var _configVault = function(options) {
    _log("Loading env from encrypted .env.vault");
    const parsed = DotenvModule._parseVault(options);
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options);
    return { parsed };
  };
  var configDotenv = function(options) {
    let dotenvPath = path.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    const debug = Boolean(options && options.debug);
    if (options) {
      if (options.path != null) {
        let envPath = options.path;
        if (Array.isArray(envPath)) {
          for (const filepath of options.path) {
            if (fs.existsSync(filepath)) {
              envPath = filepath;
              break;
            }
          }
        }
        dotenvPath = _resolveHome(envPath);
      }
      if (options.encoding != null) {
        encoding = options.encoding;
      } else {
        if (debug) {
          _debug("No encoding is specified. UTF-8 is used by default");
        }
      }
    }
    try {
      const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, { encoding }));
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    } catch (e) {
      if (debug) {
        _debug(`Failed to load ${dotenvPath} ${e.message}`);
      }
      return { error: e };
    }
  };
  var config = function(options) {
    if (_dotenvKey(options).length === 0) {
      return DotenvModule.configDotenv(options);
    }
    const vaultPath = _vaultPath(options);
    if (!vaultPath) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options);
    }
    return DotenvModule._configVault(options);
  };
  var decrypt = function(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
      const aesgcm = crypto.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error) {
      const isRange = error instanceof RangeError;
      const invalidKeyLength = error.message === "Invalid key length";
      const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      } else if (decryptionFailed) {
        const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        err.code = "DECRYPTION_FAILED";
        throw err;
      } else {
        throw error;
      }
    }
  };
  var populate = function(processEnv, parsed, options = {}) {
    const debug = Boolean(options && options.debug);
    const override = Boolean(options && options.override);
    if (typeof parsed !== "object") {
      const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      err.code = "OBJECT_REQUIRED";
      throw err;
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
        }
        if (debug) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
      }
    }
  };
  var fs = __require("fs");
  var path = __require("path");
  var os = __require("os");
  var crypto = __require("crypto");
  var packageJson = require_package();
  var version = packageJson.version;
  var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  var DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config,
    decrypt,
    parse,
    populate
  };
  exports.configDotenv = DotenvModule.configDotenv;
  exports._configVault = DotenvModule._configVault;
  exports._parseVault = DotenvModule._parseVault;
  exports.config = DotenvModule.config;
  exports.decrypt = DotenvModule.decrypt;
  exports.parse = DotenvModule.parse;
  exports.populate = DotenvModule.populate;
  module.exports = DotenvModule;
});

// ../node_modules/.pnpm/abitype@0.9.8_typescript@5.3.3_zod@3.22.4/node_modules/abitype/dist/esm/regex.js
function execTyped(regex, string) {
  const match = regex.exec(string);
  return match?.groups;
}
var init_regex = __esm(() => {
});

// ../node_modules/.pnpm/abitype@0.9.8_typescript@5.3.3_zod@3.22.4/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js
function formatAbiParameter(abiParameter) {
  let type = abiParameter.type;
  if (tupleRegex.test(abiParameter.type) && "components" in abiParameter) {
    type = "(";
    const length = abiParameter.components.length;
    for (let i = 0;i < length; i++) {
      const component = abiParameter.components[i];
      type += formatAbiParameter(component);
      if (i < length - 1)
        type += ", ";
    }
    const result = execTyped(tupleRegex, abiParameter.type);
    type += `)${result?.array ?? ""}`;
    return formatAbiParameter({
      ...abiParameter,
      type
    });
  }
  if ("indexed" in abiParameter && abiParameter.indexed)
    type = `${type} indexed`;
  if (abiParameter.name)
    return `${type} ${abiParameter.name}`;
  return type;
}
var tupleRegex;
var init_formatAbiParameter = __esm(() => {
  init_regex();
  tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
});

// ../node_modules/.pnpm/abitype@0.9.8_typescript@5.3.3_zod@3.22.4/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js
function formatAbiParameters(abiParameters) {
  let params = "";
  const length = abiParameters.length;
  for (let i = 0;i < length; i++) {
    const abiParameter = abiParameters[i];
    params += formatAbiParameter(abiParameter);
    if (i !== length - 1)
      params += ", ";
  }
  return params;
}
var init_formatAbiParameters = __esm(() => {
  init_formatAbiParameter();
});

// ../node_modules/.pnpm/abitype@0.9.8_typescript@5.3.3_zod@3.22.4/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js
function formatAbiItem(abiItem) {
  if (abiItem.type === "function")
    return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== "nonpayable" ? ` ${abiItem.stateMutability}` : ""}${abiItem.outputs.length ? ` returns (${formatAbiParameters(abiItem.outputs)})` : ""}`;
  else if (abiItem.type === "event")
    return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  else if (abiItem.type === "error")
    return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  else if (abiItem.type === "constructor")
    return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === "payable" ? " payable" : ""}`;
  else if (abiItem.type === "fallback")
    return "fallback()";
  return "receive() external payable";
}
var init_formatAbiItem = __esm(() => {
  init_formatAbiParameters();
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/abitype/dist/esm/index.js
var init_esm = __esm(() => {
  init_formatAbiItem();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/abi/formatAbiItem.js
function formatAbiItem2(abiItem, { includeName = false } = {}) {
  if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
    throw new InvalidDefinitionTypeError(abiItem.type);
  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
}
function formatAbiParams(params, { includeName = false } = {}) {
  if (!params)
    return "";
  return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? ", " : ",");
}
var formatAbiParam;
var init_formatAbiItem2 = __esm(() => {
  init_abi();
  formatAbiParam = function(param, { includeName }) {
    if (param.type.startsWith("tuple")) {
      return `(${formatAbiParams(param.components, { includeName })})${param.type.slice("tuple".length)}`;
    }
    return param.type + (includeName && param.name ? ` ${param.name}` : "");
  };
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/data/isHex.js
function isHex(value, { strict = true } = {}) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}
var init_isHex = __esm(() => {
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/data/size.js
function size(value) {
  if (isHex(value, { strict: false }))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}
var init_size = __esm(() => {
  init_isHex();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/version.js
var version;
var init_version = __esm(() => {
  version = "1.21.3";
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/utils.js
var getContractAddress, getUrl, getVersion;
var init_utils = __esm(() => {
  init_version();
  getContractAddress = (address) => address;
  getUrl = (url) => url;
  getVersion = () => `viem@${version}`;
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/base.js
class BaseError extends Error {
  constructor(shortMessage, args = {}) {
    super();
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ViemError"
    });
    Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: getVersion()
    });
    const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
    const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
    this.message = [
      shortMessage || "An error occurred.",
      "",
      ...args.metaMessages ? [...args.metaMessages, ""] : [],
      ...docsPath ? [
        `Docs: https://viem.sh${docsPath}.html${args.docsSlug ? `#${args.docsSlug}` : ""}`
      ] : [],
      ...details ? [`Details: ${details}`] : [],
      `Version: ${this.version}`
    ].join("\n");
    if (args.cause)
      this.cause = args.cause;
    this.details = details;
    this.docsPath = docsPath;
    this.metaMessages = args.metaMessages;
    this.shortMessage = shortMessage;
  }
  walk(fn) {
    return walk(this, fn);
  }
}
var walk;
var init_base = __esm(() => {
  init_utils();
  walk = function(err, fn) {
    if (fn?.(err))
      return err;
    if (err && typeof err === "object" && "cause" in err)
      return walk(err.cause, fn);
    return fn ? null : err;
  };
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/abi.js
class AbiConstructorNotFoundError extends BaseError {
  constructor({ docsPath }) {
    super([
      "A constructor was not found on the ABI.",
      "Make sure you are using the correct ABI and that the constructor exists on it."
    ].join("\n"), {
      docsPath
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiConstructorNotFoundError"
    });
  }
}

class AbiConstructorParamsNotFoundError extends BaseError {
  constructor({ docsPath }) {
    super([
      "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
      "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
    ].join("\n"), {
      docsPath
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiConstructorParamsNotFoundError"
    });
  }
}

class AbiDecodingDataSizeTooSmallError extends BaseError {
  constructor({ data, params, size: size3 }) {
    super([`Data size of ${size3} bytes is too small for given parameters.`].join("\n"), {
      metaMessages: [
        `Params: (${formatAbiParams(params, { includeName: true })})`,
        `Data:   ${data} (${size3} bytes)`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiDecodingDataSizeTooSmallError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "params", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "size", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.data = data;
    this.params = params;
    this.size = size3;
  }
}

class AbiDecodingZeroDataError extends BaseError {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.');
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiDecodingZeroDataError"
    });
  }
}

class AbiEncodingArrayLengthMismatchError extends BaseError {
  constructor({ expectedLength, givenLength, type }) {
    super([
      `ABI encoding array length mismatch for type ${type}.`,
      `Expected length: ${expectedLength}`,
      `Given length: ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEncodingArrayLengthMismatchError"
    });
  }
}

class AbiEncodingBytesSizeMismatchError extends BaseError {
  constructor({ expectedSize, value }) {
    super(`Size of bytes "${value}" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEncodingBytesSizeMismatchError"
    });
  }
}

class AbiEncodingLengthMismatchError extends BaseError {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEncodingLengthMismatchError"
    });
  }
}

class AbiErrorSignatureNotFoundError extends BaseError {
  constructor(signature, { docsPath }) {
    super([
      `Encoded error signature "${signature}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
    ].join("\n"), {
      docsPath
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiErrorSignatureNotFoundError"
    });
    Object.defineProperty(this, "signature", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.signature = signature;
  }
}

class AbiEventSignatureEmptyTopicsError extends BaseError {
  constructor({ docsPath }) {
    super("Cannot extract event signature from empty topics.", {
      docsPath
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEventSignatureEmptyTopicsError"
    });
  }
}

class AbiEventSignatureNotFoundError extends BaseError {
  constructor(signature, { docsPath }) {
    super([
      `Encoded event signature "${signature}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it.",
      `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
    ].join("\n"), {
      docsPath
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEventSignatureNotFoundError"
    });
  }
}

class AbiEventNotFoundError extends BaseError {
  constructor(eventName, { docsPath } = {}) {
    super([
      `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it."
    ].join("\n"), {
      docsPath
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEventNotFoundError"
    });
  }
}

class AbiFunctionNotFoundError extends BaseError {
  constructor(functionName, { docsPath } = {}) {
    super([
      `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join("\n"), {
      docsPath
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiFunctionNotFoundError"
    });
  }
}

class AbiFunctionOutputsNotFoundError extends BaseError {
  constructor(functionName, { docsPath }) {
    super([
      `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
      "Cannot decode function result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join("\n"), {
      docsPath
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiFunctionOutputsNotFoundError"
    });
  }
}

class AbiFunctionSignatureNotFoundError extends BaseError {
  constructor(signature, { docsPath }) {
    super([
      `Encoded function signature "${signature}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it.",
      `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
    ].join("\n"), {
      docsPath
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiFunctionSignatureNotFoundError"
    });
  }
}

class AbiItemAmbiguityError extends BaseError {
  constructor(x, y) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${x.type}\` in \`${formatAbiItem2(x.abiItem)}\`, and`,
        `\`${y.type}\` in \`${formatAbiItem2(y.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiItemAmbiguityError"
    });
  }
}

class BytesSizeMismatchError extends BaseError {
  constructor({ expectedSize, givenSize }) {
    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BytesSizeMismatchError"
    });
  }
}

class DecodeLogDataMismatch extends BaseError {
  constructor({ abiItem, data, params, size: size3 }) {
    super([
      `Data size of ${size3} bytes is too small for non-indexed event parameters.`
    ].join("\n"), {
      metaMessages: [
        `Params: (${formatAbiParams(params, { includeName: true })})`,
        `Data:   ${data} (${size3} bytes)`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "DecodeLogDataMismatch"
    });
    Object.defineProperty(this, "abiItem", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "params", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "size", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.abiItem = abiItem;
    this.data = data;
    this.params = params;
    this.size = size3;
  }
}

class DecodeLogTopicsMismatch extends BaseError {
  constructor({ abiItem, param }) {
    super([
      `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${formatAbiItem2(abiItem, { includeName: true })}".`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "DecodeLogTopicsMismatch"
    });
    Object.defineProperty(this, "abiItem", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.abiItem = abiItem;
  }
}

class InvalidAbiEncodingTypeError extends BaseError {
  constructor(type, { docsPath }) {
    super([
      `Type "${type}" is not a valid encoding type.`,
      "Please provide a valid ABI type."
    ].join("\n"), { docsPath });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAbiEncodingType"
    });
  }
}

class InvalidAbiDecodingTypeError extends BaseError {
  constructor(type, { docsPath }) {
    super([
      `Type "${type}" is not a valid decoding type.`,
      "Please provide a valid ABI type."
    ].join("\n"), { docsPath });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAbiDecodingType"
    });
  }
}

class InvalidArrayError extends BaseError {
  constructor(value) {
    super([`Value "${value}" is not a valid array.`].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidArrayError"
    });
  }
}

class InvalidDefinitionTypeError extends BaseError {
  constructor(type) {
    super([
      `"${type}" is not a valid definition type.`,
      'Valid types: "function", "event", "error"'
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidDefinitionTypeError"
    });
  }
}
var init_abi = __esm(() => {
  init_formatAbiItem2();
  init_size();
  init_base();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/data.js
class SliceOffsetOutOfBoundsError extends BaseError {
  constructor({ offset, position, size: size3 }) {
    super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size3}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SliceOffsetOutOfBoundsError"
    });
  }
}

class SizeExceedsPaddingSizeError extends BaseError {
  constructor({ size: size3, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size3}) exceeds padding size (${targetSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SizeExceedsPaddingSizeError"
    });
  }
}
var init_data = __esm(() => {
  init_base();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/data/pad.js
function pad(hexOrBytes, { dir, size: size3 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex(hexOrBytes, { dir, size: size3 });
  return padBytes(hexOrBytes, { dir, size: size3 });
}
function padHex(hex_, { dir, size: size3 = 32 } = {}) {
  if (size3 === null)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size3 * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(hex.length / 2),
      targetSize: size3,
      type: "hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size3 * 2, "0")}`;
}
function padBytes(bytes, { dir, size: size3 = 32 } = {}) {
  if (size3 === null)
    return bytes;
  if (bytes.length > size3)
    throw new SizeExceedsPaddingSizeError({
      size: bytes.length,
      targetSize: size3,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size3);
  for (let i = 0;i < size3; i++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i : size3 - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];
  }
  return paddedBytes;
}
var init_pad = __esm(() => {
  init_data();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/encoding.js
class IntegerOutOfRangeError extends BaseError {
  constructor({ max, min, signed, size: size3, value }) {
    super(`Number "${value}" is not in safe ${size3 ? `${size3 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "IntegerOutOfRangeError"
    });
  }
}

class InvalidHexBooleanError extends BaseError {
  constructor(hex) {
    super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidHexBooleanError"
    });
  }
}

class SizeOverflowError extends BaseError {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SizeOverflowError"
    });
  }
}
var init_encoding = __esm(() => {
  init_base();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/data/trim.js
function trim(hexOrBytes, { dir = "left" } = {}) {
  let data2 = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
  let sliceLength = 0;
  for (let i = 0;i < data2.length - 1; i++) {
    if (data2[dir === "left" ? i : data2.length - i - 1].toString() === "0")
      sliceLength++;
    else
      break;
  }
  data2 = dir === "left" ? data2.slice(sliceLength) : data2.slice(0, data2.length - sliceLength);
  if (typeof hexOrBytes === "string") {
    if (data2.length === 1 && dir === "right")
      data2 = `${data2}0`;
    return `0x${data2.length % 2 === 1 ? `0${data2}` : data2}`;
  }
  return data2;
}
var init_trim = __esm(() => {
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/encoding/fromHex.js
function assertSize(hexOrBytes, { size: size4 }) {
  if (size(hexOrBytes) > size4)
    throw new SizeOverflowError({
      givenSize: size(hexOrBytes),
      maxSize: size4
    });
}
function hexToBigInt(hex, opts = {}) {
  const { signed } = opts;
  if (opts.size)
    assertSize(hex, { size: opts.size });
  const value = BigInt(hex);
  if (!signed)
    return value;
  const size4 = (hex.length - 2) / 2;
  const max = (1n << BigInt(size4) * 8n - 1n) - 1n;
  if (value <= max)
    return value;
  return value - BigInt(`0x${"f".padStart(size4 * 2, "f")}`) - 1n;
}
function hexToBool(hex_, opts = {}) {
  let hex = hex_;
  if (opts.size) {
    assertSize(hex, { size: opts.size });
    hex = trim(hex);
  }
  if (trim(hex) === "0x00")
    return false;
  if (trim(hex) === "0x01")
    return true;
  throw new InvalidHexBooleanError(hex);
}
function hexToNumber(hex, opts = {}) {
  return Number(hexToBigInt(hex, opts));
}
function hexToString(hex, opts = {}) {
  let bytes = hexToBytes(hex);
  if (opts.size) {
    assertSize(bytes, { size: opts.size });
    bytes = trim(bytes, { dir: "right" });
  }
  return new TextDecoder().decode(bytes);
}
var init_fromHex = __esm(() => {
  init_encoding();
  init_size();
  init_trim();
  init_toBytes();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/encoding/toHex.js
function toHex2(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToHex(value, opts);
  if (typeof value === "string") {
    return stringToHex(value, opts);
  }
  if (typeof value === "boolean")
    return boolToHex(value, opts);
  return bytesToHex(value, opts);
}
function boolToHex(value, opts = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad(hex, { size: opts.size });
  }
  return hex;
}
function bytesToHex(value, opts = {}) {
  let string = "";
  for (let i = 0;i < value.length; i++) {
    string += hexes[value[i]];
  }
  const hex = `0x${string}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad(hex, { dir: "right", size: opts.size });
  }
  return hex;
}
function numberToHex(value_, opts = {}) {
  const { signed, size: size4 } = opts;
  const value = BigInt(value_);
  let maxValue;
  if (size4) {
    if (signed)
      maxValue = (1n << BigInt(size4) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size4) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value > maxValue || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: maxValue ? `${maxValue}${suffix}` : undefined,
      min: `${minValue}${suffix}`,
      signed,
      size: size4,
      value: `${value_}${suffix}`
    });
  }
  const hex = `0x${(signed && value < 0 ? (1n << BigInt(size4 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size4)
    return pad(hex, { size: size4 });
  return hex;
}
function stringToHex(value_, opts = {}) {
  const value = encoder.encode(value_);
  return bytesToHex(value, opts);
}
var hexes, encoder;
var init_toHex = __esm(() => {
  init_encoding();
  init_pad();
  init_fromHex();
  hexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
  encoder = new TextEncoder;
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/encoding/toBytes.js
function toBytes2(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToBytes(value, opts);
  if (typeof value === "boolean")
    return boolToBytes(value, opts);
  if (isHex(value))
    return hexToBytes(value, opts);
  return stringToBytes(value, opts);
}
function boolToBytes(value, opts = {}) {
  const bytes = new Uint8Array(1);
  bytes[0] = Number(value);
  if (typeof opts.size === "number") {
    assertSize(bytes, { size: opts.size });
    return pad(bytes, { size: opts.size });
  }
  return bytes;
}
function hexToBytes(hex_, opts = {}) {
  let hex = hex_;
  if (opts.size) {
    assertSize(hex, { size: opts.size });
    hex = pad(hex, { dir: "right", size: opts.size });
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes = new Uint8Array(length);
  for (let index = 0, j = 0;index < length; index++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
    if (nibbleLeft === undefined || nibbleRight === undefined) {
      throw new BaseError(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
    }
    bytes[index] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes;
}
function numberToBytes(value, opts) {
  const hex = numberToHex(value, opts);
  return hexToBytes(hex);
}
function stringToBytes(value, opts = {}) {
  const bytes = encoder2.encode(value);
  if (typeof opts.size === "number") {
    assertSize(bytes, { size: opts.size });
    return pad(bytes, { dir: "right", size: opts.size });
  }
  return bytes;
}
var charCodeToBase16, encoder2, charCodeMap;
var init_toBytes = __esm(() => {
  init_base();
  init_isHex();
  init_pad();
  init_fromHex();
  init_toHex();
  charCodeToBase16 = function(char) {
    if (char >= charCodeMap.zero && char <= charCodeMap.nine)
      return char - charCodeMap.zero;
    if (char >= charCodeMap.A && char <= charCodeMap.F)
      return char - (charCodeMap.A - 10);
    if (char >= charCodeMap.a && char <= charCodeMap.f)
      return char - (charCodeMap.a - 10);
    return;
  };
  encoder2 = new TextEncoder;
  charCodeMap = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
  };
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/hash/normalizeSignature.js
function normalizeSignature(signature) {
  let active = true;
  let current = "";
  let level = 0;
  let result = "";
  let valid = false;
  for (let i = 0;i < signature.length; i++) {
    const char = signature[i];
    if (["(", ")", ","].includes(char))
      active = true;
    if (char === "(")
      level++;
    if (char === ")")
      level--;
    if (!active)
      continue;
    if (level === 0) {
      if (char === " " && ["event", "function", ""].includes(result))
        result = "";
      else {
        result += char;
        if (char === ")") {
          valid = true;
          break;
        }
      }
      continue;
    }
    if (char === " ") {
      if (signature[i - 1] !== "," && current !== "," && current !== ",(") {
        current = "";
        active = false;
      }
      continue;
    }
    result += char;
    current += char;
  }
  if (!valid)
    throw new BaseError("Unable to normalize signature.");
  return result;
}
var init_normalizeSignature = __esm(() => {
  init_base();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/hash/getFunctionSignature.js
var getFunctionSignature;
var init_getFunctionSignature = __esm(() => {
  init_esm();
  init_normalizeSignature();
  getFunctionSignature = (fn_) => {
    const fn = (() => {
      if (typeof fn_ === "string")
        return fn_;
      return formatAbiItem(fn_);
    })();
    return normalizeSignature(fn);
  };
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/hash/getEventSignature.js
var getEventSignature;
var init_getEventSignature = __esm(() => {
  init_getFunctionSignature();
  getEventSignature = (fn) => {
    return getFunctionSignature(fn);
  };
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/@scure+bip32@1.3.2/node_modules/@noble/hashes/esm/_assert.js
var number, bytes, hash, exists, output;
var init__assert = __esm(() => {
  number = function(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error(`Wrong positive integer: ${n}`);
  };
  bytes = function(b, ...lengths) {
    if (!(b instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
  };
  hash = function(hash2) {
    if (typeof hash2 !== "function" || typeof hash2.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(hash2.outputLen);
    number(hash2.blockLen);
  };
  exists = function(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  };
  output = function(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  };
});

// ../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_u64.js
var fromBig, split, U32_MASK64, _32n, rotlSH, rotlSL, rotlBH, rotlBL;
var init__u64 = __esm(() => {
  fromBig = function(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  };
  split = function(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0;i < lst.length; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  };
  U32_MASK64 = BigInt(2 ** 32 - 1);
  _32n = BigInt(32);
  rotlSH = (h, l, s) => h << s | l >>> 32 - s;
  rotlSL = (h, l, s) => l << s | h >>> 32 - s;
  rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
  rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
});

// ../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/cryptoNode.js
import * as nc from "node:crypto";
var crypto;
var init_cryptoNode = __esm(() => {
  crypto = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : undefined;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/@scure+bip32@1.3.2/node_modules/@noble/hashes/esm/utils.js
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes3(data2) {
  if (typeof data2 === "string")
    data2 = utf8ToBytes(data2);
  if (!u8a(data2))
    throw new Error(`expected Uint8Array, got ${typeof data2}`);
  return data2;
}
function concatBytes(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad4 = 0;
  arrays.forEach((a) => {
    if (!u8a(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad4);
    pad4 += a.length;
  });
  return r;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes3(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes3(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto && typeof crypto.getRandomValues === "function") {
    return crypto.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

class Hash {
  clone() {
    return this._cloneInto();
  }
}
var u8a, u32, createView, rotr, isLE, toStr;
var init_utils2 = __esm(() => {
  init_cryptoNode();
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  u8a = (a) => a instanceof Uint8Array;
  u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  rotr = (word, shift) => word << 32 - shift | word >>> shift;
  isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!isLE)
    throw new Error("Non little-endian hardware is not supported");
  toStr = {}.toString;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/@noble/hashes/esm/sha3.js
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds;round < 24; round++) {
    for (let x = 0;x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0;x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0;y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0;t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0;y < 50; y += 10) {
      for (let x = 0;x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0;x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}

class Keccak extends Hash {
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data2) {
    exists(this);
    const { blockLen, state } = this;
    data2 = toBytes3(data2);
    const len = data2.length;
    for (let pos = 0;pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0;i < take; i++)
        state[this.pos++] ^= data2[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length;pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
var SHA3_PI, SHA3_ROTL, _SHA3_IOTA, _0n, _1n, _2n, _7n, _256n, _0x71n, SHA3_IOTA_H, SHA3_IOTA_L, rotlH, rotlL, gen, sha3_224, sha3_256, sha3_384, sha3_512, keccak_224, keccak_256, keccak_384, keccak_512, genShake, shake128, shake256;
var init_sha3 = __esm(() => {
  init__assert();
  init__u64();
  init_utils2();
  [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
  _0n = BigInt(0);
  _1n = BigInt(1);
  _2n = BigInt(2);
  _7n = BigInt(7);
  _256n = BigInt(256);
  _0x71n = BigInt(113);
  for (let round = 0, R = _1n, x = 1, y = 0;round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n;
    for (let j = 0;j < 7; j++) {
      R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n)
        t ^= _1n << (_1n << BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
  }
  [SHA3_IOTA_H, SHA3_IOTA_L] = split(_SHA3_IOTA, true);
  rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
  rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
  gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
  sha3_224 = gen(6, 144, 224 / 8);
  sha3_256 = gen(6, 136, 256 / 8);
  sha3_384 = gen(6, 104, 384 / 8);
  sha3_512 = gen(6, 72, 512 / 8);
  keccak_224 = gen(1, 144, 224 / 8);
  keccak_256 = gen(1, 136, 256 / 8);
  keccak_384 = gen(1, 104, 384 / 8);
  keccak_512 = gen(1, 72, 512 / 8);
  genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
  shake128 = genShake(31, 168, 128 / 8);
  shake256 = genShake(31, 136, 256 / 8);
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/hash/keccak256.js
function keccak256(value, to_) {
  const to = to_ || "hex";
  const bytes2 = keccak_256(isHex(value, { strict: false }) ? toBytes2(value) : value);
  if (to === "bytes")
    return bytes2;
  return toHex2(bytes2);
}
var init_keccak256 = __esm(() => {
  init_sha3();
  init_isHex();
  init_toBytes();
  init_toHex();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/hash/getEventSelector.js
var hash2, getEventSelector;
var init_getEventSelector = __esm(() => {
  init_toBytes();
  init_getEventSignature();
  init_keccak256();
  hash2 = (value) => keccak256(toBytes2(value));
  getEventSelector = (fn) => hash2(getEventSignature(fn));
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/address.js
class InvalidAddressError extends BaseError {
  constructor({ address }) {
    super(`Address "${address}" is invalid.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAddressError"
    });
  }
}
var init_address = __esm(() => {
  init_base();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/address/isAddress.js
function isAddress(address) {
  return addressRegex.test(address);
}
var addressRegex;
var init_isAddress = __esm(() => {
  addressRegex = /^0x[a-fA-F0-9]{40}$/;
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/data/concat.js
function concat(values) {
  if (typeof values[0] === "string")
    return concatHex(values);
  return concatBytes2(values);
}
function concatBytes2(values) {
  let length = 0;
  for (const arr of values) {
    length += arr.length;
  }
  const result = new Uint8Array(length);
  let offset = 0;
  for (const arr of values) {
    result.set(arr, offset);
    offset += arr.length;
  }
  return result;
}
function concatHex(values) {
  return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
}
var init_concat = __esm(() => {
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/data/slice.js
function slice(value, start, end, { strict } = {}) {
  if (isHex(value, { strict: false }))
    return sliceHex(value, start, end, {
      strict
    });
  return sliceBytes(value, start, end, {
    strict
  });
}
function sliceBytes(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = value_.slice(start, end);
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
function sliceHex(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
var assertStartOffset, assertEndOffset;
var init_slice = __esm(() => {
  init_data();
  init_isHex();
  init_size();
  assertStartOffset = function(value, start) {
    if (typeof start === "number" && start > 0 && start > size(value) - 1)
      throw new SliceOffsetOutOfBoundsError({
        offset: start,
        position: "start",
        size: size(value)
      });
  };
  assertEndOffset = function(value, start, end) {
    if (typeof start === "number" && typeof end === "number" && size(value) !== end - start) {
      throw new SliceOffsetOutOfBoundsError({
        offset: end,
        position: "end",
        size: size(value)
      });
    }
  };
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/abi/encodeAbiParameters.js
function encodeAbiParameters(params, values) {
  if (params.length !== values.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: params.length,
      givenLength: values.length
    });
  const preparedParams = prepareParams({
    params,
    values
  });
  const data3 = encodeParams(preparedParams);
  if (data3.length === 0)
    return "0x";
  return data3;
}
function getArrayComponents(type) {
  const matches = type.match(/^(.*)\[(\d+)?\]$/);
  return matches ? [matches[2] ? Number(matches[2]) : null, matches[1]] : undefined;
}
var prepareParams, prepareParam, encodeParams, encodeAddress, encodeArray, encodeBytes, encodeBool, encodeNumber, encodeString, encodeTuple;
var init_encodeAbiParameters = __esm(() => {
  init_abi();
  init_address();
  init_isAddress();
  init_concat();
  init_pad();
  init_size();
  init_slice();
  init_toHex();
  prepareParams = function({ params, values }) {
    const preparedParams = [];
    for (let i = 0;i < params.length; i++) {
      preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
    }
    return preparedParams;
  };
  prepareParam = function({ param, value }) {
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents) {
      const [length, type] = arrayComponents;
      return encodeArray(value, { length, param: { ...param, type } });
    }
    if (param.type === "tuple") {
      return encodeTuple(value, {
        param
      });
    }
    if (param.type === "address") {
      return encodeAddress(value);
    }
    if (param.type === "bool") {
      return encodeBool(value);
    }
    if (param.type.startsWith("uint") || param.type.startsWith("int")) {
      const signed = param.type.startsWith("int");
      return encodeNumber(value, { signed });
    }
    if (param.type.startsWith("bytes")) {
      return encodeBytes(value, { param });
    }
    if (param.type === "string") {
      return encodeString(value);
    }
    throw new InvalidAbiEncodingTypeError(param.type, {
      docsPath: "/docs/contract/encodeAbiParameters"
    });
  };
  encodeParams = function(preparedParams) {
    let staticSize = 0;
    for (let i = 0;i < preparedParams.length; i++) {
      const { dynamic, encoded } = preparedParams[i];
      if (dynamic)
        staticSize += 32;
      else
        staticSize += size(encoded);
    }
    const staticParams = [];
    const dynamicParams = [];
    let dynamicSize = 0;
    for (let i = 0;i < preparedParams.length; i++) {
      const { dynamic, encoded } = preparedParams[i];
      if (dynamic) {
        staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));
        dynamicParams.push(encoded);
        dynamicSize += size(encoded);
      } else {
        staticParams.push(encoded);
      }
    }
    return concat([...staticParams, ...dynamicParams]);
  };
  encodeAddress = function(value) {
    if (!isAddress(value))
      throw new InvalidAddressError({ address: value });
    return { dynamic: false, encoded: padHex(value.toLowerCase()) };
  };
  encodeArray = function(value, { length, param }) {
    const dynamic = length === null;
    if (!Array.isArray(value))
      throw new InvalidArrayError(value);
    if (!dynamic && value.length !== length)
      throw new AbiEncodingArrayLengthMismatchError({
        expectedLength: length,
        givenLength: value.length,
        type: `${param.type}[${length}]`
      });
    let dynamicChild = false;
    const preparedParams = [];
    for (let i = 0;i < value.length; i++) {
      const preparedParam = prepareParam({ param, value: value[i] });
      if (preparedParam.dynamic)
        dynamicChild = true;
      preparedParams.push(preparedParam);
    }
    if (dynamic || dynamicChild) {
      const data3 = encodeParams(preparedParams);
      if (dynamic) {
        const length2 = numberToHex(preparedParams.length, { size: 32 });
        return {
          dynamic: true,
          encoded: preparedParams.length > 0 ? concat([length2, data3]) : length2
        };
      }
      if (dynamicChild)
        return { dynamic: true, encoded: data3 };
    }
    return {
      dynamic: false,
      encoded: concat(preparedParams.map(({ encoded }) => encoded))
    };
  };
  encodeBytes = function(value, { param }) {
    const [, paramSize] = param.type.split("bytes");
    const bytesSize = size(value);
    if (!paramSize) {
      let value_ = value;
      if (bytesSize % 32 !== 0)
        value_ = padHex(value_, {
          dir: "right",
          size: Math.ceil((value.length - 2) / 2 / 32) * 32
        });
      return {
        dynamic: true,
        encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_])
      };
    }
    if (bytesSize !== parseInt(paramSize))
      throw new AbiEncodingBytesSizeMismatchError({
        expectedSize: parseInt(paramSize),
        value
      });
    return { dynamic: false, encoded: padHex(value, { dir: "right" }) };
  };
  encodeBool = function(value) {
    return { dynamic: false, encoded: padHex(boolToHex(value)) };
  };
  encodeNumber = function(value, { signed }) {
    return {
      dynamic: false,
      encoded: numberToHex(value, {
        size: 32,
        signed
      })
    };
  };
  encodeString = function(value) {
    const hexValue = stringToHex(value);
    const partsLength = Math.ceil(size(hexValue) / 32);
    const parts = [];
    for (let i = 0;i < partsLength; i++) {
      parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {
        dir: "right"
      }));
    }
    return {
      dynamic: true,
      encoded: concat([
        padHex(numberToHex(size(hexValue), { size: 32 })),
        ...parts
      ])
    };
  };
  encodeTuple = function(value, { param }) {
    let dynamic = false;
    const preparedParams = [];
    for (let i = 0;i < param.components.length; i++) {
      const param_ = param.components[i];
      const index = Array.isArray(value) ? i : param_.name;
      const preparedParam = prepareParam({
        param: param_,
        value: value[index]
      });
      preparedParams.push(preparedParam);
      if (preparedParam.dynamic)
        dynamic = true;
    }
    return {
      dynamic,
      encoded: dynamic ? encodeParams(preparedParams) : concat(preparedParams.map(({ encoded }) => encoded))
    };
  };
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/hash/getFunctionSelector.js
var hash3, getFunctionSelector;
var init_getFunctionSelector = __esm(() => {
  init_slice();
  init_toBytes();
  init_getFunctionSignature();
  init_keccak256();
  hash3 = (value) => keccak256(toBytes2(value));
  getFunctionSelector = (fn) => slice(hash3(getFunctionSignature(fn)), 0, 4);
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/abi/getAbiItem.js
function getAbiItem({ abi: abi4, args = [], name }) {
  const isSelector = isHex(name, { strict: false });
  const abiItems = abi4.filter((abiItem) => {
    if (isSelector) {
      if (abiItem.type === "function")
        return getFunctionSelector(abiItem) === name;
      if (abiItem.type === "event")
        return getEventSelector(abiItem) === name;
      return false;
    }
    return "name" in abiItem && abiItem.name === name;
  });
  if (abiItems.length === 0)
    return;
  if (abiItems.length === 1)
    return abiItems[0];
  let matchedAbiItem = undefined;
  for (const abiItem of abiItems) {
    if (!("inputs" in abiItem))
      continue;
    if (!args || args.length === 0) {
      if (!abiItem.inputs || abiItem.inputs.length === 0)
        return abiItem;
      continue;
    }
    if (!abiItem.inputs)
      continue;
    if (abiItem.inputs.length === 0)
      continue;
    if (abiItem.inputs.length !== args.length)
      continue;
    const matched = args.every((arg, index) => {
      const abiParameter = "inputs" in abiItem && abiItem.inputs[index];
      if (!abiParameter)
        return false;
      return isArgOfType(arg, abiParameter);
    });
    if (matched) {
      if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
        const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);
        if (ambiguousTypes)
          throw new AbiItemAmbiguityError({
            abiItem,
            type: ambiguousTypes[0]
          }, {
            abiItem: matchedAbiItem,
            type: ambiguousTypes[1]
          });
      }
      matchedAbiItem = abiItem;
    }
  }
  if (matchedAbiItem)
    return matchedAbiItem;
  return abiItems[0];
}
function isArgOfType(arg, abiParameter) {
  const argType = typeof arg;
  const abiParameterType = abiParameter.type;
  switch (abiParameterType) {
    case "address":
      return isAddress(arg);
    case "bool":
      return argType === "boolean";
    case "function":
      return argType === "string";
    case "string":
      return argType === "string";
    default: {
      if (abiParameterType === "tuple" && "components" in abiParameter)
        return Object.values(abiParameter.components).every((component, index) => {
          return isArgOfType(Object.values(arg)[index], component);
        });
      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
        return argType === "number" || argType === "bigint";
      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
        return argType === "string" || arg instanceof Uint8Array;
      if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
        return Array.isArray(arg) && arg.every((x) => isArgOfType(x, {
          ...abiParameter,
          type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
        }));
      }
      return false;
    }
  }
}
function getAmbiguousTypes(sourceParameters, targetParameters, args) {
  for (const parameterIndex in sourceParameters) {
    const sourceParameter = sourceParameters[parameterIndex];
    const targetParameter = targetParameters[parameterIndex];
    if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
      return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
    const types = [sourceParameter.type, targetParameter.type];
    const ambiguous = (() => {
      if (types.includes("address") && types.includes("bytes20"))
        return true;
      if (types.includes("address") && types.includes("string"))
        return isAddress(args[parameterIndex]);
      if (types.includes("address") && types.includes("bytes"))
        return isAddress(args[parameterIndex]);
      return false;
    })();
    if (ambiguous)
      return types;
  }
  return;
}
var init_getAbiItem = __esm(() => {
  init_abi();
  init_isHex();
  init_getEventSelector();
  init_getFunctionSelector();
  init_isAddress();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/accounts/utils/parseAccount.js
function parseAccount(account) {
  if (typeof account === "string")
    return { address: account, type: "json-rpc" };
  return account;
}
var init_parseAccount = __esm(() => {
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/abi/encodeFunctionData.js
function encodeFunctionData({ abi: abi6, args, functionName }) {
  let abiItem = abi6[0];
  if (functionName) {
    abiItem = getAbiItem({
      abi: abi6,
      args,
      name: functionName
    });
    if (!abiItem)
      throw new AbiFunctionNotFoundError(functionName, {
        docsPath: "/docs/contract/encodeFunctionData"
      });
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(undefined, {
      docsPath: "/docs/contract/encodeFunctionData"
    });
  const definition = formatAbiItem2(abiItem);
  const signature = getFunctionSelector(definition);
  const data3 = "inputs" in abiItem && abiItem.inputs ? encodeAbiParameters(abiItem.inputs, args ?? []) : undefined;
  return concatHex([signature, data3 ?? "0x"]);
}
var init_encodeFunctionData = __esm(() => {
  init_abi();
  init_concat();
  init_getFunctionSelector();
  init_encodeAbiParameters();
  init_formatAbiItem2();
  init_getAbiItem();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/constants/solidity.js
var panicReasons, solidityError, solidityPanic;
var init_solidity = __esm(() => {
  panicReasons = {
    1: "An `assert` condition failed.",
    17: "Arithmic operation resulted in underflow or overflow.",
    18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
    33: "Attempted to convert to an invalid type.",
    34: "Attempted to access a storage byte array that is incorrectly encoded.",
    49: "Performed `.pop()` on an empty array",
    50: "Array index is out of bounds.",
    65: "Allocated too much memory or created an array which is too large.",
    81: "Attempted to call a zero-initialized variable of internal function type."
  };
  solidityError = {
    inputs: [
      {
        name: "message",
        type: "string"
      }
    ],
    name: "Error",
    type: "error"
  };
  solidityPanic = {
    inputs: [
      {
        name: "reason",
        type: "uint256"
      }
    ],
    name: "Panic",
    type: "error"
  };
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/address/getAddress.js
function checksumAddress(address_, chainId) {
  const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
  const hash4 = keccak256(stringToBytes(hexAddress), "bytes");
  const address3 = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
  for (let i = 0;i < 40; i += 2) {
    if (hash4[i >> 1] >> 4 >= 8 && address3[i]) {
      address3[i] = address3[i].toUpperCase();
    }
    if ((hash4[i >> 1] & 15) >= 8 && address3[i + 1]) {
      address3[i + 1] = address3[i + 1].toUpperCase();
    }
  }
  return `0x${address3.join("")}`;
}
function getAddress(address3, chainId) {
  if (!isAddress(address3))
    throw new InvalidAddressError({ address: address3 });
  return checksumAddress(address3, chainId);
}
var init_getAddress = __esm(() => {
  init_address();
  init_toBytes();
  init_keccak256();
  init_isAddress();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/abi/decodeAbiParameters.js
function decodeAbiParameters(params, data3) {
  if (data3 === "0x" && params.length > 0)
    throw new AbiDecodingZeroDataError;
  if (size(data3) && size(data3) < 32)
    throw new AbiDecodingDataSizeTooSmallError({
      data: data3,
      params,
      size: size(data3)
    });
  return decodeParams({
    data: data3,
    params
  });
}
var decodeParams, decodeParam, decodeAddress, decodeArray, decodeBool, decodeBytes, decodeNumber, decodeString, decodeTuple, hasDynamicChild;
var init_decodeAbiParameters = __esm(() => {
  init_abi();
  init_getAddress();
  init_size();
  init_slice();
  init_trim();
  init_fromHex();
  init_encodeAbiParameters();
  decodeParams = function({ data: data3, params }) {
    const decodedValues = [];
    let position = 0;
    for (let i = 0;i < params.length; i++) {
      if (position >= size(data3))
        throw new AbiDecodingDataSizeTooSmallError({
          data: data3,
          params,
          size: size(data3)
        });
      const param = params[i];
      const { consumed, value } = decodeParam({ data: data3, param, position });
      decodedValues.push(value);
      position += consumed;
    }
    return decodedValues;
  };
  decodeParam = function({ data: data3, param, position }) {
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents) {
      const [length, type] = arrayComponents;
      return decodeArray(data3, {
        length,
        param: { ...param, type },
        position
      });
    }
    if (param.type === "tuple") {
      return decodeTuple(data3, { param, position });
    }
    if (param.type === "string") {
      return decodeString(data3, { position });
    }
    if (param.type.startsWith("bytes")) {
      return decodeBytes(data3, { param, position });
    }
    const value = slice(data3, position, position + 32, { strict: true });
    if (param.type.startsWith("uint") || param.type.startsWith("int")) {
      return decodeNumber(value, { param });
    }
    if (param.type === "address") {
      return decodeAddress(value);
    }
    if (param.type === "bool") {
      return decodeBool(value);
    }
    throw new InvalidAbiDecodingTypeError(param.type, {
      docsPath: "/docs/contract/decodeAbiParameters"
    });
  };
  decodeAddress = function(value) {
    return { consumed: 32, value: checksumAddress(slice(value, -20)) };
  };
  decodeArray = function(data3, { param, length, position }) {
    if (!length) {
      const offset = hexToNumber(slice(data3, position, position + 32, { strict: true }));
      const length2 = hexToNumber(slice(data3, offset, offset + 32, { strict: true }));
      let consumed2 = 0;
      const value2 = [];
      for (let i = 0;i < length2; ++i) {
        const decodedChild = decodeParam({
          data: slice(data3, offset + 32),
          param,
          position: consumed2
        });
        consumed2 += decodedChild.consumed;
        value2.push(decodedChild.value);
      }
      return { value: value2, consumed: 32 };
    }
    if (hasDynamicChild(param)) {
      const arrayComponents = getArrayComponents(param.type);
      const dynamicChild = !arrayComponents?.[0];
      let consumed2 = 0;
      const value2 = [];
      for (let i = 0;i < length; ++i) {
        const offset = hexToNumber(slice(data3, position, position + 32, { strict: true }));
        const decodedChild = decodeParam({
          data: slice(data3, offset),
          param,
          position: dynamicChild ? consumed2 : i * 32
        });
        consumed2 += decodedChild.consumed;
        value2.push(decodedChild.value);
      }
      return { value: value2, consumed: 32 };
    }
    let consumed = 0;
    const value = [];
    for (let i = 0;i < length; ++i) {
      const decodedChild = decodeParam({
        data: data3,
        param,
        position: position + consumed
      });
      consumed += decodedChild.consumed;
      value.push(decodedChild.value);
    }
    return { value, consumed };
  };
  decodeBool = function(value) {
    return { consumed: 32, value: hexToBool(value) };
  };
  decodeBytes = function(data3, { param, position }) {
    const [_, size7] = param.type.split("bytes");
    if (!size7) {
      const offset = hexToNumber(slice(data3, position, position + 32, { strict: true }));
      const length = hexToNumber(slice(data3, offset, offset + 32, { strict: true }));
      if (length === 0)
        return { consumed: 32, value: "0x" };
      const value2 = slice(data3, offset + 32, offset + 32 + length, {
        strict: true
      });
      return { consumed: 32, value: value2 };
    }
    const value = slice(data3, position, position + parseInt(size7), {
      strict: true
    });
    return { consumed: 32, value };
  };
  decodeNumber = function(value, { param }) {
    const signed = param.type.startsWith("int");
    const size7 = parseInt(param.type.split("int")[1] || "256");
    return {
      consumed: 32,
      value: size7 > 48 ? hexToBigInt(value, { signed }) : hexToNumber(value, { signed })
    };
  };
  decodeString = function(data3, { position }) {
    const offset = hexToNumber(slice(data3, position, position + 32, { strict: true }));
    const length = hexToNumber(slice(data3, offset, offset + 32, { strict: true }));
    if (length === 0)
      return { consumed: 32, value: "" };
    const value = hexToString(trim(slice(data3, offset + 32, offset + 32 + length, { strict: true })));
    return { consumed: 32, value };
  };
  decodeTuple = function(data3, { param, position }) {
    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
    const value = hasUnnamedChild ? [] : {};
    let consumed = 0;
    if (hasDynamicChild(param)) {
      const offset = hexToNumber(slice(data3, position, position + 32, { strict: true }));
      for (let i = 0;i < param.components.length; ++i) {
        const component = param.components[i];
        const decodedChild = decodeParam({
          data: slice(data3, offset),
          param: component,
          position: consumed
        });
        consumed += decodedChild.consumed;
        value[hasUnnamedChild ? i : component?.name] = decodedChild.value;
      }
      return { consumed: 32, value };
    }
    for (let i = 0;i < param.components.length; ++i) {
      const component = param.components[i];
      const decodedChild = decodeParam({
        data: data3,
        param: component,
        position: position + consumed
      });
      consumed += decodedChild.consumed;
      value[hasUnnamedChild ? i : component?.name] = decodedChild.value;
    }
    return { consumed, value };
  };
  hasDynamicChild = function(param) {
    const { type } = param;
    if (type === "string")
      return true;
    if (type === "bytes")
      return true;
    if (type.endsWith("[]"))
      return true;
    if (type === "tuple")
      return param.components?.some(hasDynamicChild);
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents && hasDynamicChild({ ...param, type: arrayComponents[1] }))
      return true;
    return false;
  };
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/abi/decodeErrorResult.js
function decodeErrorResult({ abi: abi8, data: data3 }) {
  const signature = slice(data3, 0, 4);
  if (signature === "0x")
    throw new AbiDecodingZeroDataError;
  const abi_ = [...abi8 || [], solidityError, solidityPanic];
  const abiItem = abi_.find((x) => x.type === "error" && signature === getFunctionSelector(formatAbiItem2(x)));
  if (!abiItem)
    throw new AbiErrorSignatureNotFoundError(signature, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem,
    args: "inputs" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? decodeAbiParameters(abiItem.inputs, slice(data3, 4)) : undefined,
    errorName: abiItem.name
  };
}
var init_decodeErrorResult = __esm(() => {
  init_solidity();
  init_abi();
  init_slice();
  init_getFunctionSelector();
  init_decodeAbiParameters();
  init_formatAbiItem2();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/stringify.js
var stringify;
var init_stringify = __esm(() => {
  stringify = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
    const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
    return typeof replacer === "function" ? replacer(key, value2) : value2;
  }, space);
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/abi/formatAbiItemWithArgs.js
function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false }) {
  if (!("name" in abiItem))
    return;
  if (!("inputs" in abiItem))
    return;
  if (!abiItem.inputs)
    return;
  return `${includeFunctionName ? abiItem.name : ""}(${abiItem.inputs.map((input, i) => `${includeName && input.name ? `${input.name}: ` : ""}${typeof args[i] === "object" ? stringify(args[i]) : args[i]}`).join(", ")})`;
}
var init_formatAbiItemWithArgs = __esm(() => {
  init_stringify();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/constants/unit.js
var etherUnits, gweiUnits;
var init_unit = __esm(() => {
  etherUnits = {
    gwei: 9,
    wei: 18
  };
  gweiUnits = {
    ether: -9,
    wei: 9
  };
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/unit/formatUnits.js
function formatUnits(value, decimals) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}
var init_formatUnits = __esm(() => {
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/unit/formatEther.js
function formatEther(wei, unit2 = "wei") {
  return formatUnits(wei, etherUnits[unit2]);
}
var init_formatEther = __esm(() => {
  init_unit();
  init_formatUnits();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/unit/formatGwei.js
function formatGwei(wei, unit3 = "wei") {
  return formatUnits(wei, gweiUnits[unit3]);
}
var init_formatGwei = __esm(() => {
  init_unit();
  init_formatUnits();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/transaction.js
function prettyPrint(args) {
  const entries = Object.entries(args).map(([key, value]) => {
    if (value === undefined || value === false)
      return null;
    return [key, value];
  }).filter(Boolean);
  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
  return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
}

class FeeConflictError extends BaseError {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FeeConflictError"
    });
  }
}

class InvalidLegacyVError extends BaseError {
  constructor({ v }) {
    super(`Invalid \`v\` value "${v}". Expected 27 or 28.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidLegacyVError"
    });
  }
}

class InvalidSerializableTransactionError extends BaseError {
  constructor({ transaction }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        prettyPrint(transaction),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidSerializableTransactionError"
    });
  }
}

class InvalidStorageKeySizeError extends BaseError {
  constructor({ storageKey }) {
    super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidStorageKeySizeError"
    });
  }
}

class TransactionExecutionError extends BaseError {
  constructor(cause, { account, docsPath, chain, data: data3, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    const prettyArgs = prettyPrint({
      chain: chain && `${chain?.name} (id: ${chain?.id})`,
      from: account?.address,
      to,
      value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
      data: data3,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Request Arguments:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionExecutionError"
    });
    this.cause = cause;
  }
}

class TransactionNotFoundError extends BaseError {
  constructor({ blockHash, blockNumber, blockTag, hash: hash4, index }) {
    let identifier = "Transaction";
    if (blockTag && index !== undefined)
      identifier = `Transaction at block time "${blockTag}" at index "${index}"`;
    if (blockHash && index !== undefined)
      identifier = `Transaction at block hash "${blockHash}" at index "${index}"`;
    if (blockNumber && index !== undefined)
      identifier = `Transaction at block number "${blockNumber}" at index "${index}"`;
    if (hash4)
      identifier = `Transaction with hash "${hash4}"`;
    super(`${identifier} could not be found.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionNotFoundError"
    });
  }
}

class TransactionReceiptNotFoundError extends BaseError {
  constructor({ hash: hash4 }) {
    super(`Transaction receipt with hash "${hash4}" could not be found. The Transaction may not be processed on a block yet.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionReceiptNotFoundError"
    });
  }
}

class WaitForTransactionReceiptTimeoutError extends BaseError {
  constructor({ hash: hash4 }) {
    super(`Timed out while waiting for transaction with hash "${hash4}" to be confirmed.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WaitForTransactionReceiptTimeoutError"
    });
  }
}
var init_transaction = __esm(() => {
  init_formatEther();
  init_formatGwei();
  init_base();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/contract.js
class CallExecutionError extends BaseError {
  constructor(cause, { account: account_, docsPath, chain, data: data3, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    const account = account_ ? parseAccount(account_) : undefined;
    const prettyArgs = prettyPrint({
      from: account?.address,
      to,
      value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
      data: data3,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Raw Call Arguments:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "CallExecutionError"
    });
    this.cause = cause;
  }
}

class ContractFunctionExecutionError extends BaseError {
  constructor(cause, { abi: abi9, args, contractAddress, docsPath, functionName, sender }) {
    const abiItem = getAbiItem({ abi: abi9, args, name: functionName });
    const formattedArgs = abiItem ? formatAbiItemWithArgs({
      abiItem,
      args,
      includeFunctionName: false,
      includeName: false
    }) : undefined;
    const functionWithParams = abiItem ? formatAbiItem2(abiItem, { includeName: true }) : undefined;
    const prettyArgs = prettyPrint({
      address: contractAddress && getContractAddress(contractAddress),
      function: functionWithParams,
      args: formattedArgs && formattedArgs !== "()" && `${[...Array(functionName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}`,
      sender
    });
    super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
      cause,
      docsPath,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Contract Call:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "abi", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "args", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "contractAddress", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "formattedArgs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "functionName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "sender", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ContractFunctionExecutionError"
    });
    this.abi = abi9;
    this.args = args;
    this.cause = cause;
    this.contractAddress = contractAddress;
    this.functionName = functionName;
    this.sender = sender;
  }
}

class ContractFunctionRevertedError extends BaseError {
  constructor({ abi: abi9, data: data3, functionName, message }) {
    let cause;
    let decodedData = undefined;
    let metaMessages;
    let reason;
    if (data3 && data3 !== "0x") {
      try {
        decodedData = decodeErrorResult({ abi: abi9, data: data3 });
        const { abiItem, errorName, args: errorArgs } = decodedData;
        if (errorName === "Error") {
          reason = errorArgs[0];
        } else if (errorName === "Panic") {
          const [firstArg] = errorArgs;
          reason = panicReasons[firstArg];
        } else {
          const errorWithParams = abiItem ? formatAbiItem2(abiItem, { includeName: true }) : undefined;
          const formattedArgs = abiItem && errorArgs ? formatAbiItemWithArgs({
            abiItem,
            args: errorArgs,
            includeFunctionName: false,
            includeName: false
          }) : undefined;
          metaMessages = [
            errorWithParams ? `Error: ${errorWithParams}` : "",
            formattedArgs && formattedArgs !== "()" ? `       ${[...Array(errorName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}` : ""
          ];
        }
      } catch (err) {
        cause = err;
      }
    } else if (message)
      reason = message;
    let signature;
    if (cause instanceof AbiErrorSignatureNotFoundError) {
      signature = cause.signature;
      metaMessages = [
        `Unable to decode signature "${signature}" as it was not found on the provided ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it.",
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
      ];
    }
    super(reason && reason !== "execution reverted" || signature ? [
      `The contract function "${functionName}" reverted with the following ${signature ? "signature" : "reason"}:`,
      reason || signature
    ].join("\n") : `The contract function "${functionName}" reverted.`, {
      cause,
      metaMessages
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ContractFunctionRevertedError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "reason", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "signature", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.data = decodedData;
    this.reason = reason;
    this.signature = signature;
  }
}

class ContractFunctionZeroDataError extends BaseError {
  constructor({ functionName }) {
    super(`The contract function "${functionName}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${functionName}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ContractFunctionZeroDataError"
    });
  }
}

class RawContractError extends BaseError {
  constructor({ data: data3, message }) {
    super(message || "");
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 3
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RawContractError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.data = data3;
  }
}
var init_contract = __esm(() => {
  init_parseAccount();
  init_solidity();
  init_decodeErrorResult();
  init_formatAbiItem2();
  init_formatAbiItemWithArgs();
  init_getAbiItem();
  init_formatEther();
  init_formatGwei();
  init_abi();
  init_base();
  init_transaction();
  init_utils();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/request.js
class HttpRequestError extends BaseError {
  constructor({ body, details, headers, status, url }) {
    super("HTTP request failed.", {
      details,
      metaMessages: [
        status && `Status: ${status}`,
        `URL: ${getUrl(url)}`,
        body && `Request body: ${stringify(body)}`
      ].filter(Boolean)
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "HttpRequestError"
    });
    Object.defineProperty(this, "body", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "headers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "status", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "url", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.body = body;
    this.headers = headers;
    this.status = status;
    this.url = url;
  }
}

class WebSocketRequestError extends BaseError {
  constructor({ body, details, url }) {
    super("WebSocket request failed.", {
      details,
      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WebSocketRequestError"
    });
  }
}

class RpcRequestError extends BaseError {
  constructor({ body, error, url }) {
    super("RPC Request failed.", {
      cause: error,
      details: error.message,
      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcRequestError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.code = error.code;
  }
}

class TimeoutError extends BaseError {
  constructor({ body, url }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TimeoutError"
    });
  }
}
var init_request = __esm(() => {
  init_stringify();
  init_base();
  init_utils();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/rpc.js
class RpcError extends BaseError {
  constructor(cause, { code, docsPath, metaMessages, shortMessage }) {
    super(shortMessage, {
      cause,
      docsPath,
      metaMessages: metaMessages || cause?.metaMessages
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.name = cause.name;
    this.code = cause instanceof RpcRequestError ? cause.code : code ?? unknownErrorCode;
  }
}

class ProviderRpcError extends RpcError {
  constructor(cause, options) {
    super(cause, options);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderRpcError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.data = options.data;
  }
}

class ParseRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ParseRpcError.code,
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ParseRpcError"
    });
  }
}

class InvalidRequestRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidRequestRpcError.code,
      shortMessage: "JSON is not a valid request object."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidRequestRpcError"
    });
  }
}

class MethodNotFoundRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: MethodNotFoundRpcError.code,
      shortMessage: "The method does not exist / is not available."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "MethodNotFoundRpcError"
    });
  }
}

class InvalidParamsRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidParamsRpcError.code,
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join("\n")
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidParamsRpcError"
    });
  }
}

class InternalRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InternalRpcError.code,
      shortMessage: "An internal error was received."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InternalRpcError"
    });
  }
}

class InvalidInputRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidInputRpcError.code,
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join("\n")
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidInputRpcError"
    });
  }
}

class ResourceNotFoundRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ResourceNotFoundRpcError.code,
      shortMessage: "Requested resource not found."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ResourceNotFoundRpcError"
    });
  }
}

class ResourceUnavailableRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ResourceUnavailableRpcError.code,
      shortMessage: "Requested resource not available."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ResourceUnavailableRpcError"
    });
  }
}

class TransactionRejectedRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: TransactionRejectedRpcError.code,
      shortMessage: "Transaction creation failed."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionRejectedRpcError"
    });
  }
}

class MethodNotSupportedRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: MethodNotSupportedRpcError.code,
      shortMessage: "Method is not implemented."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "MethodNotSupportedRpcError"
    });
  }
}

class LimitExceededRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: LimitExceededRpcError.code,
      shortMessage: "Request exceeds defined limit."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "LimitExceededRpcError"
    });
  }
}

class JsonRpcVersionUnsupportedError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: JsonRpcVersionUnsupportedError.code,
      shortMessage: "Version of JSON-RPC protocol is not supported."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "JsonRpcVersionUnsupportedError"
    });
  }
}

class UserRejectedRequestError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UserRejectedRequestError.code,
      shortMessage: "User rejected the request."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UserRejectedRequestError"
    });
  }
}

class UnauthorizedProviderError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UnauthorizedProviderError.code,
      shortMessage: "The requested method and/or account has not been authorized by the user."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnauthorizedProviderError"
    });
  }
}

class UnsupportedProviderMethodError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UnsupportedProviderMethodError.code,
      shortMessage: "The Provider does not support the requested method."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnsupportedProviderMethodError"
    });
  }
}

class ProviderDisconnectedError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: ProviderDisconnectedError.code,
      shortMessage: "The Provider is disconnected from all chains."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderDisconnectedError"
    });
  }
}

class ChainDisconnectedError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: ChainDisconnectedError.code,
      shortMessage: "The Provider is not connected to the requested chain."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainDisconnectedError"
    });
  }
}

class SwitchChainError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: SwitchChainError.code,
      shortMessage: "An error occurred when attempting to switch chain."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SwitchChainError"
    });
  }
}

class UnknownRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      shortMessage: "An unknown RPC error occurred."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownRpcError"
    });
  }
}
var unknownErrorCode;
var init_rpc = __esm(() => {
  init_base();
  init_request();
  unknownErrorCode = -1;
  Object.defineProperty(ParseRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32700
  });
  Object.defineProperty(InvalidRequestRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32600
  });
  Object.defineProperty(MethodNotFoundRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32601
  });
  Object.defineProperty(InvalidParamsRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32602
  });
  Object.defineProperty(InternalRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32603
  });
  Object.defineProperty(InvalidInputRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32000
  });
  Object.defineProperty(ResourceNotFoundRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32001
  });
  Object.defineProperty(ResourceUnavailableRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32002
  });
  Object.defineProperty(TransactionRejectedRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32003
  });
  Object.defineProperty(MethodNotSupportedRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32004
  });
  Object.defineProperty(LimitExceededRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32005
  });
  Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32006
  });
  Object.defineProperty(UserRejectedRequestError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4001
  });
  Object.defineProperty(UnauthorizedProviderError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4100
  });
  Object.defineProperty(UnsupportedProviderMethodError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4200
  });
  Object.defineProperty(ProviderDisconnectedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4900
  });
  Object.defineProperty(ChainDisconnectedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4901
  });
  Object.defineProperty(SwitchChainError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4902
  });
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/node.js
class ExecutionRevertedError extends BaseError {
  constructor({ cause, message } = {}) {
    const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
    super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ExecutionRevertedError"
    });
  }
}

class FeeCapTooHighError extends BaseError {
  constructor({ cause, maxFeePerGas } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FeeCapTooHigh"
    });
  }
}

class FeeCapTooLowError extends BaseError {
  constructor({ cause, maxFeePerGas } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FeeCapTooLow"
    });
  }
}

class NonceTooHighError extends BaseError {
  constructor({ cause, nonce } = {}) {
    super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "NonceTooHighError"
    });
  }
}

class NonceTooLowError extends BaseError {
  constructor({ cause, nonce } = {}) {
    super([
      `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join("\n"), { cause });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "NonceTooLowError"
    });
  }
}

class NonceMaxValueError extends BaseError {
  constructor({ cause, nonce } = {}) {
    super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "NonceMaxValueError"
    });
  }
}

class InsufficientFundsError extends BaseError {
  constructor({ cause } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join("\n"), {
      cause,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InsufficientFundsError"
    });
  }
}

class IntrinsicGasTooHighError extends BaseError {
  constructor({ cause, gas } = {}) {
    super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "IntrinsicGasTooHighError"
    });
  }
}

class IntrinsicGasTooLowError extends BaseError {
  constructor({ cause, gas } = {}) {
    super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "IntrinsicGasTooLowError"
    });
  }
}

class TransactionTypeNotSupportedError extends BaseError {
  constructor({ cause }) {
    super("The transaction type is not supported for this chain.", {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionTypeNotSupportedError"
    });
  }
}

class TipAboveFeeCapError extends BaseError {
  constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
    ].join("\n"), {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TipAboveFeeCapError"
    });
  }
}

class UnknownNodeError extends BaseError {
  constructor({ cause }) {
    super(`An error occurred while executing: ${cause?.shortMessage}`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownNodeError"
    });
  }
}
var init_node = __esm(() => {
  init_formatGwei();
  init_base();
  Object.defineProperty(ExecutionRevertedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 3
  });
  Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /execution reverted/
  });
  Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
  });
  Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
  });
  Object.defineProperty(NonceTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too high/
  });
  Object.defineProperty(NonceTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too low|transaction already imported|already known/
  });
  Object.defineProperty(NonceMaxValueError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce has max value/
  });
  Object.defineProperty(InsufficientFundsError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /insufficient funds/
  });
  Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too high|gas limit reached/
  });
  Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too low/
  });
  Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /transaction type not valid/
  });
  Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
  });
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/errors/getNodeError.js
function getNodeError(err, args) {
  const message = (err.details || "").toLowerCase();
  const executionRevertedError = err.walk((e) => e.code === ExecutionRevertedError.code);
  if (executionRevertedError instanceof BaseError) {
    return new ExecutionRevertedError({
      cause: err,
      message: executionRevertedError.details
    });
  }
  if (ExecutionRevertedError.nodeMessage.test(message))
    return new ExecutionRevertedError({
      cause: err,
      message: err.details
    });
  if (FeeCapTooHighError.nodeMessage.test(message))
    return new FeeCapTooHighError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas
    });
  if (FeeCapTooLowError.nodeMessage.test(message))
    return new FeeCapTooLowError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas
    });
  if (NonceTooHighError.nodeMessage.test(message))
    return new NonceTooHighError({ cause: err, nonce: args?.nonce });
  if (NonceTooLowError.nodeMessage.test(message))
    return new NonceTooLowError({ cause: err, nonce: args?.nonce });
  if (NonceMaxValueError.nodeMessage.test(message))
    return new NonceMaxValueError({ cause: err, nonce: args?.nonce });
  if (InsufficientFundsError.nodeMessage.test(message))
    return new InsufficientFundsError({ cause: err });
  if (IntrinsicGasTooHighError.nodeMessage.test(message))
    return new IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
  if (IntrinsicGasTooLowError.nodeMessage.test(message))
    return new IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
  if (TransactionTypeNotSupportedError.nodeMessage.test(message))
    return new TransactionTypeNotSupportedError({ cause: err });
  if (TipAboveFeeCapError.nodeMessage.test(message))
    return new TipAboveFeeCapError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas,
      maxPriorityFeePerGas: args?.maxPriorityFeePerGas
    });
  return new UnknownNodeError({
    cause: err
  });
}
var init_getNodeError = __esm(() => {
  init_base();
  init_node();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/formatters/extract.js
function extract(value_, { format: format3 }) {
  if (!format3)
    return {};
  const value = {};
  function extract_(formatted2) {
    const keys = Object.keys(formatted2);
    for (const key of keys) {
      if (key in value_)
        value[key] = value_[key];
      if (formatted2[key] && typeof formatted2[key] === "object" && !Array.isArray(formatted2[key]))
        extract_(formatted2[key]);
    }
  }
  const formatted = format3(value_ || {});
  extract_(formatted);
  return value;
}
var init_extract = __esm(() => {
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/formatters/formatter.js
function defineFormatter(type, format3) {
  return ({ exclude, format: overrides }) => {
    return {
      exclude,
      format: (args) => {
        const formatted = format3(args);
        if (exclude) {
          for (const key of exclude) {
            delete formatted[key];
          }
        }
        return {
          ...formatted,
          ...overrides(args)
        };
      },
      type
    };
  };
}
var init_formatter = __esm(() => {
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/formatters/transactionRequest.js
function formatTransactionRequest(transactionRequest) {
  return {
    ...transactionRequest,
    gas: typeof transactionRequest.gas !== "undefined" ? numberToHex(transactionRequest.gas) : undefined,
    gasPrice: typeof transactionRequest.gasPrice !== "undefined" ? numberToHex(transactionRequest.gasPrice) : undefined,
    maxFeePerGas: typeof transactionRequest.maxFeePerGas !== "undefined" ? numberToHex(transactionRequest.maxFeePerGas) : undefined,
    maxPriorityFeePerGas: typeof transactionRequest.maxPriorityFeePerGas !== "undefined" ? numberToHex(transactionRequest.maxPriorityFeePerGas) : undefined,
    nonce: typeof transactionRequest.nonce !== "undefined" ? numberToHex(transactionRequest.nonce) : undefined,
    type: typeof transactionRequest.type !== "undefined" ? rpcTransactionType[transactionRequest.type] : undefined,
    value: typeof transactionRequest.value !== "undefined" ? numberToHex(transactionRequest.value) : undefined
  };
}
var rpcTransactionType, defineTransactionRequest;
var init_transactionRequest = __esm(() => {
  init_toHex();
  init_formatter();
  rpcTransactionType = {
    legacy: "0x0",
    eip2930: "0x1",
    eip1559: "0x2"
  };
  defineTransactionRequest = defineFormatter("transactionRequest", formatTransactionRequest);
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/transaction/assertRequest.js
function assertRequest(args) {
  const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
  const account = account_ ? parseAccount(account_) : undefined;
  if (account && !isAddress(account.address))
    throw new InvalidAddressError({ address: account.address });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
    throw new FeeConflictError;
  if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
var init_assertRequest = __esm(() => {
  init_parseAccount();
  init_address();
  init_node();
  init_transaction();
  init_isAddress();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/abi/decodeFunctionResult.js
function decodeFunctionResult({ abi: abi13, args, functionName, data: data3 }) {
  let abiItem = abi13[0];
  if (functionName) {
    abiItem = getAbiItem({
      abi: abi13,
      args,
      name: functionName
    });
    if (!abiItem)
      throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath2 });
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(undefined, { docsPath: docsPath2 });
  if (!abiItem.outputs)
    throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath2 });
  const values = decodeAbiParameters(abiItem.outputs, data3);
  if (values && values.length > 1)
    return values;
  if (values && values.length === 1)
    return values[0];
  return;
}
var docsPath2;
var init_decodeFunctionResult = __esm(() => {
  init_abi();
  init_decodeAbiParameters();
  init_getAbiItem();
  docsPath2 = "/docs/contract/decodeFunctionResult";
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/constants/abis.js
var multicall3Abi, universalResolverErrors, universalResolverResolveAbi, universalResolverReverseAbi, textResolverAbi, addressResolverAbi, universalSignatureValidatorAbi;
var init_abis = __esm(() => {
  multicall3Abi = [
    {
      inputs: [
        {
          components: [
            {
              name: "target",
              type: "address"
            },
            {
              name: "allowFailure",
              type: "bool"
            },
            {
              name: "callData",
              type: "bytes"
            }
          ],
          name: "calls",
          type: "tuple[]"
        }
      ],
      name: "aggregate3",
      outputs: [
        {
          components: [
            {
              name: "success",
              type: "bool"
            },
            {
              name: "returnData",
              type: "bytes"
            }
          ],
          name: "returnData",
          type: "tuple[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    }
  ];
  universalResolverErrors = [
    {
      inputs: [],
      name: "ResolverNotFound",
      type: "error"
    },
    {
      inputs: [],
      name: "ResolverWildcardNotSupported",
      type: "error"
    }
  ];
  universalResolverResolveAbi = [
    ...universalResolverErrors,
    {
      name: "resolve",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes" },
        { name: "data", type: "bytes" }
      ],
      outputs: [
        { name: "", type: "bytes" },
        { name: "address", type: "address" }
      ]
    }
  ];
  universalResolverReverseAbi = [
    ...universalResolverErrors,
    {
      name: "reverse",
      type: "function",
      stateMutability: "view",
      inputs: [{ type: "bytes", name: "reverseName" }],
      outputs: [
        { type: "string", name: "resolvedName" },
        { type: "address", name: "resolvedAddress" },
        { type: "address", name: "reverseResolver" },
        { type: "address", name: "resolver" }
      ]
    }
  ];
  textResolverAbi = [
    {
      name: "text",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes32" },
        { name: "key", type: "string" }
      ],
      outputs: [{ name: "", type: "string" }]
    }
  ];
  addressResolverAbi = [
    {
      name: "addr",
      type: "function",
      stateMutability: "view",
      inputs: [{ name: "name", type: "bytes32" }],
      outputs: [{ name: "", type: "address" }]
    },
    {
      name: "addr",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes32" },
        { name: "coinType", type: "uint256" }
      ],
      outputs: [{ name: "", type: "bytes" }]
    }
  ];
  universalSignatureValidatorAbi = [
    {
      inputs: [
        {
          internalType: "address",
          name: "_signer",
          type: "address"
        },
        {
          internalType: "bytes32",
          name: "_hash",
          type: "bytes32"
        },
        {
          internalType: "bytes",
          name: "_signature",
          type: "bytes"
        }
      ],
      stateMutability: "nonpayable",
      type: "constructor"
    }
  ];
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/constants/contract.js
var aggregate3Signature;
var init_contract2 = __esm(() => {
  aggregate3Signature = "0x82ad56cb";
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/chain.js
class ChainDoesNotSupportContract extends BaseError {
  constructor({ blockNumber, chain, contract: contract2 }) {
    super(`Chain "${chain.name}" does not support contract "${contract2.name}".`, {
      metaMessages: [
        "This could be due to any of the following:",
        ...blockNumber && contract2.blockCreated && contract2.blockCreated > blockNumber ? [
          `- The contract "${contract2.name}" was not deployed until block ${contract2.blockCreated} (current block ${blockNumber}).`
        ] : [
          `- The chain does not have the contract "${contract2.name}" configured.`
        ]
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainDoesNotSupportContract"
    });
  }
}

class ChainMismatchError extends BaseError {
  constructor({ chain, currentChainId }) {
    super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} \u2013 ${chain.name}).`, {
      metaMessages: [
        `Current Chain ID:  ${currentChainId}`,
        `Expected Chain ID: ${chain.id} \u2013 ${chain.name}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainMismatchError"
    });
  }
}

class ChainNotFoundError extends BaseError {
  constructor() {
    super([
      "No chain was provided to the request.",
      "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainNotFoundError"
    });
  }
}

class ClientChainNotConfiguredError extends BaseError {
  constructor() {
    super("No chain was provided to the Client.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ClientChainNotConfiguredError"
    });
  }
}

class InvalidChainIdError extends BaseError {
  constructor({ chainId }) {
    super(`Chain ID "${chainId}" is invalid.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidChainIdError"
    });
  }
}
var init_chain = __esm(() => {
  init_base();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/chain/getChainContractAddress.js
function getChainContractAddress({ blockNumber, chain: chain2, contract: name }) {
  const contract2 = chain2?.contracts?.[name];
  if (!contract2)
    throw new ChainDoesNotSupportContract({
      chain: chain2,
      contract: { name }
    });
  if (blockNumber && contract2.blockCreated && contract2.blockCreated > blockNumber)
    throw new ChainDoesNotSupportContract({
      blockNumber,
      chain: chain2,
      contract: {
        name,
        blockCreated: contract2.blockCreated
      }
    });
  return contract2.address;
}
var init_getChainContractAddress = __esm(() => {
  init_chain();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/errors/getCallError.js
function getCallError(err, { docsPath: docsPath3, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new CallExecutionError(cause, {
    docsPath: docsPath3,
    ...args
  });
}
var init_getCallError = __esm(() => {
  init_contract();
  init_node();
  init_getNodeError();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/promise/createBatchScheduler.js
function createBatchScheduler({ fn, id, shouldSplitBatch, wait = 0, sort }) {
  const exec = async () => {
    const scheduler = getScheduler();
    flush();
    const args = scheduler.map(({ args: args2 }) => args2);
    if (args.length === 0)
      return;
    fn(args).then((data3) => {
      if (sort && Array.isArray(data3))
        data3.sort(sort);
      for (let i = 0;i < scheduler.length; i++) {
        const { pendingPromise } = scheduler[i];
        pendingPromise.resolve?.([data3[i], data3]);
      }
    }).catch((err) => {
      for (let i = 0;i < scheduler.length; i++) {
        const { pendingPromise } = scheduler[i];
        pendingPromise.reject?.(err);
      }
    });
  };
  const flush = () => schedulerCache.delete(id);
  const getBatchedArgs = () => getScheduler().map(({ args }) => args);
  const getScheduler = () => schedulerCache.get(id) || [];
  const setScheduler = (item) => schedulerCache.set(id, [...getScheduler(), item]);
  return {
    flush,
    async schedule(args) {
      const pendingPromise = {};
      const promise = new Promise((resolve5, reject) => {
        pendingPromise.resolve = resolve5;
        pendingPromise.reject = reject;
      });
      const split2 = shouldSplitBatch?.([...getBatchedArgs(), args]);
      if (split2)
        exec();
      const hasActiveScheduler = getScheduler().length > 0;
      if (hasActiveScheduler) {
        setScheduler({ args, pendingPromise });
        return promise;
      }
      setScheduler({ args, pendingPromise });
      setTimeout(exec, wait);
      return promise;
    }
  };
}
var schedulerCache;
var init_createBatchScheduler = __esm(() => {
  schedulerCache = new Map;
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/ccip.js
class OffchainLookupError extends BaseError {
  constructor({ callbackSelector, cause, data: data3, extraData, sender, urls }) {
    super(cause.shortMessage || "An error occurred while fetching for an offchain result.", {
      cause,
      metaMessages: [
        ...cause.metaMessages || [],
        cause.metaMessages?.length ? "" : [],
        "Offchain Gateway Call:",
        urls && [
          "  Gateway URL(s):",
          ...urls.map((url) => `    ${getUrl(url)}`)
        ],
        `  Sender: ${sender}`,
        `  Data: ${data3}`,
        `  Callback selector: ${callbackSelector}`,
        `  Extra data: ${extraData}`
      ].flat()
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "OffchainLookupError"
    });
  }
}

class OffchainLookupResponseMalformedError extends BaseError {
  constructor({ result, url }) {
    super("Offchain gateway response is malformed. Response data must be a hex value.", {
      metaMessages: [
        `Gateway URL: ${getUrl(url)}`,
        `Response: ${stringify(result)}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "OffchainLookupResponseMalformedError"
    });
  }
}

class OffchainLookupSenderMismatchError extends BaseError {
  constructor({ sender, to }) {
    super("Reverted sender address does not match target contract address (`to`).", {
      metaMessages: [
        `Contract address: ${to}`,
        `OffchainLookup sender address: ${sender}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "OffchainLookupSenderMismatchError"
    });
  }
}
var init_ccip = __esm(() => {
  init_stringify();
  init_base();
  init_utils();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/address/isAddressEqual.js
function isAddressEqual(a, b) {
  if (!isAddress(a))
    throw new InvalidAddressError({ address: a });
  if (!isAddress(b))
    throw new InvalidAddressError({ address: b });
  return a.toLowerCase() === b.toLowerCase();
}
var init_isAddressEqual = __esm(() => {
  init_address();
  init_isAddress();
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/ccip.js
var exports_ccip = {};
__export(exports_ccip, {
  offchainLookupSignature: () => {
    {
      return offchainLookupSignature;
    }
  },
  offchainLookupAbiItem: () => {
    {
      return offchainLookupAbiItem;
    }
  },
  offchainLookup: () => {
    {
      return offchainLookup;
    }
  },
  ccipFetch: () => {
    {
      return ccipFetch;
    }
  }
});
async function offchainLookup(client, { blockNumber, blockTag, data: data3, to }) {
  const { args } = decodeErrorResult({
    data: data3,
    abi: [offchainLookupAbiItem]
  });
  const [sender, urls, callData, callbackSelector, extraData] = args;
  try {
    if (!isAddressEqual(to, sender))
      throw new OffchainLookupSenderMismatchError({ sender, to });
    const result = await ccipFetch({ data: callData, sender, urls });
    const { data: data_ } = await call2(client, {
      blockNumber,
      blockTag,
      data: concat([
        callbackSelector,
        encodeAbiParameters([{ type: "bytes" }, { type: "bytes" }], [result, extraData])
      ]),
      to
    });
    return data_;
  } catch (err) {
    throw new OffchainLookupError({
      callbackSelector,
      cause: err,
      data: data3,
      extraData,
      sender,
      urls
    });
  }
}
async function ccipFetch({ data: data3, sender, urls }) {
  let error = new Error("An unknown error occurred.");
  for (let i = 0;i < urls.length; i++) {
    const url = urls[i];
    const method = url.includes("{data}") ? "GET" : "POST";
    const body = method === "POST" ? { data: data3, sender } : undefined;
    try {
      const response = await fetch(url.replace("{sender}", sender).replace("{data}", data3), {
        body: JSON.stringify(body),
        method
      });
      let result;
      if (response.headers.get("Content-Type")?.startsWith("application/json")) {
        result = (await response.json()).data;
      } else {
        result = await response.text();
      }
      if (!response.ok) {
        error = new HttpRequestError({
          body,
          details: result?.error ? stringify(result.error) : response.statusText,
          headers: response.headers,
          status: response.status,
          url
        });
        continue;
      }
      if (!isHex(result)) {
        error = new OffchainLookupResponseMalformedError({
          result,
          url
        });
        continue;
      }
      return result;
    } catch (err) {
      error = new HttpRequestError({
        body,
        details: err.message,
        url
      });
    }
  }
  throw error;
}
var offchainLookupSignature, offchainLookupAbiItem;
var init_ccip2 = __esm(() => {
  init_call();
  init_ccip();
  init_request();
  init_decodeErrorResult();
  init_encodeAbiParameters();
  init_isAddressEqual();
  init_concat();
  init_isHex();
  init_stringify();
  offchainLookupSignature = "0x556f1830";
  offchainLookupAbiItem = {
    name: "OffchainLookup",
    type: "error",
    inputs: [
      {
        name: "sender",
        type: "address"
      },
      {
        name: "urls",
        type: "string[]"
      },
      {
        name: "callData",
        type: "bytes"
      },
      {
        name: "callbackFunction",
        type: "bytes4"
      },
      {
        name: "extraData",
        type: "bytes"
      }
    ]
  };
});

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/call.js
async function call2(client, args) {
  const { account: account_ = client.account, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = "latest", accessList, data: data3, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
  const account3 = account_ ? parseAccount(account_) : undefined;
  try {
    assertRequest(args);
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
    const block3 = blockNumberHex || blockTag;
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format3 = chainFormat || formatTransactionRequest;
    const request3 = format3({
      ...extract(rest, { format: chainFormat }),
      from: account3?.address,
      accessList,
      data: data3,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    if (batch && shouldPerformMulticall({ request: request3 })) {
      try {
        return await scheduleMulticall(client, {
          ...request3,
          blockNumber,
          blockTag
        });
      } catch (err) {
        if (!(err instanceof ClientChainNotConfiguredError) && !(err instanceof ChainDoesNotSupportContract))
          throw err;
      }
    }
    const response = await client.request({
      method: "eth_call",
      params: block3 ? [request3, block3] : [request3]
    });
    if (response === "0x")
      return { data: undefined };
    return { data: response };
  } catch (err) {
    const data4 = getRevertErrorData(err);
    const { offchainLookup: offchainLookup2, offchainLookupSignature: offchainLookupSignature2 } = await Promise.resolve().then(() => (init_ccip2(), exports_ccip));
    if (data4?.slice(0, 10) === offchainLookupSignature2 && to) {
      return { data: await offchainLookup2(client, { data: data4, to }) };
    }
    throw getCallError(err, {
      ...args,
      account: account3,
      chain: client.chain
    });
  }
}
async function scheduleMulticall(client, args) {
  const { batchSize = 1024, wait = 0 } = typeof client.batch?.multicall === "object" ? client.batch.multicall : {};
  const { blockNumber, blockTag = "latest", data: data3, multicallAddress: multicallAddress_, to } = args;
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client.chain)
      throw new ClientChainNotConfiguredError;
    multicallAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "multicall3"
    });
  }
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
  const block3 = blockNumberHex || blockTag;
  const { schedule } = createBatchScheduler({
    id: `${client.uid}.${block3}`,
    wait,
    shouldSplitBatch(args2) {
      const size7 = args2.reduce((size8, { data: data4 }) => size8 + (data4.length - 2), 0);
      return size7 > batchSize * 2;
    },
    fn: async (requests) => {
      const calls = requests.map((request3) => ({
        allowFailure: true,
        callData: request3.data,
        target: request3.to
      }));
      const calldata = encodeFunctionData({
        abi: multicall3Abi,
        args: [calls],
        functionName: "aggregate3"
      });
      const data4 = await client.request({
        method: "eth_call",
        params: [
          {
            data: calldata,
            to: multicallAddress
          },
          block3
        ]
      });
      return decodeFunctionResult({
        abi: multicall3Abi,
        args: [calls],
        functionName: "aggregate3",
        data: data4 || "0x"
      });
    }
  });
  const [{ returnData, success }] = await schedule({ data: data3, to });
  if (!success)
    throw new RawContractError({ data: returnData });
  if (returnData === "0x")
    return { data: undefined };
  return { data: returnData };
}
function getRevertErrorData(err) {
  if (!(err instanceof BaseError))
    return;
  const error = err.walk();
  return typeof error.data === "object" ? error.data.data : error.data;
}
var shouldPerformMulticall;
var init_call = __esm(() => {
  init_parseAccount();
  init_abis();
  init_contract2();
  init_base();
  init_chain();
  init_contract();
  init_decodeFunctionResult();
  init_encodeFunctionData();
  init_getChainContractAddress();
  init_toHex();
  init_getCallError();
  init_extract();
  init_transactionRequest();
  init_createBatchScheduler();
  init_assertRequest();
  shouldPerformMulticall = function({ request: request3 }) {
    const { data: data3, to, ...request_ } = request3;
    if (!data3)
      return false;
    if (data3.startsWith(aggregate3Signature))
      return false;
    if (!to)
      return false;
    if (Object.values(request_).filter((x) => typeof x !== "undefined").length > 0)
      return false;
    return true;
  };
});

// ../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_sha2.js
class SHA2 extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data3) {
    exists(this);
    const { view, buffer: buffer2, blockLen } = this;
    data3 = toBytes3(data3);
    const len = data3.length;
    for (let pos = 0;pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data3);
        for (;blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data3.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data3.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos;i < blockLen; i++)
      buffer2[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0;i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor);
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
}
var setBigUint64;
var init__sha2 = __esm(() => {
  init__assert();
  init_utils2();
  setBigUint64 = function(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n2 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE2 ? 4 : 0;
    const l = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE2);
    view.setUint32(byteOffset + l, wl, isLE2);
  };
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/@scure+bip32@1.3.2/node_modules/@noble/hashes/esm/sha256.js
class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0;i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16;i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0;i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
var Chi, Maj, SHA256_K, IV, SHA256_W, sha256;
var init_sha256 = __esm(() => {
  init__sha2();
  init_utils2();
  Chi = (a, b, c) => a & b ^ ~a & c;
  Maj = (a, b, c) => a & b ^ a & c ^ b & c;
  SHA256_K = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  IV = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  SHA256_W = new Uint32Array(64);
  sha256 = wrapConstructor(() => new SHA256);
});

// ../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/utils.js
var exports_utils = {};
__export(exports_utils, {
  validateObject: () => {
    {
      return validateObject;
    }
  },
  utf8ToBytes: () => {
    {
      return utf8ToBytes2;
    }
  },
  numberToVarBytesBE: () => {
    {
      return numberToVarBytesBE;
    }
  },
  numberToHexUnpadded: () => {
    {
      return numberToHexUnpadded;
    }
  },
  numberToBytesLE: () => {
    {
      return numberToBytesLE;
    }
  },
  numberToBytesBE: () => {
    {
      return numberToBytesBE;
    }
  },
  hexToNumber: () => {
    {
      return hexToNumber2;
    }
  },
  hexToBytes: () => {
    {
      return hexToBytes2;
    }
  },
  equalBytes: () => {
    {
      return equalBytes;
    }
  },
  ensureBytes: () => {
    {
      return ensureBytes;
    }
  },
  createHmacDrbg: () => {
    {
      return createHmacDrbg;
    }
  },
  concatBytes: () => {
    {
      return concatBytes3;
    }
  },
  bytesToNumberLE: () => {
    {
      return bytesToNumberLE;
    }
  },
  bytesToNumberBE: () => {
    {
      return bytesToNumberBE;
    }
  },
  bytesToHex: () => {
    {
      return bytesToHex2;
    }
  },
  bitSet: () => {
    {
      return bitSet;
    }
  },
  bitMask: () => {
    {
      return bitMask;
    }
  },
  bitLen: () => {
    {
      return bitLen;
    }
  },
  bitGet: () => {
    {
      return bitGet;
    }
  }
});
function bytesToHex2(bytes2) {
  if (!u8a2(bytes2))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0;i < bytes2.length; i++) {
    hex += hexes2[bytes2[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
function hexToBytes2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const len = hex.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i = 0;i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber2(bytesToHex2(bytes2));
}
function bytesToNumberLE(bytes2) {
  if (!u8a2(bytes2))
    throw new Error("Uint8Array expected");
  return hexToNumber2(bytesToHex2(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes2(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes2(numberToHexUnpadded(n));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes2(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (u8a2(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes3(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad5 = 0;
  arrays.forEach((a) => {
    if (!u8a2(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad5);
    pad5 += a.length;
  });
  return r;
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i = 0;i < b1.length; i++)
    if (b1[i] !== b2[i])
      return false;
  return true;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n) {
  let len;
  for (len = 0;n > _0n2; n >>= _1n2, len += 1)
    ;
  return len;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n2;
}
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen2 = () => {
    if (i++ >= 1000)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes3(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = undefined;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === undefined)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}
var _0n2, _1n2, _2n2, u8a2, hexes2, bitSet, bitMask, u8n, u8fr, validatorFns;
var init_utils3 = __esm(() => {
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n2 = BigInt(0);
  _1n2 = BigInt(1);
  _2n2 = BigInt(2);
  u8a2 = (a) => a instanceof Uint8Array;
  hexes2 = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  bitSet = (n, pos, value) => {
    return n | (value ? _1n2 : _0n2) << BigInt(pos);
  };
  bitMask = (n) => (_2n2 << BigInt(n - 1)) - _1n2;
  u8n = (data3) => new Uint8Array(data3);
  u8fr = (arr) => Uint8Array.from(arr);
  validatorFns = {
    bigint: (val) => typeof val === "bigint",
    function: (val) => typeof val === "function",
    boolean: (val) => typeof val === "boolean",
    string: (val) => typeof val === "string",
    stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
  };
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/@scure+bip32@1.3.2/node_modules/@noble/curves/esm/abstract/modular.js
function mod(a, b) {
  const result = a % b;
  return result >= _0n3 ? result : b + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n3 || power < _0n3)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n3)
    return _0n3;
  let res = _1n3;
  while (power > _0n3) {
    if (power & _1n3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n3;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n3 || modulo <= _0n3) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a = mod(number2, modulo);
  let b = modulo;
  let x = _0n3, y = _1n3, u = _1n3, v = _0n3;
  while (a !== _0n3) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n3)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n3) / _2n3;
  let Q, S, Z;
  for (Q = P - _1n3, S = 0;Q % _2n3 === _0n3; Q /= _2n3, S++)
    ;
  for (Z = _2n3;Z < P && pow(Z, legendreC, P) !== P - _1n3; Z++)
    ;
  if (S === 1) {
    const p1div4 = (P + _1n3) / _4n;
    return function tonelliFast(Fp, n) {
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n3) / _2n3;
  return function tonelliSlow(Fp, n) {
    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
    let x = Fp.pow(n, Q1div2);
    let b = Fp.pow(n, Q);
    while (!Fp.eql(b, Fp.ONE)) {
      if (Fp.eql(b, Fp.ZERO))
        return Fp.ZERO;
      let m = 1;
      for (let t2 = Fp.sqr(b);m < r; m++) {
        if (Fp.eql(t2, Fp.ONE))
          break;
        t2 = Fp.sqr(t2);
      }
      const ge = Fp.pow(g, _1n3 << BigInt(r - m - 1));
      g = Fp.sqr(ge);
      x = Fp.mul(x, ge);
      b = Fp.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n3) / _4n;
    return function sqrt3mod4(Fp, n) {
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp, n) {
      const n2 = Fp.mul(n, _2n3);
      const v = Fp.pow(n2, c1);
      const nv = Fp.mul(n, v);
      const i = Fp.mul(Fp.mul(nv, _2n3), v);
      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f, num, power) {
  if (power < _0n3)
    throw new Error("Expected power > 0");
  if (power === _0n3)
    return f.ONE;
  if (power === _1n3)
    return num;
  let p = f.ONE;
  let d = num;
  while (power > _0n3) {
    if (power & _1n3)
      p = f.mul(p, d);
    d = f.sqr(d);
    power >>= _1n3;
  }
  return p;
}
function FpInvertBatch(f, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = acc;
    return f.mul(acc, num);
  }, f.ONE);
  const inverted = f.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = f.mul(acc, tmp[i]);
    return f.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n3)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n3,
    ONE: _1n3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n3 <= num && num < ORDER;
    },
    is0: (num) => num === _0n3,
    isOdd: (num) => (num & _1n3) === _1n3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
    invertBatch: (lst) => FpInvertBatch(f, lst),
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n3) + _1n3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
var _0n3, _1n3, _2n3, _3n, _4n, _5n, _8n, _9n, _16n, FIELD_FIELDS;
var init_modular = __esm(() => {
  init_utils3();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n3 = BigInt(0);
  _1n3 = BigInt(1);
  _2n3 = BigInt(2);
  _3n = BigInt(3);
  _4n = BigInt(4);
  _5n = BigInt(5);
  _8n = BigInt(8);
  _9n = BigInt(9);
  _16n = BigInt(16);
  FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
});

// ../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/curve.js
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    unsafeLadder(elm, n) {
      let p = c.ZERO;
      let d = elm;
      while (n > _0n4) {
        if (n & _1n4)
          p = p.add(d);
        d = d.double();
        n >>= _1n4;
      }
      return p;
    },
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base29 = p;
      for (let window2 = 0;window2 < windows; window2++) {
        base29 = p;
        points.push(base29);
        for (let i = 1;i < windowSize; i++) {
          base29 = base29.add(p);
          points.push(base29);
        }
        p = base29.double();
      }
      return points;
    },
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0;window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n4;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f };
    },
    wNAFCached(P, precomputesMap, n, transform) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
var _0n4, _1n4;
var init_curve = __esm(() => {
  init_modular();
  init_utils3();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n4 = BigInt(0);
  _1n4 = BigInt(1);
});

// ../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/weierstrass.js
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp } = CURVE;
  const toBytes15 = CURVE.toBytes || ((_c2, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes3(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
    const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE;
    const x2 = Fp.sqr(x);
    const x3 = Fp.mul(x2, x);
    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
  }
  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n5 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex2(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = new Map;
  function assertPrjPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }

  class Point {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp.isValid(pz))
        throw new Error("z required");
    }
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp.eql(i, Fp.ZERO);
      if (is0(x) && is0(y))
        return Point.ZERO;
      return new Point(x, y, Fp.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(points) {
      const toInv = Fp.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
    }
    static fromHex(hex) {
      const P = Point.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left2 = Fp.sqr(y);
      const right2 = weierstrassEquation(x);
      if (!Fp.eql(left2, right2))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp.isOdd)
        return !Fp.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
      return U1 && U2;
    }
    negate() {
      return new Point(this.px, Fp.neg(this.py), this.pz);
    }
    double() {
      const { a, b } = CURVE;
      const b3 = Fp.mul(b, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp;
      let t0 = Fp.mul(X1, X1);
      let t1 = Fp.mul(Y1, Y1);
      let t2 = Fp.mul(Z1, Z1);
      let t3 = Fp.mul(X1, Y1);
      t3 = Fp.add(t3, t3);
      Z3 = Fp.mul(X1, Z1);
      Z3 = Fp.add(Z3, Z3);
      X3 = Fp.mul(a, Z3);
      Y3 = Fp.mul(b3, t2);
      Y3 = Fp.add(X3, Y3);
      X3 = Fp.sub(t1, Y3);
      Y3 = Fp.add(t1, Y3);
      Y3 = Fp.mul(X3, Y3);
      X3 = Fp.mul(t3, X3);
      Z3 = Fp.mul(b3, Z3);
      t2 = Fp.mul(a, t2);
      t3 = Fp.sub(t0, t2);
      t3 = Fp.mul(a, t3);
      t3 = Fp.add(t3, Z3);
      Z3 = Fp.add(t0, t0);
      t0 = Fp.add(Z3, t0);
      t0 = Fp.add(t0, t2);
      t0 = Fp.mul(t0, t3);
      Y3 = Fp.add(Y3, t0);
      t2 = Fp.mul(Y1, Z1);
      t2 = Fp.add(t2, t2);
      t0 = Fp.mul(t2, t3);
      X3 = Fp.sub(X3, t0);
      Z3 = Fp.mul(t2, t1);
      Z3 = Fp.add(Z3, Z3);
      Z3 = Fp.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp;
      const a = CURVE.a;
      const b3 = Fp.mul(CURVE.b, _3n2);
      let t0 = Fp.mul(X1, X2);
      let t1 = Fp.mul(Y1, Y2);
      let t2 = Fp.mul(Z1, Z2);
      let t3 = Fp.add(X1, Y1);
      let t4 = Fp.add(X2, Y2);
      t3 = Fp.mul(t3, t4);
      t4 = Fp.add(t0, t1);
      t3 = Fp.sub(t3, t4);
      t4 = Fp.add(X1, Z1);
      let t5 = Fp.add(X2, Z2);
      t4 = Fp.mul(t4, t5);
      t5 = Fp.add(t0, t2);
      t4 = Fp.sub(t4, t5);
      t5 = Fp.add(Y1, Z1);
      X3 = Fp.add(Y2, Z2);
      t5 = Fp.mul(t5, X3);
      X3 = Fp.add(t1, t2);
      t5 = Fp.sub(t5, X3);
      Z3 = Fp.mul(a, t4);
      X3 = Fp.mul(b3, t2);
      Z3 = Fp.add(X3, Z3);
      X3 = Fp.sub(t1, Z3);
      Z3 = Fp.add(t1, Z3);
      Y3 = Fp.mul(X3, Z3);
      t1 = Fp.add(t0, t0);
      t1 = Fp.add(t1, t0);
      t2 = Fp.mul(a, t2);
      t4 = Fp.mul(b3, t4);
      t1 = Fp.add(t1, t2);
      t2 = Fp.sub(t0, t2);
      t2 = Fp.mul(a, t2);
      t4 = Fp.add(t4, t2);
      t0 = Fp.mul(t1, t4);
      Y3 = Fp.add(Y3, t0);
      t0 = Fp.mul(t5, t4);
      X3 = Fp.mul(t3, X3);
      X3 = Fp.sub(X3, t0);
      t0 = Fp.mul(t3, t1);
      Z3 = Fp.mul(t5, Z3);
      Z3 = Fp.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
        const toInv = Fp.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
      });
    }
    multiplyUnsafe(n) {
      const I = Point.ZERO;
      if (n === _0n5)
        return I;
      assertGE(n);
      if (n === _1n5)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n5 || k2 > _0n5) {
        if (k1 & _1n5)
          k1p = k1p.add(d);
        if (k2 & _1n5)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n5;
        k2 >>= _1n5;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    multiply(scalar) {
      assertGE(scalar);
      let n = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(n);
        point = p;
        fake = f;
      }
      return Point.normalizeZ([point, fake])[0];
    }
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point.BASE;
      const mul = (P, a2) => a2 === _0n5 || a2 === _1n5 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b));
      return sum.is0() ? undefined : sum;
    }
    toAffine(iz) {
      const { px: x, py: y, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp.ONE : Fp.inv(z);
      const ax = Fp.mul(x, iz);
      const ay = Fp.mul(y, iz);
      const zz = Fp.mul(z, iz);
      if (is0)
        return { x: Fp.ZERO, y: Fp.ZERO };
      if (!Fp.eql(zz, Fp.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n5)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n5)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes15(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex2(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
  Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp.BYTES + 1;
  const uncompressedLen = 2 * Fp.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n5 < num && num < Fp.ORDER;
  }
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c2, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp.toBytes(a.x);
      const cat = concatBytes3;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y = Fp.sqrt(y2);
        const isYOdd = (y & _1n5) === _1n5;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex2(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n5;
    return number2 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));

  class Signature {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h * ir);
      const u2 = modN(s * ir);
      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return hexToBytes2(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return hexToBytes2(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils17 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n5 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => (k in opts)))
      throw new Error("sign() legacy options not supported");
    const { hash: hash4, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash4(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e = ent === true ? randomBytes2(Fp.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes3(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point.BASE.multiply(k).toAffine();
      const r = modN(q.x);
      if (r === _0n5)
        return;
      const s = modN(ik * modN(m + r * d));
      if (s === _0n5)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n5);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = undefined;
    let P;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig = new Signature(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN(h * is);
    const u2 = modN(r * is);
    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = modN(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point,
    Signature,
    utils: utils17
  };
}
var validatePointOpts, validateOpts, b2n, h2b, DER, _0n5, _1n5, _2n4, _3n2, _4n2;
var init_weierstrass = __esm(() => {
  init_modular();
  init_utils3();
  init_utils3();
  init_curve();
  validatePointOpts = function(curve2) {
    const opts = validateBasic(curve2);
    validateObject(opts, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo, Fp, a } = opts;
    if (endo) {
      if (!Fp.eql(a, Fp.ZERO)) {
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      }
      if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
      }
    }
    return Object.freeze({ ...opts });
  };
  validateOpts = function(curve2) {
    const opts = validateBasic(curve2);
    validateObject(opts, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    });
    return Object.freeze({ lowS: true, ...opts });
  };
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  ({ bytesToNumberBE: b2n, hexToBytes: h2b } = exports_utils);
  DER = {
    Err: class DERErr extends Error {
      constructor(m = "") {
        super(m);
      }
    },
    _parseInt(data3) {
      const { Err: E } = DER;
      if (data3.length < 2 || data3[0] !== 2)
        throw new E("Invalid signature integer tag");
      const len = data3[1];
      const res = data3.subarray(2, len + 2);
      if (!len || res.length !== len)
        throw new E("Invalid signature integer: wrong length");
      if (res[0] & 128)
        throw new E("Invalid signature integer: negative");
      if (res[0] === 0 && !(res[1] & 128))
        throw new E("Invalid signature integer: unnecessary leading zero");
      return { d: b2n(res), l: data3.subarray(len + 2) };
    },
    toSig(hex) {
      const { Err: E } = DER;
      const data3 = typeof hex === "string" ? h2b(hex) : hex;
      if (!(data3 instanceof Uint8Array))
        throw new Error("ui8a expected");
      let l = data3.length;
      if (l < 2 || data3[0] != 48)
        throw new E("Invalid signature tag");
      if (data3[1] !== l - 2)
        throw new E("Invalid signature: incorrect length");
      const { d: r, l: sBytes } = DER._parseInt(data3.subarray(2));
      const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
      if (rBytesLeft.length)
        throw new E("Invalid signature: left bytes after parsing");
      return { r, s };
    },
    hexFromSig(sig) {
      const slice7 = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
      const h = (num) => {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      };
      const s = slice7(h(sig.s));
      const r = slice7(h(sig.r));
      const shl = s.length / 2;
      const rhl = r.length / 2;
      const sl = h(shl);
      const rl = h(rhl);
      return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
    }
  };
  _0n5 = BigInt(0);
  _1n5 = BigInt(1);
  _2n4 = BigInt(2);
  _3n2 = BigInt(3);
  _4n2 = BigInt(4);
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/@scure+bip32@1.3.2/node_modules/@noble/hashes/esm/hmac.js
class HMAC extends Hash {
  constructor(hash4, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash4);
    const key = toBytes3(_key);
    this.iHash = hash4.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad5 = new Uint8Array(blockLen);
    pad5.set(key.length > blockLen ? hash4.create().update(key).digest() : key);
    for (let i = 0;i < pad5.length; i++)
      pad5[i] ^= 54;
    this.iHash.update(pad5);
    this.oHash = hash4.create();
    for (let i = 0;i < pad5.length; i++)
      pad5[i] ^= 54 ^ 92;
    this.oHash.update(pad5);
    pad5.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
var hmac;
var init_hmac = __esm(() => {
  init__assert();
  init_utils2();
  hmac = (hash4, key, message) => new HMAC(hash4, key).update(message).digest();
  hmac.create = (hash4, key) => new HMAC(hash4, key);
});

// ../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash4) {
  return {
    hash: hash4,
    hmac: (key, ...msgs) => hmac(hash4, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash4) => weierstrass({ ...curveDef, ...getHash(hash4) });
  return Object.freeze({ ...create(defHash), create });
}
var init__shortw_utils = __esm(() => {
  init_hmac();
  init_utils2();
  init_weierstrass();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/@noble/curves/esm/secp256k1.js
var sqrtMod, secp256k1P, secp256k1N, _1n6, _2n5, divNearest, Fp, secp256k1, _0n6, Point;
var init_secp256k1 = __esm(() => {
  init_sha256();
  init_modular();
  init__shortw_utils();
  sqrtMod = function(y) {
    const P = secp256k1P;
    const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P;
    const b3 = b2 * b2 * y % P;
    const b6 = pow2(b3, _3n3, P) * b3 % P;
    const b9 = pow2(b6, _3n3, P) * b3 % P;
    const b11 = pow2(b9, _2n5, P) * b2 % P;
    const b22 = pow2(b11, _11n, P) * b11 % P;
    const b44 = pow2(b22, _22n, P) * b22 % P;
    const b88 = pow2(b44, _44n, P) * b44 % P;
    const b176 = pow2(b88, _88n, P) * b88 % P;
    const b220 = pow2(b176, _44n, P) * b44 % P;
    const b223 = pow2(b220, _3n3, P) * b3 % P;
    const t1 = pow2(b223, _23n, P) * b22 % P;
    const t2 = pow2(t1, _6n, P) * b2 % P;
    const root = pow2(t2, _2n5, P);
    if (!Fp.eql(Fp.sqr(root), y))
      throw new Error("Cannot find square root");
    return root;
  };
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
  secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
  _1n6 = BigInt(1);
  _2n5 = BigInt(2);
  divNearest = (a, b) => (a + b / _2n5) / b;
  Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
  secp256k1 = createCurve({
    a: BigInt(0),
    b: BigInt(7),
    Fp,
    n: secp256k1N,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: true,
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (k) => {
        const n = secp256k1N;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b2 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = mod(k - c1 * a1 - c2 * a2, n);
        let k2 = mod(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg)
          k1 = n - k1;
        if (k2neg)
          k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128) {
          throw new Error("splitScalar: Endomorphism failed, k=" + k);
        }
        return { k1neg, k1, k2neg, k2 };
      }
    }
  }, sha256);
  _0n6 = BigInt(0);
  Point = secp256k1.ProjectivePoint;
});

// ../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-helpers.js
var require_err_helpers = __commonJS((exports, module) => {
  var isErrorLike = (err) => {
    return err && typeof err.message === "string";
  };
  var getErrorCause = (err) => {
    if (!err)
      return;
    const cause = err.cause;
    if (typeof cause === "function") {
      const causeResult = err.cause();
      return isErrorLike(causeResult) ? causeResult : undefined;
    } else {
      return isErrorLike(cause) ? cause : undefined;
    }
  };
  var _stackWithCauses = (err, seen) => {
    if (!isErrorLike(err))
      return "";
    const stack = err.stack || "";
    if (seen.has(err)) {
      return stack + "\ncauses have become circular...";
    }
    const cause = getErrorCause(err);
    if (cause) {
      seen.add(err);
      return stack + "\ncaused by: " + _stackWithCauses(cause, seen);
    } else {
      return stack;
    }
  };
  var stackWithCauses = (err) => _stackWithCauses(err, new Set);
  var _messageWithCauses = (err, seen, skip) => {
    if (!isErrorLike(err))
      return "";
    const message = skip ? "" : err.message || "";
    if (seen.has(err)) {
      return message + ": ...";
    }
    const cause = getErrorCause(err);
    if (cause) {
      seen.add(err);
      const skipIfVErrorStyleCause = typeof err.cause === "function";
      return message + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
    } else {
      return message;
    }
  };
  var messageWithCauses = (err) => _messageWithCauses(err, new Set);
  module.exports = {
    isErrorLike,
    getErrorCause,
    stackWithCauses,
    messageWithCauses
  };
});

// ../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-proto.js
var require_err_proto = __commonJS((exports, module) => {
  var seen = Symbol("circular-ref-tag");
  var rawSymbol = Symbol("pino-raw-err-ref");
  var pinoErrProto = Object.create({}, {
    type: {
      enumerable: true,
      writable: true,
      value: undefined
    },
    message: {
      enumerable: true,
      writable: true,
      value: undefined
    },
    stack: {
      enumerable: true,
      writable: true,
      value: undefined
    },
    aggregateErrors: {
      enumerable: true,
      writable: true,
      value: undefined
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoErrProto, rawSymbol, {
    writable: true,
    value: {}
  });
  module.exports = {
    pinoErrProto,
    pinoErrorSymbols: {
      seen,
      rawSymbol
    }
  };
});

// ../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err.js
var require_err = __commonJS((exports, module) => {
  var errSerializer = function(err) {
    if (!isErrorLike(err)) {
      return err;
    }
    err[seen] = undefined;
    const _err = Object.create(pinoErrProto);
    _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
    _err.message = messageWithCauses(err);
    _err.stack = stackWithCauses(err);
    if (Array.isArray(err.errors)) {
      _err.aggregateErrors = err.errors.map((err2) => errSerializer(err2));
    }
    for (const key in err) {
      if (_err[key] === undefined) {
        const val = err[key];
        if (isErrorLike(val)) {
          if (key !== "cause" && !Object.prototype.hasOwnProperty.call(val, seen)) {
            _err[key] = errSerializer(val);
          }
        } else {
          _err[key] = val;
        }
      }
    }
    delete err[seen];
    _err.raw = err;
    return _err;
  };
  module.exports = errSerializer;
  var { messageWithCauses, stackWithCauses, isErrorLike } = require_err_helpers();
  var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
  var { seen } = pinoErrorSymbols;
  var { toString } = Object.prototype;
});

// ../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-with-cause.js
var require_err_with_cause = __commonJS((exports, module) => {
  var errWithCauseSerializer = function(err) {
    if (!isErrorLike(err)) {
      return err;
    }
    err[seen] = undefined;
    const _err = Object.create(pinoErrProto);
    _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
    _err.message = err.message;
    _err.stack = err.stack;
    if (Array.isArray(err.errors)) {
      _err.aggregateErrors = err.errors.map((err2) => errWithCauseSerializer(err2));
    }
    if (isErrorLike(err.cause) && !Object.prototype.hasOwnProperty.call(err.cause, seen)) {
      _err.cause = errWithCauseSerializer(err.cause);
    }
    for (const key in err) {
      if (_err[key] === undefined) {
        const val = err[key];
        if (isErrorLike(val)) {
          if (!Object.prototype.hasOwnProperty.call(val, seen)) {
            _err[key] = errWithCauseSerializer(val);
          }
        } else {
          _err[key] = val;
        }
      }
    }
    delete err[seen];
    _err.raw = err;
    return _err;
  };
  module.exports = errWithCauseSerializer;
  var { isErrorLike } = require_err_helpers();
  var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
  var { seen } = pinoErrorSymbols;
  var { toString } = Object.prototype;
});

// ../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/req.js
var require_req = __commonJS((exports, module) => {
  var reqSerializer = function(req) {
    const connection = req.info || req.socket;
    const _req = Object.create(pinoReqProto);
    _req.id = typeof req.id === "function" ? req.id() : req.id || (req.info ? req.info.id : undefined);
    _req.method = req.method;
    if (req.originalUrl) {
      _req.url = req.originalUrl;
    } else {
      const path = req.path;
      _req.url = typeof path === "string" ? path : req.url ? req.url.path || req.url : undefined;
    }
    if (req.query) {
      _req.query = req.query;
    }
    if (req.params) {
      _req.params = req.params;
    }
    _req.headers = req.headers;
    _req.remoteAddress = connection && connection.remoteAddress;
    _req.remotePort = connection && connection.remotePort;
    _req.raw = req.raw || req;
    return _req;
  };
  var mapHttpRequest = function(req) {
    return {
      req: reqSerializer(req)
    };
  };
  module.exports = {
    mapHttpRequest,
    reqSerializer
  };
  var rawSymbol = Symbol("pino-raw-req-ref");
  var pinoReqProto = Object.create({}, {
    id: {
      enumerable: true,
      writable: true,
      value: ""
    },
    method: {
      enumerable: true,
      writable: true,
      value: ""
    },
    url: {
      enumerable: true,
      writable: true,
      value: ""
    },
    query: {
      enumerable: true,
      writable: true,
      value: ""
    },
    params: {
      enumerable: true,
      writable: true,
      value: ""
    },
    headers: {
      enumerable: true,
      writable: true,
      value: {}
    },
    remoteAddress: {
      enumerable: true,
      writable: true,
      value: ""
    },
    remotePort: {
      enumerable: true,
      writable: true,
      value: ""
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoReqProto, rawSymbol, {
    writable: true,
    value: {}
  });
});

// ../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/res.js
var require_res = __commonJS((exports, module) => {
  var resSerializer = function(res) {
    const _res = Object.create(pinoResProto);
    _res.statusCode = res.headersSent ? res.statusCode : null;
    _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
    _res.raw = res;
    return _res;
  };
  var mapHttpResponse = function(res) {
    return {
      res: resSerializer(res)
    };
  };
  module.exports = {
    mapHttpResponse,
    resSerializer
  };
  var rawSymbol = Symbol("pino-raw-res-ref");
  var pinoResProto = Object.create({}, {
    statusCode: {
      enumerable: true,
      writable: true,
      value: 0
    },
    headers: {
      enumerable: true,
      writable: true,
      value: ""
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoResProto, rawSymbol, {
    writable: true,
    value: {}
  });
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/pino@8.18.0/node_modules/pino-std-serializers/index.js
var require_pino_std_serializers = __commonJS((exports, module) => {
  var errSerializer = require_err();
  var errWithCauseSerializer = require_err_with_cause();
  var reqSerializers = require_req();
  var resSerializers = require_res();
  module.exports = {
    err: errSerializer,
    errWithCause: errWithCauseSerializer,
    mapHttpRequest: reqSerializers.mapHttpRequest,
    mapHttpResponse: resSerializers.mapHttpResponse,
    req: reqSerializers.reqSerializer,
    res: resSerializers.resSerializer,
    wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
      if (customSerializer === errSerializer)
        return customSerializer;
      return function wrapErrSerializer(err) {
        return customSerializer(errSerializer(err));
      };
    },
    wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
      if (customSerializer === reqSerializers.reqSerializer)
        return customSerializer;
      return function wrappedReqSerializer(req) {
        return customSerializer(reqSerializers.reqSerializer(req));
      };
    },
    wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
      if (customSerializer === resSerializers.resSerializer)
        return customSerializer;
      return function wrappedResSerializer(res) {
        return customSerializer(resSerializers.resSerializer(res));
      };
    }
  };
});

// ../node_modules/.pnpm/pino@8.18.0/node_modules/pino/lib/caller.js
var require_caller = __commonJS((exports, module) => {
  var noOpPrepareStackTrace = function(_, stack) {
    return stack;
  };
  module.exports = function getCallers() {
    const originalPrepare = Error.prepareStackTrace;
    Error.prepareStackTrace = noOpPrepareStackTrace;
    const stack = new Error().stack;
    Error.prepareStackTrace = originalPrepare;
    if (!Array.isArray(stack)) {
      return;
    }
    const entries = stack.slice(2);
    const fileNames = [];
    for (const entry of entries) {
      if (!entry) {
        continue;
      }
      fileNames.push(entry.getFileName());
    }
    return fileNames;
  };
});

// ../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/validator.js
var require_validator = __commonJS((exports, module) => {
  var validator = function(opts = {}) {
    const {
      ERR_PATHS_MUST_BE_STRINGS = () => "fast-redact - Paths must be (non-empty) strings",
      ERR_INVALID_PATH = (s) => `fast-redact \u2013 Invalid path (${s})`
    } = opts;
    return function validate({ paths }) {
      paths.forEach((s) => {
        if (typeof s !== "string") {
          throw Error(ERR_PATHS_MUST_BE_STRINGS());
        }
        try {
          if (//.test(s))
            throw Error();
          const expr = (s[0] === "[" ? "" : ".") + s.replace(/^\*/, "\u3007").replace(/\.\*/g, ".\u3007").replace(/\[\*\]/g, "[\u3007]");
          if (/\n|\r|;/.test(expr))
            throw Error();
          if (/\/\*/.test(expr))
            throw Error();
          Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const \u3007 = null;
            o${expr}
            if ([o${expr}].length !== 1) throw Error()`)();
        } catch (e) {
          throw Error(ERR_INVALID_PATH(s));
        }
      });
    };
  };
  module.exports = validator;
});

// ../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/rx.js
var require_rx = __commonJS((exports, module) => {
  module.exports = /[^.[\]]+|\[((?:.)*?)\]/g;
});

// ../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var parse = function({ paths }) {
    const wildcards = [];
    var wcLen = 0;
    const secret = paths.reduce(function(o, strPath, ix) {
      var path = strPath.match(rx).map((p) => p.replace(/'|"|`/g, ""));
      const leadingBracket = strPath[0] === "[";
      path = path.map((p) => {
        if (p[0] === "[")
          return p.substr(1, p.length - 2);
        else
          return p;
      });
      const star = path.indexOf("*");
      if (star > -1) {
        const before = path.slice(0, star);
        const beforeStr = before.join(".");
        const after = path.slice(star + 1, path.length);
        const nested = after.length > 0;
        wcLen++;
        wildcards.push({
          before,
          beforeStr,
          after,
          nested
        });
      } else {
        o[strPath] = {
          path,
          val: undefined,
          precensored: false,
          circle: "",
          escPath: JSON.stringify(strPath),
          leadingBracket
        };
      }
      return o;
    }, {});
    return { wildcards, wcLen, secret };
  };
  var rx = require_rx();
  module.exports = parse;
});

// ../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/redactor.js
var require_redactor = __commonJS((exports, module) => {
  var redactor = function({ secret, serialize, wcLen, strict, isCensorFct, censorFctTakesPath }, state) {
    const redact = Function("o", `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize)}
    }
    const { censor, secret } = this
    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    ${resultTmpl(serialize)}
  `).bind(state);
    if (serialize === false) {
      redact.restore = (o) => state.restore(o);
    }
    return redact;
  };
  var redactTmpl = function(secret, isCensorFct, censorFctTakesPath) {
    return Object.keys(secret).map((path) => {
      const { escPath, leadingBracket, path: arrPath } = secret[path];
      const skip = leadingBracket ? 1 : 0;
      const delim = leadingBracket ? "" : ".";
      const hops = [];
      var match;
      while ((match = rx.exec(path)) !== null) {
        const [, ix] = match;
        const { index: index2, input } = match;
        if (index2 > skip)
          hops.push(input.substring(0, index2 - (ix ? 0 : 1)));
      }
      var existence = hops.map((p) => `o${delim}${p}`).join(" && ");
      if (existence.length === 0)
        existence += `o${delim}${path} != null`;
      else
        existence += ` && o${delim}${path} != null`;
      const circularDetection = `
      switch (true) {
        ${hops.reverse().map((p) => `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `).join("\n")}
      }
    `;
      const censorArgs = censorFctTakesPath ? `val, ${JSON.stringify(arrPath)}` : `val`;
      return `
      if (${existence}) {
        const val = o${delim}${path}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path} = ${isCensorFct ? `censor(${censorArgs})` : "censor"}
          ${circularDetection}
        }
      }
    `;
    }).join("\n");
  };
  var dynamicRedactTmpl = function(hasWildcards, isCensorFct, censorFctTakesPath) {
    return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  ` : "";
  };
  var resultTmpl = function(serialize) {
    return serialize === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
  };
  var strictImpl = function(strict, serialize) {
    return strict === true ? `throw Error('fast-redact: primitives cannot be redacted')` : serialize === false ? `return o` : `return this.serialize(o)`;
  };
  var rx = require_rx();
  module.exports = redactor;
});

// ../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/modifiers.js
var require_modifiers = __commonJS((exports, module) => {
  var groupRestore = function({ keys, values, target }) {
    if (target == null)
      return;
    const length = keys.length;
    for (var i = 0;i < length; i++) {
      const k = keys[i];
      target[k] = values[i];
    }
  };
  var groupRedact = function(o, path, censor, isCensorFct, censorFctTakesPath) {
    const target = get(o, path);
    if (target == null)
      return { keys: null, values: null, target: null, flat: true };
    const keys = Object.keys(target);
    const keysLength = keys.length;
    const pathLength = path.length;
    const pathWithKey = censorFctTakesPath ? [...path] : undefined;
    const values = new Array(keysLength);
    for (var i = 0;i < keysLength; i++) {
      const key = keys[i];
      values[i] = target[key];
      if (censorFctTakesPath) {
        pathWithKey[pathLength] = key;
        target[key] = censor(target[key], pathWithKey);
      } else if (isCensorFct) {
        target[key] = censor(target[key]);
      } else {
        target[key] = censor;
      }
    }
    return { keys, values, target, flat: true };
  };
  var nestedRestore = function(instructions) {
    for (let i = 0;i < instructions.length; i++) {
      const { target, path, value } = instructions[i];
      let current = target;
      for (let i2 = path.length - 1;i2 > 0; i2--) {
        current = current[path[i2]];
      }
      current[path[0]] = value;
    }
  };
  var nestedRedact = function(store, o, path, ns, censor, isCensorFct, censorFctTakesPath) {
    const target = get(o, path);
    if (target == null)
      return;
    const keys = Object.keys(target);
    const keysLength = keys.length;
    for (var i = 0;i < keysLength; i++) {
      const key = keys[i];
      specialSet(store, target, key, path, ns, censor, isCensorFct, censorFctTakesPath);
    }
    return store;
  };
  var has = function(obj, prop) {
    return obj !== undefined && obj !== null ? "hasOwn" in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop) : false;
  };
  var specialSet = function(store, o, k, path, afterPath, censor, isCensorFct, censorFctTakesPath) {
    const afterPathLen = afterPath.length;
    const lastPathIndex = afterPathLen - 1;
    const originalKey = k;
    var i = -1;
    var n;
    var nv;
    var ov;
    var oov = null;
    var wc = null;
    var kIsWc;
    var wcov;
    var consecutive = false;
    var level = 0;
    var depth = 0;
    var redactPathCurrent = tree();
    ov = n = o[k];
    if (typeof n !== "object")
      return;
    while (n != null && ++i < afterPathLen) {
      depth += 1;
      k = afterPath[i];
      oov = ov;
      if (k !== "*" && !wc && !(typeof n === "object" && (k in n))) {
        break;
      }
      if (k === "*") {
        if (wc === "*") {
          consecutive = true;
        }
        wc = k;
        if (i !== lastPathIndex) {
          continue;
        }
      }
      if (wc) {
        const wcKeys = Object.keys(n);
        for (var j = 0;j < wcKeys.length; j++) {
          const wck = wcKeys[j];
          wcov = n[wck];
          kIsWc = k === "*";
          if (consecutive) {
            redactPathCurrent = node8(redactPathCurrent, wck, depth);
            level = i;
            ov = iterateNthLevel(wcov, level - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, o[originalKey], depth + 1);
          } else {
            if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
              if (kIsWc) {
                ov = wcov;
              } else {
                ov = wcov[k];
              }
              nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
              if (kIsWc) {
                const rv = restoreInstr(node8(redactPathCurrent, wck, depth), ov, o[originalKey]);
                store.push(rv);
                n[wck] = nv;
              } else {
                if (wcov[k] === nv) {
                } else if (nv === undefined && censor !== undefined || has(wcov, k) && nv === ov) {
                  redactPathCurrent = node8(redactPathCurrent, wck, depth);
                } else {
                  redactPathCurrent = node8(redactPathCurrent, wck, depth);
                  const rv = restoreInstr(node8(redactPathCurrent, k, depth + 1), ov, o[originalKey]);
                  store.push(rv);
                  wcov[k] = nv;
                }
              }
            }
          }
        }
        wc = null;
      } else {
        ov = n[k];
        redactPathCurrent = node8(redactPathCurrent, k, depth);
        nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
        if (has(n, k) && nv === ov || nv === undefined && censor !== undefined) {
        } else {
          const rv = restoreInstr(redactPathCurrent, ov, o[originalKey]);
          store.push(rv);
          n[k] = nv;
        }
        n = n[k];
      }
      if (typeof n !== "object")
        break;
      if (ov === oov || typeof ov === "undefined") {
      }
    }
  };
  var get = function(o, p) {
    var i = -1;
    var l = p.length;
    var n = o;
    while (n != null && ++i < l) {
      n = n[p[i]];
    }
    return n;
  };
  var iterateNthLevel = function(wcov, level, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth) {
    if (level === 0) {
      if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
        if (kIsWc) {
          ov = wcov;
        } else {
          ov = wcov[k];
        }
        nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
        if (kIsWc) {
          const rv = restoreInstr(redactPathCurrent, ov, parent);
          store.push(rv);
          n[wck] = nv;
        } else {
          if (wcov[k] === nv) {
          } else if (nv === undefined && censor !== undefined || has(wcov, k) && nv === ov) {
          } else {
            const rv = restoreInstr(node8(redactPathCurrent, k, depth + 1), ov, parent);
            store.push(rv);
            wcov[k] = nv;
          }
        }
      }
    }
    for (const key in wcov) {
      if (typeof wcov[key] === "object") {
        redactPathCurrent = node8(redactPathCurrent, key, depth);
        iterateNthLevel(wcov[key], level - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth + 1);
      }
    }
  };
  var tree = function() {
    return { parent: null, key: null, children: [], depth: 0 };
  };
  var node8 = function(parent, key, depth) {
    if (parent.depth === depth) {
      return node8(parent.parent, key, depth);
    }
    var child = {
      parent,
      key,
      depth,
      children: []
    };
    parent.children.push(child);
    return child;
  };
  var restoreInstr = function(node9, value, target) {
    let current = node9;
    const path = [];
    do {
      path.push(current.key);
      current = current.parent;
    } while (current.parent != null);
    return { path, value, target };
  };
  module.exports = {
    groupRedact,
    groupRestore,
    nestedRedact,
    nestedRestore
  };
});

// ../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/restorer.js
var require_restorer = __commonJS((exports, module) => {
  var restorer = function({ secret, wcLen }) {
    return function compileRestore() {
      if (this.restore)
        return;
      const paths = Object.keys(secret);
      const resetters = resetTmpl(secret, paths);
      const hasWildcards = wcLen > 0;
      const state = hasWildcards ? { secret, groupRestore, nestedRestore } : { secret };
      this.restore = Function("o", restoreTmpl(resetters, paths, hasWildcards)).bind(state);
    };
  };
  var resetTmpl = function(secret, paths) {
    return paths.map((path) => {
      const { circle, escPath, leadingBracket } = secret[path];
      const delim = leadingBracket ? "" : ".";
      const reset = circle ? `o.${circle} = secret[${escPath}].val` : `o${delim}${path} = secret[${escPath}].val`;
      const clear = `secret[${escPath}].val = undefined`;
      return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset} } catch (e) {}
        ${clear}
      }
    `;
    }).join("");
  };
  var restoreTmpl = function(resetters, paths, hasWildcards) {
    const dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o.flat === true) this.groupRestore(o)
      else this.nestedRestore(o)
      secret[k] = null
    }
  ` : "";
    return `
    const secret = this.secret
    ${dynamicReset}
    ${resetters}
    return o
  `;
  };
  var { groupRestore, nestedRestore } = require_modifiers();
  module.exports = restorer;
});

// ../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/state.js
var require_state = __commonJS((exports, module) => {
  var state = function(o) {
    const {
      secret,
      censor,
      compileRestore,
      serialize,
      groupRedact,
      nestedRedact,
      wildcards,
      wcLen
    } = o;
    const builder = [{ secret, censor, compileRestore }];
    if (serialize !== false)
      builder.push({ serialize });
    if (wcLen > 0)
      builder.push({ groupRedact, nestedRedact, wildcards, wcLen });
    return Object.assign(...builder);
  };
  module.exports = state;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/pino@8.18.0/node_modules/fast-redact/index.js
var require_fast_redact = __commonJS((exports, module) => {
  var fastRedact = function(opts = {}) {
    const paths = Array.from(new Set(opts.paths || []));
    const serialize = "serialize" in opts ? opts.serialize === false ? opts.serialize : typeof opts.serialize === "function" ? opts.serialize : JSON.stringify : JSON.stringify;
    const remove = opts.remove;
    if (remove === true && serialize !== JSON.stringify) {
      throw Error("fast-redact \u2013 remove option may only be set when serializer is JSON.stringify");
    }
    const censor = remove === true ? undefined : ("censor" in opts) ? opts.censor : DEFAULT_CENSOR;
    const isCensorFct = typeof censor === "function";
    const censorFctTakesPath = isCensorFct && censor.length > 1;
    if (paths.length === 0)
      return serialize || noop;
    validate({ paths, serialize, censor });
    const { wildcards, wcLen, secret } = parse({ paths, censor });
    const compileRestore = restorer({ secret, wcLen });
    const strict = "strict" in opts ? opts.strict : true;
    return redactor({ secret, wcLen, serialize, strict, isCensorFct, censorFctTakesPath }, state({
      secret,
      censor,
      compileRestore,
      serialize,
      groupRedact,
      nestedRedact,
      wildcards,
      wcLen
    }));
  };
  var validator = require_validator();
  var parse = require_parse();
  var redactor = require_redactor();
  var restorer = require_restorer();
  var { groupRedact, nestedRedact } = require_modifiers();
  var state = require_state();
  var rx = require_rx();
  var validate = validator();
  var noop = (o) => o;
  noop.restore = noop;
  var DEFAULT_CENSOR = "[REDACTED]";
  fastRedact.rx = rx;
  fastRedact.validator = validator;
  module.exports = fastRedact;
});

// ../node_modules/.pnpm/pino@8.18.0/node_modules/pino/lib/symbols.js
var require_symbols = __commonJS((exports, module) => {
  var setLevelSym = Symbol("pino.setLevel");
  var getLevelSym = Symbol("pino.getLevel");
  var levelValSym = Symbol("pino.levelVal");
  var levelCompSym = Symbol("pino.levelComp");
  var useLevelLabelsSym = Symbol("pino.useLevelLabels");
  var useOnlyCustomLevelsSym = Symbol("pino.useOnlyCustomLevels");
  var mixinSym = Symbol("pino.mixin");
  var lsCacheSym = Symbol("pino.lsCache");
  var chindingsSym = Symbol("pino.chindings");
  var asJsonSym = Symbol("pino.asJson");
  var writeSym = Symbol("pino.write");
  var redactFmtSym = Symbol("pino.redactFmt");
  var timeSym = Symbol("pino.time");
  var timeSliceIndexSym = Symbol("pino.timeSliceIndex");
  var streamSym = Symbol("pino.stream");
  var stringifySym = Symbol("pino.stringify");
  var stringifySafeSym = Symbol("pino.stringifySafe");
  var stringifiersSym = Symbol("pino.stringifiers");
  var endSym = Symbol("pino.end");
  var formatOptsSym = Symbol("pino.formatOpts");
  var messageKeySym = Symbol("pino.messageKey");
  var errorKeySym = Symbol("pino.errorKey");
  var nestedKeySym = Symbol("pino.nestedKey");
  var nestedKeyStrSym = Symbol("pino.nestedKeyStr");
  var mixinMergeStrategySym = Symbol("pino.mixinMergeStrategy");
  var msgPrefixSym = Symbol("pino.msgPrefix");
  var wildcardFirstSym = Symbol("pino.wildcardFirst");
  var serializersSym = Symbol.for("pino.serializers");
  var formattersSym = Symbol.for("pino.formatters");
  var hooksSym = Symbol.for("pino.hooks");
  var needsMetadataGsym = Symbol.for("pino.metadata");
  module.exports = {
    setLevelSym,
    getLevelSym,
    levelValSym,
    levelCompSym,
    useLevelLabelsSym,
    mixinSym,
    lsCacheSym,
    chindingsSym,
    asJsonSym,
    writeSym,
    serializersSym,
    redactFmtSym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    stringifySym,
    stringifySafeSym,
    stringifiersSym,
    endSym,
    formatOptsSym,
    messageKeySym,
    errorKeySym,
    nestedKeySym,
    wildcardFirstSym,
    needsMetadataGsym,
    useOnlyCustomLevelsSym,
    formattersSym,
    hooksSym,
    nestedKeyStrSym,
    mixinMergeStrategySym,
    msgPrefixSym
  };
});

// ../node_modules/.pnpm/pino@8.18.0/node_modules/pino/lib/redaction.js
var require_redaction = __commonJS((exports, module) => {
  var redaction = function(opts, serialize) {
    const { paths, censor } = handle(opts);
    const shape = paths.reduce((o, str) => {
      rx.lastIndex = 0;
      const first = rx.exec(str);
      const next = rx.exec(str);
      let ns = first[1] !== undefined ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
      if (ns === "*") {
        ns = wildcardFirstSym;
      }
      if (next === null) {
        o[ns] = null;
        return o;
      }
      if (o[ns] === null) {
        return o;
      }
      const { index: index2 } = next;
      const nextPath = `${str.substr(index2, str.length - 1)}`;
      o[ns] = o[ns] || [];
      if (ns !== wildcardFirstSym && o[ns].length === 0) {
        o[ns].push(...o[wildcardFirstSym] || []);
      }
      if (ns === wildcardFirstSym) {
        Object.keys(o).forEach(function(k) {
          if (o[k]) {
            o[k].push(nextPath);
          }
        });
      }
      o[ns].push(nextPath);
      return o;
    }, {});
    const result = {
      [redactFmtSym]: fastRedact({ paths, censor, serialize, strict })
    };
    const topCensor = (...args) => {
      return typeof censor === "function" ? serialize(censor(...args)) : serialize(censor);
    };
    return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {
      if (shape[k] === null) {
        o[k] = (value) => topCensor(value, [k]);
      } else {
        const wrappedCensor = typeof censor === "function" ? (value, path) => {
          return censor(value, [k, ...path]);
        } : censor;
        o[k] = fastRedact({
          paths: shape[k],
          censor: wrappedCensor,
          serialize,
          strict
        });
      }
      return o;
    }, result);
  };
  var handle = function(opts) {
    if (Array.isArray(opts)) {
      opts = { paths: opts, censor: CENSOR };
      validate(opts);
      return opts;
    }
    let { paths, censor = CENSOR, remove } = opts;
    if (Array.isArray(paths) === false) {
      throw Error("pino \u2013 redact must contain an array of strings");
    }
    if (remove === true)
      censor = undefined;
    validate({ paths, censor });
    return { paths, censor };
  };
  var fastRedact = require_fast_redact();
  var { redactFmtSym, wildcardFirstSym } = require_symbols();
  var { rx, validator } = fastRedact;
  var validate = validator({
    ERR_PATHS_MUST_BE_STRINGS: () => "pino \u2013 redacted paths must be strings",
    ERR_INVALID_PATH: (s) => `pino \u2013 redact paths array contains an invalid path (${s})`
  });
  var CENSOR = "[Redacted]";
  var strict = false;
  module.exports = redaction;
});

// ../node_modules/.pnpm/pino@8.18.0/node_modules/pino/lib/time.js
var require_time2 = __commonJS((exports, module) => {
  var nullTime = () => "";
  var epochTime = () => `,"time":${Date.now()}`;
  var unixTime = () => `,"time":${Math.round(Date.now() / 1000)}`;
  var isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
  module.exports = { nullTime, epochTime, unixTime, isoTime };
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/pino@8.18.0/node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS((exports, module) => {
  var tryStringify = function(o) {
    try {
      return JSON.stringify(o);
    } catch (e) {
      return '"[Circular]"';
    }
  };
  var format3 = function(f, args, opts) {
    var ss = opts && opts.stringify || tryStringify;
    var offset = 1;
    if (typeof f === "object" && f !== null) {
      var len = args.length + offset;
      if (len === 1)
        return f;
      var objects = new Array(len);
      objects[0] = ss(f);
      for (var index2 = 1;index2 < len; index2++) {
        objects[index2] = ss(args[index2]);
      }
      return objects.join(" ");
    }
    if (typeof f !== "string") {
      return f;
    }
    var argLen = args.length;
    if (argLen === 0)
      return f;
    var str = "";
    var a = 1 - offset;
    var lastPos = -1;
    var flen = f && f.length || 0;
    for (var i = 0;i < flen; ) {
      if (f.charCodeAt(i) === 37 && i + 1 < flen) {
        lastPos = lastPos > -1 ? lastPos : 0;
        switch (f.charCodeAt(i + 1)) {
          case 100:
          case 102:
            if (a >= argLen)
              break;
            if (args[a] == null)
              break;
            if (lastPos < i)
              str += f.slice(lastPos, i);
            str += Number(args[a]);
            lastPos = i + 2;
            i++;
            break;
          case 105:
            if (a >= argLen)
              break;
            if (args[a] == null)
              break;
            if (lastPos < i)
              str += f.slice(lastPos, i);
            str += Math.floor(Number(args[a]));
            lastPos = i + 2;
            i++;
            break;
          case 79:
          case 111:
          case 106:
            if (a >= argLen)
              break;
            if (args[a] === undefined)
              break;
            if (lastPos < i)
              str += f.slice(lastPos, i);
            var type = typeof args[a];
            if (type === "string") {
              str += "\'" + args[a] + "\'";
              lastPos = i + 2;
              i++;
              break;
            }
            if (type === "function") {
              str += args[a].name || "<anonymous>";
              lastPos = i + 2;
              i++;
              break;
            }
            str += ss(args[a]);
            lastPos = i + 2;
            i++;
            break;
          case 115:
            if (a >= argLen)
              break;
            if (lastPos < i)
              str += f.slice(lastPos, i);
            str += String(args[a]);
            lastPos = i + 2;
            i++;
            break;
          case 37:
            if (lastPos < i)
              str += f.slice(lastPos, i);
            str += "%";
            lastPos = i + 2;
            i++;
            a--;
            break;
        }
        ++a;
      }
      ++i;
    }
    if (lastPos === -1)
      return f;
    else if (lastPos < flen) {
      str += f.slice(lastPos);
    }
    return str;
  };
  module.exports = format3;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/pino@8.18.0/node_modules/atomic-sleep/index.js
var require_atomic_sleep = __commonJS((exports, module) => {
  if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
    let sleep = function(ms) {
      const valid = ms > 0 && ms < Infinity;
      if (valid === false) {
        if (typeof ms !== "number" && typeof ms !== "bigint") {
          throw TypeError("sleep: ms must be a number");
        }
        throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      }
      Atomics.wait(nil, 0, 0, Number(ms));
    };
    const nil = new Int32Array(new SharedArrayBuffer(4));
    module.exports = sleep;
  } else {
    let sleep = function(ms) {
      const valid = ms > 0 && ms < Infinity;
      if (valid === false) {
        if (typeof ms !== "number" && typeof ms !== "bigint") {
          throw TypeError("sleep: ms must be a number");
        }
        throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      }
      const target = Date.now() + Number(ms);
      while (target > Date.now()) {
      }
    };
    module.exports = sleep;
  }
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/pino@8.18.0/node_modules/sonic-boom/index.js
var require_sonic_boom = __commonJS((exports, module) => {
  var openFile = function(file, sonic) {
    sonic._opening = true;
    sonic._writing = true;
    sonic._asyncDrainScheduled = false;
    function fileOpened(err, fd) {
      if (err) {
        sonic._reopening = false;
        sonic._writing = false;
        sonic._opening = false;
        if (sonic.sync) {
          process.nextTick(() => {
            if (sonic.listenerCount("error") > 0) {
              sonic.emit("error", err);
            }
          });
        } else {
          sonic.emit("error", err);
        }
        return;
      }
      sonic.fd = fd;
      sonic.file = file;
      sonic._reopening = false;
      sonic._opening = false;
      sonic._writing = false;
      if (sonic.sync) {
        process.nextTick(() => sonic.emit("ready"));
      } else {
        sonic.emit("ready");
      }
      if (sonic._reopening || sonic.destroyed) {
        return;
      }
      if (!sonic._writing && sonic._len > sonic.minLength || sonic._flushPending) {
        sonic._actualWrite();
      }
    }
    const flags = sonic.append ? "a" : "w";
    const mode = sonic.mode;
    if (sonic.sync) {
      try {
        if (sonic.mkdir)
          fs.mkdirSync(path.dirname(file), { recursive: true });
        const fd = fs.openSync(file, flags, mode);
        fileOpened(null, fd);
      } catch (err) {
        fileOpened(err);
        throw err;
      }
    } else if (sonic.mkdir) {
      fs.mkdir(path.dirname(file), { recursive: true }, (err) => {
        if (err)
          return fileOpened(err);
        fs.open(file, flags, mode, fileOpened);
      });
    } else {
      fs.open(file, flags, mode, fileOpened);
    }
  };
  var SonicBoom = function(opts) {
    if (!(this instanceof SonicBoom)) {
      return new SonicBoom(opts);
    }
    let { fd, dest, minLength, maxLength, maxWrite, sync: sync2, append = true, mkdir, retryEAGAIN, fsync, contentMode, mode } = opts || {};
    fd = fd || dest;
    this._len = 0;
    this.fd = -1;
    this._bufs = [];
    this._lens = [];
    this._writing = false;
    this._ending = false;
    this._reopening = false;
    this._asyncDrainScheduled = false;
    this._flushPending = false;
    this._hwm = Math.max(minLength || 0, 16387);
    this.file = null;
    this.destroyed = false;
    this.minLength = minLength || 0;
    this.maxLength = maxLength || 0;
    this.maxWrite = maxWrite || MAX_WRITE;
    this.sync = sync2 || false;
    this.writable = true;
    this._fsync = fsync || false;
    this.append = append || false;
    this.mode = mode;
    this.retryEAGAIN = retryEAGAIN || (() => true);
    this.mkdir = mkdir || false;
    let fsWriteSync;
    let fsWrite;
    if (contentMode === kContentModeBuffer) {
      this._writingBuf = kEmptyBuffer;
      this.write = writeBuffer;
      this.flush = flushBuffer;
      this.flushSync = flushBufferSync;
      this._actualWrite = actualWriteBuffer;
      fsWriteSync = () => fs.writeSync(this.fd, this._writingBuf);
      fsWrite = () => fs.write(this.fd, this._writingBuf, this.release);
    } else if (contentMode === undefined || contentMode === kContentModeUtf8) {
      this._writingBuf = "";
      this.write = write;
      this.flush = flush;
      this.flushSync = flushSync;
      this._actualWrite = actualWrite;
      fsWriteSync = () => fs.writeSync(this.fd, this._writingBuf, "utf8");
      fsWrite = () => fs.write(this.fd, this._writingBuf, "utf8", this.release);
    } else {
      throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`);
    }
    if (typeof fd === "number") {
      this.fd = fd;
      process.nextTick(() => this.emit("ready"));
    } else if (typeof fd === "string") {
      openFile(fd, this);
    } else {
      throw new Error("SonicBoom supports only file descriptors and files");
    }
    if (this.minLength >= this.maxWrite) {
      throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
    }
    this.release = (err, n) => {
      if (err) {
        if ((err.code === "EAGAIN" || err.code === "EBUSY") && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
          if (this.sync) {
            try {
              sleep(BUSY_WRITE_TIMEOUT);
              this.release(undefined, 0);
            } catch (err2) {
              this.release(err2);
            }
          } else {
            setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
          }
        } else {
          this._writing = false;
          this.emit("error", err);
        }
        return;
      }
      this.emit("write", n);
      const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
      this._len = releasedBufObj.len;
      this._writingBuf = releasedBufObj.writingBuf;
      if (this._writingBuf.length) {
        if (!this.sync) {
          fsWrite();
          return;
        }
        try {
          do {
            const n2 = fsWriteSync();
            const releasedBufObj2 = releaseWritingBuf(this._writingBuf, this._len, n2);
            this._len = releasedBufObj2.len;
            this._writingBuf = releasedBufObj2.writingBuf;
          } while (this._writingBuf.length);
        } catch (err2) {
          this.release(err2);
          return;
        }
      }
      if (this._fsync) {
        fs.fsyncSync(this.fd);
      }
      const len = this._len;
      if (this._reopening) {
        this._writing = false;
        this._reopening = false;
        this.reopen();
      } else if (len > this.minLength) {
        this._actualWrite();
      } else if (this._ending) {
        if (len > 0) {
          this._actualWrite();
        } else {
          this._writing = false;
          actualClose(this);
        }
      } else {
        this._writing = false;
        if (this.sync) {
          if (!this._asyncDrainScheduled) {
            this._asyncDrainScheduled = true;
            process.nextTick(emitDrain, this);
          }
        } else {
          this.emit("drain");
        }
      }
    };
    this.on("newListener", function(name) {
      if (name === "drain") {
        this._asyncDrainScheduled = false;
      }
    });
  };
  var releaseWritingBuf = function(writingBuf, len, n) {
    if (typeof writingBuf === "string" && Buffer.byteLength(writingBuf) !== n) {
      n = Buffer.from(writingBuf).subarray(0, n).toString().length;
    }
    len = Math.max(len - n, 0);
    writingBuf = writingBuf.slice(n);
    return { writingBuf, len };
  };
  var emitDrain = function(sonic) {
    const hasListeners = sonic.listenerCount("drain") > 0;
    if (!hasListeners)
      return;
    sonic._asyncDrainScheduled = false;
    sonic.emit("drain");
  };
  var mergeBuf = function(bufs, len) {
    if (bufs.length === 0) {
      return kEmptyBuffer;
    }
    if (bufs.length === 1) {
      return bufs[0];
    }
    return Buffer.concat(bufs, len);
  };
  var write = function(data3) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    const len = this._len + data3.length;
    const bufs = this._bufs;
    if (this.maxLength && len > this.maxLength) {
      this.emit("drop", data3);
      return this._len < this._hwm;
    }
    if (bufs.length === 0 || bufs[bufs.length - 1].length + data3.length > this.maxWrite) {
      bufs.push("" + data3);
    } else {
      bufs[bufs.length - 1] += data3;
    }
    this._len = len;
    if (!this._writing && this._len >= this.minLength) {
      this._actualWrite();
    }
    return this._len < this._hwm;
  };
  var writeBuffer = function(data3) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    const len = this._len + data3.length;
    const bufs = this._bufs;
    const lens = this._lens;
    if (this.maxLength && len > this.maxLength) {
      this.emit("drop", data3);
      return this._len < this._hwm;
    }
    if (bufs.length === 0 || lens[lens.length - 1] + data3.length > this.maxWrite) {
      bufs.push([data3]);
      lens.push(data3.length);
    } else {
      bufs[bufs.length - 1].push(data3);
      lens[lens.length - 1] += data3.length;
    }
    this._len = len;
    if (!this._writing && this._len >= this.minLength) {
      this._actualWrite();
    }
    return this._len < this._hwm;
  };
  var callFlushCallbackOnDrain = function(cb) {
    this._flushPending = true;
    const onDrain = () => {
      if (!this._fsync) {
        fs.fsync(this.fd, (err) => {
          this._flushPending = false;
          cb(err);
        });
      } else {
        this._flushPending = false;
        cb();
      }
      this.off("error", onError);
    };
    const onError = (err) => {
      this._flushPending = false;
      cb(err);
      this.off("drain", onDrain);
    };
    this.once("drain", onDrain);
    this.once("error", onError);
  };
  var flush = function(cb) {
    if (cb != null && typeof cb !== "function") {
      throw new Error("flush cb must be a function");
    }
    if (this.destroyed) {
      const error = new Error("SonicBoom destroyed");
      if (cb) {
        cb(error);
        return;
      }
      throw error;
    }
    if (this.minLength <= 0) {
      cb?.();
      return;
    }
    if (cb) {
      callFlushCallbackOnDrain.call(this, cb);
    }
    if (this._writing) {
      return;
    }
    if (this._bufs.length === 0) {
      this._bufs.push("");
    }
    this._actualWrite();
  };
  var flushBuffer = function(cb) {
    if (cb != null && typeof cb !== "function") {
      throw new Error("flush cb must be a function");
    }
    if (this.destroyed) {
      const error = new Error("SonicBoom destroyed");
      if (cb) {
        cb(error);
        return;
      }
      throw error;
    }
    if (this.minLength <= 0) {
      cb?.();
      return;
    }
    if (cb) {
      callFlushCallbackOnDrain.call(this, cb);
    }
    if (this._writing) {
      return;
    }
    if (this._bufs.length === 0) {
      this._bufs.push([]);
      this._lens.push(0);
    }
    this._actualWrite();
  };
  var flushSync = function() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this.fd < 0) {
      throw new Error("sonic boom is not ready yet");
    }
    if (!this._writing && this._writingBuf.length > 0) {
      this._bufs.unshift(this._writingBuf);
      this._writingBuf = "";
    }
    let buf = "";
    while (this._bufs.length || buf) {
      if (buf.length <= 0) {
        buf = this._bufs[0];
      }
      try {
        const n = fs.writeSync(this.fd, buf, "utf8");
        const releasedBufObj = releaseWritingBuf(buf, this._len, n);
        buf = releasedBufObj.writingBuf;
        this._len = releasedBufObj.len;
        if (buf.length <= 0) {
          this._bufs.shift();
        }
      } catch (err) {
        const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
        if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
          throw err;
        }
        sleep(BUSY_WRITE_TIMEOUT);
      }
    }
    try {
      fs.fsyncSync(this.fd);
    } catch {
    }
  };
  var flushBufferSync = function() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this.fd < 0) {
      throw new Error("sonic boom is not ready yet");
    }
    if (!this._writing && this._writingBuf.length > 0) {
      this._bufs.unshift([this._writingBuf]);
      this._writingBuf = kEmptyBuffer;
    }
    let buf = kEmptyBuffer;
    while (this._bufs.length || buf.length) {
      if (buf.length <= 0) {
        buf = mergeBuf(this._bufs[0], this._lens[0]);
      }
      try {
        const n = fs.writeSync(this.fd, buf);
        buf = buf.subarray(n);
        this._len = Math.max(this._len - n, 0);
        if (buf.length <= 0) {
          this._bufs.shift();
          this._lens.shift();
        }
      } catch (err) {
        const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
        if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
          throw err;
        }
        sleep(BUSY_WRITE_TIMEOUT);
      }
    }
  };
  var actualWrite = function() {
    const release = this.release;
    this._writing = true;
    this._writingBuf = this._writingBuf || this._bufs.shift() || "";
    if (this.sync) {
      try {
        const written = fs.writeSync(this.fd, this._writingBuf, "utf8");
        release(null, written);
      } catch (err) {
        release(err);
      }
    } else {
      fs.write(this.fd, this._writingBuf, "utf8", release);
    }
  };
  var actualWriteBuffer = function() {
    const release = this.release;
    this._writing = true;
    this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());
    if (this.sync) {
      try {
        const written = fs.writeSync(this.fd, this._writingBuf);
        release(null, written);
      } catch (err) {
        release(err);
      }
    } else {
      fs.write(this.fd, this._writingBuf, release);
    }
  };
  var actualClose = function(sonic) {
    if (sonic.fd === -1) {
      sonic.once("ready", actualClose.bind(null, sonic));
      return;
    }
    sonic.destroyed = true;
    sonic._bufs = [];
    sonic._lens = [];
    fs.fsync(sonic.fd, closeWrapped);
    function closeWrapped() {
      if (sonic.fd !== 1 && sonic.fd !== 2) {
        fs.close(sonic.fd, done);
      } else {
        done();
      }
    }
    function done(err) {
      if (err) {
        sonic.emit("error", err);
        return;
      }
      if (sonic._ending && !sonic._writing) {
        sonic.emit("finish");
      }
      sonic.emit("close");
    }
  };
  var fs = __require("fs");
  var EventEmitter = __require("events");
  var inherits = __require("util").inherits;
  var path = __require("path");
  var sleep = require_atomic_sleep();
  var BUSY_WRITE_TIMEOUT = 100;
  var kEmptyBuffer = Buffer.allocUnsafe(0);
  var MAX_WRITE = 16 * 1024;
  var kContentModeBuffer = "buffer";
  var kContentModeUtf8 = "utf8";
  inherits(SonicBoom, EventEmitter);
  SonicBoom.prototype.reopen = function(file) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this._opening) {
      this.once("ready", () => {
        this.reopen(file);
      });
      return;
    }
    if (this._ending) {
      return;
    }
    if (!this.file) {
      throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
    }
    this._reopening = true;
    if (this._writing) {
      return;
    }
    const fd = this.fd;
    this.once("ready", () => {
      if (fd !== this.fd) {
        fs.close(fd, (err) => {
          if (err) {
            return this.emit("error", err);
          }
        });
      }
    });
    openFile(file || this.file, this);
  };
  SonicBoom.prototype.end = function() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this._opening) {
      this.once("ready", () => {
        this.end();
      });
      return;
    }
    if (this._ending) {
      return;
    }
    this._ending = true;
    if (this._writing) {
      return;
    }
    if (this._len > 0 && this.fd >= 0) {
      this._actualWrite();
    } else {
      actualClose(this);
    }
  };
  SonicBoom.prototype.destroy = function() {
    if (this.destroyed) {
      return;
    }
    actualClose(this);
  };
  SonicBoom.SonicBoom = SonicBoom;
  SonicBoom.default = SonicBoom;
  module.exports = SonicBoom;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/pino@8.18.0/node_modules/on-exit-leak-free/index.js
var require_on_exit_leak_free = __commonJS((exports, module) => {
  var ensureRegistry = function() {
    if (registry === undefined) {
      registry = new FinalizationRegistry(clear);
    }
  };
  var install = function(event) {
    if (refs[event].length > 0) {
      return;
    }
    process.on(event, functions[event]);
  };
  var uninstall = function(event) {
    if (refs[event].length > 0) {
      return;
    }
    process.removeListener(event, functions[event]);
    if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
      registry = undefined;
    }
  };
  var onExit = function() {
    callRefs("exit");
  };
  var onBeforeExit = function() {
    callRefs("beforeExit");
  };
  var callRefs = function(event) {
    for (const ref of refs[event]) {
      const obj = ref.deref();
      const fn = ref.fn;
      if (obj !== undefined) {
        fn(obj, event);
      }
    }
    refs[event] = [];
  };
  var clear = function(ref) {
    for (const event of ["exit", "beforeExit"]) {
      const index2 = refs[event].indexOf(ref);
      refs[event].splice(index2, index2 + 1);
      uninstall(event);
    }
  };
  var _register = function(event, obj, fn) {
    if (obj === undefined) {
      throw new Error("the object can\'t be undefined");
    }
    install(event);
    const ref = new WeakRef(obj);
    ref.fn = fn;
    ensureRegistry();
    registry.register(obj, ref);
    refs[event].push(ref);
  };
  var register = function(obj, fn) {
    _register("exit", obj, fn);
  };
  var registerBeforeExit = function(obj, fn) {
    _register("beforeExit", obj, fn);
  };
  var unregister = function(obj) {
    if (registry === undefined) {
      return;
    }
    registry.unregister(obj);
    for (const event of ["exit", "beforeExit"]) {
      refs[event] = refs[event].filter((ref) => {
        const _obj = ref.deref();
        return _obj && _obj !== obj;
      });
      uninstall(event);
    }
  };
  var refs = {
    exit: [],
    beforeExit: []
  };
  var functions = {
    exit: onExit,
    beforeExit: onBeforeExit
  };
  var registry;
  module.exports = {
    register,
    registerBeforeExit,
    unregister
  };
});

// ../node_modules/.pnpm/thread-stream@2.4.1/node_modules/thread-stream/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "thread-stream",
    version: "2.4.1",
    description: "A streaming way to send data to a Node.js Worker Thread",
    main: "index.js",
    types: "index.d.ts",
    dependencies: {
      "real-require": "^0.2.0"
    },
    devDependencies: {
      "@types/node": "^20.1.0",
      "@types/tap": "^15.0.0",
      desm: "^1.3.0",
      fastbench: "^1.0.1",
      husky: "^8.0.1",
      "pino-elasticsearch": "^6.0.0",
      "sonic-boom": "^3.0.0",
      standard: "^17.0.0",
      tap: "^16.2.0",
      "ts-node": "^10.8.0",
      typescript: "^4.7.2",
      "why-is-node-running": "^2.2.2"
    },
    scripts: {
      test: "standard && npm run transpile && tap test/*.test.*js && tap --ts test/*.test.*ts",
      "test:ci": "standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts",
      "test:ci:js": "tap --no-check-coverage --coverage-report=lcovonly \"test/**/*.test.*js\"",
      "test:ci:ts": "tap --ts --no-check-coverage --coverage-report=lcovonly \"test/**/*.test.*ts\"",
      "test:yarn": "npm run transpile && tap \"test/**/*.test.js\" --no-check-coverage",
      transpile: "sh ./test/ts/transpile.sh",
      prepare: "husky install"
    },
    standard: {
      ignore: [
        "test/ts/**/*"
      ]
    },
    repository: {
      type: "git",
      url: "git+https://github.com/mcollina/thread-stream.git"
    },
    keywords: [
      "worker",
      "thread",
      "threads",
      "stream"
    ],
    author: "Matteo Collina <hello@matteocollina.com>",
    license: "MIT",
    bugs: {
      url: "https://github.com/mcollina/thread-stream/issues"
    },
    homepage: "https://github.com/mcollina/thread-stream#readme"
  };
});

// ../node_modules/.pnpm/thread-stream@2.4.1/node_modules/thread-stream/lib/wait.js
var require_wait = __commonJS((exports, module) => {
  var wait4 = function(state, index2, expected, timeout, done) {
    const max = Date.now() + timeout;
    let current = Atomics.load(state, index2);
    if (current === expected) {
      done(null, "ok");
      return;
    }
    let prior = current;
    const check = (backoff) => {
      if (Date.now() > max) {
        done(null, "timed-out");
      } else {
        setTimeout(() => {
          prior = current;
          current = Atomics.load(state, index2);
          if (current === prior) {
            check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
          } else {
            if (current === expected)
              done(null, "ok");
            else
              done(null, "not-equal");
          }
        }, backoff);
      }
    };
    check(1);
  };
  var waitDiff = function(state, index2, expected, timeout, done) {
    const max = Date.now() + timeout;
    let current = Atomics.load(state, index2);
    if (current !== expected) {
      done(null, "ok");
      return;
    }
    const check = (backoff) => {
      if (Date.now() > max) {
        done(null, "timed-out");
      } else {
        setTimeout(() => {
          current = Atomics.load(state, index2);
          if (current !== expected) {
            done(null, "ok");
          } else {
            check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
          }
        }, backoff);
      }
    };
    check(1);
  };
  var MAX_TIMEOUT = 1000;
  module.exports = { wait: wait4, waitDiff };
});

// ../node_modules/.pnpm/thread-stream@2.4.1/node_modules/thread-stream/lib/indexes.js
var require_indexes = __commonJS((exports, module) => {
  var WRITE_INDEX = 4;
  var READ_INDEX = 8;
  module.exports = {
    WRITE_INDEX,
    READ_INDEX
  };
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/pino@8.18.0/node_modules/thread-stream/index.js
var require_thread_stream = __commonJS((exports, module) => {
  var createWorker = function(stream, opts) {
    const { filename, workerData } = opts;
    const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
    const toExecute = bundlerOverrides["thread-stream-worker"] || join(__dirname, "lib", "worker.js");
    const worker = new Worker(toExecute, {
      ...opts.workerOpts,
      trackUnmanagedFds: false,
      workerData: {
        filename: filename.indexOf("file://") === 0 ? filename : pathToFileURL(filename).href,
        dataBuf: stream[kImpl].dataBuf,
        stateBuf: stream[kImpl].stateBuf,
        workerData: {
          $context: {
            threadStreamVersion: version3
          },
          ...workerData
        }
      }
    });
    worker.stream = new FakeWeakRef(stream);
    worker.on("message", onWorkerMessage);
    worker.on("exit", onWorkerExit);
    registry.register(stream, worker);
    return worker;
  };
  var drain = function(stream) {
    assert(!stream[kImpl].sync);
    if (stream[kImpl].needDrain) {
      stream[kImpl].needDrain = false;
      stream.emit("drain");
    }
  };
  var nextFlush = function(stream) {
    const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    let leftover = stream[kImpl].data.length - writeIndex;
    if (leftover > 0) {
      if (stream[kImpl].buf.length === 0) {
        stream[kImpl].flushing = false;
        if (stream[kImpl].ending) {
          end(stream);
        } else if (stream[kImpl].needDrain) {
          process.nextTick(drain, stream);
        }
        return;
      }
      let toWrite = stream[kImpl].buf.slice(0, leftover);
      let toWriteBytes = Buffer.byteLength(toWrite);
      if (toWriteBytes <= leftover) {
        stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
        write(stream, toWrite, nextFlush.bind(null, stream));
      } else {
        stream.flush(() => {
          if (stream.destroyed) {
            return;
          }
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          while (toWriteBytes > stream[kImpl].data.length) {
            leftover = leftover / 2;
            toWrite = stream[kImpl].buf.slice(0, leftover);
            toWriteBytes = Buffer.byteLength(toWrite);
          }
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, nextFlush.bind(null, stream));
        });
      }
    } else if (leftover === 0) {
      if (writeIndex === 0 && stream[kImpl].buf.length === 0) {
        return;
      }
      stream.flush(() => {
        Atomics.store(stream[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
        nextFlush(stream);
      });
    } else {
      destroy(stream, new Error("overwritten"));
    }
  };
  var onWorkerMessage = function(msg) {
    const stream = this.stream.deref();
    if (stream === undefined) {
      this.exited = true;
      this.terminate();
      return;
    }
    switch (msg.code) {
      case "READY":
        this.stream = new WeakRef2(stream);
        stream.flush(() => {
          stream[kImpl].ready = true;
          stream.emit("ready");
        });
        break;
      case "ERROR":
        destroy(stream, msg.err);
        break;
      case "EVENT":
        if (Array.isArray(msg.args)) {
          stream.emit(msg.name, ...msg.args);
        } else {
          stream.emit(msg.name, msg.args);
        }
        break;
      case "WARNING":
        process.emitWarning(msg.err);
        break;
      default:
        destroy(stream, new Error("this should not happen: " + msg.code));
    }
  };
  var onWorkerExit = function(code) {
    const stream = this.stream.deref();
    if (stream === undefined) {
      return;
    }
    registry.unregister(stream);
    stream.worker.exited = true;
    stream.worker.off("exit", onWorkerExit);
    destroy(stream, code !== 0 ? new Error("the worker thread exited") : null);
  };
  var error = function(stream, err) {
    setImmediate(() => {
      stream.emit("error", err);
    });
  };
  var destroy = function(stream, err) {
    if (stream[kImpl].destroyed) {
      return;
    }
    stream[kImpl].destroyed = true;
    if (err) {
      stream[kImpl].errored = err;
      error(stream, err);
    }
    if (!stream.worker.exited) {
      stream.worker.terminate().catch(() => {
      }).then(() => {
        stream[kImpl].closed = true;
        stream.emit("close");
      });
    } else {
      setImmediate(() => {
        stream[kImpl].closed = true;
        stream.emit("close");
      });
    }
  };
  var write = function(stream, data3, cb) {
    const current = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    const length = Buffer.byteLength(data3);
    stream[kImpl].data.write(data3, current);
    Atomics.store(stream[kImpl].state, WRITE_INDEX, current + length);
    Atomics.notify(stream[kImpl].state, WRITE_INDEX);
    cb();
    return true;
  };
  var end = function(stream) {
    if (stream[kImpl].ended || !stream[kImpl].ending || stream[kImpl].flushing) {
      return;
    }
    stream[kImpl].ended = true;
    try {
      stream.flushSync();
      let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
      Atomics.store(stream[kImpl].state, WRITE_INDEX, -1);
      Atomics.notify(stream[kImpl].state, WRITE_INDEX);
      let spins = 0;
      while (readIndex !== -1) {
        Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1000);
        readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        if (readIndex === -2) {
          destroy(stream, new Error("end() failed"));
          return;
        }
        if (++spins === 10) {
          destroy(stream, new Error("end() took too long (10s)"));
          return;
        }
      }
      process.nextTick(() => {
        stream[kImpl].finished = true;
        stream.emit("finish");
      });
    } catch (err) {
      destroy(stream, err);
    }
  };
  var writeSync = function(stream) {
    const cb = () => {
      if (stream[kImpl].ending) {
        end(stream);
      } else if (stream[kImpl].needDrain) {
        process.nextTick(drain, stream);
      }
    };
    stream[kImpl].flushing = false;
    while (stream[kImpl].buf.length !== 0) {
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let leftover = stream[kImpl].data.length - writeIndex;
      if (leftover === 0) {
        flushSync(stream);
        Atomics.store(stream[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
        continue;
      } else if (leftover < 0) {
        throw new Error("overwritten");
      }
      let toWrite = stream[kImpl].buf.slice(0, leftover);
      let toWriteBytes = Buffer.byteLength(toWrite);
      if (toWriteBytes <= leftover) {
        stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
        write(stream, toWrite, cb);
      } else {
        flushSync(stream);
        Atomics.store(stream[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
        while (toWriteBytes > stream[kImpl].buf.length) {
          leftover = leftover / 2;
          toWrite = stream[kImpl].buf.slice(0, leftover);
          toWriteBytes = Buffer.byteLength(toWrite);
        }
        stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
        write(stream, toWrite, cb);
      }
    }
  };
  var flushSync = function(stream) {
    if (stream[kImpl].flushing) {
      throw new Error("unable to flush while flushing");
    }
    const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    let spins = 0;
    while (true) {
      const readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
      if (readIndex === -2) {
        throw Error("_flushSync failed");
      }
      if (readIndex !== writeIndex) {
        Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1000);
      } else {
        break;
      }
      if (++spins === 10) {
        throw new Error("_flushSync took too long (10s)");
      }
    }
  };
  var __dirname = "/home/mous/work/pimlico/alto/node_modules/.pnpm/thread-stream@2.4.1/node_modules/thread-stream";
  var { version: version3 } = require_package2();
  var { EventEmitter } = __require("events");
  var { Worker } = __require("worker_threads");
  var { join } = __require("path");
  var { pathToFileURL } = __require("url");
  var { wait: wait4 } = require_wait();
  var {
    WRITE_INDEX,
    READ_INDEX
  } = require_indexes();
  var buffer2 = __require("buffer");
  var assert = __require("assert");
  var kImpl = Symbol("kImpl");
  var MAX_STRING = buffer2.constants.MAX_STRING_LENGTH;

  class FakeWeakRef {
    constructor(value) {
      this._value = value;
    }
    deref() {
      return this._value;
    }
  }

  class FakeFinalizationRegistry {
    register() {
    }
    unregister() {
    }
  }
  var FinalizationRegistry2 = process.env.NODE_V8_COVERAGE ? FakeFinalizationRegistry : global.FinalizationRegistry || FakeFinalizationRegistry;
  var WeakRef2 = process.env.NODE_V8_COVERAGE ? FakeWeakRef : global.WeakRef || FakeWeakRef;
  var registry = new FinalizationRegistry2((worker) => {
    if (worker.exited) {
      return;
    }
    worker.terminate();
  });

  class ThreadStream extends EventEmitter {
    constructor(opts = {}) {
      super();
      if (opts.bufferSize < 4) {
        throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
      }
      this[kImpl] = {};
      this[kImpl].stateBuf = new SharedArrayBuffer(128);
      this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
      this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
      this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
      this[kImpl].sync = opts.sync || false;
      this[kImpl].ending = false;
      this[kImpl].ended = false;
      this[kImpl].needDrain = false;
      this[kImpl].destroyed = false;
      this[kImpl].flushing = false;
      this[kImpl].ready = false;
      this[kImpl].finished = false;
      this[kImpl].errored = null;
      this[kImpl].closed = false;
      this[kImpl].buf = "";
      this.worker = createWorker(this, opts);
    }
    write(data3) {
      if (this[kImpl].destroyed) {
        error(this, new Error("the worker has exited"));
        return false;
      }
      if (this[kImpl].ending) {
        error(this, new Error("the worker is ending"));
        return false;
      }
      if (this[kImpl].flushing && this[kImpl].buf.length + data3.length >= MAX_STRING) {
        try {
          writeSync(this);
          this[kImpl].flushing = true;
        } catch (err) {
          destroy(this, err);
          return false;
        }
      }
      this[kImpl].buf += data3;
      if (this[kImpl].sync) {
        try {
          writeSync(this);
          return true;
        } catch (err) {
          destroy(this, err);
          return false;
        }
      }
      if (!this[kImpl].flushing) {
        this[kImpl].flushing = true;
        setImmediate(nextFlush, this);
      }
      this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
      return !this[kImpl].needDrain;
    }
    end() {
      if (this[kImpl].destroyed) {
        return;
      }
      this[kImpl].ending = true;
      end(this);
    }
    flush(cb) {
      if (this[kImpl].destroyed) {
        if (typeof cb === "function") {
          process.nextTick(cb, new Error("the worker has exited"));
        }
        return;
      }
      const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
      wait4(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err, res) => {
        if (err) {
          destroy(this, err);
          process.nextTick(cb, err);
          return;
        }
        if (res === "not-equal") {
          this.flush(cb);
          return;
        }
        process.nextTick(cb);
      });
    }
    flushSync() {
      if (this[kImpl].destroyed) {
        return;
      }
      writeSync(this);
      flushSync(this);
    }
    unref() {
      this.worker.unref();
    }
    ref() {
      this.worker.ref();
    }
    get ready() {
      return this[kImpl].ready;
    }
    get destroyed() {
      return this[kImpl].destroyed;
    }
    get closed() {
      return this[kImpl].closed;
    }
    get writable() {
      return !this[kImpl].destroyed && !this[kImpl].ending;
    }
    get writableEnded() {
      return this[kImpl].ending;
    }
    get writableFinished() {
      return this[kImpl].finished;
    }
    get writableNeedDrain() {
      return this[kImpl].needDrain;
    }
    get writableObjectMode() {
      return false;
    }
    get writableErrored() {
      return this[kImpl].errored;
    }
  }
  module.exports = ThreadStream;
});

// ../node_modules/.pnpm/pino@8.18.0/node_modules/pino/lib/transport.js
var require_transport = __commonJS((exports, module) => {
  var setupOnExit = function(stream) {
    onExit.register(stream, autoEnd);
    onExit.registerBeforeExit(stream, flush);
    stream.on("close", function() {
      onExit.unregister(stream);
    });
  };
  var buildStream = function(filename, workerData, workerOpts) {
    const stream = new ThreadStream({
      filename,
      workerData,
      workerOpts
    });
    stream.on("ready", onReady);
    stream.on("close", function() {
      process.removeListener("exit", onExit2);
    });
    process.on("exit", onExit2);
    function onReady() {
      process.removeListener("exit", onExit2);
      stream.unref();
      if (workerOpts.autoEnd !== false) {
        setupOnExit(stream);
      }
    }
    function onExit2() {
      if (stream.closed) {
        return;
      }
      stream.flushSync();
      sleep(100);
      stream.end();
    }
    return stream;
  };
  var autoEnd = function(stream) {
    stream.ref();
    stream.flushSync();
    stream.end();
    stream.once("close", function() {
      stream.unref();
    });
  };
  var flush = function(stream) {
    stream.flushSync();
  };
  var transport = function(fullOptions) {
    const { pipeline, targets, levels, dedupe, options = {}, worker = {}, caller = getCallers() } = fullOptions;
    const callers = typeof caller === "string" ? [caller] : caller;
    const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
    let target = fullOptions.target;
    if (target && targets) {
      throw new Error("only one of target or targets can be specified");
    }
    if (targets) {
      target = bundlerOverrides["pino-worker"] || join(__dirname, "worker.js");
      options.targets = targets.map((dest) => {
        return {
          ...dest,
          target: fixTarget(dest.target)
        };
      });
    } else if (pipeline) {
      target = bundlerOverrides["pino-pipeline-worker"] || join(__dirname, "worker-pipeline.js");
      options.targets = pipeline.map((dest) => {
        return {
          ...dest,
          target: fixTarget(dest.target)
        };
      });
    }
    if (levels) {
      options.levels = levels;
    }
    if (dedupe) {
      options.dedupe = dedupe;
    }
    return buildStream(fixTarget(target), options, worker);
    function fixTarget(origin) {
      origin = bundlerOverrides[origin] || origin;
      if (isAbsolute(origin) || origin.indexOf("file://") === 0) {
        return origin;
      }
      if (origin === "pino/file") {
        return join(__dirname, "..", "file.js");
      }
      let fixTarget2;
      for (const filePath of callers) {
        try {
          const context = filePath === "node:repl" ? process.cwd() + sep : filePath;
          fixTarget2 = createRequire2(context).resolve(origin);
          break;
        } catch (err) {
          continue;
        }
      }
      if (!fixTarget2) {
        throw new Error(`unable to determine transport target for "${origin}"`);
      }
      return fixTarget2;
    }
  };
  var __dirname = "/home/mous/work/pimlico/alto/node_modules/.pnpm/pino@8.18.0/node_modules/pino/lib";
  var { createRequire: createRequire2 } = __require("module");
  var getCallers = require_caller();
  var { join, isAbsolute, sep } = __require("path");
  var sleep = require_atomic_sleep();
  var onExit = require_on_exit_leak_free();
  var ThreadStream = require_thread_stream();
  module.exports = transport;
});

// ../node_modules/.pnpm/pino@8.18.0/node_modules/pino/lib/tools.js
var require_tools = __commonJS((exports, module) => {
  var noop = function() {
  };
  var genLog = function(level, hook) {
    if (!hook)
      return LOG;
    return function hookWrappedLog(...args) {
      hook.call(this, args, LOG, level);
    };
    function LOG(o, ...n) {
      if (typeof o === "object") {
        let msg = o;
        if (o !== null) {
          if (o.method && o.headers && o.socket) {
            o = mapHttpRequest(o);
          } else if (typeof o.setHeader === "function") {
            o = mapHttpResponse(o);
          }
        }
        let formatParams;
        if (msg === null && n.length === 0) {
          formatParams = [null];
        } else {
          msg = n.shift();
          formatParams = n;
        }
        if (typeof this[msgPrefixSym] === "string" && msg !== undefined && msg !== null) {
          msg = this[msgPrefixSym] + msg;
        }
        this[writeSym](o, format3(msg, formatParams, this[formatOptsSym]), level);
      } else {
        let msg = o === undefined ? n.shift() : o;
        if (typeof this[msgPrefixSym] === "string" && msg !== undefined && msg !== null) {
          msg = this[msgPrefixSym] + msg;
        }
        this[writeSym](null, format3(msg, n, this[formatOptsSym]), level);
      }
    }
  };
  var asString = function(str) {
    let result = "";
    let last = 0;
    let found = false;
    let point = 255;
    const l = str.length;
    if (l > 100) {
      return JSON.stringify(str);
    }
    for (var i = 0;i < l && point >= 32; i++) {
      point = str.charCodeAt(i);
      if (point === 34 || point === 92) {
        result += str.slice(last, i) + "\\";
        last = i;
        found = true;
      }
    }
    if (!found) {
      result = str;
    } else {
      result += str.slice(last);
    }
    return point < 32 ? JSON.stringify(str) : '"' + result + '"';
  };
  var asJson = function(obj, msg, num, time) {
    const stringify15 = this[stringifySym];
    const stringifySafe = this[stringifySafeSym];
    const stringifiers = this[stringifiersSym];
    const end = this[endSym];
    const chindings = this[chindingsSym];
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const messageKey = this[messageKeySym];
    const errorKey = this[errorKeySym];
    let data3 = this[lsCacheSym][num] + time;
    data3 = data3 + chindings;
    let value;
    if (formatters.log) {
      obj = formatters.log(obj);
    }
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    let propStr = "";
    for (const key in obj) {
      value = obj[key];
      if (Object.prototype.hasOwnProperty.call(obj, key) && value !== undefined) {
        if (serializers[key]) {
          value = serializers[key](value);
        } else if (key === errorKey && serializers.err) {
          value = serializers.err(value);
        }
        const stringifier = stringifiers[key] || wildcardStringifier;
        switch (typeof value) {
          case "undefined":
          case "function":
            continue;
          case "number":
            if (Number.isFinite(value) === false) {
              value = null;
            }
          case "boolean":
            if (stringifier)
              value = stringifier(value);
            break;
          case "string":
            value = (stringifier || asString)(value);
            break;
          default:
            value = (stringifier || stringify15)(value, stringifySafe);
        }
        if (value === undefined)
          continue;
        const strKey = asString(key);
        propStr += "," + strKey + ":" + value;
      }
    }
    let msgStr = "";
    if (msg !== undefined) {
      value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
      const stringifier = stringifiers[messageKey] || wildcardStringifier;
      switch (typeof value) {
        case "function":
          break;
        case "number":
          if (Number.isFinite(value) === false) {
            value = null;
          }
        case "boolean":
          if (stringifier)
            value = stringifier(value);
          msgStr = ',"' + messageKey + '":' + value;
          break;
        case "string":
          value = (stringifier || asString)(value);
          msgStr = ',"' + messageKey + '":' + value;
          break;
        default:
          value = (stringifier || stringify15)(value, stringifySafe);
          msgStr = ',"' + messageKey + '":' + value;
      }
    }
    if (this[nestedKeySym] && propStr) {
      return data3 + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end;
    } else {
      return data3 + propStr + msgStr + end;
    }
  };
  var asChindings = function(instance, bindings) {
    let value;
    let data3 = instance[chindingsSym];
    const stringify15 = instance[stringifySym];
    const stringifySafe = instance[stringifySafeSym];
    const stringifiers = instance[stringifiersSym];
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    const serializers = instance[serializersSym];
    const formatter5 = instance[formattersSym].bindings;
    bindings = formatter5(bindings);
    for (const key in bindings) {
      value = bindings[key];
      const valid = key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels" && bindings.hasOwnProperty(key) && value !== undefined;
      if (valid === true) {
        value = serializers[key] ? serializers[key](value) : value;
        value = (stringifiers[key] || wildcardStringifier || stringify15)(value, stringifySafe);
        if (value === undefined)
          continue;
        data3 += ',"' + key + '":' + value;
      }
    }
    return data3;
  };
  var hasBeenTampered = function(stream) {
    return stream.write !== stream.constructor.prototype.write;
  };
  var buildSafeSonicBoom = function(opts) {
    const stream = new SonicBoom(opts);
    stream.on("error", filterBrokenPipe);
    if (!hasNodeCodeCoverage && !opts.sync && isMainThread) {
      onExit.register(stream, autoEnd);
      stream.on("close", function() {
        onExit.unregister(stream);
      });
    }
    return stream;
    function filterBrokenPipe(err) {
      if (err.code === "EPIPE") {
        stream.write = noop;
        stream.end = noop;
        stream.flushSync = noop;
        stream.destroy = noop;
        return;
      }
      stream.removeListener("error", filterBrokenPipe);
      stream.emit("error", err);
    }
  };
  var autoEnd = function(stream, eventName) {
    if (stream.destroyed) {
      return;
    }
    if (eventName === "beforeExit") {
      stream.flush();
      stream.on("drain", function() {
        stream.end();
      });
    } else {
      stream.flushSync();
    }
  };
  var createArgsNormalizer = function(defaultOptions) {
    return function normalizeArgs(instance, caller, opts = {}, stream) {
      if (typeof opts === "string") {
        stream = buildSafeSonicBoom({ dest: opts });
        opts = {};
      } else if (typeof stream === "string") {
        if (opts && opts.transport) {
          throw Error("only one of option.transport or stream can be specified");
        }
        stream = buildSafeSonicBoom({ dest: stream });
      } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
        stream = opts;
        opts = {};
      } else if (opts.transport) {
        if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
          throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
        }
        if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === "function") {
          throw Error("option.transport.targets do not allow custom level formatters");
        }
        let customLevels;
        if (opts.customLevels) {
          customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
        }
        stream = transport({ caller, ...opts.transport, levels: customLevels });
      }
      opts = Object.assign({}, defaultOptions, opts);
      opts.serializers = Object.assign({}, defaultOptions.serializers, opts.serializers);
      opts.formatters = Object.assign({}, defaultOptions.formatters, opts.formatters);
      if (opts.prettyPrint) {
        throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
      }
      const { enabled, onChild } = opts;
      if (enabled === false)
        opts.level = "silent";
      if (!onChild)
        opts.onChild = noop;
      if (!stream) {
        if (!hasBeenTampered(process.stdout)) {
          stream = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
        } else {
          stream = process.stdout;
        }
      }
      return { opts, stream };
    };
  };
  var stringify14 = function(obj, stringifySafeFn) {
    try {
      return JSON.stringify(obj);
    } catch (_) {
      try {
        const stringify15 = stringifySafeFn || this[stringifySafeSym];
        return stringify15(obj);
      } catch (_2) {
        return '"[unable to serialize, circular reference is too complex to analyze]"';
      }
    }
  };
  var buildFormatters = function(level, bindings, log7) {
    return {
      level,
      bindings,
      log: log7
    };
  };
  var normalizeDestFileDescriptor = function(destination) {
    const fd = Number(destination);
    if (typeof destination === "string" && Number.isFinite(fd)) {
      return fd;
    }
    if (destination === undefined) {
      return 1;
    }
    return destination;
  };
  var format3 = require_quick_format_unescaped();
  var { mapHttpRequest, mapHttpResponse } = require_pino_std_serializers();
  var SonicBoom = require_sonic_boom();
  var onExit = require_on_exit_leak_free();
  var {
    lsCacheSym,
    chindingsSym,
    writeSym,
    serializersSym,
    formatOptsSym,
    endSym,
    stringifiersSym,
    stringifySym,
    stringifySafeSym,
    wildcardFirstSym,
    nestedKeySym,
    formattersSym,
    messageKeySym,
    errorKeySym,
    nestedKeyStrSym,
    msgPrefixSym
  } = require_symbols();
  var { isMainThread } = __require("worker_threads");
  var transport = require_transport();
  var hasNodeCodeCoverage = process.env.NODE_V8_COVERAGE || process.env.V8_COVERAGE;
  module.exports = {
    noop,
    buildSafeSonicBoom,
    asChindings,
    asJson,
    genLog,
    createArgsNormalizer,
    stringify: stringify14,
    buildFormatters,
    normalizeDestFileDescriptor
  };
});

// ../node_modules/.pnpm/pino@8.18.0/node_modules/pino/lib/constants.js
var require_constants3 = __commonJS((exports, module) => {
  var DEFAULT_LEVELS = {
    trace: 10,
    debug: 20,
    info: 30,
    warn: 40,
    error: 50,
    fatal: 60
  };
  var SORTING_ORDER = {
    ASC: "ASC",
    DESC: "DESC"
  };
  module.exports = {
    DEFAULT_LEVELS,
    SORTING_ORDER
  };
});

// ../node_modules/.pnpm/pino@8.18.0/node_modules/pino/lib/levels.js
var require_levels = __commonJS((exports, module) => {
  var genLsCache = function(instance) {
    const formatter5 = instance[formattersSym].level;
    const { labels } = instance.levels;
    const cache = {};
    for (const label in labels) {
      const level = formatter5(labels[label], Number(label));
      cache[label] = JSON.stringify(level).slice(0, -1);
    }
    instance[lsCacheSym] = cache;
    return instance;
  };
  var isStandardLevel = function(level, useOnlyCustomLevels) {
    if (useOnlyCustomLevels) {
      return false;
    }
    switch (level) {
      case "fatal":
      case "error":
      case "warn":
      case "info":
      case "debug":
      case "trace":
        return true;
      default:
        return false;
    }
  };
  var setLevel = function(level) {
    const { labels, values } = this.levels;
    if (typeof level === "number") {
      if (labels[level] === undefined)
        throw Error("unknown level value" + level);
      level = labels[level];
    }
    if (values[level] === undefined)
      throw Error("unknown level " + level);
    const preLevelVal = this[levelValSym];
    const levelVal = this[levelValSym] = values[level];
    const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
    const hook = this[hooksSym].logMethod;
    for (const key in values) {
      if (levelVal > values[key]) {
        this[key] = noop;
        continue;
      }
      this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
    }
    this.emit("level-change", level, levelVal, labels[preLevelVal], preLevelVal, this);
  };
  var getLevel = function(level) {
    const { levels, levelVal } = this;
    return levels && levels.labels ? levels.labels[levelVal] : "";
  };
  var isLevelEnabled = function(logLevel2) {
    const { values } = this.levels;
    const logLevelVal = values[logLevel2];
    return logLevelVal !== undefined && this[levelCompSym](logLevelVal, this[levelValSym]);
  };
  var compareLevel = function(direction, current, expected) {
    if (direction === SORTING_ORDER.DESC) {
      return current <= expected;
    }
    return current >= expected;
  };
  var genLevelComparison = function(levelComparison) {
    if (typeof levelComparison === "string") {
      return compareLevel.bind(null, levelComparison);
    }
    return levelComparison;
  };
  var mappings = function(customLevels = null, useOnlyCustomLevels = false) {
    const customNums = customLevels ? Object.keys(customLevels).reduce((o, k) => {
      o[customLevels[k]] = k;
      return o;
    }, {}) : null;
    const labels = Object.assign(Object.create(Object.prototype, { Infinity: { value: "silent" } }), useOnlyCustomLevels ? null : nums, customNums);
    const values = Object.assign(Object.create(Object.prototype, { silent: { value: Infinity } }), useOnlyCustomLevels ? null : DEFAULT_LEVELS, customLevels);
    return { labels, values };
  };
  var assertDefaultLevelFound = function(defaultLevel, customLevels, useOnlyCustomLevels) {
    if (typeof defaultLevel === "number") {
      const values = [].concat(Object.keys(customLevels || {}).map((key) => customLevels[key]), useOnlyCustomLevels ? [] : Object.keys(nums).map((level) => +level), Infinity);
      if (!values.includes(defaultLevel)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
      }
      return;
    }
    const labels = Object.assign(Object.create(Object.prototype, { silent: { value: Infinity } }), useOnlyCustomLevels ? null : DEFAULT_LEVELS, customLevels);
    if (!(defaultLevel in labels)) {
      throw Error(`default level:${defaultLevel} must be included in custom levels`);
    }
  };
  var assertNoLevelCollisions = function(levels, customLevels) {
    const { labels, values } = levels;
    for (const k in customLevels) {
      if (k in values) {
        throw Error("levels cannot be overridden");
      }
      if (customLevels[k] in labels) {
        throw Error("pre-existing level values cannot be used for new levels");
      }
    }
  };
  var assertLevelComparison = function(levelComparison) {
    if (typeof levelComparison === "function") {
      return;
    }
    if (typeof levelComparison === "string" && Object.values(SORTING_ORDER).includes(levelComparison)) {
      return;
    }
    throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
  };
  var {
    lsCacheSym,
    levelValSym,
    useOnlyCustomLevelsSym,
    streamSym,
    formattersSym,
    hooksSym,
    levelCompSym
  } = require_symbols();
  var { noop, genLog } = require_tools();
  var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants3();
  var levelMethods = {
    fatal: (hook) => {
      const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
      return function(...args) {
        const stream = this[streamSym];
        logFatal.call(this, ...args);
        if (typeof stream.flushSync === "function") {
          try {
            stream.flushSync();
          } catch (e) {
          }
        }
      };
    },
    error: (hook) => genLog(DEFAULT_LEVELS.error, hook),
    warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),
    info: (hook) => genLog(DEFAULT_LEVELS.info, hook),
    debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),
    trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)
  };
  var nums = Object.keys(DEFAULT_LEVELS).reduce((o, k) => {
    o[DEFAULT_LEVELS[k]] = k;
    return o;
  }, {});
  var initialLsCache = Object.keys(nums).reduce((o, k) => {
    o[k] = '{"level":' + Number(k);
    return o;
  }, {});
  module.exports = {
    initialLsCache,
    genLsCache,
    levelMethods,
    getLevel,
    setLevel,
    isLevelEnabled,
    mappings,
    assertNoLevelCollisions,
    assertDefaultLevelFound,
    genLevelComparison,
    assertLevelComparison
  };
});

// ../node_modules/.pnpm/pino@8.18.0/node_modules/pino/lib/meta.js
var require_meta = __commonJS((exports, module) => {
  module.exports = { version: "8.18.0" };
});

// ../node_modules/.pnpm/pino@8.18.0/node_modules/pino/lib/proto.js
var require_proto = __commonJS((exports, module) => {
  var child = function(bindings2, options) {
    if (!bindings2) {
      throw Error("missing bindings for child Pino");
    }
    options = options || {};
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const instance = Object.create(this);
    if (options.hasOwnProperty("serializers") === true) {
      instance[serializersSym] = Object.create(null);
      for (const k in serializers) {
        instance[serializersSym][k] = serializers[k];
      }
      const parentSymbols = Object.getOwnPropertySymbols(serializers);
      for (var i = 0;i < parentSymbols.length; i++) {
        const ks = parentSymbols[i];
        instance[serializersSym][ks] = serializers[ks];
      }
      for (const bk in options.serializers) {
        instance[serializersSym][bk] = options.serializers[bk];
      }
      const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
      for (var bi = 0;bi < bindingsSymbols.length; bi++) {
        const bks = bindingsSymbols[bi];
        instance[serializersSym][bks] = options.serializers[bks];
      }
    } else
      instance[serializersSym] = serializers;
    if (options.hasOwnProperty("formatters")) {
      const { level, bindings: chindings, log: log7 } = options.formatters;
      instance[formattersSym] = buildFormatters(level || formatters.level, chindings || resetChildingsFormatter, log7 || formatters.log);
    } else {
      instance[formattersSym] = buildFormatters(formatters.level, resetChildingsFormatter, formatters.log);
    }
    if (options.hasOwnProperty("customLevels") === true) {
      assertNoLevelCollisions(this.levels, options.customLevels);
      instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
      genLsCache(instance);
    }
    if (typeof options.redact === "object" && options.redact !== null || Array.isArray(options.redact)) {
      instance.redact = options.redact;
      const stringifiers = redaction(instance.redact, stringify14);
      const formatOpts = { stringify: stringifiers[redactFmtSym] };
      instance[stringifySym] = stringify14;
      instance[stringifiersSym] = stringifiers;
      instance[formatOptsSym] = formatOpts;
    }
    if (typeof options.msgPrefix === "string") {
      instance[msgPrefixSym] = (this[msgPrefixSym] || "") + options.msgPrefix;
    }
    instance[chindingsSym] = asChindings(instance, bindings2);
    const childLevel = options.level || this.level;
    instance[setLevelSym](childLevel);
    this.onChild(instance);
    return instance;
  };
  var bindings = function() {
    const chindings = this[chindingsSym];
    const chindingsJson = `{${chindings.substr(1)}}`;
    const bindingsFromJson = JSON.parse(chindingsJson);
    delete bindingsFromJson.pid;
    delete bindingsFromJson.hostname;
    return bindingsFromJson;
  };
  var setBindings = function(newBindings) {
    const chindings = asChindings(this, newBindings);
    this[chindingsSym] = chindings;
    delete this[parsedChindingsSym];
  };
  var defaultMixinMergeStrategy = function(mergeObject, mixinObject) {
    return Object.assign(mixinObject, mergeObject);
  };
  var write = function(_obj, msg, num) {
    const t = this[timeSym]();
    const mixin3 = this[mixinSym];
    const errorKey = this[errorKeySym];
    const messageKey = this[messageKeySym];
    const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
    let obj;
    if (_obj === undefined || _obj === null) {
      obj = {};
    } else if (_obj instanceof Error) {
      obj = { [errorKey]: _obj };
      if (msg === undefined) {
        msg = _obj.message;
      }
    } else {
      obj = _obj;
      if (msg === undefined && _obj[messageKey] === undefined && _obj[errorKey]) {
        msg = _obj[errorKey].message;
      }
    }
    if (mixin3) {
      obj = mixinMergeStrategy(obj, mixin3(obj, num, this));
    }
    const s = this[asJsonSym](obj, msg, num, t);
    const stream = this[streamSym];
    if (stream[needsMetadataGsym] === true) {
      stream.lastLevel = num;
      stream.lastObj = obj;
      stream.lastMsg = msg;
      stream.lastTime = t.slice(this[timeSliceIndexSym]);
      stream.lastLogger = this;
    }
    stream.write(s);
  };
  var noop = function() {
  };
  var flush = function(cb) {
    if (cb != null && typeof cb !== "function") {
      throw Error("callback must be a function");
    }
    const stream = this[streamSym];
    if (typeof stream.flush === "function") {
      stream.flush(cb || noop);
    } else if (cb)
      cb();
  };
  var { EventEmitter } = __require("events");
  var {
    lsCacheSym,
    levelValSym,
    setLevelSym,
    getLevelSym,
    chindingsSym,
    parsedChindingsSym,
    mixinSym,
    asJsonSym,
    writeSym,
    mixinMergeStrategySym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    serializersSym,
    formattersSym,
    errorKeySym,
    messageKeySym,
    useOnlyCustomLevelsSym,
    needsMetadataGsym,
    redactFmtSym,
    stringifySym,
    formatOptsSym,
    stringifiersSym,
    msgPrefixSym
  } = require_symbols();
  var {
    getLevel,
    setLevel,
    isLevelEnabled,
    mappings,
    initialLsCache,
    genLsCache,
    assertNoLevelCollisions
  } = require_levels();
  var {
    asChindings,
    asJson,
    buildFormatters,
    stringify: stringify14
  } = require_tools();
  var {
    version: version3
  } = require_meta();
  var redaction = require_redaction();
  var constructor = class Pino {
  };
  var prototype = {
    constructor,
    child,
    bindings,
    setBindings,
    flush,
    isLevelEnabled,
    version: version3,
    get level() {
      return this[getLevelSym]();
    },
    set level(lvl) {
      this[setLevelSym](lvl);
    },
    get levelVal() {
      return this[levelValSym];
    },
    set levelVal(n) {
      throw Error("levelVal is read-only");
    },
    [lsCacheSym]: initialLsCache,
    [writeSym]: write,
    [asJsonSym]: asJson,
    [getLevelSym]: getLevel,
    [setLevelSym]: setLevel
  };
  Object.setPrototypeOf(prototype, EventEmitter.prototype);
  module.exports = function() {
    return Object.create(prototype);
  };
  var resetChildingsFormatter = (bindings2) => bindings2;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/pino@8.18.0/node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS((exports, module) => {
  var strEscape = function(str) {
    if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {
      return `"${str}"`;
    }
    return JSON.stringify(str);
  };
  var insertSort = function(array) {
    if (array.length > 200) {
      return array.sort();
    }
    for (let i = 1;i < array.length; i++) {
      const currentValue = array[i];
      let position = i;
      while (position !== 0 && array[position - 1] > currentValue) {
        array[position] = array[position - 1];
        position--;
      }
      array[position] = currentValue;
    }
    return array;
  };
  var isTypedArrayWithEntries = function(value) {
    return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0;
  };
  var stringifyTypedArray = function(array, separator, maximumBreadth) {
    if (array.length < maximumBreadth) {
      maximumBreadth = array.length;
    }
    const whitespace = separator === "," ? "" : " ";
    let res = `"0":${whitespace}${array[0]}`;
    for (let i = 1;i < maximumBreadth; i++) {
      res += `${separator}"${i}":${whitespace}${array[i]}`;
    }
    return res;
  };
  var getCircularValueOption = function(options) {
    if (hasOwnProperty.call(options, "circularValue")) {
      const circularValue = options.circularValue;
      if (typeof circularValue === "string") {
        return `"${circularValue}"`;
      }
      if (circularValue == null) {
        return circularValue;
      }
      if (circularValue === Error || circularValue === TypeError) {
        return {
          toString() {
            throw new TypeError("Converting circular structure to JSON");
          }
        };
      }
      throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
    }
    return '"[Circular]"';
  };
  var getBooleanOption = function(options, key) {
    let value;
    if (hasOwnProperty.call(options, key)) {
      value = options[key];
      if (typeof value !== "boolean") {
        throw new TypeError(`The "${key}" argument must be of type boolean`);
      }
    }
    return value === undefined ? true : value;
  };
  var getPositiveIntegerOption = function(options, key) {
    let value;
    if (hasOwnProperty.call(options, key)) {
      value = options[key];
      if (typeof value !== "number") {
        throw new TypeError(`The "${key}" argument must be of type number`);
      }
      if (!Number.isInteger(value)) {
        throw new TypeError(`The "${key}" argument must be an integer`);
      }
      if (value < 1) {
        throw new RangeError(`The "${key}" argument must be >= 1`);
      }
    }
    return value === undefined ? Infinity : value;
  };
  var getItemCount = function(number2) {
    if (number2 === 1) {
      return "1 item";
    }
    return `${number2} items`;
  };
  var getUniqueReplacerSet = function(replacerArray) {
    const replacerSet = new Set;
    for (const value of replacerArray) {
      if (typeof value === "string" || typeof value === "number") {
        replacerSet.add(String(value));
      }
    }
    return replacerSet;
  };
  var getStrictOption = function(options) {
    if (hasOwnProperty.call(options, "strict")) {
      const value = options.strict;
      if (typeof value !== "boolean") {
        throw new TypeError('The "strict" argument must be of type boolean');
      }
      if (value) {
        return (value2) => {
          let message = `Object can not safely be stringified. Received type ${typeof value2}`;
          if (typeof value2 !== "function")
            message += ` (${value2.toString()})`;
          throw new Error(message);
        };
      }
    }
  };
  var configure = function(options) {
    options = { ...options };
    const fail = getStrictOption(options);
    if (fail) {
      if (options.bigint === undefined) {
        options.bigint = false;
      }
      if (!("circularValue" in options)) {
        options.circularValue = Error;
      }
    }
    const circularValue = getCircularValueOption(options);
    const bigint = getBooleanOption(options, "bigint");
    const deterministic = getBooleanOption(options, "deterministic");
    const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
    const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
    function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
      let value = parent[key];
      if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      value = replacer.call(parent, key, value);
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          let res = "";
          let join = ",";
          const originalIndentation = indentation;
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            if (spacer !== "") {
              indentation += spacer;
              res += `\n${indentation}`;
              join = `,\n${indentation}`;
            }
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += join;
            }
            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
            res += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            if (spacer !== "") {
              res += `\n${originalIndentation}`;
            }
            stack.pop();
            return `[${res}]`;
          }
          let keys = Object.keys(value);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          let whitespace = "";
          let separator = "";
          if (spacer !== "") {
            indentation += spacer;
            join = `,\n${indentation}`;
            whitespace = " ";
          }
          const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (deterministic && !isTypedArrayWithEntries(value)) {
            keys = insertSort(keys);
          }
          stack.push(value);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
              separator = join;
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
            separator = join;
          }
          if (spacer !== "" && separator.length > 1) {
            res = `\n${indentation}${res}\n${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
      if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          const originalIndentation = indentation;
          let res = "";
          let join = ",";
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            if (spacer !== "") {
              indentation += spacer;
              res += `\n${indentation}`;
              join = `,\n${indentation}`;
            }
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += join;
            }
            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
            res += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            if (spacer !== "") {
              res += `\n${originalIndentation}`;
            }
            stack.pop();
            return `[${res}]`;
          }
          stack.push(value);
          let whitespace = "";
          if (spacer !== "") {
            indentation += spacer;
            join = `,\n${indentation}`;
            whitespace = " ";
          }
          let separator = "";
          for (const key2 of replacer) {
            const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
              separator = join;
            }
          }
          if (spacer !== "" && separator.length > 1) {
            res = `\n${indentation}${res}\n${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringifyIndent(key, value, stack, spacer, indentation) {
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (typeof value.toJSON === "function") {
            value = value.toJSON(key);
            if (typeof value !== "object") {
              return stringifyIndent(key, value, stack, spacer, indentation);
            }
            if (value === null) {
              return "null";
            }
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          const originalIndentation = indentation;
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            indentation += spacer;
            let res2 = `\n${indentation}`;
            const join2 = `,\n${indentation}`;
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res2 += tmp2 !== undefined ? tmp2 : "null";
              res2 += join2;
            }
            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
            res2 += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            res2 += `\n${originalIndentation}`;
            stack.pop();
            return `[${res2}]`;
          }
          let keys = Object.keys(value);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          indentation += spacer;
          const join = `,\n${indentation}`;
          let res = "";
          let separator = "";
          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (isTypedArrayWithEntries(value)) {
            res += stringifyTypedArray(value, join, maximumBreadth);
            keys = keys.slice(value.length);
            maximumPropertiesToStringify -= value.length;
            separator = join;
          }
          if (deterministic) {
            keys = insertSort(keys);
          }
          stack.push(value);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}: ${tmp}`;
              separator = join;
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
            separator = join;
          }
          if (separator !== "") {
            res = `\n${indentation}${res}\n${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringifySimple(key, value, stack) {
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (typeof value.toJSON === "function") {
            value = value.toJSON(key);
            if (typeof value !== "object") {
              return stringifySimple(key, value, stack);
            }
            if (value === null) {
              return "null";
            }
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          let res = "";
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifySimple(String(i), value[i], stack);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += ",";
            }
            const tmp = stringifySimple(String(i), value[i], stack);
            res += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res += `,"... ${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `[${res}]`;
          }
          let keys = Object.keys(value);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          let separator = "";
          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (isTypedArrayWithEntries(value)) {
            res += stringifyTypedArray(value, ",", maximumBreadth);
            keys = keys.slice(value.length);
            maximumPropertiesToStringify -= value.length;
            separator = ",";
          }
          if (deterministic) {
            keys = insertSort(keys);
          }
          stack.push(value);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifySimple(key2, value[key2], stack);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${tmp}`;
              separator = ",";
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringify15(value, replacer, space) {
      if (arguments.length > 1) {
        let spacer = "";
        if (typeof space === "number") {
          spacer = " ".repeat(Math.min(space, 10));
        } else if (typeof space === "string") {
          spacer = space.slice(0, 10);
        }
        if (replacer != null) {
          if (typeof replacer === "function") {
            return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
          }
          if (Array.isArray(replacer)) {
            return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
          }
        }
        if (spacer.length !== 0) {
          return stringifyIndent("", value, [], spacer, "");
        }
      }
      return stringifySimple("", value, []);
    }
    return stringify15;
  };
  var { hasOwnProperty } = Object.prototype;
  var stringify14 = configure();
  stringify14.configure = configure;
  stringify14.stringify = stringify14;
  stringify14.default = stringify14;
  exports.stringify = stringify14;
  exports.configure = configure;
  module.exports = stringify14;
  var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/;
  var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array)), Symbol.toStringTag).get;
});

// ../node_modules/.pnpm/pino@8.18.0/node_modules/pino/lib/multistream.js
var require_multistream = __commonJS((exports, module) => {
  var multistream = function(streamsArray, opts) {
    let counter = 0;
    streamsArray = streamsArray || [];
    opts = opts || { dedupe: false };
    const streamLevels = Object.create(DEFAULT_LEVELS);
    streamLevels.silent = Infinity;
    if (opts.levels && typeof opts.levels === "object") {
      Object.keys(opts.levels).forEach((i) => {
        streamLevels[i] = opts.levels[i];
      });
    }
    const res = {
      write,
      add,
      flushSync,
      end,
      minLevel: 0,
      streams: [],
      clone,
      [metadata]: true,
      streamLevels
    };
    if (Array.isArray(streamsArray)) {
      streamsArray.forEach(add, res);
    } else {
      add.call(res, streamsArray);
    }
    streamsArray = null;
    return res;
    function write(data3) {
      let dest;
      const level = this.lastLevel;
      const { streams } = this;
      let recordedLevel = 0;
      let stream;
      for (let i = initLoopVar(streams.length, opts.dedupe);checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)) {
        dest = streams[i];
        if (dest.level <= level) {
          if (recordedLevel !== 0 && recordedLevel !== dest.level) {
            break;
          }
          stream = dest.stream;
          if (stream[metadata]) {
            const { lastTime, lastMsg, lastObj, lastLogger } = this;
            stream.lastLevel = level;
            stream.lastTime = lastTime;
            stream.lastMsg = lastMsg;
            stream.lastObj = lastObj;
            stream.lastLogger = lastLogger;
          }
          stream.write(data3);
          if (opts.dedupe) {
            recordedLevel = dest.level;
          }
        } else if (!opts.dedupe) {
          break;
        }
      }
    }
    function flushSync() {
      for (const { stream } of this.streams) {
        if (typeof stream.flushSync === "function") {
          stream.flushSync();
        }
      }
    }
    function add(dest) {
      if (!dest) {
        return res;
      }
      const isStream = typeof dest.write === "function" || dest.stream;
      const stream_ = dest.write ? dest : dest.stream;
      if (!isStream) {
        throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
      }
      const { streams, streamLevels: streamLevels2 } = this;
      let level;
      if (typeof dest.levelVal === "number") {
        level = dest.levelVal;
      } else if (typeof dest.level === "string") {
        level = streamLevels2[dest.level];
      } else if (typeof dest.level === "number") {
        level = dest.level;
      } else {
        level = DEFAULT_INFO_LEVEL;
      }
      const dest_ = {
        stream: stream_,
        level,
        levelVal: undefined,
        id: counter++
      };
      streams.unshift(dest_);
      streams.sort(compareByLevel);
      this.minLevel = streams[0].level;
      return res;
    }
    function end() {
      for (const { stream } of this.streams) {
        if (typeof stream.flushSync === "function") {
          stream.flushSync();
        }
        stream.end();
      }
    }
    function clone(level) {
      const streams = new Array(this.streams.length);
      for (let i = 0;i < streams.length; i++) {
        streams[i] = {
          level,
          stream: this.streams[i].stream
        };
      }
      return {
        write,
        add,
        minLevel: level,
        streams,
        clone,
        flushSync,
        [metadata]: true
      };
    }
  };
  var compareByLevel = function(a, b) {
    return a.level - b.level;
  };
  var initLoopVar = function(length, dedupe) {
    return dedupe ? length - 1 : 0;
  };
  var adjustLoopVar = function(i, dedupe) {
    return dedupe ? i - 1 : i + 1;
  };
  var checkLoopVar = function(i, length, dedupe) {
    return dedupe ? i >= 0 : i < length;
  };
  var metadata = Symbol.for("pino.metadata");
  var { DEFAULT_LEVELS } = require_constants3();
  var DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;
  module.exports = multistream;
});

// /home/mous/work/pimlico/alto/src/node_modules/pino/pino.js
var require_pino = __commonJS((exports, module) => {
  var pino = function(...args) {
    const instance = {};
    const { opts, stream } = normalize2(instance, caller(), ...args);
    const {
      redact,
      crlf,
      serializers: serializers2,
      timestamp,
      messageKey,
      errorKey,
      nestedKey,
      base: base29,
      name,
      level,
      customLevels,
      levelComparison,
      mixin: mixin3,
      mixinMergeStrategy,
      useOnlyCustomLevels,
      formatters,
      hooks,
      depthLimit,
      edgeLimit,
      onChild,
      msgPrefix
    } = opts;
    const stringifySafe = configure({
      maximumDepth: depthLimit,
      maximumBreadth: edgeLimit
    });
    const allFormatters = buildFormatters(formatters.level, formatters.bindings, formatters.log);
    const stringifyFn = stringify14.bind({
      [stringifySafeSym]: stringifySafe
    });
    const stringifiers = redact ? redaction(redact, stringifyFn) : {};
    const formatOpts = redact ? { stringify: stringifiers[redactFmtSym] } : { stringify: stringifyFn };
    const end = "}" + (crlf ? "\r\n" : "\n");
    const coreChindings = asChindings.bind(null, {
      [chindingsSym]: "",
      [serializersSym]: serializers2,
      [stringifiersSym]: stringifiers,
      [stringifySym]: stringify14,
      [stringifySafeSym]: stringifySafe,
      [formattersSym]: allFormatters
    });
    let chindings = "";
    if (base29 !== null) {
      if (name === undefined) {
        chindings = coreChindings(base29);
      } else {
        chindings = coreChindings(Object.assign({}, base29, { name }));
      }
    }
    const time2 = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;
    const timeSliceIndex = time2().indexOf(":") + 1;
    if (useOnlyCustomLevels && !customLevels)
      throw Error("customLevels is required if useOnlyCustomLevels is set true");
    if (mixin3 && typeof mixin3 !== "function")
      throw Error(`Unknown mixin type "${typeof mixin3}" - expected "function"`);
    if (msgPrefix && typeof msgPrefix !== "string")
      throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
    assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
    const levels = mappings(customLevels, useOnlyCustomLevels);
    assertLevelComparison(levelComparison);
    const levelCompFunc = genLevelComparison(levelComparison);
    Object.assign(instance, {
      levels,
      [levelCompSym]: levelCompFunc,
      [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
      [streamSym]: stream,
      [timeSym]: time2,
      [timeSliceIndexSym]: timeSliceIndex,
      [stringifySym]: stringify14,
      [stringifySafeSym]: stringifySafe,
      [stringifiersSym]: stringifiers,
      [endSym]: end,
      [formatOptsSym]: formatOpts,
      [messageKeySym]: messageKey,
      [errorKeySym]: errorKey,
      [nestedKeySym]: nestedKey,
      [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
      [serializersSym]: serializers2,
      [mixinSym]: mixin3,
      [mixinMergeStrategySym]: mixinMergeStrategy,
      [chindingsSym]: chindings,
      [formattersSym]: allFormatters,
      [hooksSym]: hooks,
      silent: noop,
      onChild,
      [msgPrefixSym]: msgPrefix
    });
    Object.setPrototypeOf(instance, proto());
    genLsCache(instance);
    instance[setLevelSym](level);
    return instance;
  };
  var os = __require("os");
  var stdSerializers = require_pino_std_serializers();
  var caller = require_caller();
  var redaction = require_redaction();
  var time = require_time2();
  var proto = require_proto();
  var symbols = require_symbols();
  var { configure } = require_safe_stable_stringify();
  var { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = require_levels();
  var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants3();
  var {
    createArgsNormalizer,
    asChindings,
    buildSafeSonicBoom,
    buildFormatters,
    stringify: stringify14,
    normalizeDestFileDescriptor,
    noop
  } = require_tools();
  var { version: version3 } = require_meta();
  var {
    chindingsSym,
    redactFmtSym,
    serializersSym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    stringifySym,
    stringifySafeSym,
    stringifiersSym,
    setLevelSym,
    endSym,
    formatOptsSym,
    messageKeySym,
    errorKeySym,
    nestedKeySym,
    mixinSym,
    levelCompSym,
    useOnlyCustomLevelsSym,
    formattersSym,
    hooksSym,
    nestedKeyStrSym,
    mixinMergeStrategySym,
    msgPrefixSym
  } = symbols;
  var { epochTime, nullTime } = time;
  var { pid } = process;
  var hostname = os.hostname();
  var defaultErrorSerializer = stdSerializers.err;
  var defaultOptions = {
    level: "info",
    levelComparison: SORTING_ORDER.ASC,
    levels: DEFAULT_LEVELS,
    messageKey: "msg",
    errorKey: "err",
    nestedKey: null,
    enabled: true,
    base: { pid, hostname },
    serializers: Object.assign(Object.create(null), {
      err: defaultErrorSerializer
    }),
    formatters: Object.assign(Object.create(null), {
      bindings(bindings) {
        return bindings;
      },
      level(label, number2) {
        return { level: number2 };
      }
    }),
    hooks: {
      logMethod: undefined
    },
    timestamp: epochTime,
    name: undefined,
    redact: null,
    customLevels: null,
    useOnlyCustomLevels: false,
    depthLimit: 5,
    edgeLimit: 100
  };
  var normalize2 = createArgsNormalizer(defaultOptions);
  var serializers = Object.assign(Object.create(null), stdSerializers);
  module.exports = pino;
  module.exports.destination = (dest = process.stdout.fd) => {
    if (typeof dest === "object") {
      dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
      return buildSafeSonicBoom(dest);
    } else {
      return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 });
    }
  };
  module.exports.transport = require_transport();
  module.exports.multistream = require_multistream();
  module.exports.levels = mappings();
  module.exports.stdSerializers = serializers;
  module.exports.stdTimeFunctions = Object.assign({}, time);
  module.exports.symbols = symbols;
  module.exports.version = version3;
  module.exports.default = pino;
  module.exports.pino = pino;
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/util.js
var require_util = __commonJS((exports) => {
  var hashObject = function(labels) {
    let keys = Object.keys(labels);
    if (keys.length === 0) {
      return "";
    }
    if (keys.length > 1) {
      keys = keys.sort();
    }
    let hash4 = "";
    let i = 0;
    const size9 = keys.length;
    for (;i < size9 - 1; i++) {
      hash4 += `${keys[i]}:${labels[keys[i]]},`;
    }
    hash4 += `${keys[i]}:${labels[keys[i]]}`;
    return hash4;
  };
  exports.getValueAsString = function getValueString(value) {
    if (Number.isNaN(value)) {
      return "Nan";
    } else if (!Number.isFinite(value)) {
      if (value < 0) {
        return "-Inf";
      } else {
        return "+Inf";
      }
    } else {
      return `${value}`;
    }
  };
  exports.removeLabels = function removeLabels(hashMap, labels) {
    const hash4 = hashObject(labels);
    delete hashMap[hash4];
  };
  exports.setValue = function setValue(hashMap, value, labels) {
    const hash4 = hashObject(labels);
    hashMap[hash4] = {
      value: typeof value === "number" ? value : 0,
      labels: labels || {}
    };
    return hashMap;
  };
  exports.setValueDelta = function setValueDelta(hashMap, deltaValue, labels, hash4 = "") {
    const value = typeof deltaValue === "number" ? deltaValue : 0;
    if (hashMap[hash4]) {
      hashMap[hash4].value += value;
    } else {
      hashMap[hash4] = { value, labels };
    }
    return hashMap;
  };
  exports.getLabels = function(labelNames, args) {
    if (typeof args[0] === "object") {
      return args[0];
    }
    if (labelNames.length !== args.length) {
      throw new Error("Invalid number of arguments");
    }
    const acc = {};
    for (let i = 0;i < labelNames.length; i++) {
      acc[labelNames[i]] = args[i];
    }
    return acc;
  };
  exports.hashObject = hashObject;
  exports.isObject = function isObject(obj) {
    return obj === Object(obj);
  };

  class Grouper extends Map {
    add(key, value) {
      if (this.has(key)) {
        this.get(key).push(value);
      } else {
        this.set(key, [value]);
      }
    }
  }
  exports.Grouper = Grouper;
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/registry.js
var require_registry = __commonJS((exports, module) => {
  var escapeString = function(str) {
    return str.replace(/\n/g, "\\n").replace(/\\(?!n)/g, "\\\\");
  };
  var escapeLabelValue = function(str) {
    if (typeof str !== "string") {
      return str;
    }
    return escapeString(str).replace(/"/g, '\\"');
  };
  var { getValueAsString } = require_util();

  class Registry {
    constructor() {
      this._metrics = {};
      this._collectors = [];
      this._defaultLabels = {};
    }
    getMetricsAsArray() {
      return Object.values(this._metrics);
    }
    async getMetricAsPrometheusString(metric) {
      const item = await metric.get();
      const name = escapeString(item.name);
      const help = `# HELP ${name} ${escapeString(item.help)}`;
      const type = `# TYPE ${name} ${item.type}`;
      const defaultLabels = Object.keys(this._defaultLabels).length > 0 ? this._defaultLabels : null;
      const values = [help, type];
      for (const { metricName = item.name, value, labels = {} } of item.values || []) {
        const labelsWithDefaults = defaultLabels ? { ...labels, ...defaultLabels, ...labels } : labels;
        const formattedLabels = Object.entries(labelsWithDefaults).map(([n, v]) => `${n}="${escapeLabelValue(v)}"`);
        const labelsString = formattedLabels.length ? `{${formattedLabels.join(",")}}` : "";
        values.push(`${metricName}${labelsString} ${getValueAsString(value)}`);
      }
      return values.join("\n");
    }
    async metrics() {
      const promises = [];
      for (const metric of this.getMetricsAsArray()) {
        promises.push(this.getMetricAsPrometheusString(metric));
      }
      const resolves = await Promise.all(promises);
      return `${resolves.join("\n\n")}\n`;
    }
    registerMetric(metric) {
      if (this._metrics[metric.name] && this._metrics[metric.name] !== metric) {
        throw new Error(`A metric with the name ${metric.name} has already been registered.`);
      }
      this._metrics[metric.name] = metric;
    }
    clear() {
      this._metrics = {};
      this._defaultLabels = {};
    }
    async getMetricsAsJSON() {
      const metrics = [];
      const defaultLabelNames = Object.keys(this._defaultLabels);
      const promises = [];
      for (const metric of this.getMetricsAsArray()) {
        promises.push(metric.get());
      }
      const resolves = await Promise.all(promises);
      for (const item of resolves) {
        if (item.values && defaultLabelNames.length > 0) {
          for (const val of item.values) {
            val.labels = Object.assign({}, val.labels);
            for (const labelName of defaultLabelNames) {
              val.labels[labelName] = val.labels[labelName] || this._defaultLabels[labelName];
            }
          }
        }
        metrics.push(item);
      }
      return metrics;
    }
    removeSingleMetric(name) {
      delete this._metrics[name];
    }
    getSingleMetricAsString(name) {
      return this.getMetricAsPrometheusString(this._metrics[name]);
    }
    getSingleMetric(name) {
      return this._metrics[name];
    }
    setDefaultLabels(labels) {
      this._defaultLabels = labels;
    }
    resetMetrics() {
      for (const metric in this._metrics) {
        this._metrics[metric].reset();
      }
    }
    get contentType() {
      return "text/plain; version=0.0.4; charset=utf-8";
    }
    static merge(registers) {
      const mergedRegistry = new Registry;
      const metricsToMerge = registers.reduce((acc, reg) => acc.concat(reg.getMetricsAsArray()), []);
      metricsToMerge.forEach(mergedRegistry.registerMetric, mergedRegistry);
      return mergedRegistry;
    }
  }
  module.exports = Registry;
  module.exports.globalRegistry = new Registry;
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/validation.js
var require_validation = __commonJS((exports) => {
  var util2 = __require("util");
  var metricRegexp = /^[a-zA-Z_:][a-zA-Z0-9_:]*$/;
  var labelRegexp = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
  exports.validateMetricName = function(name) {
    return metricRegexp.test(name);
  };
  exports.validateLabelName = function(names = []) {
    return names.every((name) => labelRegexp.test(name));
  };
  exports.validateLabel = function validateLabel(savedLabels, labels) {
    for (const label in labels) {
      if (!savedLabels.includes(label)) {
        throw new Error(`Added label "${label}" is not included in initial labelset: ${util2.inspect(savedLabels)}`);
      }
    }
  };
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/metric.js
var require_metric = __commonJS((exports, module) => {
  var { globalRegistry } = require_registry();
  var { isObject } = require_util();
  var { validateMetricName, validateLabelName } = require_validation();

  class Metric {
    constructor(config, defaults = {}) {
      if (!isObject(config)) {
        throw new TypeError("constructor expected a config object");
      }
      Object.assign(this, {
        labelNames: [],
        registers: [globalRegistry],
        aggregator: "sum"
      }, defaults, config);
      if (!this.registers) {
        this.registers = [globalRegistry];
      }
      if (!this.help) {
        throw new Error("Missing mandatory help parameter");
      }
      if (!this.name) {
        throw new Error("Missing mandatory name parameter");
      }
      if (!validateMetricName(this.name)) {
        throw new Error("Invalid metric name");
      }
      if (!validateLabelName(this.labelNames)) {
        throw new Error("Invalid label name");
      }
      if (this.collect && typeof this.collect !== "function") {
        throw new Error('Optional "collect" parameter must be a function');
      }
      this.reset();
      for (const register of this.registers) {
        register.registerMetric(this);
      }
    }
    reset() {
    }
  }
  module.exports = { Metric };
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/counter.js
var require_counter = __commonJS((exports, module) => {
  var setValue = function(hashMap, value, labels = {}, hash4 = "") {
    if (hashMap[hash4]) {
      hashMap[hash4].value += value;
    } else {
      hashMap[hash4] = { value, labels };
    }
    return hashMap;
  };
  var util2 = __require("util");
  var type = "counter";
  var { hashObject, isObject, getLabels, removeLabels } = require_util();
  var { validateLabel } = require_validation();
  var { Metric } = require_metric();

  class Counter extends Metric {
    inc(labels, value) {
      let hash4;
      if (isObject(labels)) {
        hash4 = hashObject(labels);
        validateLabel(this.labelNames, labels);
      } else {
        value = labels;
        labels = {};
      }
      if (value && !Number.isFinite(value)) {
        throw new TypeError(`Value is not a valid number: ${util2.format(value)}`);
      }
      if (value < 0) {
        throw new Error("It is not possible to decrease a counter");
      }
      if (value === null || value === undefined)
        value = 1;
      setValue(this.hashMap, value, labels, hash4);
    }
    reset() {
      this.hashMap = {};
      if (this.labelNames.length === 0) {
        setValue(this.hashMap, 0);
      }
    }
    async get() {
      if (this.collect) {
        const v = this.collect();
        if (v instanceof Promise)
          await v;
      }
      return {
        help: this.help,
        name: this.name,
        type,
        values: Object.values(this.hashMap),
        aggregator: this.aggregator
      };
    }
    labels(...args) {
      const labels = getLabels(this.labelNames, args) || {};
      return {
        inc: this.inc.bind(this, labels)
      };
    }
    remove(...args) {
      const labels = getLabels(this.labelNames, args) || {};
      validateLabel(this.labelNames, labels);
      return removeLabels.call(this, this.hashMap, labels);
    }
  }
  module.exports = Counter;
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/gauge.js
var require_gauge = __commonJS((exports, module) => {
  var set = function(gauge, labels, value) {
    if (typeof value !== "number") {
      throw new TypeError(`Value is not a valid number: ${util2.format(value)}`);
    }
    validateLabel(gauge.labelNames, labels);
    setValue(gauge.hashMap, value, labels);
  };
  var setDelta = function(gauge, labels, delta) {
    if (typeof delta !== "number") {
      throw new TypeError(`Delta is not a valid number: ${util2.format(delta)}`);
    }
    validateLabel(gauge.labelNames, labels);
    const hash4 = hashObject(labels);
    setValueDelta(gauge.hashMap, delta, labels, hash4);
  };
  var getLabelArg = function(labels) {
    return isObject(labels) ? labels : {};
  };
  var getValueArg = function(labels, value) {
    return isObject(labels) ? value : labels;
  };
  var util2 = __require("util");
  var type = "gauge";
  var {
    setValue,
    setValueDelta,
    getLabels,
    hashObject,
    isObject,
    removeLabels
  } = require_util();
  var { validateLabel } = require_validation();
  var { Metric } = require_metric();

  class Gauge extends Metric {
    set(labels, value) {
      value = getValueArg(labels, value);
      labels = getLabelArg(labels);
      set(this, labels, value);
    }
    reset() {
      this.hashMap = {};
      if (this.labelNames.length === 0) {
        setValue(this.hashMap, 0, {});
      }
    }
    inc(labels, value) {
      value = getValueArg(labels, value);
      labels = getLabelArg(labels);
      if (value === undefined)
        value = 1;
      setDelta(this, labels, value);
    }
    dec(labels, value) {
      value = getValueArg(labels, value);
      labels = getLabelArg(labels);
      if (value === undefined)
        value = 1;
      setDelta(this, labels, -value);
    }
    setToCurrentTime(labels) {
      const now = Date.now() / 1000;
      if (labels === undefined) {
        this.set(now);
      } else {
        this.set(labels, now);
      }
    }
    startTimer(labels) {
      const start = process.hrtime();
      return (endLabels) => {
        const delta = process.hrtime(start);
        const value = delta[0] + delta[1] / 1e9;
        this.set(Object.assign({}, labels, endLabels), value);
        return value;
      };
    }
    async get() {
      if (this.collect) {
        const v = this.collect();
        if (v instanceof Promise)
          await v;
      }
      return {
        help: this.help,
        name: this.name,
        type,
        values: Object.values(this.hashMap),
        aggregator: this.aggregator
      };
    }
    _getValue(labels) {
      const hash4 = hashObject(labels || {});
      return this.hashMap[hash4] ? this.hashMap[hash4].value : 0;
    }
    labels(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      return {
        inc: this.inc.bind(this, labels),
        dec: this.dec.bind(this, labels),
        set: this.set.bind(this, labels),
        setToCurrentTime: this.setToCurrentTime.bind(this, labels),
        startTimer: this.startTimer.bind(this, labels)
      };
    }
    remove(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      removeLabels.call(this, this.hashMap, labels);
    }
  }
  module.exports = Gauge;
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/histogram.js
var require_histogram = __commonJS((exports, module) => {
  var startTimer = function(startLabels) {
    return () => {
      const start = process.hrtime();
      return (endLabels) => {
        const delta = process.hrtime(start);
        const value = delta[0] + delta[1] / 1e9;
        this.observe(Object.assign({}, startLabels, endLabels), value);
        return value;
      };
    };
  };
  var setValuePair = function(labels, value, metricName) {
    return {
      labels,
      value,
      metricName
    };
  };
  var findBound = function(upperBounds, value) {
    for (let i = 0;i < upperBounds.length; i++) {
      const bound = upperBounds[i];
      if (value <= bound) {
        return bound;
      }
    }
    return -1;
  };
  var observe8 = function(labels) {
    return (value) => {
      const labelValuePair = convertLabelsAndValues(labels, value);
      validateLabel(this.labelNames, labelValuePair.labels);
      if (!Number.isFinite(labelValuePair.value)) {
        throw new TypeError(`Value is not a valid number: ${util2.format(labelValuePair.value)}`);
      }
      const hash4 = hashObject(labelValuePair.labels);
      let valueFromMap = this.hashMap[hash4];
      if (!valueFromMap) {
        valueFromMap = createBaseValues(labelValuePair.labels, Object.assign({}, this.bucketValues));
      }
      const b = findBound(this.upperBounds, labelValuePair.value);
      valueFromMap.sum += labelValuePair.value;
      valueFromMap.count += 1;
      if (Object.prototype.hasOwnProperty.call(valueFromMap.bucketValues, b)) {
        valueFromMap.bucketValues[b] += 1;
      }
      this.hashMap[hash4] = valueFromMap;
    };
  };
  var createBaseValues = function(labels, bucketValues) {
    return {
      labels,
      bucketValues,
      sum: 0,
      count: 0
    };
  };
  var convertLabelsAndValues = function(labels, value) {
    if (!isObject(labels)) {
      return {
        value: labels,
        labels: {}
      };
    }
    return {
      labels,
      value
    };
  };
  var extractBucketValuesForExport = function(histogram) {
    return (bucketData) => {
      const buckets = [];
      const bucketLabelNames = Object.keys(bucketData.labels);
      let acc = 0;
      for (const upperBound of histogram.upperBounds) {
        acc += bucketData.bucketValues[upperBound];
        const lbls = { le: upperBound };
        for (const labelName of bucketLabelNames) {
          lbls[labelName] = bucketData.labels[labelName];
        }
        buckets.push(setValuePair(lbls, acc, `${histogram.name}_bucket`));
      }
      return { buckets, data: bucketData };
    };
  };
  var addSumAndCountForExport = function(histogram) {
    return (acc, d) => {
      acc.push(...d.buckets);
      const infLabel = { le: "+Inf" };
      for (const label of Object.keys(d.data.labels)) {
        infLabel[label] = d.data.labels[label];
      }
      acc.push(setValuePair(infLabel, d.data.count, `${histogram.name}_bucket`), setValuePair(d.data.labels, d.data.sum, `${histogram.name}_sum`), setValuePair(d.data.labels, d.data.count, `${histogram.name}_count`));
      return acc;
    };
  };
  var util2 = __require("util");
  var type = "histogram";
  var { getLabels, hashObject, isObject, removeLabels } = require_util();
  var { validateLabel } = require_validation();
  var { Metric } = require_metric();

  class Histogram extends Metric {
    constructor(config) {
      super(config, {
        buckets: [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]
      });
      for (const label of this.labelNames) {
        if (label === "le") {
          throw new Error("le is a reserved label keyword");
        }
      }
      this.upperBounds = this.buckets;
      this.bucketValues = this.upperBounds.reduce((acc, upperBound) => {
        acc[upperBound] = 0;
        return acc;
      }, {});
      Object.freeze(this.bucketValues);
      Object.freeze(this.upperBounds);
      if (this.labelNames.length === 0) {
        this.hashMap = {
          [hashObject({})]: createBaseValues({}, Object.assign({}, this.bucketValues))
        };
      }
    }
    observe(labels, value) {
      observe8.call(this, labels === 0 ? 0 : labels || {})(value);
    }
    async get() {
      if (this.collect) {
        const v = this.collect();
        if (v instanceof Promise)
          await v;
      }
      const data3 = Object.values(this.hashMap);
      const values = data3.map(extractBucketValuesForExport(this)).reduce(addSumAndCountForExport(this), []);
      return {
        name: this.name,
        help: this.help,
        type,
        values,
        aggregator: this.aggregator
      };
    }
    reset() {
      this.hashMap = {};
    }
    zero(labels) {
      const hash4 = hashObject(labels);
      this.hashMap[hash4] = createBaseValues(labels, Object.assign({}, this.bucketValues));
    }
    startTimer(labels) {
      return startTimer.call(this, labels)();
    }
    labels(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      return {
        observe: observe8.call(this, labels),
        startTimer: startTimer.call(this, labels)
      };
    }
    remove(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      removeLabels.call(this, this.hashMap, labels);
    }
  }
  module.exports = Histogram;
});

// ../node_modules/.pnpm/bintrees@1.0.2/node_modules/bintrees/lib/treebase.js
var require_treebase = __commonJS((exports, module) => {
  var TreeBase = function() {
  };
  var Iterator = function(tree) {
    this._tree = tree;
    this._ancestors = [];
    this._cursor = null;
  };
  TreeBase.prototype.clear = function() {
    this._root = null;
    this.size = 0;
  };
  TreeBase.prototype.find = function(data3) {
    var res = this._root;
    while (res !== null) {
      var c = this._comparator(data3, res.data);
      if (c === 0) {
        return res.data;
      } else {
        res = res.get_child(c > 0);
      }
    }
    return null;
  };
  TreeBase.prototype.findIter = function(data3) {
    var res = this._root;
    var iter = this.iterator();
    while (res !== null) {
      var c = this._comparator(data3, res.data);
      if (c === 0) {
        iter._cursor = res;
        return iter;
      } else {
        iter._ancestors.push(res);
        res = res.get_child(c > 0);
      }
    }
    return null;
  };
  TreeBase.prototype.lowerBound = function(item) {
    var cur = this._root;
    var iter = this.iterator();
    var cmp = this._comparator;
    while (cur !== null) {
      var c = cmp(item, cur.data);
      if (c === 0) {
        iter._cursor = cur;
        return iter;
      }
      iter._ancestors.push(cur);
      cur = cur.get_child(c > 0);
    }
    for (var i = iter._ancestors.length - 1;i >= 0; --i) {
      cur = iter._ancestors[i];
      if (cmp(item, cur.data) < 0) {
        iter._cursor = cur;
        iter._ancestors.length = i;
        return iter;
      }
    }
    iter._ancestors.length = 0;
    return iter;
  };
  TreeBase.prototype.upperBound = function(item) {
    var iter = this.lowerBound(item);
    var cmp = this._comparator;
    while (iter.data() !== null && cmp(iter.data(), item) === 0) {
      iter.next();
    }
    return iter;
  };
  TreeBase.prototype.min = function() {
    var res = this._root;
    if (res === null) {
      return null;
    }
    while (res.left !== null) {
      res = res.left;
    }
    return res.data;
  };
  TreeBase.prototype.max = function() {
    var res = this._root;
    if (res === null) {
      return null;
    }
    while (res.right !== null) {
      res = res.right;
    }
    return res.data;
  };
  TreeBase.prototype.iterator = function() {
    return new Iterator(this);
  };
  TreeBase.prototype.each = function(cb) {
    var it = this.iterator(), data3;
    while ((data3 = it.next()) !== null) {
      if (cb(data3) === false) {
        return;
      }
    }
  };
  TreeBase.prototype.reach = function(cb) {
    var it = this.iterator(), data3;
    while ((data3 = it.prev()) !== null) {
      if (cb(data3) === false) {
        return;
      }
    }
  };
  Iterator.prototype.data = function() {
    return this._cursor !== null ? this._cursor.data : null;
  };
  Iterator.prototype.next = function() {
    if (this._cursor === null) {
      var root = this._tree._root;
      if (root !== null) {
        this._minNode(root);
      }
    } else {
      if (this._cursor.right === null) {
        var save;
        do {
          save = this._cursor;
          if (this._ancestors.length) {
            this._cursor = this._ancestors.pop();
          } else {
            this._cursor = null;
            break;
          }
        } while (this._cursor.right === save);
      } else {
        this._ancestors.push(this._cursor);
        this._minNode(this._cursor.right);
      }
    }
    return this._cursor !== null ? this._cursor.data : null;
  };
  Iterator.prototype.prev = function() {
    if (this._cursor === null) {
      var root = this._tree._root;
      if (root !== null) {
        this._maxNode(root);
      }
    } else {
      if (this._cursor.left === null) {
        var save;
        do {
          save = this._cursor;
          if (this._ancestors.length) {
            this._cursor = this._ancestors.pop();
          } else {
            this._cursor = null;
            break;
          }
        } while (this._cursor.left === save);
      } else {
        this._ancestors.push(this._cursor);
        this._maxNode(this._cursor.left);
      }
    }
    return this._cursor !== null ? this._cursor.data : null;
  };
  Iterator.prototype._minNode = function(start) {
    while (start.left !== null) {
      this._ancestors.push(start);
      start = start.left;
    }
    this._cursor = start;
  };
  Iterator.prototype._maxNode = function(start) {
    while (start.right !== null) {
      this._ancestors.push(start);
      start = start.right;
    }
    this._cursor = start;
  };
  module.exports = TreeBase;
});

// ../node_modules/.pnpm/bintrees@1.0.2/node_modules/bintrees/lib/rbtree.js
var require_rbtree = __commonJS((exports, module) => {
  var Node = function(data3) {
    this.data = data3;
    this.left = null;
    this.right = null;
    this.red = true;
  };
  var RBTree = function(comparator) {
    this._root = null;
    this._comparator = comparator;
    this.size = 0;
  };
  var is_red = function(node8) {
    return node8 !== null && node8.red;
  };
  var single_rotate = function(root, dir) {
    var save = root.get_child(!dir);
    root.set_child(!dir, save.get_child(dir));
    save.set_child(dir, root);
    root.red = true;
    save.red = false;
    return save;
  };
  var double_rotate = function(root, dir) {
    root.set_child(!dir, single_rotate(root.get_child(!dir), !dir));
    return single_rotate(root, dir);
  };
  var TreeBase = require_treebase();
  Node.prototype.get_child = function(dir) {
    return dir ? this.right : this.left;
  };
  Node.prototype.set_child = function(dir, val) {
    if (dir) {
      this.right = val;
    } else {
      this.left = val;
    }
  };
  RBTree.prototype = new TreeBase;
  RBTree.prototype.insert = function(data3) {
    var ret2 = false;
    if (this._root === null) {
      this._root = new Node(data3);
      ret2 = true;
      this.size++;
    } else {
      var head = new Node(undefined);
      var dir = 0;
      var last = 0;
      var gp = null;
      var ggp = head;
      var p = null;
      var node8 = this._root;
      ggp.right = this._root;
      while (true) {
        if (node8 === null) {
          node8 = new Node(data3);
          p.set_child(dir, node8);
          ret2 = true;
          this.size++;
        } else if (is_red(node8.left) && is_red(node8.right)) {
          node8.red = true;
          node8.left.red = false;
          node8.right.red = false;
        }
        if (is_red(node8) && is_red(p)) {
          var dir2 = ggp.right === gp;
          if (node8 === p.get_child(last)) {
            ggp.set_child(dir2, single_rotate(gp, !last));
          } else {
            ggp.set_child(dir2, double_rotate(gp, !last));
          }
        }
        var cmp = this._comparator(node8.data, data3);
        if (cmp === 0) {
          break;
        }
        last = dir;
        dir = cmp < 0;
        if (gp !== null) {
          ggp = gp;
        }
        gp = p;
        p = node8;
        node8 = node8.get_child(dir);
      }
      this._root = head.right;
    }
    this._root.red = false;
    return ret2;
  };
  RBTree.prototype.remove = function(data3) {
    if (this._root === null) {
      return false;
    }
    var head = new Node(undefined);
    var node8 = head;
    node8.right = this._root;
    var p = null;
    var gp = null;
    var found = null;
    var dir = 1;
    while (node8.get_child(dir) !== null) {
      var last = dir;
      gp = p;
      p = node8;
      node8 = node8.get_child(dir);
      var cmp = this._comparator(data3, node8.data);
      dir = cmp > 0;
      if (cmp === 0) {
        found = node8;
      }
      if (!is_red(node8) && !is_red(node8.get_child(dir))) {
        if (is_red(node8.get_child(!dir))) {
          var sr = single_rotate(node8, dir);
          p.set_child(last, sr);
          p = sr;
        } else if (!is_red(node8.get_child(!dir))) {
          var sibling = p.get_child(!last);
          if (sibling !== null) {
            if (!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {
              p.red = false;
              sibling.red = true;
              node8.red = true;
            } else {
              var dir2 = gp.right === p;
              if (is_red(sibling.get_child(last))) {
                gp.set_child(dir2, double_rotate(p, last));
              } else if (is_red(sibling.get_child(!last))) {
                gp.set_child(dir2, single_rotate(p, last));
              }
              var gpc = gp.get_child(dir2);
              gpc.red = true;
              node8.red = true;
              gpc.left.red = false;
              gpc.right.red = false;
            }
          }
        }
      }
    }
    if (found !== null) {
      found.data = node8.data;
      p.set_child(p.right === node8, node8.get_child(node8.left === null));
      this.size--;
    }
    this._root = head.right;
    if (this._root !== null) {
      this._root.red = false;
    }
    return found !== null;
  };
  module.exports = RBTree;
});

// ../node_modules/.pnpm/bintrees@1.0.2/node_modules/bintrees/lib/bintree.js
var require_bintree = __commonJS((exports, module) => {
  var Node = function(data3) {
    this.data = data3;
    this.left = null;
    this.right = null;
  };
  var BinTree = function(comparator) {
    this._root = null;
    this._comparator = comparator;
    this.size = 0;
  };
  var TreeBase = require_treebase();
  Node.prototype.get_child = function(dir) {
    return dir ? this.right : this.left;
  };
  Node.prototype.set_child = function(dir, val) {
    if (dir) {
      this.right = val;
    } else {
      this.left = val;
    }
  };
  BinTree.prototype = new TreeBase;
  BinTree.prototype.insert = function(data3) {
    if (this._root === null) {
      this._root = new Node(data3);
      this.size++;
      return true;
    }
    var dir = 0;
    var p = null;
    var node8 = this._root;
    while (true) {
      if (node8 === null) {
        node8 = new Node(data3);
        p.set_child(dir, node8);
        ret = true;
        this.size++;
        return true;
      }
      if (this._comparator(node8.data, data3) === 0) {
        return false;
      }
      dir = this._comparator(node8.data, data3) < 0;
      p = node8;
      node8 = node8.get_child(dir);
    }
  };
  BinTree.prototype.remove = function(data3) {
    if (this._root === null) {
      return false;
    }
    var head = new Node(undefined);
    var node8 = head;
    node8.right = this._root;
    var p = null;
    var found = null;
    var dir = 1;
    while (node8.get_child(dir) !== null) {
      p = node8;
      node8 = node8.get_child(dir);
      var cmp = this._comparator(data3, node8.data);
      dir = cmp > 0;
      if (cmp === 0) {
        found = node8;
      }
    }
    if (found !== null) {
      found.data = node8.data;
      p.set_child(p.right === node8, node8.get_child(node8.left === null));
      this._root = head.right;
      this.size--;
      return true;
    } else {
      return false;
    }
  };
  module.exports = BinTree;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/tdigest@0.1.2/node_modules/bintrees/index.js
var require_bintrees = __commonJS((exports, module) => {
  module.exports = {
    RBTree: require_rbtree(),
    BinTree: require_bintree()
  };
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/prom-client@14.2.0/node_modules/tdigest/tdigest.js
var require_tdigest = __commonJS((exports, module) => {
  var TDigest = function(delta, K, CX) {
    this.discrete = delta === false;
    this.delta = delta || 0.01;
    this.K = K === undefined ? 25 : K;
    this.CX = CX === undefined ? 1.1 : CX;
    this.centroids = new RBTree(compare_centroid_means);
    this.nreset = 0;
    this.reset();
  };
  var compare_centroid_means = function(a, b) {
    return a.mean > b.mean ? 1 : a.mean < b.mean ? -1 : 0;
  };
  var compare_centroid_mean_cumns = function(a, b) {
    return a.mean_cumn - b.mean_cumn;
  };
  var pop_random = function(choices) {
    var idx = Math.floor(Math.random() * choices.length);
    return choices.splice(idx, 1)[0];
  };
  var Digest = function(config) {
    this.config = config || {};
    this.mode = this.config.mode || "auto";
    TDigest.call(this, this.mode === "cont" ? config.delta : false);
    this.digest_ratio = this.config.ratio || 0.9;
    this.digest_thresh = this.config.thresh || 1000;
    this.n_unique = 0;
  };
  var RBTree = require_bintrees().RBTree;
  TDigest.prototype.reset = function() {
    this.centroids.clear();
    this.n = 0;
    this.nreset += 1;
    this.last_cumulate = 0;
  };
  TDigest.prototype.size = function() {
    return this.centroids.size;
  };
  TDigest.prototype.toArray = function(everything) {
    var result = [];
    if (everything) {
      this._cumulate(true);
      this.centroids.each(function(c) {
        result.push(c);
      });
    } else {
      this.centroids.each(function(c) {
        result.push({ mean: c.mean, n: c.n });
      });
    }
    return result;
  };
  TDigest.prototype.summary = function() {
    var approx = this.discrete ? "exact " : "approximating ";
    var s = [
      approx + this.n + " samples using " + this.size() + " centroids",
      "min = " + this.percentile(0),
      "Q1  = " + this.percentile(0.25),
      "Q2  = " + this.percentile(0.5),
      "Q3  = " + this.percentile(0.75),
      "max = " + this.percentile(1)
    ];
    return s.join("\n");
  };
  TDigest.prototype.push = function(x, n) {
    n = n || 1;
    x = Array.isArray(x) ? x : [x];
    for (var i = 0;i < x.length; i++) {
      this._digest(x[i], n);
    }
  };
  TDigest.prototype.push_centroid = function(c) {
    c = Array.isArray(c) ? c : [c];
    for (var i = 0;i < c.length; i++) {
      this._digest(c[i].mean, c[i].n);
    }
  };
  TDigest.prototype._cumulate = function(exact) {
    if (this.n === this.last_cumulate || !exact && this.CX && this.CX > this.n / this.last_cumulate) {
      return;
    }
    var cumn = 0;
    this.centroids.each(function(c) {
      c.mean_cumn = cumn + c.n / 2;
      cumn = c.cumn = cumn + c.n;
    });
    this.n = this.last_cumulate = cumn;
  };
  TDigest.prototype.find_nearest = function(x) {
    if (this.size() === 0) {
      return null;
    }
    var iter = this.centroids.lowerBound({ mean: x });
    var c = iter.data() === null ? iter.prev() : iter.data();
    if (c.mean === x || this.discrete) {
      return c;
    }
    var prev = iter.prev();
    if (prev && Math.abs(prev.mean - x) < Math.abs(c.mean - x)) {
      return prev;
    } else {
      return c;
    }
  };
  TDigest.prototype._new_centroid = function(x, n, cumn) {
    var c = { mean: x, n, cumn };
    this.centroids.insert(c);
    this.n += n;
    return c;
  };
  TDigest.prototype._addweight = function(nearest, x, n) {
    if (x !== nearest.mean) {
      nearest.mean += n * (x - nearest.mean) / (nearest.n + n);
    }
    nearest.cumn += n;
    nearest.mean_cumn += n / 2;
    nearest.n += n;
    this.n += n;
  };
  TDigest.prototype._digest = function(x, n) {
    var min = this.centroids.min();
    var max = this.centroids.max();
    var nearest = this.find_nearest(x);
    if (nearest && nearest.mean === x) {
      this._addweight(nearest, x, n);
    } else if (nearest === min) {
      this._new_centroid(x, n, 0);
    } else if (nearest === max) {
      this._new_centroid(x, n, this.n);
    } else if (this.discrete) {
      this._new_centroid(x, n, nearest.cumn);
    } else {
      var p = nearest.mean_cumn / this.n;
      var max_n = Math.floor(4 * this.n * this.delta * p * (1 - p));
      if (max_n - nearest.n >= n) {
        this._addweight(nearest, x, n);
      } else {
        this._new_centroid(x, n, nearest.cumn);
      }
    }
    this._cumulate(false);
    if (!this.discrete && this.K && this.size() > this.K / this.delta) {
      this.compress();
    }
  };
  TDigest.prototype.bound_mean = function(x) {
    var iter = this.centroids.upperBound({ mean: x });
    var lower = iter.prev();
    var upper = lower.mean === x ? lower : iter.next();
    return [lower, upper];
  };
  TDigest.prototype.p_rank = function(x_or_xlist) {
    var xs = Array.isArray(x_or_xlist) ? x_or_xlist : [x_or_xlist];
    var ps = xs.map(this._p_rank, this);
    return Array.isArray(x_or_xlist) ? ps : ps[0];
  };
  TDigest.prototype._p_rank = function(x) {
    if (this.size() === 0) {
      return;
    } else if (x < this.centroids.min().mean) {
      return 0;
    } else if (x > this.centroids.max().mean) {
      return 1;
    }
    this._cumulate(true);
    var bound = this.bound_mean(x);
    var lower = bound[0], upper = bound[1];
    if (this.discrete) {
      return lower.cumn / this.n;
    } else {
      var cumn = lower.mean_cumn;
      if (lower !== upper) {
        cumn += (x - lower.mean) * (upper.mean_cumn - lower.mean_cumn) / (upper.mean - lower.mean);
      }
      return cumn / this.n;
    }
  };
  TDigest.prototype.bound_mean_cumn = function(cumn) {
    this.centroids._comparator = compare_centroid_mean_cumns;
    var iter = this.centroids.upperBound({ mean_cumn: cumn });
    this.centroids._comparator = compare_centroid_means;
    var lower = iter.prev();
    var upper = lower && lower.mean_cumn === cumn ? lower : iter.next();
    return [lower, upper];
  };
  TDigest.prototype.percentile = function(p_or_plist) {
    var ps = Array.isArray(p_or_plist) ? p_or_plist : [p_or_plist];
    var qs = ps.map(this._percentile, this);
    return Array.isArray(p_or_plist) ? qs : qs[0];
  };
  TDigest.prototype._percentile = function(p) {
    if (this.size() === 0) {
      return;
    }
    this._cumulate(true);
    var h = this.n * p;
    var bound = this.bound_mean_cumn(h);
    var lower = bound[0], upper = bound[1];
    if (upper === lower || lower === null || upper === null) {
      return (lower || upper).mean;
    } else if (!this.discrete) {
      return lower.mean + (h - lower.mean_cumn) * (upper.mean - lower.mean) / (upper.mean_cumn - lower.mean_cumn);
    } else if (h <= lower.cumn) {
      return lower.mean;
    } else {
      return upper.mean;
    }
  };
  TDigest.prototype.compress = function() {
    if (this.compressing) {
      return;
    }
    var points = this.toArray();
    this.reset();
    this.compressing = true;
    while (points.length > 0) {
      this.push_centroid(pop_random(points));
    }
    this._cumulate(true);
    this.compressing = false;
  };
  Digest.prototype = Object.create(TDigest.prototype);
  Digest.prototype.constructor = Digest;
  Digest.prototype.push = function(x_or_xlist) {
    TDigest.prototype.push.call(this, x_or_xlist);
    this.check_continuous();
  };
  Digest.prototype._new_centroid = function(x, n, cumn) {
    this.n_unique += 1;
    TDigest.prototype._new_centroid.call(this, x, n, cumn);
  };
  Digest.prototype._addweight = function(nearest, x, n) {
    if (nearest.n === 1) {
      this.n_unique -= 1;
    }
    TDigest.prototype._addweight.call(this, nearest, x, n);
  };
  Digest.prototype.check_continuous = function() {
    if (this.mode !== "auto" || this.size() < this.digest_thresh) {
      return false;
    }
    if (this.n_unique / this.size() > this.digest_ratio) {
      this.mode = "cont";
      this.discrete = false;
      this.delta = this.config.delta || 0.01;
      this.compress();
      return true;
    }
    return false;
  };
  module.exports = {
    TDigest,
    Digest
  };
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/timeWindowQuantiles.js
var require_timeWindowQuantiles = __commonJS((exports, module) => {
  var rotate = function() {
    let timeSinceLastRotateMillis = Date.now() - this.lastRotateTimestampMillis;
    while (timeSinceLastRotateMillis > this.durationBetweenRotatesMillis && this.shouldRotate) {
      this.ringBuffer[this.currentBuffer] = new TDigest;
      if (++this.currentBuffer >= this.ringBuffer.length) {
        this.currentBuffer = 0;
      }
      timeSinceLastRotateMillis -= this.durationBetweenRotatesMillis;
      this.lastRotateTimestampMillis += this.durationBetweenRotatesMillis;
    }
    return this.ringBuffer[this.currentBuffer];
  };
  var { TDigest } = require_tdigest();

  class TimeWindowQuantiles {
    constructor(maxAgeSeconds, ageBuckets) {
      this.maxAgeSeconds = maxAgeSeconds || 0;
      this.ageBuckets = ageBuckets || 0;
      this.shouldRotate = maxAgeSeconds && ageBuckets;
      this.ringBuffer = Array(ageBuckets).fill(new TDigest);
      this.currentBuffer = 0;
      this.lastRotateTimestampMillis = Date.now();
      this.durationBetweenRotatesMillis = maxAgeSeconds * 1000 / ageBuckets || Infinity;
    }
    size() {
      const bucket = rotate.call(this);
      return bucket.size();
    }
    percentile(quantile) {
      const bucket = rotate.call(this);
      return bucket.percentile(quantile);
    }
    push(value) {
      rotate.call(this);
      this.ringBuffer.forEach((bucket) => {
        bucket.push(value);
      });
    }
    reset() {
      this.ringBuffer.forEach((bucket) => {
        bucket.reset();
      });
    }
    compress() {
      this.ringBuffer.forEach((bucket) => {
        bucket.compress();
      });
    }
  }
  module.exports = TimeWindowQuantiles;
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/summary.js
var require_summary = __commonJS((exports, module) => {
  var extractSummariesForExport = function(summaryOfLabels, percentiles) {
    summaryOfLabels.td.compress();
    return percentiles.map((percentile) => {
      const percentileValue = summaryOfLabels.td.percentile(percentile);
      return {
        labels: Object.assign({ quantile: percentile }, summaryOfLabels.labels),
        value: percentileValue ? percentileValue : 0
      };
    });
  };
  var getCountForExport = function(value, summary) {
    return {
      metricName: `${summary.name}_count`,
      labels: value.labels,
      value: value.count
    };
  };
  var getSumForExport = function(value, summary) {
    return {
      metricName: `${summary.name}_sum`,
      labels: value.labels,
      value: value.sum
    };
  };
  var startTimer = function(startLabels) {
    return () => {
      const start = process.hrtime();
      return (endLabels) => {
        const delta = process.hrtime(start);
        const value = delta[0] + delta[1] / 1e9;
        this.observe(Object.assign({}, startLabels, endLabels), value);
        return value;
      };
    };
  };
  var observe8 = function(labels) {
    return (value) => {
      const labelValuePair = convertLabelsAndValues(labels, value);
      validateLabel(this.labelNames, labels);
      if (!Number.isFinite(labelValuePair.value)) {
        throw new TypeError(`Value is not a valid number: ${util2.format(labelValuePair.value)}`);
      }
      const hash4 = hashObject(labelValuePair.labels);
      let summaryOfLabel = this.hashMap[hash4];
      if (!summaryOfLabel) {
        summaryOfLabel = {
          labels: labelValuePair.labels,
          td: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),
          count: 0,
          sum: 0
        };
      }
      summaryOfLabel.td.push(labelValuePair.value);
      summaryOfLabel.count++;
      if (summaryOfLabel.count % this.compressCount === 0) {
        summaryOfLabel.td.compress();
      }
      summaryOfLabel.sum += labelValuePair.value;
      this.hashMap[hash4] = summaryOfLabel;
    };
  };
  var convertLabelsAndValues = function(labels, value) {
    if (value === undefined) {
      return {
        value: labels,
        labels: {}
      };
    }
    return {
      labels,
      value
    };
  };
  var util2 = __require("util");
  var type = "summary";
  var { getLabels, hashObject, removeLabels } = require_util();
  var { validateLabel } = require_validation();
  var { Metric } = require_metric();
  var timeWindowQuantiles = require_timeWindowQuantiles();
  var DEFAULT_COMPRESS_COUNT = 1000;

  class Summary extends Metric {
    constructor(config) {
      super(config, {
        percentiles: [0.01, 0.05, 0.5, 0.9, 0.95, 0.99, 0.999],
        compressCount: DEFAULT_COMPRESS_COUNT,
        hashMap: {}
      });
      for (const label of this.labelNames) {
        if (label === "quantile")
          throw new Error("quantile is a reserved label keyword");
      }
      if (this.labelNames.length === 0) {
        this.hashMap = {
          [hashObject({})]: {
            labels: {},
            td: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),
            count: 0,
            sum: 0
          }
        };
      }
    }
    observe(labels, value) {
      observe8.call(this, labels === 0 ? 0 : labels || {})(value);
    }
    async get() {
      if (this.collect) {
        const v = this.collect();
        if (v instanceof Promise)
          await v;
      }
      const hashKeys = Object.keys(this.hashMap);
      const values = [];
      hashKeys.forEach((hashKey) => {
        const s = this.hashMap[hashKey];
        if (s) {
          if (this.pruneAgedBuckets && s.td.size() === 0) {
            delete this.hashMap[hashKey];
          } else {
            extractSummariesForExport(s, this.percentiles).forEach((v) => {
              values.push(v);
            });
            values.push(getSumForExport(s, this));
            values.push(getCountForExport(s, this));
          }
        }
      });
      return {
        name: this.name,
        help: this.help,
        type,
        values,
        aggregator: this.aggregator
      };
    }
    reset() {
      const data3 = Object.values(this.hashMap);
      data3.forEach((s) => {
        s.td.reset();
        s.count = 0;
        s.sum = 0;
      });
    }
    startTimer(labels) {
      return startTimer.call(this, labels)();
    }
    labels(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      return {
        observe: observe8.call(this, labels),
        startTimer: startTimer.call(this, labels)
      };
    }
    remove(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      removeLabels.call(this, this.hashMap, labels);
    }
  }
  module.exports = Summary;
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/pushgateway.js
var require_pushgateway = __commonJS((exports, module) => {
  async function useGateway(method, job, groupings) {
    const gatewayUrlParsed = url.parse(this.gatewayUrl);
    const gatewayUrlPath = gatewayUrlParsed.pathname && gatewayUrlParsed.pathname !== "/" ? gatewayUrlParsed.pathname : "";
    const path = `${gatewayUrlPath}/metrics/job/${encodeURIComponent(job)}${generateGroupings(groupings)}`;
    const target = url.resolve(this.gatewayUrl, path);
    const requestParams = url.parse(target);
    const httpModule = isHttps(requestParams.href) ? https : http2;
    const options = Object.assign(requestParams, this.requestOptions, {
      method
    });
    return new Promise((resolve5, reject) => {
      const req = httpModule.request(options, (resp) => {
        let body = "";
        resp.setEncoding("utf8");
        resp.on("data", (chunk) => {
          body += chunk;
        });
        resp.on("end", () => {
          resolve5({ resp, body });
        });
      });
      req.on("error", (err) => {
        reject(err);
      });
      if (method !== "DELETE") {
        this.registry.metrics().then((metrics) => {
          if (options.headers && options.headers["Content-Encoding"] === "gzip") {
            metrics = gzipSync(metrics);
          }
          req.write(metrics);
          req.end();
        }).catch((err) => {
          reject(err);
        });
      } else {
        req.end();
      }
    });
  }
  var generateGroupings = function(groupings) {
    if (!groupings) {
      return "";
    }
    return Object.keys(groupings).map((key) => `/${encodeURIComponent(key)}/${encodeURIComponent(groupings[key])}`).join("");
  };
  var isHttps = function(href) {
    return href.search(/^https/) !== -1;
  };
  var url = __require("url");
  var http2 = __require("http");
  var https = __require("https");
  var { gzipSync } = __require("zlib");
  var { globalRegistry } = require_registry();

  class Pushgateway {
    constructor(gatewayUrl, options, registry) {
      if (!registry) {
        registry = globalRegistry;
      }
      this.registry = registry;
      this.gatewayUrl = gatewayUrl;
      this.requestOptions = Object.assign({}, options);
    }
    pushAdd(params) {
      if (!params || !params.jobName) {
        throw new Error("Missing jobName parameter");
      }
      return useGateway.call(this, "POST", params.jobName, params.groupings);
    }
    push(params) {
      if (!params || !params.jobName) {
        throw new Error("Missing jobName parameter");
      }
      return useGateway.call(this, "PUT", params.jobName, params.groupings);
    }
    delete(params) {
      if (!params || !params.jobName) {
        throw new Error("Missing jobName parameter");
      }
      return useGateway.call(this, "DELETE", params.jobName, params.groupings);
    }
  }
  module.exports = Pushgateway;
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/bucketGenerators.js
var require_bucketGenerators = __commonJS((exports) => {
  exports.linearBuckets = (start, width, count) => {
    if (count < 1) {
      throw new Error("Linear buckets needs a positive count");
    }
    const buckets = new Array(count);
    for (let i = 0;i < count; i++) {
      buckets[i] = start + i * width;
    }
    return buckets;
  };
  exports.exponentialBuckets = (start, factor, count) => {
    if (start <= 0) {
      throw new Error("Exponential buckets needs a positive start");
    }
    if (count < 1) {
      throw new Error("Exponential buckets needs a positive count");
    }
    if (factor <= 1) {
      throw new Error("Exponential buckets needs a factor greater than 1");
    }
    const buckets = new Array(count);
    for (let i = 0;i < count; i++) {
      buckets[i] = start;
      start *= factor;
    }
    return buckets;
  };
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/metrics/processCpuTotal.js
var require_processCpuTotal = __commonJS((exports, module) => {
  var Counter = require_counter();
  var PROCESS_CPU_USER_SECONDS = "process_cpu_user_seconds_total";
  var PROCESS_CPU_SYSTEM_SECONDS = "process_cpu_system_seconds_total";
  var PROCESS_CPU_SECONDS = "process_cpu_seconds_total";
  module.exports = (registry, config = {}) => {
    const registers = registry ? [registry] : undefined;
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    let lastCpuUsage = process.cpuUsage();
    const cpuUserUsageCounter = new Counter({
      name: namePrefix + PROCESS_CPU_USER_SECONDS,
      help: "Total user CPU time spent in seconds.",
      registers,
      labelNames,
      collect() {
        const cpuUsage = process.cpuUsage();
        const userUsageMicros = cpuUsage.user - lastCpuUsage.user;
        const systemUsageMicros = cpuUsage.system - lastCpuUsage.system;
        lastCpuUsage = cpuUsage;
        cpuUserUsageCounter.inc(labels, userUsageMicros / 1e6);
        cpuSystemUsageCounter.inc(labels, systemUsageMicros / 1e6);
        cpuUsageCounter.inc(labels, (userUsageMicros + systemUsageMicros) / 1e6);
      }
    });
    const cpuSystemUsageCounter = new Counter({
      name: namePrefix + PROCESS_CPU_SYSTEM_SECONDS,
      help: "Total system CPU time spent in seconds.",
      registers,
      labelNames
    });
    const cpuUsageCounter = new Counter({
      name: namePrefix + PROCESS_CPU_SECONDS,
      help: "Total user and system CPU time spent in seconds.",
      registers,
      labelNames
    });
  };
  module.exports.metricNames = [
    PROCESS_CPU_USER_SECONDS,
    PROCESS_CPU_SYSTEM_SECONDS,
    PROCESS_CPU_SECONDS
  ];
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/metrics/processStartTime.js
var require_processStartTime = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var startInSeconds = Math.round(Date.now() / 1000 - process.uptime());
  var PROCESS_START_TIME = "process_start_time_seconds";
  module.exports = (registry, config = {}) => {
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + PROCESS_START_TIME,
      help: "Start time of the process since unix epoch in seconds.",
      registers: registry ? [registry] : undefined,
      labelNames,
      aggregator: "omit",
      collect() {
        this.set(labels, startInSeconds);
      }
    });
  };
  module.exports.metricNames = [PROCESS_START_TIME];
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/metrics/osMemoryHeapLinux.js
var require_osMemoryHeapLinux = __commonJS((exports, module) => {
  var structureOutput = function(input) {
    const returnValue = {};
    input.split("\n").filter((s) => values.some((value) => s.indexOf(value) === 0)).forEach((string) => {
      const split2 = string.split(":");
      let value = split2[1].trim();
      value = value.substr(0, value.length - 3);
      value = Number(value) * 1024;
      returnValue[split2[0]] = value;
    });
    return returnValue;
  };
  var Gauge = require_gauge();
  var fs = __require("fs");
  var values = ["VmSize", "VmRSS", "VmData"];
  var PROCESS_RESIDENT_MEMORY = "process_resident_memory_bytes";
  var PROCESS_VIRTUAL_MEMORY = "process_virtual_memory_bytes";
  var PROCESS_HEAP = "process_heap_bytes";
  module.exports = (registry, config = {}) => {
    const registers = registry ? [registry] : undefined;
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    const residentMemGauge = new Gauge({
      name: namePrefix + PROCESS_RESIDENT_MEMORY,
      help: "Resident memory size in bytes.",
      registers,
      labelNames,
      collect() {
        try {
          const stat = fs.readFileSync("/proc/self/status", "utf8");
          const structuredOutput = structureOutput(stat);
          residentMemGauge.set(labels, structuredOutput.VmRSS);
          virtualMemGauge.set(labels, structuredOutput.VmSize);
          heapSizeMemGauge.set(labels, structuredOutput.VmData);
        } catch {
        }
      }
    });
    const virtualMemGauge = new Gauge({
      name: namePrefix + PROCESS_VIRTUAL_MEMORY,
      help: "Virtual memory size in bytes.",
      registers,
      labelNames
    });
    const heapSizeMemGauge = new Gauge({
      name: namePrefix + PROCESS_HEAP,
      help: "Process heap size in bytes.",
      registers,
      labelNames
    });
  };
  module.exports.metricNames = [
    PROCESS_RESIDENT_MEMORY,
    PROCESS_VIRTUAL_MEMORY,
    PROCESS_HEAP
  ];
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/metrics/helpers/safeMemoryUsage.js
var require_safeMemoryUsage = __commonJS((exports, module) => {
  var safeMemoryUsage = function() {
    try {
      return process.memoryUsage();
    } catch {
      return;
    }
  };
  module.exports = safeMemoryUsage;
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/metrics/osMemoryHeap.js
var require_osMemoryHeap = __commonJS((exports, module) => {
  var notLinuxVariant = function(registry, config = {}) {
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + PROCESS_RESIDENT_MEMORY,
      help: "Resident memory size in bytes.",
      registers: registry ? [registry] : undefined,
      labelNames,
      collect() {
        const memUsage = safeMemoryUsage();
        if (memUsage) {
          this.set(labels, memUsage.rss);
        }
      }
    });
  };
  var Gauge = require_gauge();
  var linuxVariant = require_osMemoryHeapLinux();
  var safeMemoryUsage = require_safeMemoryUsage();
  var PROCESS_RESIDENT_MEMORY = "process_resident_memory_bytes";
  module.exports = (registry, config) => process.platform === "linux" ? linuxVariant(registry, config) : notLinuxVariant(registry, config);
  module.exports.metricNames = process.platform === "linux" ? linuxVariant.metricNames : [PROCESS_RESIDENT_MEMORY];
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/metrics/processOpenFileDescriptors.js
var require_processOpenFileDescriptors = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var fs = __require("fs");
  var process2 = __require("process");
  var PROCESS_OPEN_FDS = "process_open_fds";
  module.exports = (registry, config = {}) => {
    if (process2.platform !== "linux") {
      return;
    }
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + PROCESS_OPEN_FDS,
      help: "Number of open file descriptors.",
      registers: registry ? [registry] : undefined,
      labelNames,
      collect() {
        try {
          const fds = fs.readdirSync("/proc/self/fd");
          this.set(labels, fds.length - 1);
        } catch {
        }
      }
    });
  };
  module.exports.metricNames = [PROCESS_OPEN_FDS];
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/metrics/processMaxFileDescriptors.js
var require_processMaxFileDescriptors = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var fs = __require("fs");
  var PROCESS_MAX_FDS = "process_max_fds";
  var maxFds;
  module.exports = (registry, config = {}) => {
    if (maxFds === undefined) {
      try {
        const limits = fs.readFileSync("/proc/self/limits", "utf8");
        const lines = limits.split("\n");
        for (const line of lines) {
          if (line.startsWith("Max open files")) {
            const parts = line.split(/  +/);
            maxFds = Number(parts[1]);
            break;
          }
        }
      } catch {
        return;
      }
    }
    if (maxFds === undefined)
      return;
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + PROCESS_MAX_FDS,
      help: "Maximum number of open file descriptors.",
      registers: registry ? [registry] : undefined,
      labelNames,
      collect() {
        if (maxFds !== undefined)
          this.set(labels, maxFds);
      }
    });
  };
  module.exports.metricNames = [PROCESS_MAX_FDS];
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/metrics/eventLoopLag.js
var require_eventLoopLag = __commonJS((exports, module) => {
  var reportEventloopLag = function(start, gauge, labels) {
    const delta = process.hrtime(start);
    const nanosec = delta[0] * 1e9 + delta[1];
    const seconds = nanosec / 1e9;
    gauge.set(labels, seconds);
  };
  var Gauge = require_gauge();
  var perf_hooks;
  try {
    perf_hooks = __require("perf_hooks");
  } catch {
  }
  var NODEJS_EVENTLOOP_LAG = "nodejs_eventloop_lag_seconds";
  var NODEJS_EVENTLOOP_LAG_MIN = "nodejs_eventloop_lag_min_seconds";
  var NODEJS_EVENTLOOP_LAG_MAX = "nodejs_eventloop_lag_max_seconds";
  var NODEJS_EVENTLOOP_LAG_MEAN = "nodejs_eventloop_lag_mean_seconds";
  var NODEJS_EVENTLOOP_LAG_STDDEV = "nodejs_eventloop_lag_stddev_seconds";
  var NODEJS_EVENTLOOP_LAG_P50 = "nodejs_eventloop_lag_p50_seconds";
  var NODEJS_EVENTLOOP_LAG_P90 = "nodejs_eventloop_lag_p90_seconds";
  var NODEJS_EVENTLOOP_LAG_P99 = "nodejs_eventloop_lag_p99_seconds";
  module.exports = (registry, config = {}) => {
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    const registers = registry ? [registry] : undefined;
    let collect;
    if (!perf_hooks || !perf_hooks.monitorEventLoopDelay) {
      collect = () => {
        const start = process.hrtime();
        setImmediate(reportEventloopLag, start, lag, labels);
      };
    } else {
      const histogram = perf_hooks.monitorEventLoopDelay({
        resolution: config.eventLoopMonitoringPrecision
      });
      histogram.enable();
      collect = () => {
        const start = process.hrtime();
        setImmediate(reportEventloopLag, start, lag, labels);
        lagMin.set(labels, histogram.min / 1e9);
        lagMax.set(labels, histogram.max / 1e9);
        lagMean.set(labels, histogram.mean / 1e9);
        lagStddev.set(labels, histogram.stddev / 1e9);
        lagP50.set(labels, histogram.percentile(50) / 1e9);
        lagP90.set(labels, histogram.percentile(90) / 1e9);
        lagP99.set(labels, histogram.percentile(99) / 1e9);
        histogram.reset();
      };
    }
    const lag = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG,
      help: "Lag of event loop in seconds.",
      registers,
      labelNames,
      aggregator: "average",
      collect
    });
    const lagMin = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_MIN,
      help: "The minimum recorded event loop delay.",
      registers,
      labelNames,
      aggregator: "min"
    });
    const lagMax = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_MAX,
      help: "The maximum recorded event loop delay.",
      registers,
      labelNames,
      aggregator: "max"
    });
    const lagMean = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_MEAN,
      help: "The mean of the recorded event loop delays.",
      registers,
      labelNames,
      aggregator: "average"
    });
    const lagStddev = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_STDDEV,
      help: "The standard deviation of the recorded event loop delays.",
      registers,
      labelNames,
      aggregator: "average"
    });
    const lagP50 = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_P50,
      help: "The 50th percentile of the recorded event loop delays.",
      registers,
      labelNames,
      aggregator: "average"
    });
    const lagP90 = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_P90,
      help: "The 90th percentile of the recorded event loop delays.",
      registers,
      labelNames,
      aggregator: "average"
    });
    const lagP99 = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_P99,
      help: "The 99th percentile of the recorded event loop delays.",
      registers,
      labelNames,
      aggregator: "average"
    });
  };
  module.exports.metricNames = [
    NODEJS_EVENTLOOP_LAG,
    NODEJS_EVENTLOOP_LAG_MIN,
    NODEJS_EVENTLOOP_LAG_MAX,
    NODEJS_EVENTLOOP_LAG_MEAN,
    NODEJS_EVENTLOOP_LAG_STDDEV,
    NODEJS_EVENTLOOP_LAG_P50,
    NODEJS_EVENTLOOP_LAG_P90,
    NODEJS_EVENTLOOP_LAG_P99
  ];
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/metrics/helpers/processMetricsHelpers.js
var require_processMetricsHelpers = __commonJS((exports, module) => {
  var aggregateByObjectName = function(list) {
    const data3 = {};
    for (let i = 0;i < list.length; i++) {
      const listElement = list[i];
      if (!listElement || typeof listElement.constructor === "undefined") {
        continue;
      }
      if (Object.hasOwnProperty.call(data3, listElement.constructor.name)) {
        data3[listElement.constructor.name] += 1;
      } else {
        data3[listElement.constructor.name] = 1;
      }
    }
    return data3;
  };
  var updateMetrics = function(gauge, data3, labels) {
    gauge.reset();
    for (const key in data3) {
      gauge.set(Object.assign({ type: key }, labels || {}), data3[key]);
    }
  };
  module.exports = {
    aggregateByObjectName,
    updateMetrics
  };
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/metrics/processHandles.js
var require_processHandles = __commonJS((exports, module) => {
  var { aggregateByObjectName } = require_processMetricsHelpers();
  var { updateMetrics } = require_processMetricsHelpers();
  var Gauge = require_gauge();
  var NODEJS_ACTIVE_HANDLES = "nodejs_active_handles";
  var NODEJS_ACTIVE_HANDLES_TOTAL = "nodejs_active_handles_total";
  module.exports = (registry, config = {}) => {
    if (typeof process._getActiveHandles !== "function") {
      return;
    }
    const registers = registry ? [registry] : undefined;
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_HANDLES,
      help: "Number of active libuv handles grouped by handle type. Every handle type is C++ class name.",
      labelNames: ["type", ...labelNames],
      registers,
      collect() {
        const handles = process._getActiveHandles();
        updateMetrics(this, aggregateByObjectName(handles), labels);
      }
    });
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_HANDLES_TOTAL,
      help: "Total number of active handles.",
      registers,
      labelNames,
      collect() {
        const handles = process._getActiveHandles();
        this.set(labels, handles.length);
      }
    });
  };
  module.exports.metricNames = [
    NODEJS_ACTIVE_HANDLES,
    NODEJS_ACTIVE_HANDLES_TOTAL
  ];
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/metrics/processRequests.js
var require_processRequests = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var { aggregateByObjectName } = require_processMetricsHelpers();
  var { updateMetrics } = require_processMetricsHelpers();
  var NODEJS_ACTIVE_REQUESTS = "nodejs_active_requests";
  var NODEJS_ACTIVE_REQUESTS_TOTAL = "nodejs_active_requests_total";
  module.exports = (registry, config = {}) => {
    if (typeof process._getActiveRequests !== "function") {
      return;
    }
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_REQUESTS,
      help: "Number of active libuv requests grouped by request type. Every request type is C++ class name.",
      labelNames: ["type", ...labelNames],
      registers: registry ? [registry] : undefined,
      collect() {
        const requests = process._getActiveRequests();
        updateMetrics(this, aggregateByObjectName(requests), labels);
      }
    });
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_REQUESTS_TOTAL,
      help: "Total number of active requests.",
      registers: registry ? [registry] : undefined,
      labelNames,
      collect() {
        const requests = process._getActiveRequests();
        this.set(labels, requests.length);
      }
    });
  };
  module.exports.metricNames = [
    NODEJS_ACTIVE_REQUESTS,
    NODEJS_ACTIVE_REQUESTS_TOTAL
  ];
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/metrics/processResources.js
var require_processResources = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var { updateMetrics } = require_processMetricsHelpers();
  var NODEJS_ACTIVE_RESOURCES = "nodejs_active_resources";
  var NODEJS_ACTIVE_RESOURCES_TOTAL = "nodejs_active_resources_total";
  module.exports = (registry, config = {}) => {
    if (typeof process.getActiveResourcesInfo !== "function") {
      return;
    }
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_RESOURCES,
      help: "Number of active resources that are currently keeping the event loop alive, grouped by async resource type.",
      labelNames: ["type", ...labelNames],
      registers: registry ? [registry] : undefined,
      collect() {
        const resources = process.getActiveResourcesInfo();
        const data3 = {};
        for (let i = 0;i < resources.length; i++) {
          const resource = resources[i];
          if (Object.hasOwn(data3, resource)) {
            data3[resource] += 1;
          } else {
            data3[resource] = 1;
          }
        }
        updateMetrics(this, data3, labels);
      }
    });
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_RESOURCES_TOTAL,
      help: "Total number of active resources.",
      registers: registry ? [registry] : undefined,
      labelNames,
      collect() {
        const resources = process.getActiveResourcesInfo();
        this.set(labels, resources.length);
      }
    });
  };
  module.exports.metricNames = [
    NODEJS_ACTIVE_RESOURCES,
    NODEJS_ACTIVE_RESOURCES_TOTAL
  ];
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/metrics/heapSizeAndUsed.js
var require_heapSizeAndUsed = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var safeMemoryUsage = require_safeMemoryUsage();
  var NODEJS_HEAP_SIZE_TOTAL = "nodejs_heap_size_total_bytes";
  var NODEJS_HEAP_SIZE_USED = "nodejs_heap_size_used_bytes";
  var NODEJS_EXTERNAL_MEMORY = "nodejs_external_memory_bytes";
  module.exports = (registry, config = {}) => {
    if (typeof process.memoryUsage !== "function") {
      return;
    }
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    const registers = registry ? [registry] : undefined;
    const namePrefix = config.prefix ? config.prefix : "";
    const collect = () => {
      const memUsage = safeMemoryUsage();
      if (memUsage) {
        heapSizeTotal.set(labels, memUsage.heapTotal);
        heapSizeUsed.set(labels, memUsage.heapUsed);
        if (memUsage.external !== undefined) {
          externalMemUsed.set(labels, memUsage.external);
        }
      }
    };
    const heapSizeTotal = new Gauge({
      name: namePrefix + NODEJS_HEAP_SIZE_TOTAL,
      help: "Process heap size from Node.js in bytes.",
      registers,
      labelNames,
      collect
    });
    const heapSizeUsed = new Gauge({
      name: namePrefix + NODEJS_HEAP_SIZE_USED,
      help: "Process heap size used from Node.js in bytes.",
      registers,
      labelNames
    });
    const externalMemUsed = new Gauge({
      name: namePrefix + NODEJS_EXTERNAL_MEMORY,
      help: "Node.js external memory size in bytes.",
      registers,
      labelNames
    });
  };
  module.exports.metricNames = [
    NODEJS_HEAP_SIZE_TOTAL,
    NODEJS_HEAP_SIZE_USED,
    NODEJS_EXTERNAL_MEMORY
  ];
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/metrics/heapSpacesSizeAndUsed.js
var require_heapSpacesSizeAndUsed = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var v8 = __require("v8");
  var METRICS = ["total", "used", "available"];
  var NODEJS_HEAP_SIZE = {};
  METRICS.forEach((metricType) => {
    NODEJS_HEAP_SIZE[metricType] = `nodejs_heap_space_size_${metricType}_bytes`;
  });
  module.exports = (registry, config = {}) => {
    const registers = registry ? [registry] : undefined;
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = ["space", ...Object.keys(labels)];
    const gauges = {};
    METRICS.forEach((metricType) => {
      gauges[metricType] = new Gauge({
        name: namePrefix + NODEJS_HEAP_SIZE[metricType],
        help: `Process heap space size ${metricType} from Node.js in bytes.`,
        labelNames,
        registers
      });
    });
    gauges.total.collect = () => {
      for (const space of v8.getHeapSpaceStatistics()) {
        const spaceName = space.space_name.substr(0, space.space_name.indexOf("_space"));
        gauges.total.set({ space: spaceName, ...labels }, space.space_size);
        gauges.used.set({ space: spaceName, ...labels }, space.space_used_size);
        gauges.available.set({ space: spaceName, ...labels }, space.space_available_size);
      }
    };
  };
  module.exports.metricNames = Object.values(NODEJS_HEAP_SIZE);
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/metrics/version.js
var require_version2 = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var version3 = process.version;
  var versionSegments = version3.slice(1).split(".").map(Number);
  var NODE_VERSION_INFO = "nodejs_version_info";
  module.exports = (registry, config = {}) => {
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + NODE_VERSION_INFO,
      help: "Node.js version info.",
      labelNames: ["version", "major", "minor", "patch", ...labelNames],
      registers: registry ? [registry] : undefined,
      aggregator: "first",
      collect() {
        this.labels(version3, versionSegments[0], versionSegments[1], versionSegments[2], ...Object.values(labels)).set(1);
      }
    });
  };
  module.exports.metricNames = [NODE_VERSION_INFO];
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/metrics/gc.js
var require_gc = __commonJS((exports, module) => {
  var Histogram = require_histogram();
  var perf_hooks;
  try {
    perf_hooks = __require("perf_hooks");
  } catch {
  }
  var NODEJS_GC_DURATION_SECONDS = "nodejs_gc_duration_seconds";
  var DEFAULT_GC_DURATION_BUCKETS = [0.001, 0.01, 0.1, 1, 2, 5];
  var kinds = [];
  if (perf_hooks && perf_hooks.constants) {
    kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_MAJOR] = "major";
    kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_MINOR] = "minor";
    kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_INCREMENTAL] = "incremental";
    kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_WEAKCB] = "weakcb";
  }
  module.exports = (registry, config = {}) => {
    if (!perf_hooks) {
      return;
    }
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    const buckets = config.gcDurationBuckets ? config.gcDurationBuckets : DEFAULT_GC_DURATION_BUCKETS;
    const gcHistogram = new Histogram({
      name: namePrefix + NODEJS_GC_DURATION_SECONDS,
      help: "Garbage collection duration by kind, one of major, minor, incremental or weakcb.",
      labelNames: ["kind", ...labelNames],
      buckets,
      registers: registry ? [registry] : undefined
    });
    const obs = new perf_hooks.PerformanceObserver((list) => {
      const entry = list.getEntries()[0];
      const kind = entry.detail ? kinds[entry.detail.kind] : kinds[entry.kind];
      gcHistogram.observe(Object.assign({ kind }, labels), entry.duration / 1000);
    });
    obs.observe({ entryTypes: ["gc"] });
  };
  module.exports.metricNames = [NODEJS_GC_DURATION_SECONDS];
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/defaultMetrics.js
var require_defaultMetrics = __commonJS((exports, module) => {
  var { isObject } = require_util();
  var processCpuTotal = require_processCpuTotal();
  var processStartTime = require_processStartTime();
  var osMemoryHeap = require_osMemoryHeap();
  var processOpenFileDescriptors = require_processOpenFileDescriptors();
  var processMaxFileDescriptors = require_processMaxFileDescriptors();
  var eventLoopLag = require_eventLoopLag();
  var processHandles = require_processHandles();
  var processRequests = require_processRequests();
  var processResources = require_processResources();
  var heapSizeAndUsed = require_heapSizeAndUsed();
  var heapSpacesSizeAndUsed = require_heapSpacesSizeAndUsed();
  var version3 = require_version2();
  var gc = require_gc();
  var metrics = {
    processCpuTotal,
    processStartTime,
    osMemoryHeap,
    processOpenFileDescriptors,
    processMaxFileDescriptors,
    eventLoopLag,
    ...typeof process.getActiveResourcesInfo === "function" ? { processResources } : {},
    processHandles,
    processRequests,
    heapSizeAndUsed,
    heapSpacesSizeAndUsed,
    version: version3,
    gc
  };
  var metricsList = Object.keys(metrics);
  module.exports = function collectDefaultMetrics(config) {
    if (config !== null && config !== undefined && !isObject(config)) {
      throw new TypeError("config must be null, undefined, or an object");
    }
    config = { eventLoopMonitoringPrecision: 10, ...config };
    for (const metric of Object.values(metrics)) {
      metric(config.register, config);
    }
  };
  module.exports.metricsList = metricsList;
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/metricAggregators.js
var require_metricAggregators = __commonJS((exports) => {
  var AggregatorFactory = function(aggregatorFn) {
    return (metrics) => {
      if (metrics.length === 0)
        return;
      const result = {
        help: metrics[0].help,
        name: metrics[0].name,
        type: metrics[0].type,
        values: [],
        aggregator: metrics[0].aggregator
      };
      const byLabels = new Grouper;
      metrics.forEach((metric) => {
        metric.values.forEach((value) => {
          const key = hashObject(value.labels);
          byLabels.add(`${value.metricName}_${key}`, value);
        });
      });
      byLabels.forEach((values) => {
        if (values.length === 0)
          return;
        const valObj = {
          value: aggregatorFn(values),
          labels: values[0].labels
        };
        if (values[0].metricName) {
          valObj.metricName = values[0].metricName;
        }
        result.values.push(valObj);
      });
      return result;
    };
  };
  var { Grouper, hashObject } = require_util();
  exports.AggregatorFactory = AggregatorFactory;
  exports.aggregators = {
    sum: AggregatorFactory((v) => v.reduce((p, c) => p + c.value, 0)),
    first: AggregatorFactory((v) => v[0].value),
    omit: () => {
    },
    average: AggregatorFactory((v) => v.reduce((p, c) => p + c.value, 0) / v.length),
    min: AggregatorFactory((v) => v.reduce((p, c) => Math.min(p, c.value), Infinity)),
    max: AggregatorFactory((v) => v.reduce((p, c) => Math.max(p, c.value), (-Infinity)))
  };
});

// ../node_modules/.pnpm/prom-client@14.2.0/node_modules/prom-client/lib/cluster.js
var require_cluster = __commonJS((exports, module) => {
  var addListeners = function() {
    if (listenersAdded)
      return;
    listenersAdded = true;
    if (cluster().isMaster) {
      cluster().on("message", (worker, message) => {
        if (message.type === GET_METRICS_RES) {
          const request5 = requests.get(message.requestId);
          if (message.error) {
            request5.done(new Error(message.error));
            return;
          }
          message.metrics.forEach((registry) => request5.responses.push(registry));
          request5.pending--;
          if (request5.pending === 0) {
            requests.delete(message.requestId);
            clearTimeout(request5.errorTimeout);
            const registry = AggregatorRegistry.aggregate(request5.responses);
            const promString = registry.metrics();
            request5.done(null, promString);
          }
        }
      });
    }
    if (cluster().isWorker) {
      process.on("message", (message) => {
        if (message.type === GET_METRICS_REQ) {
          Promise.all(registries.map((r) => r.getMetricsAsJSON())).then((metrics) => {
            process.send({
              type: GET_METRICS_RES,
              requestId: message.requestId,
              metrics
            });
          }).catch((error) => {
            process.send({
              type: GET_METRICS_RES,
              requestId: message.requestId,
              error: error.message
            });
          });
        }
      });
    }
  };
  var Registry = require_registry();
  var { Grouper } = require_util();
  var { aggregators } = require_metricAggregators();
  var cluster = () => {
    const data3 = __require("cluster");
    cluster = () => data3;
    return data3;
  };
  var GET_METRICS_REQ = "prom-client:getMetricsReq";
  var GET_METRICS_RES = "prom-client:getMetricsRes";
  var registries = [Registry.globalRegistry];
  var requestCtr = 0;
  var listenersAdded = false;
  var requests = new Map;

  class AggregatorRegistry extends Registry {
    constructor() {
      super();
      addListeners();
    }
    clusterMetrics() {
      const requestId = requestCtr++;
      return new Promise((resolve5, reject) => {
        let settled = false;
        function done(err, result) {
          if (settled)
            return;
          settled = true;
          if (err)
            reject(err);
          else
            resolve5(result);
        }
        const request5 = {
          responses: [],
          pending: 0,
          done,
          errorTimeout: setTimeout(() => {
            const err = new Error("Operation timed out.");
            request5.done(err);
          }, 5000)
        };
        requests.set(requestId, request5);
        const message = {
          type: GET_METRICS_REQ,
          requestId
        };
        for (const id2 in cluster().workers) {
          if (cluster().workers[id2].isConnected()) {
            cluster().workers[id2].send(message);
            request5.pending++;
          }
        }
        if (request5.pending === 0) {
          clearTimeout(request5.errorTimeout);
          process.nextTick(() => done(null, ""));
        }
      });
    }
    static aggregate(metricsArr) {
      const aggregatedRegistry = new Registry;
      const metricsByName = new Grouper;
      metricsArr.forEach((metrics) => {
        metrics.forEach((metric) => {
          metricsByName.add(metric.name, metric);
        });
      });
      metricsByName.forEach((metrics) => {
        const aggregatorName = metrics[0].aggregator;
        const aggregatorFn = aggregators[aggregatorName];
        if (typeof aggregatorFn !== "function") {
          throw new Error(`'${aggregatorName}' is not a defined aggregator.`);
        }
        const aggregatedMetric = aggregatorFn(metrics);
        if (aggregatedMetric) {
          const aggregatedMetricWrapper = Object.assign({
            get: () => aggregatedMetric
          }, aggregatedMetric);
          aggregatedRegistry.registerMetric(aggregatedMetricWrapper);
        }
      });
      return aggregatedRegistry;
    }
    static setRegistries(regs) {
      if (!Array.isArray(regs))
        regs = [regs];
      regs.forEach((reg) => {
        if (!(reg instanceof Registry)) {
          throw new TypeError(`Expected Registry, got ${typeof reg}`);
        }
      });
      registries = regs;
    }
  }
  module.exports = AggregatorRegistry;
});

// ../node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/helpers/util.js
var require_util2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = undefined;
  var util2;
  (function(util3) {
    util3.assertEqual = (val) => val;
    function assertIs(_arg) {
    }
    util3.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error;
    }
    util3.assertNever = assertNever;
    util3.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util3.getValidEnumValues = (obj) => {
      const validKeys = util3.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util3.objectValues(filtered);
    };
    util3.objectValues = (obj) => {
      return util3.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util3.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util3.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return;
    };
    util3.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util3.joinValues = joinValues;
    util3.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util2 = exports.util || (exports.util = {}));
  var objectUtil2;
  (function(objectUtil3) {
    objectUtil3.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
      };
    };
  })(objectUtil2 = exports.objectUtil || (exports.objectUtil = {}));
  exports.ZodParsedType = util2.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  var getParsedType2 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "undefined":
        return exports.ZodParsedType.undefined;
      case "string":
        return exports.ZodParsedType.string;
      case "number":
        return isNaN(data3) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;
      case "boolean":
        return exports.ZodParsedType.boolean;
      case "function":
        return exports.ZodParsedType.function;
      case "bigint":
        return exports.ZodParsedType.bigint;
      case "symbol":
        return exports.ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data3)) {
          return exports.ZodParsedType.array;
        }
        if (data3 === null) {
          return exports.ZodParsedType.null;
        }
        if (data3.then && typeof data3.then === "function" && data3.catch && typeof data3.catch === "function") {
          return exports.ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data3 instanceof Map) {
          return exports.ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data3 instanceof Set) {
          return exports.ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data3 instanceof Date) {
          return exports.ZodParsedType.date;
        }
        return exports.ZodParsedType.object;
      default:
        return exports.ZodParsedType.unknown;
    }
  };
  exports.getParsedType = getParsedType2;
});

// ../node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/ZodError.js
var require_ZodError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ZodError = exports.quotelessJson = exports.ZodIssueCode = undefined;
  var util_1 = require_util2();
  exports.ZodIssueCode = util_1.util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  var quotelessJson2 = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  exports.quotelessJson = quotelessJson2;

  class ZodError2 extends Error {
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    get errors() {
      return this.issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util_1.util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  }
  exports.ZodError = ZodError2;
  ZodError2.create = (issues) => {
    const error = new ZodError2(issues);
    return error;
  };
});

// ../node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/locales/en.js
var require_en = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util2();
  var ZodError_1 = require_ZodError();
  var errorMap2 = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodError_1.ZodIssueCode.invalid_type:
        if (issue.received === util_1.ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodError_1.ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1.util.jsonStringifyReplacer)}`;
        break;
      case ZodError_1.ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util_1.util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodError_1.ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodError_1.ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util_1.util.joinValues(issue.options)}`;
        break;
      case ZodError_1.ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util_1.util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodError_1.ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodError_1.ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodError_1.ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodError_1.ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util_1.util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodError_1.ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodError_1.ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodError_1.ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodError_1.ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodError_1.ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodError_1.ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util_1.util.assertNever(issue);
    }
    return { message };
  };
  exports.default = errorMap2;
});

// ../node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/errors.js
var require_errors2 = __commonJS((exports) => {
  var setErrorMap2 = function(map) {
    overrideErrorMap2 = map;
  };
  var getErrorMap2 = function() {
    return overrideErrorMap2;
  };
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getErrorMap = exports.setErrorMap = exports.defaultErrorMap = undefined;
  var en_1 = __importDefault(require_en());
  exports.defaultErrorMap = en_1.default;
  var overrideErrorMap2 = en_1.default;
  exports.setErrorMap = setErrorMap2;
  exports.getErrorMap = getErrorMap2;
});

// ../node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/helpers/parseUtil.js
var require_parseUtil = __commonJS((exports) => {
  var addIssueToContext2 = function(ctx, issueData) {
    const issue = (0, exports.makeIssue)({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        ctx.schemaErrorMap,
        (0, errors_1.getErrorMap)(),
        en_1.default
      ].filter((x) => !!x)
    });
    ctx.common.issues.push(issue);
  };
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.addIssueToContext = exports.EMPTY_PATH = exports.makeIssue = undefined;
  var errors_1 = require_errors2();
  var en_1 = __importDefault(require_en());
  var makeIssue2 = (params) => {
    const { data: data3, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    let errorMessage = "";
    const maps = errorMaps.filter((m) => !!m).slice().reverse();
    for (const map of maps) {
      errorMessage = map(fullIssue, { data: data3, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message || errorMessage
    };
  };
  exports.makeIssue = makeIssue2;
  exports.EMPTY_PATH = [];
  exports.addIssueToContext = addIssueToContext2;

  class ParseStatus2 {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s of results) {
        if (s.status === "aborted")
          return exports.INVALID;
        if (s.status === "dirty")
          status.dirty();
        arrayValue.push(s.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        syncPairs.push({
          key: await pair.key,
          value: await pair.value
        });
      }
      return ParseStatus2.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return exports.INVALID;
        if (value.status === "aborted")
          return exports.INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  }
  exports.ParseStatus = ParseStatus2;
  exports.INVALID = Object.freeze({
    status: "aborted"
  });
  var DIRTY2 = (value) => ({ status: "dirty", value });
  exports.DIRTY = DIRTY2;
  var OK2 = (value) => ({ status: "valid", value });
  exports.OK = OK2;
  var isAborted2 = (x) => x.status === "aborted";
  exports.isAborted = isAborted2;
  var isDirty2 = (x) => x.status === "dirty";
  exports.isDirty = isDirty2;
  var isValid2 = (x) => x.status === "valid";
  exports.isValid = isValid2;
  var isAsync2 = (x) => typeof Promise !== "undefined" && x instanceof Promise;
  exports.isAsync = isAsync2;
});

// ../node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/helpers/typeAliases.js
var require_typeAliases = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// ../node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/helpers/errorUtil.js
var require_errorUtil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.errorUtil = undefined;
  var errorUtil2;
  (function(errorUtil3) {
    errorUtil3.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil3.toString = (message) => typeof message === "string" ? message : message === null || message === undefined ? undefined : message.message;
  })(errorUtil2 = exports.errorUtil || (exports.errorUtil = {}));
});

// ../node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/types.js
var require_types2 = __commonJS((exports) => {
  var processCreateParams2 = function(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      if (typeof ctx.data === "undefined") {
        return { message: required_error !== null && required_error !== undefined ? required_error : ctx.defaultError };
      }
      return { message: invalid_type_error !== null && invalid_type_error !== undefined ? invalid_type_error : ctx.defaultError };
    };
    return { errorMap: customMap, description };
  };
  var isValidIP2 = function(ip, version3) {
    if ((version3 === "v4" || !version3) && ipv4Regex2.test(ip)) {
      return true;
    }
    if ((version3 === "v6" || !version3) && ipv6Regex2.test(ip)) {
      return true;
    }
    return false;
  };
  var floatSafeRemainder2 = function(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
  };
  var deepPartialify2 = function(schema) {
    if (schema instanceof ZodObject2) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional2.create(deepPartialify2(fieldSchema));
      }
      return new ZodObject2({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray2) {
      return new ZodArray2({
        ...schema._def,
        type: deepPartialify2(schema.element)
      });
    } else if (schema instanceof ZodOptional2) {
      return ZodOptional2.create(deepPartialify2(schema.unwrap()));
    } else if (schema instanceof ZodNullable2) {
      return ZodNullable2.create(deepPartialify2(schema.unwrap()));
    } else if (schema instanceof ZodTuple2) {
      return ZodTuple2.create(schema.items.map((item) => deepPartialify2(item)));
    } else {
      return schema;
    }
  };
  var mergeValues2 = function(a, b) {
    const aType = (0, util_1.getParsedType)(a);
    const bType = (0, util_1.getParsedType)(b);
    if (a === b) {
      return { valid: true, data: a };
    } else if (aType === util_1.ZodParsedType.object && bType === util_1.ZodParsedType.object) {
      const bKeys = util_1.util.objectKeys(b);
      const sharedKeys = util_1.util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues2(a[key], b[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === util_1.ZodParsedType.array && bType === util_1.ZodParsedType.array) {
      if (a.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index2 = 0;index2 < a.length; index2++) {
        const itemA = a[index2];
        const itemB = b[index2];
        const sharedValue = mergeValues2(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === util_1.ZodParsedType.date && bType === util_1.ZodParsedType.date && +a === +b) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  };
  var createZodEnum2 = function(values, params) {
    return new ZodEnum2({
      values,
      typeName: ZodFirstPartyTypeKind2.ZodEnum,
      ...processCreateParams2(params)
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.date = exports.boolean = exports.bigint = exports.array = exports.any = exports.coerce = exports.ZodFirstPartyTypeKind = exports.late = exports.ZodSchema = exports.Schema = exports.custom = exports.ZodReadonly = exports.ZodPipeline = exports.ZodBranded = exports.BRAND = exports.ZodNaN = exports.ZodCatch = exports.ZodDefault = exports.ZodNullable = exports.ZodOptional = exports.ZodTransformer = exports.ZodEffects = exports.ZodPromise = exports.ZodNativeEnum = exports.ZodEnum = exports.ZodLiteral = exports.ZodLazy = exports.ZodFunction = exports.ZodSet = exports.ZodMap = exports.ZodRecord = exports.ZodTuple = exports.ZodIntersection = exports.ZodDiscriminatedUnion = exports.ZodUnion = exports.ZodObject = exports.ZodArray = exports.ZodVoid = exports.ZodNever = exports.ZodUnknown = exports.ZodAny = exports.ZodNull = exports.ZodUndefined = exports.ZodSymbol = exports.ZodDate = exports.ZodBoolean = exports.ZodBigInt = exports.ZodNumber = exports.ZodString = exports.ZodType = undefined;
  exports.NEVER = exports.void = exports.unknown = exports.union = exports.undefined = exports.tuple = exports.transformer = exports.symbol = exports.string = exports.strictObject = exports.set = exports.record = exports.promise = exports.preprocess = exports.pipeline = exports.ostring = exports.optional = exports.onumber = exports.oboolean = exports.object = exports.number = exports.nullable = exports.null = exports.never = exports.nativeEnum = exports.nan = exports.map = exports.literal = exports.lazy = exports.intersection = exports.instanceof = exports.function = exports.enum = exports.effect = exports.discriminatedUnion = undefined;
  var errors_1 = require_errors2();
  var errorUtil_1 = require_errorUtil();
  var parseUtil_1 = require_parseUtil();
  var util_1 = require_util2();
  var ZodError_1 = require_ZodError();

  class ParseInputLazyPath2 {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (this._key instanceof Array) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  }
  var handleResult2 = (ctx, result) => {
    if ((0, parseUtil_1.isValid)(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error = new ZodError_1.ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };

  class ZodType2 {
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return (0, util_1.getParsedType)(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: (0, util_1.getParsedType)(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new parseUtil_1.ParseStatus,
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: (0, util_1.getParsedType)(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if ((0, parseUtil_1.isAsync)(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data3, params) {
      const result = this.safeParse(data3, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data3, params) {
      var _a2;
      const ctx = {
        common: {
          issues: [],
          async: (_a2 = params === null || params === undefined ? undefined : params.async) !== null && _a2 !== undefined ? _a2 : false,
          contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap
        },
        path: (params === null || params === undefined ? undefined : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: data3,
        parsedType: (0, util_1.getParsedType)(data3)
      };
      const result = this._parseSync({ data: data3, path: ctx.path, parent: ctx });
      return handleResult2(ctx, result);
    }
    async parseAsync(data3, params) {
      const result = await this.safeParseAsync(data3, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data3, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap,
          async: true
        },
        path: (params === null || params === undefined ? undefined : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: data3,
        parsedType: (0, util_1.getParsedType)(data3)
      };
      const maybeAsyncResult2 = this._parse({ data: data3, path: ctx.path, parent: ctx });
      const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult2) ? maybeAsyncResult2 : Promise.resolve(maybeAsyncResult2));
      return handleResult2(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodError_1.ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data3) => {
            if (!data3) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects2({
        schema: this,
        typeName: ZodFirstPartyTypeKind2.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    optional() {
      return ZodOptional2.create(this, this._def);
    }
    nullable() {
      return ZodNullable2.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray2.create(this, this._def);
    }
    promise() {
      return ZodPromise2.create(this, this._def);
    }
    or(option) {
      return ZodUnion2.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection2.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects2({
        ...processCreateParams2(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind2.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault2({
        ...processCreateParams2(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind2.ZodDefault
      });
    }
    brand() {
      return new ZodBranded2({
        typeName: ZodFirstPartyTypeKind2.ZodBranded,
        type: this,
        ...processCreateParams2(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch2({
        ...processCreateParams2(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind2.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline2.create(this, target);
    }
    readonly() {
      return ZodReadonly2.create(this);
    }
    isOptional() {
      return this.safeParse(undefined).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  exports.ZodType = ZodType2;
  exports.Schema = ZodType2;
  exports.ZodSchema = ZodType2;
  var cuidRegex2 = /^c[^\s-]{8,}$/i;
  var cuid2Regex2 = /^[a-z][a-z0-9]*$/;
  var ulidRegex2 = /^[0-9A-HJKMNP-TV-Z]{26}$/;
  var uuidRegex2 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  var emailRegex2 = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  var _emojiRegex2 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+\$`;
  var emojiRegex2;
  var ipv4Regex2 = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
  var ipv6Regex2 = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
  var datetimeRegex2 = (args) => {
    if (args.precision) {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z\$`);
      }
    } else if (args.precision === 0) {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z\$`);
      }
    } else {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z\$`);
      }
    }
  };

  class ZodString2 extends ZodType2 {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx2, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.string,
          received: ctx2.parsedType
        });
        return parseUtil_1.INVALID;
      }
      const status = new parseUtil_1.ParseStatus;
      let ctx = undefined;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "email",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex2) {
            emojiRegex2 = new RegExp(_emojiRegex2, "u");
          }
          if (!emojiRegex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "emoji",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "uuid",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "cuid",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "cuid2",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "ulid",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch (_a2) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "url",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "regex",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex3 = datetimeRegex2(check);
          if (!regex3.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP2(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "ip",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util_1.util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex3, validation7, message) {
      return this.refinement((data3) => regex3.test(data3), {
        validation: validation7,
        code: ZodError_1.ZodIssueCode.invalid_string,
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString2({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil_1.errorUtil.errToObj(options) });
    }
    datetime(options) {
      var _a2;
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
        offset: (_a2 = options === null || options === undefined ? undefined : options.offset) !== null && _a2 !== undefined ? _a2 : false,
        ...errorUtil_1.errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
      });
    }
    regex(regex3, message) {
      return this._addCheck({
        kind: "regex",
        regex: regex3,
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options === null || options === undefined ? undefined : options.position,
        ...errorUtil_1.errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    nonempty(message) {
      return this.min(1, errorUtil_1.errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString2({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString2({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString2({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  }
  exports.ZodString = ZodString2;
  ZodString2.create = (params) => {
    var _a2;
    return new ZodString2({
      checks: [],
      typeName: ZodFirstPartyTypeKind2.ZodString,
      coerce: (_a2 = params === null || params === undefined ? undefined : params.coerce) !== null && _a2 !== undefined ? _a2 : false,
      ...processCreateParams2(params)
    });
  };

  class ZodNumber2 extends ZodType2 {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx2, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.number,
          received: ctx2.parsedType
        });
        return parseUtil_1.INVALID;
      }
      let ctx = undefined;
      const status = new parseUtil_1.ParseStatus;
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util_1.util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder2(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util_1.util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber2({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil_1.errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber2({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil_1.errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util_1.util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null, min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  }
  exports.ZodNumber = ZodNumber2;
  ZodNumber2.create = (params) => {
    return new ZodNumber2({
      checks: [],
      typeName: ZodFirstPartyTypeKind2.ZodNumber,
      coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
      ...processCreateParams2(params)
    });
  };

  class ZodBigInt2 extends ZodType2 {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = BigInt(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.bigint) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx2, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.bigint,
          received: ctx2.parsedType
        });
        return parseUtil_1.INVALID;
      }
      let ctx = undefined;
      const status = new parseUtil_1.ParseStatus;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util_1.util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt2({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil_1.errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt2({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  }
  exports.ZodBigInt = ZodBigInt2;
  ZodBigInt2.create = (params) => {
    var _a2;
    return new ZodBigInt2({
      checks: [],
      typeName: ZodFirstPartyTypeKind2.ZodBigInt,
      coerce: (_a2 = params === null || params === undefined ? undefined : params.coerce) !== null && _a2 !== undefined ? _a2 : false,
      ...processCreateParams2(params)
    });
  };

  class ZodBoolean2 extends ZodType2 {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      return (0, parseUtil_1.OK)(input.data);
    }
  }
  exports.ZodBoolean = ZodBoolean2;
  ZodBoolean2.create = (params) => {
    return new ZodBoolean2({
      typeName: ZodFirstPartyTypeKind2.ZodBoolean,
      coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
      ...processCreateParams2(params)
    });
  };

  class ZodDate2 extends ZodType2 {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx2, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.date,
          received: ctx2.parsedType
        });
        return parseUtil_1.INVALID;
      }
      if (isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx2, {
          code: ZodError_1.ZodIssueCode.invalid_date
        });
        return parseUtil_1.INVALID;
      }
      const status = new parseUtil_1.ParseStatus;
      let ctx = undefined;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util_1.util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate2({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  }
  exports.ZodDate = ZodDate2;
  ZodDate2.create = (params) => {
    return new ZodDate2({
      checks: [],
      coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
      typeName: ZodFirstPartyTypeKind2.ZodDate,
      ...processCreateParams2(params)
    });
  };

  class ZodSymbol2 extends ZodType2 {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      return (0, parseUtil_1.OK)(input.data);
    }
  }
  exports.ZodSymbol = ZodSymbol2;
  ZodSymbol2.create = (params) => {
    return new ZodSymbol2({
      typeName: ZodFirstPartyTypeKind2.ZodSymbol,
      ...processCreateParams2(params)
    });
  };

  class ZodUndefined2 extends ZodType2 {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      return (0, parseUtil_1.OK)(input.data);
    }
  }
  exports.ZodUndefined = ZodUndefined2;
  ZodUndefined2.create = (params) => {
    return new ZodUndefined2({
      typeName: ZodFirstPartyTypeKind2.ZodUndefined,
      ...processCreateParams2(params)
    });
  };

  class ZodNull2 extends ZodType2 {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.null,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      return (0, parseUtil_1.OK)(input.data);
    }
  }
  exports.ZodNull = ZodNull2;
  ZodNull2.create = (params) => {
    return new ZodNull2({
      typeName: ZodFirstPartyTypeKind2.ZodNull,
      ...processCreateParams2(params)
    });
  };

  class ZodAny2 extends ZodType2 {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return (0, parseUtil_1.OK)(input.data);
    }
  }
  exports.ZodAny = ZodAny2;
  ZodAny2.create = (params) => {
    return new ZodAny2({
      typeName: ZodFirstPartyTypeKind2.ZodAny,
      ...processCreateParams2(params)
    });
  };

  class ZodUnknown2 extends ZodType2 {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return (0, parseUtil_1.OK)(input.data);
    }
  }
  exports.ZodUnknown = ZodUnknown2;
  ZodUnknown2.create = (params) => {
    return new ZodUnknown2({
      typeName: ZodFirstPartyTypeKind2.ZodUnknown,
      ...processCreateParams2(params)
    });
  };

  class ZodNever2 extends ZodType2 {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      (0, parseUtil_1.addIssueToContext)(ctx, {
        code: ZodError_1.ZodIssueCode.invalid_type,
        expected: util_1.ZodParsedType.never,
        received: ctx.parsedType
      });
      return parseUtil_1.INVALID;
    }
  }
  exports.ZodNever = ZodNever2;
  ZodNever2.create = (params) => {
    return new ZodNever2({
      typeName: ZodFirstPartyTypeKind2.ZodNever,
      ...processCreateParams2(params)
    });
  };

  class ZodVoid2 extends ZodType2 {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.void,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      return (0, parseUtil_1.OK)(input.data);
    }
  }
  exports.ZodVoid = ZodVoid2;
  ZodVoid2.create = (params) => {
    return new ZodVoid2({
      typeName: ZodFirstPartyTypeKind2.ZodVoid,
      ...processCreateParams2(params)
    });
  };

  class ZodArray2 extends ZodType2 {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== util_1.ZodParsedType.array) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.array,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : undefined,
            maximum: tooBig ? def.exactLength.value : undefined,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath2(ctx, item, ctx.path, i));
        })).then((result2) => {
          return parseUtil_1.ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath2(ctx, item, ctx.path, i));
      });
      return parseUtil_1.ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray2({
        ...this._def,
        minLength: { value: minLength, message: errorUtil_1.errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray2({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil_1.errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray2({
        ...this._def,
        exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  exports.ZodArray = ZodArray2;
  ZodArray2.create = (schema, params) => {
    return new ZodArray2({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind2.ZodArray,
      ...processCreateParams2(params)
    });
  };

  class ZodObject2 extends ZodType2 {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util_1.util.objectKeys(shape);
      return this._cached = { shape, keys };
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx2, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.object,
          received: ctx2.parsedType
        });
        return parseUtil_1.INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever2 && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath2(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever2) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") {
        } else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(new ParseInputLazyPath2(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            syncPairs.push({
              key,
              value: await pair.value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil_1.errorUtil.errToObj;
      return new ZodObject2({
        ...this._def,
        unknownKeys: "strict",
        ...message !== undefined ? {
          errorMap: (issue, ctx) => {
            var _a2, _b2, _c2, _d;
            const defaultError = (_c2 = (_b2 = (_a2 = this._def).errorMap) === null || _b2 === undefined ? undefined : _b2.call(_a2, issue, ctx).message) !== null && _c2 !== undefined ? _c2 : ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: (_d = errorUtil_1.errorUtil.errToObj(message).message) !== null && _d !== undefined ? _d : defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject2({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject2({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    extend(augmentation) {
      return new ZodObject2({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    merge(merging) {
      const merged = new ZodObject2({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind2.ZodObject
      });
      return merged;
    }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    catchall(index2) {
      return new ZodObject2({
        ...this._def,
        catchall: index2
      });
    }
    pick(mask) {
      const shape = {};
      util_1.util.objectKeys(mask).forEach((key) => {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject2({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      util_1.util.objectKeys(this.shape).forEach((key) => {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject2({
        ...this._def,
        shape: () => shape
      });
    }
    deepPartial() {
      return deepPartialify2(this);
    }
    partial(mask) {
      const newShape = {};
      util_1.util.objectKeys(this.shape).forEach((key) => {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      });
      return new ZodObject2({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      util_1.util.objectKeys(this.shape).forEach((key) => {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional2) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      });
      return new ZodObject2({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum2(util_1.util.objectKeys(this.shape));
    }
  }
  exports.ZodObject = ZodObject2;
  ZodObject2.create = (shape, params) => {
    return new ZodObject2({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever2.create(),
      typeName: ZodFirstPartyTypeKind2.ZodObject,
      ...processCreateParams2(params)
    });
  };
  ZodObject2.strictCreate = (shape, params) => {
    return new ZodObject2({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever2.create(),
      typeName: ZodFirstPartyTypeKind2.ZodObject,
      ...processCreateParams2(params)
    });
  };
  ZodObject2.lazycreate = (shape, params) => {
    return new ZodObject2({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever2.create(),
      typeName: ZodFirstPartyTypeKind2.ZodObject,
      ...processCreateParams2(params)
    });
  };

  class ZodUnion2 extends ZodType2 {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError_1.ZodError(result.ctx.common.issues));
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_union,
          unionErrors
        });
        return parseUtil_1.INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = undefined;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError_1.ZodError(issues2));
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_union,
          unionErrors
        });
        return parseUtil_1.INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  exports.ZodUnion = ZodUnion2;
  ZodUnion2.create = (types3, params) => {
    return new ZodUnion2({
      options: types3,
      typeName: ZodFirstPartyTypeKind2.ZodUnion,
      ...processCreateParams2(params)
    });
  };
  var getDiscriminator2 = (type) => {
    if (type instanceof ZodLazy2) {
      return getDiscriminator2(type.schema);
    } else if (type instanceof ZodEffects2) {
      return getDiscriminator2(type.innerType());
    } else if (type instanceof ZodLiteral2) {
      return [type.value];
    } else if (type instanceof ZodEnum2) {
      return type.options;
    } else if (type instanceof ZodNativeEnum2) {
      return Object.keys(type.enum);
    } else if (type instanceof ZodDefault2) {
      return getDiscriminator2(type._def.innerType);
    } else if (type instanceof ZodUndefined2) {
      return [undefined];
    } else if (type instanceof ZodNull2) {
      return [null];
    } else {
      return null;
    }
  };

  class ZodDiscriminatedUnion2 extends ZodType2 {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_1.ZodParsedType.object) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.object,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return parseUtil_1.INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    static create(discriminator, options, params) {
      const optionsMap = new Map;
      for (const type of options) {
        const discriminatorValues = getDiscriminator2(type.shape[discriminator]);
        if (!discriminatorValues) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion2({
        typeName: ZodFirstPartyTypeKind2.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams2(params)
      });
    }
  }
  exports.ZodDiscriminatedUnion = ZodDiscriminatedUnion2;

  class ZodIntersection2 extends ZodType2 {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight)) {
          return parseUtil_1.INVALID;
        }
        const merged = mergeValues2(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_intersection_types
          });
          return parseUtil_1.INVALID;
        }
        if ((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left2, right2]) => handleParsed(left2, right2));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  }
  exports.ZodIntersection = ZodIntersection2;
  ZodIntersection2.create = (left2, right2, params) => {
    return new ZodIntersection2({
      left: left2,
      right: right2,
      typeName: ZodFirstPartyTypeKind2.ZodIntersection,
      ...processCreateParams2(params)
    });
  };

  class ZodTuple2 extends ZodType2 {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_1.ZodParsedType.array) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.array,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return parseUtil_1.INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath2(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return parseUtil_1.ParseStatus.mergeArray(status, results);
        });
      } else {
        return parseUtil_1.ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple2({
        ...this._def,
        rest
      });
    }
  }
  exports.ZodTuple = ZodTuple2;
  ZodTuple2.create = (schemas5, params) => {
    if (!Array.isArray(schemas5)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple2({
      items: schemas5,
      typeName: ZodFirstPartyTypeKind2.ZodTuple,
      rest: null,
      ...processCreateParams2(params)
    });
  };

  class ZodRecord2 extends ZodType2 {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_1.ZodParsedType.object) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.object,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath2(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath2(ctx, ctx.data[key], ctx.path, key))
        });
      }
      if (ctx.common.async) {
        return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType2) {
        return new ZodRecord2({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind2.ZodRecord,
          ...processCreateParams2(third)
        });
      }
      return new ZodRecord2({
        keyType: ZodString2.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind2.ZodRecord,
        ...processCreateParams2(second)
      });
    }
  }
  exports.ZodRecord = ZodRecord2;

  class ZodMap2 extends ZodType2 {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_1.ZodParsedType.map) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.map,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
        return {
          key: keyType._parse(new ParseInputLazyPath2(ctx, key, ctx.path, [index2, "key"])),
          value: valueType._parse(new ParseInputLazyPath2(ctx, value, ctx.path, [index2, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = new Map;
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return parseUtil_1.INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = new Map;
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return parseUtil_1.INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  }
  exports.ZodMap = ZodMap2;
  ZodMap2.create = (keyType, valueType, params) => {
    return new ZodMap2({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind2.ZodMap,
      ...processCreateParams2(params)
    });
  };

  class ZodSet2 extends ZodType2 {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_1.ZodParsedType.set) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.set,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = new Set;
        for (const element of elements2) {
          if (element.status === "aborted")
            return parseUtil_1.INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath2(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet2({
        ...this._def,
        minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet2({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message) }
      });
    }
    size(size9, message) {
      return this.min(size9, message).max(size9, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  exports.ZodSet = ZodSet2;
  ZodSet2.create = (valueType, params) => {
    return new ZodSet2({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind2.ZodSet,
      ...processCreateParams2(params)
    });
  };

  class ZodFunction2 extends ZodType2 {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_1.ZodParsedType.function) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.function,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      function makeArgsIssue(args, error) {
        return (0, parseUtil_1.makeIssue)({
          data: args,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            (0, errors_1.getErrorMap)(),
            errors_1.defaultErrorMap
          ].filter((x) => !!x),
          issueData: {
            code: ZodError_1.ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return (0, parseUtil_1.makeIssue)({
          data: returns,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            (0, errors_1.getErrorMap)(),
            errors_1.defaultErrorMap
          ].filter((x) => !!x),
          issueData: {
            code: ZodError_1.ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise2) {
        const me = this;
        return (0, parseUtil_1.OK)(async function(...args) {
          const error = new ZodError_1.ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return (0, parseUtil_1.OK)(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction2({
        ...this._def,
        args: ZodTuple2.create(items).rest(ZodUnknown2.create())
      });
    }
    returns(returnType) {
      return new ZodFunction2({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction2({
        args: args ? args : ZodTuple2.create([]).rest(ZodUnknown2.create()),
        returns: returns || ZodUnknown2.create(),
        typeName: ZodFirstPartyTypeKind2.ZodFunction,
        ...processCreateParams2(params)
      });
    }
  }
  exports.ZodFunction = ZodFunction2;

  class ZodLazy2 extends ZodType2 {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  }
  exports.ZodLazy = ZodLazy2;
  ZodLazy2.create = (getter, params) => {
    return new ZodLazy2({
      getter,
      typeName: ZodFirstPartyTypeKind2.ZodLazy,
      ...processCreateParams2(params)
    });
  };

  class ZodLiteral2 extends ZodType2 {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          received: ctx.data,
          code: ZodError_1.ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return parseUtil_1.INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  }
  exports.ZodLiteral = ZodLiteral2;
  ZodLiteral2.create = (value, params) => {
    return new ZodLiteral2({
      value,
      typeName: ZodFirstPartyTypeKind2.ZodLiteral,
      ...processCreateParams2(params)
    });
  };

  class ZodEnum2 extends ZodType2 {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        (0, parseUtil_1.addIssueToContext)(ctx, {
          expected: util_1.util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodError_1.ZodIssueCode.invalid_type
        });
        return parseUtil_1.INVALID;
      }
      if (this._def.values.indexOf(input.data) === -1) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        (0, parseUtil_1.addIssueToContext)(ctx, {
          received: ctx.data,
          code: ZodError_1.ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return parseUtil_1.INVALID;
      }
      return (0, parseUtil_1.OK)(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values) {
      return ZodEnum2.create(values);
    }
    exclude(values) {
      return ZodEnum2.create(this.options.filter((opt) => !values.includes(opt)));
    }
  }
  exports.ZodEnum = ZodEnum2;
  ZodEnum2.create = createZodEnum2;

  class ZodNativeEnum2 extends ZodType2 {
    _parse(input) {
      const nativeEnumValues = util_1.util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== util_1.ZodParsedType.string && ctx.parsedType !== util_1.ZodParsedType.number) {
        const expectedValues = util_1.util.objectValues(nativeEnumValues);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          expected: util_1.util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodError_1.ZodIssueCode.invalid_type
        });
        return parseUtil_1.INVALID;
      }
      if (nativeEnumValues.indexOf(input.data) === -1) {
        const expectedValues = util_1.util.objectValues(nativeEnumValues);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          received: ctx.data,
          code: ZodError_1.ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return parseUtil_1.INVALID;
      }
      return (0, parseUtil_1.OK)(input.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  exports.ZodNativeEnum = ZodNativeEnum2;
  ZodNativeEnum2.create = (values, params) => {
    return new ZodNativeEnum2({
      values,
      typeName: ZodFirstPartyTypeKind2.ZodNativeEnum,
      ...processCreateParams2(params)
    });
  };

  class ZodPromise2 extends ZodType2 {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_1.ZodParsedType.promise && ctx.common.async === false) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.promise,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      const promisified = ctx.parsedType === util_1.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return (0, parseUtil_1.OK)(promisified.then((data3) => {
        return this._def.type.parseAsync(data3, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  }
  exports.ZodPromise = ZodPromise2;
  ZodPromise2.create = (schema, params) => {
    return new ZodPromise2({
      type: schema,
      typeName: ZodFirstPartyTypeKind2.ZodPromise,
      ...processCreateParams2(params)
    });
  };

  class ZodEffects2 extends ZodType2 {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind2.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          (0, parseUtil_1.addIssueToContext)(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.issues.length) {
          return {
            status: "dirty",
            value: ctx.data
          };
        }
        if (ctx.common.async) {
          return Promise.resolve(processed).then((processed2) => {
            return this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
          });
        } else {
          return this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return parseUtil_1.INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return parseUtil_1.INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base31 = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!(0, parseUtil_1.isValid)(base31))
            return base31;
          const result = effect.transform(base31.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base31) => {
            if (!(0, parseUtil_1.isValid)(base31))
              return base31;
            return Promise.resolve(effect.transform(base31.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
          });
        }
      }
      util_1.util.assertNever(effect);
    }
  }
  exports.ZodEffects = ZodEffects2;
  exports.ZodTransformer = ZodEffects2;
  ZodEffects2.create = (schema, effect, params) => {
    return new ZodEffects2({
      schema,
      typeName: ZodFirstPartyTypeKind2.ZodEffects,
      effect,
      ...processCreateParams2(params)
    });
  };
  ZodEffects2.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects2({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind2.ZodEffects,
      ...processCreateParams2(params)
    });
  };

  class ZodOptional2 extends ZodType2 {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === util_1.ZodParsedType.undefined) {
        return (0, parseUtil_1.OK)(undefined);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  exports.ZodOptional = ZodOptional2;
  ZodOptional2.create = (type, params) => {
    return new ZodOptional2({
      innerType: type,
      typeName: ZodFirstPartyTypeKind2.ZodOptional,
      ...processCreateParams2(params)
    });
  };

  class ZodNullable2 extends ZodType2 {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === util_1.ZodParsedType.null) {
        return (0, parseUtil_1.OK)(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  exports.ZodNullable = ZodNullable2;
  ZodNullable2.create = (type, params) => {
    return new ZodNullable2({
      innerType: type,
      typeName: ZodFirstPartyTypeKind2.ZodNullable,
      ...processCreateParams2(params)
    });
  };

  class ZodDefault2 extends ZodType2 {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data3 = ctx.data;
      if (ctx.parsedType === util_1.ZodParsedType.undefined) {
        data3 = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data: data3,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  exports.ZodDefault = ZodDefault2;
  ZodDefault2.create = (type, params) => {
    return new ZodDefault2({
      innerType: type,
      typeName: ZodFirstPartyTypeKind2.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams2(params)
    });
  };

  class ZodCatch2 extends ZodType2 {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if ((0, parseUtil_1.isAsync)(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError_1.ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError_1.ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  exports.ZodCatch = ZodCatch2;
  ZodCatch2.create = (type, params) => {
    return new ZodCatch2({
      innerType: type,
      typeName: ZodFirstPartyTypeKind2.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams2(params)
    });
  };

  class ZodNaN2 extends ZodType2 {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.nan,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      return { status: "valid", value: input.data };
    }
  }
  exports.ZodNaN = ZodNaN2;
  ZodNaN2.create = (params) => {
    return new ZodNaN2({
      typeName: ZodFirstPartyTypeKind2.ZodNaN,
      ...processCreateParams2(params)
    });
  };
  exports.BRAND = Symbol("zod_brand");

  class ZodBranded2 extends ZodType2 {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data3 = ctx.data;
      return this._def.type._parse({
        data: data3,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  exports.ZodBranded = ZodBranded2;

  class ZodPipeline2 extends ZodType2 {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return parseUtil_1.INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return (0, parseUtil_1.DIRTY)(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return parseUtil_1.INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new ZodPipeline2({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind2.ZodPipeline
      });
    }
  }
  exports.ZodPipeline = ZodPipeline2;

  class ZodReadonly2 extends ZodType2 {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      if ((0, parseUtil_1.isValid)(result)) {
        result.value = Object.freeze(result.value);
      }
      return result;
    }
  }
  exports.ZodReadonly = ZodReadonly2;
  ZodReadonly2.create = (type, params) => {
    return new ZodReadonly2({
      innerType: type,
      typeName: ZodFirstPartyTypeKind2.ZodReadonly,
      ...processCreateParams2(params)
    });
  };
  var custom2 = (check, params = {}, fatal) => {
    if (check)
      return ZodAny2.create().superRefine((data3, ctx) => {
        var _a2, _b2;
        if (!check(data3)) {
          const p = typeof params === "function" ? params(data3) : typeof params === "string" ? { message: params } : params;
          const _fatal = (_b2 = (_a2 = p.fatal) !== null && _a2 !== undefined ? _a2 : fatal) !== null && _b2 !== undefined ? _b2 : true;
          const p2 = typeof p === "string" ? { message: p } : p;
          ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
        }
      });
    return ZodAny2.create();
  };
  exports.custom = custom2;
  exports.late = {
    object: ZodObject2.lazycreate
  };
  var ZodFirstPartyTypeKind2;
  (function(ZodFirstPartyTypeKind3) {
    ZodFirstPartyTypeKind3["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind3["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind3["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind3["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind3["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind3["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind3["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind3["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind3["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind3["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind3["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind3["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind3["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind3["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind3["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind3["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind3["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind3["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind3["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind3["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind3["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind3["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind3["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind3["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind3["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind3["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind3["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind3["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind3["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind3["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind3["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind3["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind3["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind3["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind3["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind3["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind2 = exports.ZodFirstPartyTypeKind || (exports.ZodFirstPartyTypeKind = {}));
  var instanceOfType2 = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => (0, exports.custom)((data3) => data3 instanceof cls, params);
  exports.instanceof = instanceOfType2;
  var stringType2 = ZodString2.create;
  exports.string = stringType2;
  var numberType2 = ZodNumber2.create;
  exports.number = numberType2;
  var nanType2 = ZodNaN2.create;
  exports.nan = nanType2;
  var bigIntType2 = ZodBigInt2.create;
  exports.bigint = bigIntType2;
  var booleanType2 = ZodBoolean2.create;
  exports.boolean = booleanType2;
  var dateType2 = ZodDate2.create;
  exports.date = dateType2;
  var symbolType2 = ZodSymbol2.create;
  exports.symbol = symbolType2;
  var undefinedType2 = ZodUndefined2.create;
  exports.undefined = undefinedType2;
  var nullType2 = ZodNull2.create;
  exports.null = nullType2;
  var anyType2 = ZodAny2.create;
  exports.any = anyType2;
  var unknownType2 = ZodUnknown2.create;
  exports.unknown = unknownType2;
  var neverType2 = ZodNever2.create;
  exports.never = neverType2;
  var voidType2 = ZodVoid2.create;
  exports.void = voidType2;
  var arrayType2 = ZodArray2.create;
  exports.array = arrayType2;
  var objectType2 = ZodObject2.create;
  exports.object = objectType2;
  var strictObjectType2 = ZodObject2.strictCreate;
  exports.strictObject = strictObjectType2;
  var unionType2 = ZodUnion2.create;
  exports.union = unionType2;
  var discriminatedUnionType2 = ZodDiscriminatedUnion2.create;
  exports.discriminatedUnion = discriminatedUnionType2;
  var intersectionType2 = ZodIntersection2.create;
  exports.intersection = intersectionType2;
  var tupleType2 = ZodTuple2.create;
  exports.tuple = tupleType2;
  var recordType2 = ZodRecord2.create;
  exports.record = recordType2;
  var mapType2 = ZodMap2.create;
  exports.map = mapType2;
  var setType2 = ZodSet2.create;
  exports.set = setType2;
  var functionType2 = ZodFunction2.create;
  exports.function = functionType2;
  var lazyType2 = ZodLazy2.create;
  exports.lazy = lazyType2;
  var literalType2 = ZodLiteral2.create;
  exports.literal = literalType2;
  var enumType2 = ZodEnum2.create;
  exports.enum = enumType2;
  var nativeEnumType2 = ZodNativeEnum2.create;
  exports.nativeEnum = nativeEnumType2;
  var promiseType2 = ZodPromise2.create;
  exports.promise = promiseType2;
  var effectsType2 = ZodEffects2.create;
  exports.effect = effectsType2;
  exports.transformer = effectsType2;
  var optionalType2 = ZodOptional2.create;
  exports.optional = optionalType2;
  var nullableType2 = ZodNullable2.create;
  exports.nullable = nullableType2;
  var preprocessType2 = ZodEffects2.createWithPreprocess;
  exports.preprocess = preprocessType2;
  var pipelineType2 = ZodPipeline2.create;
  exports.pipeline = pipelineType2;
  var ostring2 = () => stringType2().optional();
  exports.ostring = ostring2;
  var onumber2 = () => numberType2().optional();
  exports.onumber = onumber2;
  var oboolean2 = () => booleanType2().optional();
  exports.oboolean = oboolean2;
  exports.coerce = {
    string: (arg) => ZodString2.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber2.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean2.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt2.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate2.create({ ...arg, coerce: true })
  };
  exports.NEVER = parseUtil_1.INVALID;
});

// ../node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/external.js
var require_external = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_errors2(), exports);
  __exportStar(require_parseUtil(), exports);
  __exportStar(require_typeAliases(), exports);
  __exportStar(require_util2(), exports);
  __exportStar(require_types2(), exports);
  __exportStar(require_ZodError(), exports);
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/zod-validation-error@1.5.0_zod@3.22.4/node_modules/zod/lib/index.js
var require_lib = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding(result, mod2, k);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.z = undefined;
  var z2 = __importStar(require_external());
  exports.z = z2;
  __exportStar(require_external(), exports);
  exports.default = z2;
});

// ../node_modules/.pnpm/zod-validation-error@1.5.0_zod@3.22.4/node_modules/zod-validation-error/dist/cjs/utils/joinPath.js
var require_joinPath = __commonJS((exports) => {
  var joinPath = function(path) {
    if (path.length === 1) {
      return path[0].toString();
    }
    return path.reduce((acc, item) => {
      if (typeof item === "number") {
        return acc + "[" + item.toString() + "]";
      }
      if (item.includes('"')) {
        return acc + '["' + escapeQuotes(item) + '"]';
      }
      if (!identifierRegex.test(item)) {
        return acc + '["' + item + '"]';
      }
      const separator = acc.length === 0 ? "" : ".";
      return acc + separator + item;
    }, "");
  };
  var escapeQuotes = function(str) {
    return str.replace(/"/g, '\\"');
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.joinPath = undefined;
  var identifierRegex = /[$_\p{ID_Start}][$\u200c\u200d\p{ID_Continue}]*/u;
  exports.joinPath = joinPath;
});

// ../node_modules/.pnpm/zod-validation-error@1.5.0_zod@3.22.4/node_modules/zod-validation-error/dist/cjs/utils/NonEmptyArray.js
var require_NonEmptyArray = __commonJS((exports) => {
  var isNonEmptyArray = function(value) {
    return value.length !== 0;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isNonEmptyArray = undefined;
  exports.isNonEmptyArray = isNonEmptyArray;
});

// ../node_modules/.pnpm/zod-validation-error@1.5.0_zod@3.22.4/node_modules/zod-validation-error/dist/cjs/ValidationError.js
var require_ValidationError = __commonJS((exports) => {
  var getMessageFromZodIssue = function(issue, issueSeparator, unionSeparator) {
    if (issue.code === "invalid_union") {
      return issue.unionErrors.reduce((acc, zodError) => {
        const newIssues = zodError.issues.map((issue2) => getMessageFromZodIssue(issue2, issueSeparator, unionSeparator)).join(issueSeparator);
        if (!acc.includes(newIssues)) {
          acc.push(newIssues);
        }
        return acc;
      }, []).join(unionSeparator);
    }
    if ((0, NonEmptyArray_1.isNonEmptyArray)(issue.path)) {
      if (issue.path.length === 1) {
        const identifier = issue.path[0];
        if (typeof identifier === "number") {
          return `${issue.message} at index ${identifier}`;
        }
      }
      return `${issue.message} at "${(0, joinPath_1.joinPath)(issue.path)}"`;
    }
    return issue.message;
  };
  var conditionallyPrefixMessage = function(reason, prefix, prefixSeparator) {
    if (prefix !== null) {
      if (reason.length > 0) {
        return [prefix, reason].join(prefixSeparator);
      }
      return prefix;
    }
    if (reason.length > 0) {
      return reason;
    }
    return PREFIX;
  };
  var fromZodIssue = function(issue, options = {}) {
    const { issueSeparator = ISSUE_SEPARATOR, unionSeparator = UNION_SEPARATOR, prefixSeparator = PREFIX_SEPARATOR, prefix = PREFIX } = options;
    const reason = getMessageFromZodIssue(issue, issueSeparator, unionSeparator);
    const message = conditionallyPrefixMessage(reason, prefix, prefixSeparator);
    return new ValidationError(message, [issue]);
  };
  var fromZodError = function(zodError, options = {}) {
    const { maxIssuesInMessage = MAX_ISSUES_IN_MESSAGE, issueSeparator = ISSUE_SEPARATOR, unionSeparator = UNION_SEPARATOR, prefixSeparator = PREFIX_SEPARATOR, prefix = PREFIX } = options;
    const reason = zodError.errors.slice(0, maxIssuesInMessage).map((issue) => getMessageFromZodIssue(issue, issueSeparator, unionSeparator)).join(issueSeparator);
    const message = conditionallyPrefixMessage(reason, prefix, prefixSeparator);
    return new ValidationError(message, zodError.errors);
  };
  var isValidationError = function(err) {
    return err instanceof ValidationError;
  };
  var isValidationErrorLike = function(err) {
    return err instanceof Error && err.name === "ZodValidationError";
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding(result, mod2, k);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.errorMap = exports.isValidationErrorLike = exports.isValidationError = exports.toValidationError = exports.fromZodError = exports.fromZodIssue = exports.ValidationError = undefined;
  var zod = __importStar(require_lib());
  var joinPath_1 = require_joinPath();
  var NonEmptyArray_1 = require_NonEmptyArray();
  var MAX_ISSUES_IN_MESSAGE = 99;
  var ISSUE_SEPARATOR = "; ";
  var UNION_SEPARATOR = ", or ";
  var PREFIX = "Validation error";
  var PREFIX_SEPARATOR = ": ";

  class ValidationError extends Error {
    details;
    name;
    constructor(message, details = []) {
      super(message);
      this.details = details;
      this.name = "ZodValidationError";
    }
    toString() {
      return this.message;
    }
  }
  exports.ValidationError = ValidationError;
  exports.fromZodIssue = fromZodIssue;
  exports.fromZodError = fromZodError;
  var toValidationError = (options = {}) => (err) => {
    if (err instanceof zod.ZodError) {
      return fromZodError(err, options);
    }
    if (err instanceof Error) {
      return err;
    }
    return new Error("Unknown error");
  };
  exports.toValidationError = toValidationError;
  exports.isValidationError = isValidationError;
  exports.isValidationErrorLike = isValidationErrorLike;
  var errorMap2 = (issue, ctx) => {
    const error = fromZodIssue({
      ...issue,
      message: issue.message ?? ctx.defaultError
    });
    return {
      message: error.message
    };
  };
  exports.errorMap = errorMap2;
});

// /home/mous/work/pimlico/alto/src/node_modules/zod-validation-error/dist/cjs/index.js
var require_cjs5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.errorMap = exports.fromZodIssue = exports.fromZodError = exports.isValidationErrorLike = exports.isValidationError = exports.toValidationError = exports.ValidationError = undefined;
  var ValidationError_1 = require_ValidationError();
  Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
    return ValidationError_1.ValidationError;
  } });
  Object.defineProperty(exports, "toValidationError", { enumerable: true, get: function() {
    return ValidationError_1.toValidationError;
  } });
  Object.defineProperty(exports, "isValidationError", { enumerable: true, get: function() {
    return ValidationError_1.isValidationError;
  } });
  Object.defineProperty(exports, "isValidationErrorLike", { enumerable: true, get: function() {
    return ValidationError_1.isValidationErrorLike;
  } });
  Object.defineProperty(exports, "fromZodError", { enumerable: true, get: function() {
    return ValidationError_1.fromZodError;
  } });
  Object.defineProperty(exports, "fromZodIssue", { enumerable: true, get: function() {
    return ValidationError_1.fromZodIssue;
  } });
  Object.defineProperty(exports, "errorMap", { enumerable: true, get: function() {
    return ValidationError_1.errorMap;
  } });
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/light-my-request@5.11.0/node_modules/cookie/index.js
var require_cookie2 = __commonJS((exports) => {
  var parse = function(str, options) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var obj = {};
    var opt = options || {};
    var dec = opt.decode || decode;
    var index2 = 0;
    while (index2 < str.length) {
      var eqIdx = str.indexOf("=", index2);
      if (eqIdx === -1) {
        break;
      }
      var endIdx = str.indexOf(";", index2);
      if (endIdx === -1) {
        endIdx = str.length;
      } else if (endIdx < eqIdx) {
        index2 = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      var key = str.slice(index2, eqIdx).trim();
      if (obj[key] === undefined) {
        var val = str.slice(eqIdx + 1, endIdx).trim();
        if (val.charCodeAt(0) === 34) {
          val = val.slice(1, -1);
        }
        obj[key] = tryDecode(val, dec);
      }
      index2 = endIdx + 1;
    }
    return obj;
  };
  var serialize = function(name, val, options) {
    var opt = options || {};
    var enc = opt.encode || encode;
    if (typeof enc !== "function") {
      throw new TypeError("option encode is invalid");
    }
    if (!fieldContentRegExp.test(name)) {
      throw new TypeError("argument name is invalid");
    }
    var value = enc(val);
    if (value && !fieldContentRegExp.test(value)) {
      throw new TypeError("argument val is invalid");
    }
    var str = name + "=" + value;
    if (opt.maxAge != null) {
      var maxAge = opt.maxAge - 0;
      if (isNaN(maxAge) || !isFinite(maxAge)) {
        throw new TypeError("option maxAge is invalid");
      }
      str += "; Max-Age=" + Math.floor(maxAge);
    }
    if (opt.domain) {
      if (!fieldContentRegExp.test(opt.domain)) {
        throw new TypeError("option domain is invalid");
      }
      str += "; Domain=" + opt.domain;
    }
    if (opt.path) {
      if (!fieldContentRegExp.test(opt.path)) {
        throw new TypeError("option path is invalid");
      }
      str += "; Path=" + opt.path;
    }
    if (opt.expires) {
      var expires = opt.expires;
      if (!isDate(expires) || isNaN(expires.valueOf())) {
        throw new TypeError("option expires is invalid");
      }
      str += "; Expires=" + expires.toUTCString();
    }
    if (opt.httpOnly) {
      str += "; HttpOnly";
    }
    if (opt.secure) {
      str += "; Secure";
    }
    if (opt.priority) {
      var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError("option priority is invalid");
      }
    }
    if (opt.sameSite) {
      var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
      switch (sameSite) {
        case true:
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError("option sameSite is invalid");
      }
    }
    return str;
  };
  var decode = function(str) {
    return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
  };
  var encode = function(val) {
    return encodeURIComponent(val);
  };
  var isDate = function(val) {
    return __toString.call(val) === "[object Date]" || val instanceof Date;
  };
  var tryDecode = function(str, decode2) {
    try {
      return decode2(str);
    } catch (e) {
      return str;
    }
  };
  /*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  exports.parse = parse;
  exports.serialize = serialize;
  var __toString = Object.prototype.toString;
  var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/light-my-request@5.11.0/node_modules/process-warning/index.js
var require_process_warning = __commonJS((exports, module) => {
  var processWarning = function() {
    const codes = {};
    const emitted = new Map;
    const opts = Object.create(null);
    function create(name, code, message, { unlimited = false } = {}) {
      if (!name)
        throw new Error("Warning name must not be empty");
      if (!code)
        throw new Error("Warning code must not be empty");
      if (!message)
        throw new Error("Warning message must not be empty");
      if (typeof unlimited !== "boolean")
        throw new Error("Warning opts.unlimited must be a boolean");
      code = code.toUpperCase();
      if (codes[code] !== undefined) {
        throw new Error(`The code '${code}' already exist`);
      }
      function buildWarnOpts(a, b, c) {
        let formatted;
        if (a && b && c) {
          formatted = format3(message, a, b, c);
        } else if (a && b) {
          formatted = format3(message, a, b);
        } else if (a) {
          formatted = format3(message, a);
        } else {
          formatted = message;
        }
        return {
          code,
          name,
          message: formatted
        };
      }
      Object.assign(opts, { unlimited });
      emitted.set(code, unlimited);
      codes[code] = buildWarnOpts;
      return codes[code];
    }
    function createDeprecation(code, message, opts2 = {}) {
      return create("DeprecationWarning", code, message, opts2);
    }
    function emit(code, a, b, c) {
      if (emitted.get(code) === true && opts.unlimited === false)
        return;
      if (codes[code] === undefined)
        throw new Error(`The code '${code}' does not exist`);
      emitted.set(code, true);
      const warning = codes[code](a, b, c);
      process.emitWarning(warning.message, warning.name, warning.code);
    }
    return {
      create,
      createDeprecation,
      emit,
      emitted
    };
  };
  var { format: format3 } = __require("node:util");
  module.exports = processWarning;
  module.exports.default = processWarning;
  module.exports.processWarning = processWarning;
});

// ../node_modules/.pnpm/light-my-request@5.11.0/node_modules/light-my-request/lib/parse-url.js
var require_parse_url = __commonJS((exports, module) => {
  var { URL: URL2 } = __require("node:url");
  var BASE_URL = "http://localhost";
  module.exports = function parseURL(url, query) {
    if ((typeof url === "string" || Object.prototype.toString.call(url) === "[object String]") && url.startsWith("//")) {
      url = BASE_URL + url;
    }
    const result = typeof url === "object" ? Object.assign(new URL2(BASE_URL), url) : new URL2(url, BASE_URL);
    if (typeof query === "string") {
      query = new URLSearchParams(query);
      for (const key of query.keys()) {
        result.searchParams.delete(key);
        for (const value of query.getAll(key)) {
          result.searchParams.append(key, value);
        }
      }
    } else {
      const merged = Object.assign({}, url.query, query);
      for (const key in merged) {
        const value = merged[key];
        if (Array.isArray(value)) {
          result.searchParams.delete(key);
          for (const param of value) {
            result.searchParams.append(key, param);
          }
        } else {
          result.searchParams.set(key, value);
        }
      }
    }
    return result;
  };
});

// ../node_modules/.pnpm/light-my-request@5.11.0/node_modules/light-my-request/lib/request.js
var require_request2 = __commonJS((exports, module) => {
  var hostHeaderFromURL = function(parsedURL) {
    return parsedURL.port ? parsedURL.host : parsedURL.hostname + (parsedURL.protocol === "https:" ? ":443" : ":80");
  };
  var CustomRequest = function(options) {
    return new _CustomLMRRequest(this);
    function _CustomLMRRequest(obj) {
      Request2.call(obj, {
        ...options,
        Request: undefined
      });
      Object.assign(this, obj);
      for (const fn of Object.keys(Request2.prototype)) {
        this.constructor.prototype[fn] = Request2.prototype[fn];
      }
      util2.inherits(this.constructor, options.Request);
      return this;
    }
  };
  var Request2 = function(options) {
    Readable.call(this, {
      autoDestroy: false
    });
    const parsedURL = parseURL(options.url || options.path, options.query);
    this.url = parsedURL.pathname + parsedURL.search;
    this.aborted = false;
    this.httpVersionMajor = 1;
    this.httpVersionMinor = 1;
    this.httpVersion = "1.1";
    this.method = options.method ? options.method.toUpperCase() : "GET";
    this.headers = {};
    this.rawHeaders = [];
    const headers = options.headers || {};
    for (const field in headers) {
      const fieldLowerCase = field.toLowerCase();
      if ((fieldLowerCase === "user-agent" || fieldLowerCase === "content-type") && headers[field] === undefined) {
        this.headers[fieldLowerCase] = undefined;
        continue;
      }
      const value = headers[field];
      assert(value !== undefined, 'invalid value "undefined" for header ' + field);
      this.headers[fieldLowerCase] = "" + value;
    }
    if ("user-agent" in this.headers === false) {
      this.headers["user-agent"] = "lightMyRequest";
    }
    this.headers.host = this.headers.host || options.authority || hostHeaderFromURL(parsedURL);
    if (options.cookies) {
      const { cookies } = options;
      const cookieValues = Object.keys(cookies).map((key) => cookie.serialize(key, cookies[key]));
      if (this.headers.cookie) {
        cookieValues.unshift(this.headers.cookie);
      }
      this.headers.cookie = cookieValues.join("; ");
    }
    this.socket = new MockSocket(options.remoteAddress || "127.0.0.1");
    Object.defineProperty(this, "connection", {
      get() {
        warning.emit("FST_LIGHTMYREQUEST_DEP01");
        return this.socket;
      },
      configurable: true
    });
    let payload = options.payload || options.body || null;
    const payloadResume = payload && typeof payload.resume === "function";
    if (payload && typeof payload !== "string" && !payloadResume && !Buffer.isBuffer(payload)) {
      payload = JSON.stringify(payload);
      if ("content-type" in this.headers === false) {
        this.headers["content-type"] = "application/json";
      }
    }
    if (payload && !payloadResume && !Object.prototype.hasOwnProperty.call(this.headers, "content-length")) {
      this.headers["content-length"] = (Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload)).toString();
    }
    for (const header of Object.keys(this.headers)) {
      this.rawHeaders.push(header, this.headers[header]);
    }
    this._lightMyRequest = {
      payload,
      isDone: false,
      simulate: options.simulate || {}
    };
    const signal = options.signal;
    if (signal) {
      addAbortSignal(signal, this);
    }
    return this;
  };
  var { Readable, addAbortSignal } = __require("node:stream");
  var util2 = __require("node:util");
  var cookie = require_cookie2();
  var assert = __require("node:assert");
  var warning = require_process_warning()();
  var parseURL = require_parse_url();
  var { EventEmitter } = __require("node:events");
  warning.create("FastifyDeprecationLightMyRequest", "FST_LIGHTMYREQUEST_DEP01", 'You are accessing "request.connection", use "request.socket" instead.');

  class MockSocket extends EventEmitter {
    constructor(remoteAddress) {
      super();
      this.remoteAddress = remoteAddress;
    }
  }
  util2.inherits(Request2, Readable);
  util2.inherits(CustomRequest, Request2);
  Request2.prototype.prepare = function(next) {
    const payload = this._lightMyRequest.payload;
    if (!payload || typeof payload.resume !== "function") {
      return next();
    }
    const chunks = [];
    payload.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
    payload.on("end", () => {
      const payload2 = Buffer.concat(chunks);
      this.headers["content-length"] = this.headers["content-length"] || "" + payload2.length;
      this._lightMyRequest.payload = payload2;
      return next();
    });
    payload.resume();
  };
  Request2.prototype._read = function(size9) {
    setImmediate(() => {
      if (this._lightMyRequest.isDone) {
        if (this._lightMyRequest.simulate.end !== false) {
          this.push(null);
        }
        return;
      }
      this._lightMyRequest.isDone = true;
      if (this._lightMyRequest.payload) {
        if (this._lightMyRequest.simulate.split) {
          this.push(this._lightMyRequest.payload.slice(0, 1));
          this.push(this._lightMyRequest.payload.slice(1));
        } else {
          this.push(this._lightMyRequest.payload);
        }
      }
      if (this._lightMyRequest.simulate.error) {
        this.emit("error", new Error("Simulated"));
      }
      if (this._lightMyRequest.simulate.close) {
        this.emit("close");
      }
      if (this._lightMyRequest.simulate.end !== false) {
        this.push(null);
      }
    });
  };
  Request2.prototype.destroy = function(error) {
    if (this.destroyed || this._lightMyRequest.isDone)
      return;
    this.destroyed = true;
    if (error) {
      this._error = true;
      process.nextTick(() => this.emit("error", error));
    }
    process.nextTick(() => this.emit("close"));
  };
  module.exports = Request2;
  module.exports.Request = Request2;
  module.exports.CustomRequest = CustomRequest;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/light-my-request@5.11.0/node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS((exports, module) => {
  var isNonEmptyString = function(str) {
    return typeof str === "string" && !!str.trim();
  };
  var parseString = function(setCookieValue, options) {
    var parts = setCookieValue.split(";").filter(isNonEmptyString);
    var nameValuePairStr = parts.shift();
    var parsed = parseNameValuePair(nameValuePairStr);
    var name = parsed.name;
    var value = parsed.value;
    options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
    try {
      value = options.decodeValues ? decodeURIComponent(value) : value;
    } catch (e) {
      console.error("set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.", e);
    }
    var cookie = {
      name,
      value
    };
    parts.forEach(function(part) {
      var sides = part.split("=");
      var key = sides.shift().trimLeft().toLowerCase();
      var value2 = sides.join("=");
      if (key === "expires") {
        cookie.expires = new Date(value2);
      } else if (key === "max-age") {
        cookie.maxAge = parseInt(value2, 10);
      } else if (key === "secure") {
        cookie.secure = true;
      } else if (key === "httponly") {
        cookie.httpOnly = true;
      } else if (key === "samesite") {
        cookie.sameSite = value2;
      } else {
        cookie[key] = value2;
      }
    });
    return cookie;
  };
  var parseNameValuePair = function(nameValuePairStr) {
    var name = "";
    var value = "";
    var nameValueArr = nameValuePairStr.split("=");
    if (nameValueArr.length > 1) {
      name = nameValueArr.shift();
      value = nameValueArr.join("=");
    } else {
      value = nameValuePairStr;
    }
    return { name, value };
  };
  var parse = function(input, options) {
    options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
    if (!input) {
      if (!options.map) {
        return [];
      } else {
        return {};
      }
    }
    if (input.headers) {
      if (typeof input.headers.getSetCookie === "function") {
        input = input.headers.getSetCookie();
      } else if (input.headers["set-cookie"]) {
        input = input.headers["set-cookie"];
      } else {
        var sch = input.headers[Object.keys(input.headers).find(function(key) {
          return key.toLowerCase() === "set-cookie";
        })];
        if (!sch && input.headers.cookie && !options.silent) {
          console.warn("Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.");
        }
        input = sch;
      }
    }
    if (!Array.isArray(input)) {
      input = [input];
    }
    options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
    if (!options.map) {
      return input.filter(isNonEmptyString).map(function(str) {
        return parseString(str, options);
      });
    } else {
      var cookies = {};
      return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
        var cookie = parseString(str, options);
        cookies2[cookie.name] = cookie;
        return cookies2;
      }, cookies);
    }
  };
  var splitCookiesString = function(cookiesString) {
    if (Array.isArray(cookiesString)) {
      return cookiesString;
    }
    if (typeof cookiesString !== "string") {
      return [];
    }
    var cookiesStrings = [];
    var pos = 0;
    var start;
    var ch;
    var lastComma;
    var nextStart;
    var cookiesSeparatorFound;
    function skipWhitespace() {
      while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
        pos += 1;
      }
      return pos < cookiesString.length;
    }
    function notSpecialChar() {
      ch = cookiesString.charAt(pos);
      return ch !== "=" && ch !== ";" && ch !== ",";
    }
    while (pos < cookiesString.length) {
      start = pos;
      cookiesSeparatorFound = false;
      while (skipWhitespace()) {
        ch = cookiesString.charAt(pos);
        if (ch === ",") {
          lastComma = pos;
          pos += 1;
          skipWhitespace();
          nextStart = pos;
          while (pos < cookiesString.length && notSpecialChar()) {
            pos += 1;
          }
          if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
            cookiesSeparatorFound = true;
            pos = nextStart;
            cookiesStrings.push(cookiesString.substring(start, lastComma));
            start = pos;
          } else {
            pos = lastComma + 1;
          }
        } else {
          pos += 1;
        }
      }
      if (!cookiesSeparatorFound || pos >= cookiesString.length) {
        cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
      }
    }
    return cookiesStrings;
  };
  var defaultParseOptions = {
    decodeValues: true,
    map: false,
    silent: false
  };
  module.exports = parse;
  module.exports.parse = parse;
  module.exports.parseString = parseString;
  module.exports.splitCookiesString = splitCookiesString;
});

// ../node_modules/.pnpm/light-my-request@5.11.0/node_modules/light-my-request/lib/response.js
var require_response = __commonJS((exports, module) => {
  var Response2 = function(req, onEnd, reject) {
    http2.ServerResponse.call(this, req);
    this._lightMyRequest = { headers: null, trailers: {}, payloadChunks: [] };
    this.setHeader("foo", "bar");
    this.removeHeader("foo");
    this.assignSocket(getNullSocket());
    this._promiseCallback = typeof reject === "function";
    let called = false;
    const onEndSuccess = (payload) => {
      called = true;
      if (this._promiseCallback) {
        return process.nextTick(() => onEnd(payload));
      }
      process.nextTick(() => onEnd(null, payload));
    };
    const onEndFailure = (err) => {
      if (called)
        return;
      called = true;
      if (this._promiseCallback) {
        return process.nextTick(() => reject(err));
      }
      process.nextTick(() => onEnd(err, null));
    };
    this.once("finish", () => {
      const res = generatePayload(this);
      res.raw.req = req;
      onEndSuccess(res);
    });
    this.connection.once("error", onEndFailure);
    this.once("error", onEndFailure);
    this.once("close", onEndFailure);
  };
  var generatePayload = function(response) {
    if (response._lightMyRequest.headers === null) {
      copyHeaders(response);
    }
    serializeHeaders(response);
    const res = {
      raw: {
        res: response
      },
      headers: response._lightMyRequest.headers,
      statusCode: response.statusCode,
      statusMessage: response.statusMessage,
      trailers: {},
      get cookies() {
        return setCookie.parse(this);
      }
    };
    const rawBuffer = Buffer.concat(response._lightMyRequest.payloadChunks);
    res.rawPayload = rawBuffer;
    res.payload = rawBuffer.toString();
    res.body = res.payload;
    res.trailers = response._lightMyRequest.trailers;
    res.json = function parseJsonPayload() {
      return JSON.parse(res.payload);
    };
    return res;
  };
  var getNullSocket = function() {
    return new Writable({
      write(chunk, encoding3, callback) {
        setImmediate(callback);
      }
    });
  };
  var serializeHeaders = function(response) {
    const headers = response._lightMyRequest.headers;
    for (const headerName of Object.keys(headers)) {
      const headerValue = headers[headerName];
      if (Array.isArray(headerValue)) {
        headers[headerName] = headerValue.map((value) => "" + value);
      } else {
        headers[headerName] = "" + headerValue;
      }
    }
  };
  var copyHeaders = function(response) {
    response._lightMyRequest.headers = Object.assign({}, response.getHeaders());
    ["Date", "Connection", "Transfer-Encoding"].forEach((name) => {
      const regex3 = new RegExp("\\r\\n" + name + ": ([^\\r]*)\\r\\n");
      const field = response._header.match(regex3);
      if (field) {
        response._lightMyRequest.headers[name.toLowerCase()] = field[1];
      }
    });
  };
  var http2 = __require("node:http");
  var { Writable } = __require("node:stream");
  var util2 = __require("node:util");
  var setCookie = require_set_cookie();
  util2.inherits(Response2, http2.ServerResponse);
  Response2.prototype.setTimeout = function(msecs, callback) {
    this.timeoutHandle = setTimeout(() => {
      this.emit("timeout");
    }, msecs);
    this.on("timeout", callback);
    return this;
  };
  Response2.prototype.writeHead = function() {
    const result = http2.ServerResponse.prototype.writeHead.apply(this, arguments);
    copyHeaders(this);
    return result;
  };
  Response2.prototype.write = function(data3, encoding3, callback) {
    if (this.timeoutHandle) {
      clearTimeout(this.timeoutHandle);
    }
    http2.ServerResponse.prototype.write.call(this, data3, encoding3, callback);
    this._lightMyRequest.payloadChunks.push(Buffer.from(data3, encoding3));
    return true;
  };
  Response2.prototype.end = function(data3, encoding3, callback) {
    if (data3) {
      this.write(data3, encoding3);
    }
    http2.ServerResponse.prototype.end.call(this, callback);
    this.emit("finish");
    this.destroy();
  };
  Response2.prototype.destroy = function(error) {
    if (this.destroyed)
      return;
    this.destroyed = true;
    if (error) {
      process.nextTick(() => this.emit("error", error));
    }
    process.nextTick(() => this.emit("close"));
  };
  Response2.prototype.addTrailers = function(trailers) {
    for (const key in trailers) {
      this._lightMyRequest.trailers[key.toLowerCase().trim()] = trailers[key].toString().trim();
    }
  };
  module.exports = Response2;
});

// ../node_modules/.pnpm/light-my-request@5.11.0/node_modules/light-my-request/lib/config-validator.js
var require_config_validator = __commonJS((exports, module) => {
  var validate10 = function(data3, { instancePath = "", parentData, parentDataProperty, rootData = data3 } = {}) {
    let vErrors = null;
    let errors4 = 0;
    const _errs1 = errors4;
    let valid0 = false;
    let passing0 = null;
    const _errs2 = errors4;
    if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
      let missing0;
      if (data3.url === undefined && (missing0 = "url")) {
        const err0 = { instancePath, schemaPath: "#/oneOf/0/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors4++;
      }
    }
    var _valid0 = _errs2 === errors4;
    if (_valid0) {
      valid0 = true;
      passing0 = 0;
    }
    const _errs3 = errors4;
    if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
      let missing1;
      if (data3.path === undefined && (missing1 = "path")) {
        const err1 = { instancePath, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" };
        if (vErrors === null) {
          vErrors = [err1];
        } else {
          vErrors.push(err1);
        }
        errors4++;
      }
    }
    var _valid0 = _errs3 === errors4;
    if (_valid0 && valid0) {
      valid0 = false;
      passing0 = [passing0, 1];
    } else {
      if (_valid0) {
        valid0 = true;
        passing0 = 1;
      }
    }
    if (!valid0) {
      const err2 = { instancePath, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
      if (vErrors === null) {
        vErrors = [err2];
      } else {
        vErrors.push(err2);
      }
      errors4++;
      validate10.errors = vErrors;
      return false;
    } else {
      errors4 = _errs1;
      if (vErrors !== null) {
        if (_errs1) {
          vErrors.length = _errs1;
        } else {
          vErrors = null;
        }
      }
    }
    if (errors4 === 0) {
      if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
        if (data3.url !== undefined) {
          let data0 = data3.url;
          const _errs5 = errors4;
          const _errs6 = errors4;
          let valid2 = false;
          let passing1 = null;
          const _errs7 = errors4;
          if (typeof data0 !== "string") {
            let dataType0 = typeof data0;
            let coerced0 = undefined;
            if (!(coerced0 !== undefined)) {
              if (dataType0 == "number" || dataType0 == "boolean") {
                coerced0 = "" + data0;
              } else if (data0 === null) {
                coerced0 = "";
              } else {
                const err3 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err3];
                } else {
                  vErrors.push(err3);
                }
                errors4++;
              }
            }
            if (coerced0 !== undefined) {
              data0 = coerced0;
              if (data3 !== undefined) {
                data3["url"] = coerced0;
              }
            }
          }
          var _valid1 = _errs7 === errors4;
          if (_valid1) {
            valid2 = true;
            passing1 = 0;
          }
          const _errs9 = errors4;
          if (errors4 === _errs9) {
            if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
              let missing2;
              if (data0.pathname === undefined && (missing2 = "pathname")) {
                const err4 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf/1/required", keyword: "required", params: { missingProperty: missing2 }, message: "must have required property '" + missing2 + "'" };
                if (vErrors === null) {
                  vErrors = [err4];
                } else {
                  vErrors.push(err4);
                }
                errors4++;
              } else {
                if (data0.protocol !== undefined) {
                  let data1 = data0.protocol;
                  const _errs12 = errors4;
                  if (typeof data1 !== "string") {
                    let dataType1 = typeof data1;
                    let coerced1 = undefined;
                    if (!(coerced1 !== undefined)) {
                      if (dataType1 == "number" || dataType1 == "boolean") {
                        coerced1 = "" + data1;
                      } else if (data1 === null) {
                        coerced1 = "";
                      } else {
                        const err5 = { instancePath: instancePath + "/url/protocol", schemaPath: "#/properties/url/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                        if (vErrors === null) {
                          vErrors = [err5];
                        } else {
                          vErrors.push(err5);
                        }
                        errors4++;
                      }
                    }
                    if (coerced1 !== undefined) {
                      data1 = coerced1;
                      if (data0 !== undefined) {
                        data0["protocol"] = coerced1;
                      }
                    }
                  }
                  var valid3 = _errs12 === errors4;
                } else {
                  var valid3 = true;
                }
                if (valid3) {
                  if (data0.hostname !== undefined) {
                    let data22 = data0.hostname;
                    const _errs14 = errors4;
                    if (typeof data22 !== "string") {
                      let dataType2 = typeof data22;
                      let coerced2 = undefined;
                      if (!(coerced2 !== undefined)) {
                        if (dataType2 == "number" || dataType2 == "boolean") {
                          coerced2 = "" + data22;
                        } else if (data22 === null) {
                          coerced2 = "";
                        } else {
                          const err6 = { instancePath: instancePath + "/url/hostname", schemaPath: "#/properties/url/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          if (vErrors === null) {
                            vErrors = [err6];
                          } else {
                            vErrors.push(err6);
                          }
                          errors4++;
                        }
                      }
                      if (coerced2 !== undefined) {
                        data22 = coerced2;
                        if (data0 !== undefined) {
                          data0["hostname"] = coerced2;
                        }
                      }
                    }
                    var valid3 = _errs14 === errors4;
                  } else {
                    var valid3 = true;
                  }
                  if (valid3) {
                    if (data0.pathname !== undefined) {
                      let data32 = data0.pathname;
                      const _errs16 = errors4;
                      if (typeof data32 !== "string") {
                        let dataType3 = typeof data32;
                        let coerced3 = undefined;
                        if (!(coerced3 !== undefined)) {
                          if (dataType3 == "number" || dataType3 == "boolean") {
                            coerced3 = "" + data32;
                          } else if (data32 === null) {
                            coerced3 = "";
                          } else {
                            const err7 = { instancePath: instancePath + "/url/pathname", schemaPath: "#/properties/url/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            if (vErrors === null) {
                              vErrors = [err7];
                            } else {
                              vErrors.push(err7);
                            }
                            errors4++;
                          }
                        }
                        if (coerced3 !== undefined) {
                          data32 = coerced3;
                          if (data0 !== undefined) {
                            data0["pathname"] = coerced3;
                          }
                        }
                      }
                      var valid3 = _errs16 === errors4;
                    } else {
                      var valid3 = true;
                    }
                  }
                }
              }
            } else {
              const err8 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err8];
              } else {
                vErrors.push(err8);
              }
              errors4++;
            }
          }
          var _valid1 = _errs9 === errors4;
          if (_valid1 && valid2) {
            valid2 = false;
            passing1 = [passing1, 1];
          } else {
            if (_valid1) {
              valid2 = true;
              passing1 = 1;
            }
          }
          if (!valid2) {
            const err9 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf", keyword: "oneOf", params: { passingSchemas: passing1 }, message: "must match exactly one schema in oneOf" };
            if (vErrors === null) {
              vErrors = [err9];
            } else {
              vErrors.push(err9);
            }
            errors4++;
            validate10.errors = vErrors;
            return false;
          } else {
            errors4 = _errs6;
            if (vErrors !== null) {
              if (_errs6) {
                vErrors.length = _errs6;
              } else {
                vErrors = null;
              }
            }
          }
          var valid1 = _errs5 === errors4;
        } else {
          var valid1 = true;
        }
        if (valid1) {
          if (data3.path !== undefined) {
            let data4 = data3.path;
            const _errs18 = errors4;
            const _errs19 = errors4;
            let valid4 = false;
            let passing2 = null;
            const _errs20 = errors4;
            if (typeof data4 !== "string") {
              let dataType4 = typeof data4;
              let coerced4 = undefined;
              if (!(coerced4 !== undefined)) {
                if (dataType4 == "number" || dataType4 == "boolean") {
                  coerced4 = "" + data4;
                } else if (data4 === null) {
                  coerced4 = "";
                } else {
                  const err10 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err10];
                  } else {
                    vErrors.push(err10);
                  }
                  errors4++;
                }
              }
              if (coerced4 !== undefined) {
                data4 = coerced4;
                if (data3 !== undefined) {
                  data3["path"] = coerced4;
                }
              }
            }
            var _valid2 = _errs20 === errors4;
            if (_valid2) {
              valid4 = true;
              passing2 = 0;
            }
            const _errs22 = errors4;
            if (errors4 === _errs22) {
              if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                let missing3;
                if (data4.pathname === undefined && (missing3 = "pathname")) {
                  const err11 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf/1/required", keyword: "required", params: { missingProperty: missing3 }, message: "must have required property '" + missing3 + "'" };
                  if (vErrors === null) {
                    vErrors = [err11];
                  } else {
                    vErrors.push(err11);
                  }
                  errors4++;
                } else {
                  if (data4.protocol !== undefined) {
                    let data5 = data4.protocol;
                    const _errs25 = errors4;
                    if (typeof data5 !== "string") {
                      let dataType5 = typeof data5;
                      let coerced5 = undefined;
                      if (!(coerced5 !== undefined)) {
                        if (dataType5 == "number" || dataType5 == "boolean") {
                          coerced5 = "" + data5;
                        } else if (data5 === null) {
                          coerced5 = "";
                        } else {
                          const err12 = { instancePath: instancePath + "/path/protocol", schemaPath: "#/properties/path/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          if (vErrors === null) {
                            vErrors = [err12];
                          } else {
                            vErrors.push(err12);
                          }
                          errors4++;
                        }
                      }
                      if (coerced5 !== undefined) {
                        data5 = coerced5;
                        if (data4 !== undefined) {
                          data4["protocol"] = coerced5;
                        }
                      }
                    }
                    var valid5 = _errs25 === errors4;
                  } else {
                    var valid5 = true;
                  }
                  if (valid5) {
                    if (data4.hostname !== undefined) {
                      let data6 = data4.hostname;
                      const _errs27 = errors4;
                      if (typeof data6 !== "string") {
                        let dataType6 = typeof data6;
                        let coerced6 = undefined;
                        if (!(coerced6 !== undefined)) {
                          if (dataType6 == "number" || dataType6 == "boolean") {
                            coerced6 = "" + data6;
                          } else if (data6 === null) {
                            coerced6 = "";
                          } else {
                            const err13 = { instancePath: instancePath + "/path/hostname", schemaPath: "#/properties/path/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            if (vErrors === null) {
                              vErrors = [err13];
                            } else {
                              vErrors.push(err13);
                            }
                            errors4++;
                          }
                        }
                        if (coerced6 !== undefined) {
                          data6 = coerced6;
                          if (data4 !== undefined) {
                            data4["hostname"] = coerced6;
                          }
                        }
                      }
                      var valid5 = _errs27 === errors4;
                    } else {
                      var valid5 = true;
                    }
                    if (valid5) {
                      if (data4.pathname !== undefined) {
                        let data7 = data4.pathname;
                        const _errs29 = errors4;
                        if (typeof data7 !== "string") {
                          let dataType7 = typeof data7;
                          let coerced7 = undefined;
                          if (!(coerced7 !== undefined)) {
                            if (dataType7 == "number" || dataType7 == "boolean") {
                              coerced7 = "" + data7;
                            } else if (data7 === null) {
                              coerced7 = "";
                            } else {
                              const err14 = { instancePath: instancePath + "/path/pathname", schemaPath: "#/properties/path/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              if (vErrors === null) {
                                vErrors = [err14];
                              } else {
                                vErrors.push(err14);
                              }
                              errors4++;
                            }
                          }
                          if (coerced7 !== undefined) {
                            data7 = coerced7;
                            if (data4 !== undefined) {
                              data4["pathname"] = coerced7;
                            }
                          }
                        }
                        var valid5 = _errs29 === errors4;
                      } else {
                        var valid5 = true;
                      }
                    }
                  }
                }
              } else {
                const err15 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                if (vErrors === null) {
                  vErrors = [err15];
                } else {
                  vErrors.push(err15);
                }
                errors4++;
              }
            }
            var _valid2 = _errs22 === errors4;
            if (_valid2 && valid4) {
              valid4 = false;
              passing2 = [passing2, 1];
            } else {
              if (_valid2) {
                valid4 = true;
                passing2 = 1;
              }
            }
            if (!valid4) {
              const err16 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf", keyword: "oneOf", params: { passingSchemas: passing2 }, message: "must match exactly one schema in oneOf" };
              if (vErrors === null) {
                vErrors = [err16];
              } else {
                vErrors.push(err16);
              }
              errors4++;
              validate10.errors = vErrors;
              return false;
            } else {
              errors4 = _errs19;
              if (vErrors !== null) {
                if (_errs19) {
                  vErrors.length = _errs19;
                } else {
                  vErrors = null;
                }
              }
            }
            var valid1 = _errs18 === errors4;
          } else {
            var valid1 = true;
          }
          if (valid1) {
            if (data3.cookies !== undefined) {
              let data8 = data3.cookies;
              const _errs31 = errors4;
              if (errors4 === _errs31) {
                if (!(data8 && typeof data8 == "object" && !Array.isArray(data8))) {
                  validate10.errors = [{ instancePath: instancePath + "/cookies", schemaPath: "#/properties/cookies/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                  return false;
                }
              }
              var valid1 = _errs31 === errors4;
            } else {
              var valid1 = true;
            }
            if (valid1) {
              if (data3.headers !== undefined) {
                let data9 = data3.headers;
                const _errs34 = errors4;
                if (errors4 === _errs34) {
                  if (!(data9 && typeof data9 == "object" && !Array.isArray(data9))) {
                    validate10.errors = [{ instancePath: instancePath + "/headers", schemaPath: "#/properties/headers/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                    return false;
                  }
                }
                var valid1 = _errs34 === errors4;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data3.query !== undefined) {
                  let data10 = data3.query;
                  const _errs37 = errors4;
                  const _errs38 = errors4;
                  let valid6 = false;
                  const _errs39 = errors4;
                  if (errors4 === _errs39) {
                    if (!(data10 && typeof data10 == "object" && !Array.isArray(data10))) {
                      const err17 = { instancePath: instancePath + "/query", schemaPath: "#/properties/query/anyOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                      if (vErrors === null) {
                        vErrors = [err17];
                      } else {
                        vErrors.push(err17);
                      }
                      errors4++;
                    }
                  }
                  var _valid3 = _errs39 === errors4;
                  valid6 = valid6 || _valid3;
                  if (!valid6) {
                    const _errs42 = errors4;
                    if (typeof data10 !== "string") {
                      let dataType8 = typeof data10;
                      let coerced8 = undefined;
                      if (!(coerced8 !== undefined)) {
                        if (dataType8 == "number" || dataType8 == "boolean") {
                          coerced8 = "" + data10;
                        } else if (data10 === null) {
                          coerced8 = "";
                        } else {
                          const err18 = { instancePath: instancePath + "/query", schemaPath: "#/properties/query/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          if (vErrors === null) {
                            vErrors = [err18];
                          } else {
                            vErrors.push(err18);
                          }
                          errors4++;
                        }
                      }
                      if (coerced8 !== undefined) {
                        data10 = coerced8;
                        if (data3 !== undefined) {
                          data3["query"] = coerced8;
                        }
                      }
                    }
                    var _valid3 = _errs42 === errors4;
                    valid6 = valid6 || _valid3;
                  }
                  if (!valid6) {
                    const err19 = { instancePath: instancePath + "/query", schemaPath: "#/properties/query/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                    if (vErrors === null) {
                      vErrors = [err19];
                    } else {
                      vErrors.push(err19);
                    }
                    errors4++;
                    validate10.errors = vErrors;
                    return false;
                  } else {
                    errors4 = _errs38;
                    if (vErrors !== null) {
                      if (_errs38) {
                        vErrors.length = _errs38;
                      } else {
                        vErrors = null;
                      }
                    }
                  }
                  var valid1 = _errs37 === errors4;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data3.simulate !== undefined) {
                    let data11 = data3.simulate;
                    const _errs44 = errors4;
                    if (errors4 === _errs44) {
                      if (data11 && typeof data11 == "object" && !Array.isArray(data11)) {
                        if (data11.end !== undefined) {
                          let data12 = data11.end;
                          const _errs46 = errors4;
                          if (typeof data12 !== "boolean") {
                            let coerced9 = undefined;
                            if (!(coerced9 !== undefined)) {
                              if (data12 === "false" || data12 === 0 || data12 === null) {
                                coerced9 = false;
                              } else if (data12 === "true" || data12 === 1) {
                                coerced9 = true;
                              } else {
                                validate10.errors = [{ instancePath: instancePath + "/simulate/end", schemaPath: "#/properties/simulate/properties/end/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                return false;
                              }
                            }
                            if (coerced9 !== undefined) {
                              data12 = coerced9;
                              if (data11 !== undefined) {
                                data11["end"] = coerced9;
                              }
                            }
                          }
                          var valid7 = _errs46 === errors4;
                        } else {
                          var valid7 = true;
                        }
                        if (valid7) {
                          if (data11.split !== undefined) {
                            let data13 = data11.split;
                            const _errs48 = errors4;
                            if (typeof data13 !== "boolean") {
                              let coerced10 = undefined;
                              if (!(coerced10 !== undefined)) {
                                if (data13 === "false" || data13 === 0 || data13 === null) {
                                  coerced10 = false;
                                } else if (data13 === "true" || data13 === 1) {
                                  coerced10 = true;
                                } else {
                                  validate10.errors = [{ instancePath: instancePath + "/simulate/split", schemaPath: "#/properties/simulate/properties/split/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                  return false;
                                }
                              }
                              if (coerced10 !== undefined) {
                                data13 = coerced10;
                                if (data11 !== undefined) {
                                  data11["split"] = coerced10;
                                }
                              }
                            }
                            var valid7 = _errs48 === errors4;
                          } else {
                            var valid7 = true;
                          }
                          if (valid7) {
                            if (data11.error !== undefined) {
                              let data14 = data11.error;
                              const _errs50 = errors4;
                              if (typeof data14 !== "boolean") {
                                let coerced11 = undefined;
                                if (!(coerced11 !== undefined)) {
                                  if (data14 === "false" || data14 === 0 || data14 === null) {
                                    coerced11 = false;
                                  } else if (data14 === "true" || data14 === 1) {
                                    coerced11 = true;
                                  } else {
                                    validate10.errors = [{ instancePath: instancePath + "/simulate/error", schemaPath: "#/properties/simulate/properties/error/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                    return false;
                                  }
                                }
                                if (coerced11 !== undefined) {
                                  data14 = coerced11;
                                  if (data11 !== undefined) {
                                    data11["error"] = coerced11;
                                  }
                                }
                              }
                              var valid7 = _errs50 === errors4;
                            } else {
                              var valid7 = true;
                            }
                            if (valid7) {
                              if (data11.close !== undefined) {
                                let data15 = data11.close;
                                const _errs52 = errors4;
                                if (typeof data15 !== "boolean") {
                                  let coerced12 = undefined;
                                  if (!(coerced12 !== undefined)) {
                                    if (data15 === "false" || data15 === 0 || data15 === null) {
                                      coerced12 = false;
                                    } else if (data15 === "true" || data15 === 1) {
                                      coerced12 = true;
                                    } else {
                                      validate10.errors = [{ instancePath: instancePath + "/simulate/close", schemaPath: "#/properties/simulate/properties/close/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                      return false;
                                    }
                                  }
                                  if (coerced12 !== undefined) {
                                    data15 = coerced12;
                                    if (data11 !== undefined) {
                                      data11["close"] = coerced12;
                                    }
                                  }
                                }
                                var valid7 = _errs52 === errors4;
                              } else {
                                var valid7 = true;
                              }
                            }
                          }
                        }
                      } else {
                        validate10.errors = [{ instancePath: instancePath + "/simulate", schemaPath: "#/properties/simulate/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                        return false;
                      }
                    }
                    var valid1 = _errs44 === errors4;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data3.authority !== undefined) {
                      let data16 = data3.authority;
                      const _errs54 = errors4;
                      if (typeof data16 !== "string") {
                        let dataType13 = typeof data16;
                        let coerced13 = undefined;
                        if (!(coerced13 !== undefined)) {
                          if (dataType13 == "number" || dataType13 == "boolean") {
                            coerced13 = "" + data16;
                          } else if (data16 === null) {
                            coerced13 = "";
                          } else {
                            validate10.errors = [{ instancePath: instancePath + "/authority", schemaPath: "#/properties/authority/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                        }
                        if (coerced13 !== undefined) {
                          data16 = coerced13;
                          if (data3 !== undefined) {
                            data3["authority"] = coerced13;
                          }
                        }
                      }
                      var valid1 = _errs54 === errors4;
                    } else {
                      var valid1 = true;
                    }
                    if (valid1) {
                      if (data3.remoteAddress !== undefined) {
                        let data17 = data3.remoteAddress;
                        const _errs56 = errors4;
                        if (typeof data17 !== "string") {
                          let dataType14 = typeof data17;
                          let coerced14 = undefined;
                          if (!(coerced14 !== undefined)) {
                            if (dataType14 == "number" || dataType14 == "boolean") {
                              coerced14 = "" + data17;
                            } else if (data17 === null) {
                              coerced14 = "";
                            } else {
                              validate10.errors = [{ instancePath: instancePath + "/remoteAddress", schemaPath: "#/properties/remoteAddress/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                          }
                          if (coerced14 !== undefined) {
                            data17 = coerced14;
                            if (data3 !== undefined) {
                              data3["remoteAddress"] = coerced14;
                            }
                          }
                        }
                        var valid1 = _errs56 === errors4;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data3.method !== undefined) {
                          let data18 = data3.method;
                          const _errs58 = errors4;
                          if (typeof data18 !== "string") {
                            let dataType15 = typeof data18;
                            let coerced15 = undefined;
                            if (!(coerced15 !== undefined)) {
                              if (dataType15 == "number" || dataType15 == "boolean") {
                                coerced15 = "" + data18;
                              } else if (data18 === null) {
                                coerced15 = "";
                              } else {
                                validate10.errors = [{ instancePath: instancePath + "/method", schemaPath: "#/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                return false;
                              }
                            }
                            if (coerced15 !== undefined) {
                              data18 = coerced15;
                              if (data3 !== undefined) {
                                data3["method"] = coerced15;
                              }
                            }
                          }
                          if (!(data18 === "ACL" || data18 === "BIND" || data18 === "CHECKOUT" || data18 === "CONNECT" || data18 === "COPY" || data18 === "DELETE" || data18 === "GET" || data18 === "HEAD" || data18 === "LINK" || data18 === "LOCK" || data18 === "M-SEARCH" || data18 === "MERGE" || data18 === "MKACTIVITY" || data18 === "MKCALENDAR" || data18 === "MKCOL" || data18 === "MOVE" || data18 === "NOTIFY" || data18 === "OPTIONS" || data18 === "PATCH" || data18 === "POST" || data18 === "PROPFIND" || data18 === "PROPPATCH" || data18 === "PURGE" || data18 === "PUT" || data18 === "REBIND" || data18 === "REPORT" || data18 === "SEARCH" || data18 === "SOURCE" || data18 === "SUBSCRIBE" || data18 === "TRACE" || data18 === "UNBIND" || data18 === "UNLINK" || data18 === "UNLOCK" || data18 === "UNSUBSCRIBE" || data18 === "acl" || data18 === "bind" || data18 === "checkout" || data18 === "connect" || data18 === "copy" || data18 === "delete" || data18 === "get" || data18 === "head" || data18 === "link" || data18 === "lock" || data18 === "m-search" || data18 === "merge" || data18 === "mkactivity" || data18 === "mkcalendar" || data18 === "mkcol" || data18 === "move" || data18 === "notify" || data18 === "options" || data18 === "patch" || data18 === "post" || data18 === "propfind" || data18 === "proppatch" || data18 === "purge" || data18 === "put" || data18 === "rebind" || data18 === "report" || data18 === "search" || data18 === "source" || data18 === "subscribe" || data18 === "trace" || data18 === "unbind" || data18 === "unlink" || data18 === "unlock" || data18 === "unsubscribe")) {
                            validate10.errors = [{ instancePath: instancePath + "/method", schemaPath: "#/properties/method/enum", keyword: "enum", params: { allowedValues: schema11.properties.method.enum }, message: "must be equal to one of the allowed values" }];
                            return false;
                          }
                          var valid1 = _errs58 === errors4;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data3.validate !== undefined) {
                            let data19 = data3.validate;
                            const _errs60 = errors4;
                            if (typeof data19 !== "boolean") {
                              let coerced16 = undefined;
                              if (!(coerced16 !== undefined)) {
                                if (data19 === "false" || data19 === 0 || data19 === null) {
                                  coerced16 = false;
                                } else if (data19 === "true" || data19 === 1) {
                                  coerced16 = true;
                                } else {
                                  validate10.errors = [{ instancePath: instancePath + "/validate", schemaPath: "#/properties/validate/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                  return false;
                                }
                              }
                              if (coerced16 !== undefined) {
                                data19 = coerced16;
                                if (data3 !== undefined) {
                                  data3["validate"] = coerced16;
                                }
                              }
                            }
                            var valid1 = _errs60 === errors4;
                          } else {
                            var valid1 = true;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        validate10.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
        return false;
      }
    }
    validate10.errors = vErrors;
    return errors4 === 0;
  };
  module.exports = validate10;
  module.exports.default = validate10;
  var schema11 = { type: "object", properties: { url: { oneOf: [{ type: "string" }, { type: "object", properties: { protocol: { type: "string" }, hostname: { type: "string" }, pathname: { type: "string" } }, additionalProperties: true, required: ["pathname"] }] }, path: { oneOf: [{ type: "string" }, { type: "object", properties: { protocol: { type: "string" }, hostname: { type: "string" }, pathname: { type: "string" } }, additionalProperties: true, required: ["pathname"] }] }, cookies: { type: "object", additionalProperties: true }, headers: { type: "object", additionalProperties: true }, query: { anyOf: [{ type: "object", additionalProperties: true }, { type: "string" }] }, simulate: { type: "object", properties: { end: { type: "boolean" }, split: { type: "boolean" }, error: { type: "boolean" }, close: { type: "boolean" } } }, authority: { type: "string" }, remoteAddress: { type: "string" }, method: { type: "string", enum: ["ACL", "BIND", "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LINK", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCALENDAR", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REBIND", "REPORT", "SEARCH", "SOURCE", "SUBSCRIBE", "TRACE", "UNBIND", "UNLINK", "UNLOCK", "UNSUBSCRIBE", "acl", "bind", "checkout", "connect", "copy", "delete", "get", "head", "link", "lock", "m-search", "merge", "mkactivity", "mkcalendar", "mkcol", "move", "notify", "options", "patch", "post", "propfind", "proppatch", "purge", "put", "rebind", "report", "search", "source", "subscribe", "trace", "unbind", "unlink", "unlock", "unsubscribe"] }, validate: { type: "boolean" } }, additionalProperties: true, oneOf: [{ required: ["url"] }, { required: ["path"] }] };
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fastify@4.26.0/node_modules/light-my-request/index.js
var require_light_my_request = __commonJS((exports, module) => {
  var inject = function(dispatchFunc, options, callback) {
    if (typeof callback === "undefined") {
      return new Chain(dispatchFunc, options);
    } else {
      return doInject(dispatchFunc, options, callback);
    }
  };
  var makeRequest = function(dispatchFunc, server, req, res) {
    req.once("error", function(err) {
      if (this.destroyed)
        res.destroy(err);
    });
    req.once("close", function() {
      if (this.destroyed && !this._error)
        res.destroy();
    });
    return req.prepare(() => dispatchFunc.call(server, req, res));
  };
  var doInject = function(dispatchFunc, options, callback) {
    options = typeof options === "string" ? { url: options } : options;
    if (options.validate !== false) {
      assert(typeof dispatchFunc === "function", "dispatchFunc should be a function");
      const isOptionValid = optsValidator(options);
      if (!isOptionValid) {
        throw new Error(optsValidator.errors.map((e) => e.message));
      }
    }
    const server = options.server || {};
    const RequestConstructor = options.Request ? Request2.CustomRequest : Request2;
    if (dispatchFunc.request && dispatchFunc.request.app === dispatchFunc) {
      Object.setPrototypeOf(Object.getPrototypeOf(dispatchFunc.request), RequestConstructor.prototype);
      Object.setPrototypeOf(Object.getPrototypeOf(dispatchFunc.response), Response2.prototype);
    }
    if (typeof callback === "function") {
      const req = new RequestConstructor(options);
      const res = new Response2(req, callback);
      return makeRequest(dispatchFunc, server, req, res);
    } else {
      return new Promise((resolve5, reject) => {
        const req = new RequestConstructor(options);
        const res = new Response2(req, resolve5, reject);
        makeRequest(dispatchFunc, server, req, res);
      });
    }
  };
  var Chain = function(dispatch, option) {
    if (typeof option === "string") {
      this.option = { url: option };
    } else {
      this.option = Object.assign({}, option);
    }
    this.dispatch = dispatch;
    this._hasInvoked = false;
    this._promise = null;
    if (this.option.autoStart !== false) {
      process.nextTick(() => {
        if (!this._hasInvoked) {
          this.end();
        }
      });
    }
  };
  var isInjection = function(obj) {
    return obj instanceof Request2 || obj instanceof Response2 || obj && obj.constructor && obj.constructor.name === "_CustomLMRRequest";
  };
  var assert = __require("node:assert");
  var Request2 = require_request2();
  var Response2 = require_response();
  var errorMessage = "The dispatch function has already been invoked";
  var optsValidator = require_config_validator();
  var httpMethods = [
    "delete",
    "get",
    "head",
    "options",
    "patch",
    "post",
    "put",
    "trace"
  ];
  httpMethods.forEach((method) => {
    Chain.prototype[method] = function(url) {
      if (this._hasInvoked === true || this._promise) {
        throw new Error(errorMessage);
      }
      this.option.url = url;
      this.option.method = method.toUpperCase();
      return this;
    };
  });
  var chainMethods = [
    "body",
    "cookies",
    "headers",
    "payload",
    "query"
  ];
  chainMethods.forEach((method) => {
    Chain.prototype[method] = function(value) {
      if (this._hasInvoked === true || this._promise) {
        throw new Error(errorMessage);
      }
      this.option[method] = value;
      return this;
    };
  });
  Chain.prototype.end = function(callback) {
    if (this._hasInvoked === true || this._promise) {
      throw new Error(errorMessage);
    }
    this._hasInvoked = true;
    if (typeof callback === "function") {
      doInject(this.dispatch, this.option, callback);
    } else {
      this._promise = doInject(this.dispatch, this.option);
      return this._promise;
    }
  };
  Object.getOwnPropertyNames(Promise.prototype).forEach((method) => {
    if (method === "constructor")
      return;
    Chain.prototype[method] = function(...args) {
      if (!this._promise) {
        if (this._hasInvoked === true) {
          throw new Error(errorMessage);
        }
        this._hasInvoked = true;
        this._promise = doInject(this.dispatch, this.option);
      }
      return this._promise[method](...args);
    };
  });
  module.exports = inject;
  module.exports.default = inject;
  module.exports.inject = inject;
  module.exports.isInjection = isInjection;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fastq@1.17.1/node_modules/reusify/reusify.js
var require_reusify = __commonJS((exports, module) => {
  var reusify = function(Constructor) {
    var head = new Constructor;
    var tail = head;
    function get() {
      var current = head;
      if (current.next) {
        head = current.next;
      } else {
        head = new Constructor;
        tail = head;
      }
      current.next = null;
      return current;
    }
    function release(obj) {
      tail.next = obj;
      tail = obj;
    }
    return {
      get,
      release
    };
  };
  module.exports = reusify;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/avvio@8.3.0/node_modules/fastq/queue.js
var require_queue = __commonJS((exports, module) => {
  var fastqueue = function(context, worker, _concurrency) {
    if (typeof context === "function") {
      _concurrency = worker;
      worker = context;
      context = null;
    }
    if (!(_concurrency >= 1)) {
      throw new Error("fastqueue concurrency must be equal to or greater than 1");
    }
    var cache = reusify(Task);
    var queueHead = null;
    var queueTail = null;
    var _running = 0;
    var errorHandler = null;
    var self2 = {
      push,
      drain: noop,
      saturated: noop,
      pause,
      paused: false,
      get concurrency() {
        return _concurrency;
      },
      set concurrency(value) {
        if (!(value >= 1)) {
          throw new Error("fastqueue concurrency must be equal to or greater than 1");
        }
        _concurrency = value;
        if (self2.paused)
          return;
        for (;queueHead && _running < _concurrency; ) {
          _running++;
          release();
        }
      },
      running,
      resume,
      idle,
      length,
      getQueue,
      unshift,
      empty: noop,
      kill,
      killAndDrain,
      error
    };
    return self2;
    function running() {
      return _running;
    }
    function pause() {
      self2.paused = true;
    }
    function length() {
      var current = queueHead;
      var counter = 0;
      while (current) {
        current = current.next;
        counter++;
      }
      return counter;
    }
    function getQueue() {
      var current = queueHead;
      var tasks = [];
      while (current) {
        tasks.push(current.value);
        current = current.next;
      }
      return tasks;
    }
    function resume() {
      if (!self2.paused)
        return;
      self2.paused = false;
      if (queueHead === null) {
        _running++;
        release();
        return;
      }
      for (;queueHead && _running < _concurrency; ) {
        _running++;
        release();
      }
    }
    function idle() {
      return _running === 0 && self2.length() === 0;
    }
    function push(value, done) {
      var current = cache.get();
      current.context = context;
      current.release = release;
      current.value = value;
      current.callback = done || noop;
      current.errorHandler = errorHandler;
      if (_running >= _concurrency || self2.paused) {
        if (queueTail) {
          queueTail.next = current;
          queueTail = current;
        } else {
          queueHead = current;
          queueTail = current;
          self2.saturated();
        }
      } else {
        _running++;
        worker.call(context, current.value, current.worked);
      }
    }
    function unshift(value, done) {
      var current = cache.get();
      current.context = context;
      current.release = release;
      current.value = value;
      current.callback = done || noop;
      current.errorHandler = errorHandler;
      if (_running >= _concurrency || self2.paused) {
        if (queueHead) {
          current.next = queueHead;
          queueHead = current;
        } else {
          queueHead = current;
          queueTail = current;
          self2.saturated();
        }
      } else {
        _running++;
        worker.call(context, current.value, current.worked);
      }
    }
    function release(holder) {
      if (holder) {
        cache.release(holder);
      }
      var next = queueHead;
      if (next && _running <= _concurrency) {
        if (!self2.paused) {
          if (queueTail === queueHead) {
            queueTail = null;
          }
          queueHead = next.next;
          next.next = null;
          worker.call(context, next.value, next.worked);
          if (queueTail === null) {
            self2.empty();
          }
        } else {
          _running--;
        }
      } else if (--_running === 0) {
        self2.drain();
      }
    }
    function kill() {
      queueHead = null;
      queueTail = null;
      self2.drain = noop;
    }
    function killAndDrain() {
      queueHead = null;
      queueTail = null;
      self2.drain();
      self2.drain = noop;
    }
    function error(handler) {
      errorHandler = handler;
    }
  };
  var noop = function() {
  };
  var Task = function() {
    this.value = null;
    this.callback = noop;
    this.next = null;
    this.release = noop;
    this.context = null;
    this.errorHandler = null;
    var self2 = this;
    this.worked = function worked(err, result) {
      var callback = self2.callback;
      var errorHandler = self2.errorHandler;
      var val = self2.value;
      self2.value = null;
      self2.callback = noop;
      if (self2.errorHandler) {
        errorHandler(err, val);
      }
      callback.call(self2.context, err, result);
      self2.release(self2);
    };
  };
  var queueAsPromised = function(context, worker, _concurrency) {
    if (typeof context === "function") {
      _concurrency = worker;
      worker = context;
      context = null;
    }
    function asyncWrapper(arg, cb) {
      worker.call(this, arg).then(function(res) {
        cb(null, res);
      }, cb);
    }
    var queue = fastqueue(context, asyncWrapper, _concurrency);
    var pushCb = queue.push;
    var unshiftCb = queue.unshift;
    queue.push = push;
    queue.unshift = unshift;
    queue.drained = drained;
    return queue;
    function push(value) {
      var p = new Promise(function(resolve5, reject) {
        pushCb(value, function(err, result) {
          if (err) {
            reject(err);
            return;
          }
          resolve5(result);
        });
      });
      p.catch(noop);
      return p;
    }
    function unshift(value) {
      var p = new Promise(function(resolve5, reject) {
        unshiftCb(value, function(err, result) {
          if (err) {
            reject(err);
            return;
          }
          resolve5(result);
        });
      });
      p.catch(noop);
      return p;
    }
    function drained() {
      if (queue.idle()) {
        return new Promise(function(resolve5) {
          resolve5();
        });
      }
      var previousDrain = queue.drain;
      var p = new Promise(function(resolve5) {
        queue.drain = function() {
          previousDrain();
          resolve5();
        };
      });
      return p;
    }
  };
  var reusify = require_reusify();
  module.exports = fastqueue;
  module.exports.promise = queueAsPromised;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fastify@4.26.0/node_modules/@fastify/error/index.js
var require_error2 = __commonJS((exports, module) => {
  var toString = function() {
    return `${this.name} [${this.code}]: ${this.message}`;
  };
  var createError = function(code, message, statusCode = 500, Base = Error) {
    if (!code)
      throw new Error("Fastify error code must not be empty");
    if (!message)
      throw new Error("Fastify error message must not be empty");
    code = code.toUpperCase();
    !statusCode && (statusCode = undefined);
    function FastifyError(...args) {
      if (!new.target) {
        return new FastifyError(...args);
      }
      this.code = code;
      this.name = "FastifyError";
      this.statusCode = statusCode;
      const lastElement = args.length - 1;
      if (lastElement !== -1 && args[lastElement] && typeof args[lastElement] === "object" && "cause" in args[lastElement]) {
        this.cause = args.pop().cause;
      }
      this.message = format3(message, ...args);
      Error.stackTraceLimit !== 0 && Error.captureStackTrace(this, FastifyError);
    }
    FastifyError.prototype = Object.create(Base.prototype, {
      constructor: {
        value: FastifyError,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    FastifyError.prototype[Symbol.toStringTag] = "Error";
    FastifyError.prototype.toString = toString;
    return FastifyError;
  };
  var { format: format3 } = __require("node:util");
  module.exports = createError;
  module.exports.default = createError;
  module.exports.createError = createError;
});

// ../node_modules/.pnpm/avvio@8.3.0/node_modules/avvio/lib/errors.js
var require_errors3 = __commonJS((exports, module) => {
  var { createError } = require_error2();
  module.exports = {
    AVV_ERR_EXPOSE_ALREADY_DEFINED: createError("AVV_ERR_EXPOSE_ALREADY_DEFINED", "'%s' is already defined, specify an expose option for '%s'"),
    AVV_ERR_ATTRIBUTE_ALREADY_DEFINED: createError("AVV_ERR_ATTRIBUTE_ALREADY_DEFINED", "'%s' is already defined"),
    AVV_ERR_CALLBACK_NOT_FN: createError("AVV_ERR_CALLBACK_NOT_FN", "Callback for '%s' hook is not a function. Received: '%s'"),
    AVV_ERR_PLUGIN_NOT_VALID: createError("AVV_ERR_PLUGIN_NOT_VALID", "Plugin must be a function or a promise. Received: '%s'"),
    AVV_ERR_ROOT_PLG_BOOTED: createError("AVV_ERR_ROOT_PLG_BOOTED", "Root plugin has already booted"),
    AVV_ERR_PARENT_PLG_LOADED: createError("AVV_ERR_PARENT_PLG_LOADED", "Impossible to load '%s' plugin because the parent '%s' was already loaded"),
    AVV_ERR_READY_TIMEOUT: createError("AVV_ERR_READY_TIMEOUT", "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"),
    AVV_ERR_PLUGIN_EXEC_TIMEOUT: createError("AVV_ERR_PLUGIN_EXEC_TIMEOUT", "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise")
  };
});

// ../node_modules/.pnpm/avvio@8.3.0/node_modules/avvio/lib/symbols.js
var require_symbols2 = __commonJS((exports, module) => {
  var kAvvio = Symbol("avvio.Boot");
  var kIsOnCloseHandler = Symbol("isOnCloseHandler");
  var kThenifyDoNotWrap = Symbol("avvio.ThenifyDoNotWrap");
  var kUntrackNode = Symbol("avvio.TimeTree.untrackNode");
  var kTrackNode = Symbol("avvio.TimeTree.trackNode");
  var kGetParent = Symbol("avvio.TimeTree.getParent");
  var kGetNode = Symbol("avvio.TimeTree.getNode");
  var kAddNode = Symbol("avvio.TimeTree.addNode");
  var kPluginMeta = Symbol.for("plugin-meta");
  module.exports = {
    kAvvio,
    kIsOnCloseHandler,
    kThenifyDoNotWrap,
    kUntrackNode,
    kTrackNode,
    kGetParent,
    kGetNode,
    kAddNode,
    kPluginMeta
  };
});

// ../node_modules/.pnpm/avvio@8.3.0/node_modules/avvio/lib/time-tree.js
var require_time_tree = __commonJS((exports, module) => {
  var prettyPrintTimeTree = function(obj, prefix = "") {
    let result = prefix;
    const nodesCount = obj.nodes.length;
    const lastIndex = nodesCount - 1;
    result += `${obj.label} ${obj.diff} ms\n`;
    for (let i = 0;i < nodesCount; ++i) {
      const node9 = obj.nodes[i];
      const prefix_ = prefix + (i === lastIndex ? "  " : "\u2502 ");
      result += prefix;
      result += i === lastIndex ? "\u2514\u2500" : "\u251C\u2500";
      result += node9.nodes.length === 0 ? "\u2500 " : "\u252C ";
      result += prettyPrintTimeTree(node9, prefix_).slice(prefix.length + 2);
    }
    return result;
  };
  var {
    kUntrackNode,
    kTrackNode,
    kGetParent,
    kGetNode,
    kAddNode
  } = require_symbols2();

  class TimeTree {
    constructor() {
      this.root = null;
      this.tableId = new Map;
      this.tableLabel = new Map;
    }
    [kTrackNode](node9) {
      this.tableId.set(node9.id, node9);
      if (this.tableLabel.has(node9.label)) {
        this.tableLabel.get(node9.label).push(node9);
      } else {
        this.tableLabel.set(node9.label, [node9]);
      }
    }
    [kUntrackNode](node9) {
      this.tableId.delete(node9.id);
      const labelNode = this.tableLabel.get(node9.label);
      labelNode.pop();
      if (labelNode.length === 0) {
        this.tableLabel.delete(node9.label);
      }
    }
    [kGetParent](parent) {
      if (parent === null) {
        return null;
      } else if (this.tableLabel.has(parent)) {
        const parentNode = this.tableLabel.get(parent);
        return parentNode[parentNode.length - 1];
      } else {
        return null;
      }
    }
    [kGetNode](nodeId) {
      return this.tableId.get(nodeId);
    }
    [kAddNode](parent, label, start) {
      const parentNode = this[kGetParent](parent);
      const isRoot = parentNode === null;
      if (isRoot) {
        this.root = {
          parent: null,
          id: "root",
          label,
          nodes: [],
          start,
          stop: null,
          diff: -1
        };
        this[kTrackNode](this.root);
        return this.root.id;
      }
      const nodeId = `${label}-${Math.random()}`;
      const childNode = {
        parent,
        id: nodeId,
        label,
        nodes: [],
        start,
        stop: null,
        diff: -1
      };
      parentNode.nodes.push(childNode);
      this[kTrackNode](childNode);
      return nodeId;
    }
    start(parent, label, start = Date.now()) {
      return this[kAddNode](parent, label, start);
    }
    stop(nodeId, stop = Date.now()) {
      const node9 = this[kGetNode](nodeId);
      if (node9) {
        node9.stop = stop;
        node9.diff = node9.stop - node9.start || 0;
        this[kUntrackNode](node9);
      }
    }
    toJSON() {
      return Object.assign({}, this.root);
    }
    prettyPrint() {
      return prettyPrintTimeTree(this.toJSON());
    }
  }
  module.exports = {
    TimeTree
  };
});

// ../node_modules/.pnpm/avvio@8.3.0/node_modules/avvio/lib/debug.js
var require_debug = __commonJS((exports, module) => {
  var { debuglog } = __require("node:util");
  var debug = debuglog("avvio");
  module.exports = {
    debug
  };
});

// ../node_modules/.pnpm/avvio@8.3.0/node_modules/avvio/lib/create-promise.js
var require_create_promise = __commonJS((exports, module) => {
  var createPromise = function() {
    const obj = {
      resolve: null,
      reject: null,
      promise: null
    };
    obj.promise = new Promise((resolve5, reject) => {
      obj.resolve = resolve5;
      obj.reject = reject;
    });
    return obj;
  };
  module.exports = {
    createPromise
  };
});

// ../node_modules/.pnpm/avvio@8.3.0/node_modules/avvio/lib/get-plugin-name.js
var require_get_plugin_name = __commonJS((exports, module) => {
  var getPluginName = function(plugin, options) {
    if (plugin[kPluginMeta] && plugin[kPluginMeta].name) {
      return plugin[kPluginMeta].name;
    }
    if (options && options.name) {
      return options.name;
    }
    if (plugin.name) {
      return plugin.name;
    } else {
      return plugin.toString().split("\n").slice(0, 2).map((s) => s.trim()).join(" -- ");
    }
  };
  var { kPluginMeta } = require_symbols2();
  module.exports = {
    getPluginName
  };
});

// ../node_modules/.pnpm/avvio@8.3.0/node_modules/avvio/lib/is-promise-like.js
var require_is_promise_like = __commonJS((exports, module) => {
  var isPromiseLike = function(maybePromiseLike) {
    return maybePromiseLike !== null && typeof maybePromiseLike === "object" && typeof maybePromiseLike.then === "function";
  };
  module.exports = {
    isPromiseLike
  };
});

// ../node_modules/.pnpm/avvio@8.3.0/node_modules/avvio/lib/plugin.js
var require_plugin = __commonJS((exports, module) => {
  var Plugin = function(queue, func, options, isAfter, timeout) {
    this.queue = queue;
    this.func = func;
    this.options = options;
    this.isAfter = isAfter;
    this.timeout = timeout;
    this.started = false;
    this.name = getPluginName(func, options);
    this.queue.pause();
    this._error = null;
    this.loaded = false;
    this._promise = null;
  };
  var noop = function() {
  };
  var { EventEmitter } = __require("node:events");
  var { inherits } = __require("node:util");
  var { debug } = require_debug();
  var { createPromise } = require_create_promise();
  var { AVV_ERR_PLUGIN_EXEC_TIMEOUT } = require_errors3();
  var { getPluginName } = require_get_plugin_name();
  var { isPromiseLike } = require_is_promise_like();
  inherits(Plugin, EventEmitter);
  Plugin.prototype.exec = function(server, callback) {
    debug("exec", this.name);
    this.server = server;
    const func = this.func;
    const name = this.name;
    let completed = false;
    this.options = typeof this.options === "function" ? this.options(this.server) : this.options;
    let timer = null;
    const done = (execErr) => {
      if (completed) {
        debug("loading complete", name);
        return;
      }
      this._error = execErr;
      if (execErr) {
        debug("exec errored", name);
      } else {
        debug("exec completed", name);
      }
      completed = true;
      if (timer) {
        clearTimeout(timer);
      }
      callback(execErr);
    };
    if (this.timeout > 0) {
      debug("setting up timeout", name, this.timeout);
      timer = setTimeout(function() {
        debug("timed out", name);
        timer = null;
        const readyTimeoutErr = new AVV_ERR_PLUGIN_EXEC_TIMEOUT(name);
        readyTimeoutErr.fn = func;
        done(readyTimeoutErr);
      }, this.timeout);
    }
    this.started = true;
    this.emit("start", this.server ? this.server.name : null, this.name, Date.now());
    const maybePromiseLike = func(this.server, this.options, done);
    if (isPromiseLike(maybePromiseLike)) {
      debug("exec: resolving promise", name);
      maybePromiseLike.then(() => process.nextTick(done), (e) => process.nextTick(done, e));
    }
  };
  Plugin.prototype.loadedSoFar = function() {
    debug("loadedSoFar", this.name);
    if (this.loaded) {
      return Promise.resolve();
    }
    const setup = () => {
      this.server.after((afterErr, callback) => {
        this._error = afterErr;
        this.queue.pause();
        if (afterErr) {
          debug("rejecting promise", this.name, afterErr);
          this._promise.reject(afterErr);
        } else {
          debug("resolving promise", this.name);
          this._promise.resolve();
        }
        this._promise = null;
        process.nextTick(callback, afterErr);
      });
      this.queue.resume();
    };
    let res;
    if (!this._promise) {
      this._promise = createPromise();
      res = this._promise.promise;
      if (!this.server) {
        this.on("start", setup);
      } else {
        setup();
      }
    } else {
      res = Promise.resolve();
    }
    return res;
  };
  Plugin.prototype.enqueue = function(plugin, callback) {
    debug("enqueue", this.name, plugin.name);
    this.emit("enqueue", this.server ? this.server.name : null, this.name, Date.now());
    this.queue.push(plugin, callback);
  };
  Plugin.prototype.finish = function(err, callback) {
    debug("finish", this.name, err);
    const done = () => {
      if (this.loaded) {
        return;
      }
      debug("loaded", this.name);
      this.emit("loaded", this.server ? this.server.name : null, this.name, Date.now());
      this.loaded = true;
      callback(err);
    };
    if (err) {
      if (this._promise) {
        this._promise.reject(err);
        this._promise = null;
      }
      done();
      return;
    }
    const check = () => {
      debug("check", this.name, this.queue.length(), this.queue.running(), this._promise);
      if (this.queue.length() === 0 && this.queue.running() === 0) {
        if (this._promise) {
          const wrap2 = () => {
            debug("wrap");
            queueMicrotask(check);
          };
          this._promise.resolve();
          this._promise.promise.then(wrap2, wrap2);
          this._promise = null;
        } else {
          done();
        }
      } else {
        debug("delayed", this.name);
        this.queue.drain = () => {
          debug("drain", this.name);
          this.queue.drain = noop;
          queueMicrotask(check);
        };
      }
    };
    queueMicrotask(check);
    this.queue.resume();
  };
  module.exports = {
    Plugin
  };
});

// ../node_modules/.pnpm/avvio@8.3.0/node_modules/avvio/lib/validate-plugin.js
var require_validate_plugin = __commonJS((exports, module) => {
  var validatePlugin = function(maybePlugin) {
    if (!(maybePlugin && (typeof maybePlugin === "function" || typeof maybePlugin.then === "function"))) {
      if (Array.isArray(maybePlugin)) {
        throw new AVV_ERR_PLUGIN_NOT_VALID("array");
      } else if (maybePlugin === null) {
        throw new AVV_ERR_PLUGIN_NOT_VALID("null");
      } else {
        throw new AVV_ERR_PLUGIN_NOT_VALID(typeof maybePlugin);
      }
    }
  };
  var { AVV_ERR_PLUGIN_NOT_VALID } = require_errors3();
  module.exports = {
    validatePlugin
  };
});

// ../node_modules/.pnpm/avvio@8.3.0/node_modules/avvio/lib/is-bundled-or-typescript-plugin.js
var require_is_bundled_or_typescript_plugin = __commonJS((exports, module) => {
  var isBundledOrTypescriptPlugin = function(maybeBundledOrTypescriptPlugin) {
    return maybeBundledOrTypescriptPlugin !== null && typeof maybeBundledOrTypescriptPlugin === "object" && typeof maybeBundledOrTypescriptPlugin.default === "function";
  };
  module.exports = {
    isBundledOrTypescriptPlugin
  };
});

// ../node_modules/.pnpm/avvio@8.3.0/node_modules/avvio/lib/thenify.js
var require_thenify = __commonJS((exports, module) => {
  var thenify = function() {
    if (this.booted) {
      debug("thenify returning undefined because we are already booted");
      return;
    }
    if (this[kThenifyDoNotWrap]) {
      this[kThenifyDoNotWrap] = false;
      return;
    }
    debug("thenify");
    return (resolve5, reject) => {
      const p = this._loadRegistered();
      return p.then(() => {
        this[kThenifyDoNotWrap] = true;
        return resolve5(this._server);
      }, reject);
    };
  };
  var { debug } = require_debug();
  var { kThenifyDoNotWrap } = require_symbols2();
  module.exports = {
    thenify
  };
});

// ../node_modules/.pnpm/avvio@8.3.0/node_modules/avvio/lib/execute-with-thenable.js
var require_execute_with_thenable = __commonJS((exports, module) => {
  var executeWithThenable = function(func, args, callback) {
    const result = func.apply(func, args);
    if (isPromiseLike(result) && !result[kAvvio]) {
      result.then(() => process.nextTick(callback), (error) => process.nextTick(callback, error));
    } else if (callback) {
      process.nextTick(callback);
    }
  };
  var { isPromiseLike } = require_is_promise_like();
  var { kAvvio } = require_symbols2();
  module.exports = {
    executeWithThenable
  };
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fastify@4.26.0/node_modules/avvio/boot.js
var require_boot = __commonJS((exports, module) => {
  var Boot = function(server, opts, done) {
    if (typeof server === "function" && arguments.length === 1) {
      done = server;
      opts = {};
      server = null;
    }
    if (typeof opts === "function") {
      done = opts;
      opts = {};
    }
    opts = opts || {};
    opts.autostart = opts.autostart !== false;
    opts.timeout = Number(opts.timeout) || 0;
    opts.expose = opts.expose || {};
    if (!new.target) {
      return new Boot(server, opts, done);
    }
    this._server = server || this;
    this._opts = opts;
    if (server) {
      this._expose();
    }
    this._current = [];
    this._error = null;
    this._lastUsed = null;
    this.setMaxListeners(0);
    if (done) {
      this.once("start", done);
    }
    this.started = false;
    this.booted = false;
    this.pluginTree = new TimeTree;
    this._readyQ = fastq(this, callWithCbOrNextTick, 1);
    this._readyQ.pause();
    this._readyQ.drain = () => {
      this.emit("start");
      this._readyQ.drain = noop;
    };
    this._closeQ = fastq(this, closeWithCbOrNextTick, 1);
    this._closeQ.pause();
    this._closeQ.drain = () => {
      this.emit("close");
      this._closeQ.drain = noop;
    };
    this._doStart = null;
    const instance = this;
    this._root = new Plugin(fastq(this, this._loadPluginNextTick, 1), function root(server2, opts2, done2) {
      instance._doStart = done2;
      opts2.autostart && instance.start();
    }, opts, false, 0);
    this._trackPluginLoading(this._root);
    this._loadPlugin(this._root, (err) => {
      debug("root plugin ready");
      try {
        this.emit("preReady");
        this._root = null;
      } catch (preReadyError) {
        err = err || this._error || preReadyError;
      }
      if (err) {
        this._error = err;
        if (this._readyQ.length() === 0) {
          throw err;
        }
      } else {
        this.booted = true;
      }
      this._readyQ.resume();
    });
  };
  var noop = function() {
  };
  var callWithCbOrNextTick = function(func, cb) {
    const context = this._server;
    const err = this._error;
    this._error = null;
    if (func.length === 0) {
      this._error = err;
      executeWithThenable(func, [], cb);
    } else if (func.length === 1) {
      executeWithThenable(func, [err], cb);
    } else {
      if (this._opts.timeout === 0) {
        const wrapCb = (err2) => {
          this._error = err2;
          cb(this._error);
        };
        if (func.length === 2) {
          func(err, wrapCb);
        } else {
          func(err, context, wrapCb);
        }
      } else {
        timeoutCall.call(this, func, err, context, cb);
      }
    }
  };
  var timeoutCall = function(func, rootErr, context, cb) {
    const name = func.name;
    debug("setting up ready timeout", name, this._opts.timeout);
    let timer = setTimeout(() => {
      debug("timed out", name);
      timer = null;
      const toutErr = new AVV_ERR_READY_TIMEOUT(name);
      toutErr.fn = func;
      this._error = toutErr;
      cb(toutErr);
    }, this._opts.timeout);
    if (func.length === 2) {
      func(rootErr, timeoutCb.bind(this));
    } else {
      func(rootErr, context, timeoutCb.bind(this));
    }
    function timeoutCb(err) {
      if (timer) {
        clearTimeout(timer);
        this._error = err;
        cb(this._error);
      } else {
      }
    }
  };
  var closeWithCbOrNextTick = function(func, cb) {
    const context = this._server;
    const isOnCloseHandler = func[kIsOnCloseHandler];
    if (func.length === 0 || func.length === 1) {
      let promise;
      if (isOnCloseHandler) {
        promise = func(context);
      } else {
        promise = func(this._error);
      }
      if (promise && typeof promise.then === "function") {
        debug("resolving close/onClose promise");
        promise.then(() => process.nextTick(cb), (e) => process.nextTick(cb, e));
      } else {
        process.nextTick(cb);
      }
    } else if (func.length === 2) {
      if (isOnCloseHandler) {
        func(context, cb);
      } else {
        func(this._error, cb);
      }
    } else {
      if (isOnCloseHandler) {
        func(context, cb);
      } else {
        func(this._error, context, cb);
      }
    }
  };
  var encapsulateTwoParam = function(func, that) {
    return _encapsulateTwoParam.bind(that);
    function _encapsulateTwoParam(context, cb) {
      let res;
      if (func.length === 0) {
        res = func();
        if (res && res.then) {
          res.then(function() {
            process.nextTick(cb);
          }, cb);
        } else {
          process.nextTick(cb);
        }
      } else if (func.length === 1) {
        res = func(this);
        if (res && res.then) {
          res.then(function() {
            process.nextTick(cb);
          }, cb);
        } else {
          process.nextTick(cb);
        }
      } else {
        func(this, cb);
      }
    }
  };
  var encapsulateThreeParam = function(func, that) {
    return _encapsulateThreeParam.bind(that);
    function _encapsulateThreeParam(err, cb) {
      let res;
      if (!func) {
        process.nextTick(cb);
      } else if (func.length === 0) {
        res = func();
        if (res && res.then) {
          res.then(function() {
            process.nextTick(cb, err);
          }, cb);
        } else {
          process.nextTick(cb, err);
        }
      } else if (func.length === 1) {
        res = func(err);
        if (res && res.then) {
          res.then(function() {
            process.nextTick(cb);
          }, cb);
        } else {
          process.nextTick(cb);
        }
      } else if (func.length === 2) {
        func(err, cb);
      } else {
        func(err, this, cb);
      }
    }
  };
  var fastq = require_queue();
  var EE = __require("node:events").EventEmitter;
  var inherits = __require("node:util").inherits;
  var {
    AVV_ERR_EXPOSE_ALREADY_DEFINED,
    AVV_ERR_CALLBACK_NOT_FN,
    AVV_ERR_ROOT_PLG_BOOTED,
    AVV_ERR_READY_TIMEOUT,
    AVV_ERR_ATTRIBUTE_ALREADY_DEFINED
  } = require_errors3();
  var {
    kAvvio,
    kIsOnCloseHandler
  } = require_symbols2();
  var { TimeTree } = require_time_tree();
  var { Plugin } = require_plugin();
  var { debug } = require_debug();
  var { validatePlugin } = require_validate_plugin();
  var { isBundledOrTypescriptPlugin } = require_is_bundled_or_typescript_plugin();
  var { isPromiseLike } = require_is_promise_like();
  var { thenify } = require_thenify();
  var { executeWithThenable } = require_execute_with_thenable();
  inherits(Boot, EE);
  Boot.prototype.start = function() {
    this.started = true;
    process.nextTick(this._doStart);
    return this;
  };
  Boot.prototype.override = function(server, func, opts) {
    return server;
  };
  Boot.prototype[kAvvio] = true;
  Boot.prototype.use = function(plugin, opts) {
    this._lastUsed = this._addPlugin(plugin, opts, false);
    return this;
  };
  Boot.prototype._loadRegistered = function() {
    const plugin = this._current[0];
    const weNeedToStart = !this.started && !this.booted;
    if (weNeedToStart) {
      process.nextTick(() => this._root.queue.resume());
    }
    if (!plugin) {
      return Promise.resolve();
    }
    return plugin.loadedSoFar();
  };
  Object.defineProperty(Boot.prototype, "then", { get: thenify });
  Boot.prototype._addPlugin = function(pluginFn, opts, isAfter) {
    if (isBundledOrTypescriptPlugin(pluginFn)) {
      pluginFn = pluginFn.default;
    }
    validatePlugin(pluginFn);
    opts = opts || {};
    if (this.booted) {
      throw new AVV_ERR_ROOT_PLG_BOOTED;
    }
    const current = this._current[0];
    const plugin = new Plugin(fastq(this, this._loadPluginNextTick, 1), pluginFn, opts, isAfter, this._opts.timeout);
    this._trackPluginLoading(plugin);
    if (current.loaded) {
      throw new Error(plugin.name, current.name);
    }
    current.enqueue(plugin, (err) => {
      err && (this._error = err);
    });
    return plugin;
  };
  Boot.prototype._expose = function _expose() {
    const instance = this;
    const server = instance._server;
    const {
      use: useKey = "use",
      after: afterKey = "after",
      ready: readyKey = "ready",
      onClose: onCloseKey = "onClose",
      close: closeKey = "close"
    } = this._opts.expose;
    if (server[useKey]) {
      throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(useKey, "use");
    }
    server[useKey] = function(fn, opts) {
      instance.use(fn, opts);
      return this;
    };
    if (server[afterKey]) {
      throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(afterKey, "after");
    }
    server[afterKey] = function(func) {
      if (typeof func !== "function") {
        return instance._loadRegistered();
      }
      instance.after(encapsulateThreeParam(func, this));
      return this;
    };
    if (server[readyKey]) {
      throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(readyKey, "ready");
    }
    server[readyKey] = function(func) {
      if (func && typeof func !== "function") {
        throw new AVV_ERR_CALLBACK_NOT_FN(readyKey, typeof func);
      }
      return instance.ready(func ? encapsulateThreeParam(func, this) : undefined);
    };
    if (server[onCloseKey]) {
      throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(onCloseKey, "onClose");
    }
    server[onCloseKey] = function(func) {
      if (typeof func !== "function") {
        throw new AVV_ERR_CALLBACK_NOT_FN(onCloseKey, typeof func);
      }
      instance.onClose(encapsulateTwoParam(func, this));
      return this;
    };
    if (server[closeKey]) {
      throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(closeKey, "close");
    }
    server[closeKey] = function(func) {
      if (func && typeof func !== "function") {
        throw new AVV_ERR_CALLBACK_NOT_FN(closeKey, typeof func);
      }
      if (func) {
        instance.close(encapsulateThreeParam(func, this));
        return this;
      }
      return instance.close();
    };
    if (server.then) {
      throw new AVV_ERR_ATTRIBUTE_ALREADY_DEFINED("then");
    }
    Object.defineProperty(server, "then", { get: thenify.bind(instance) });
    server[kAvvio] = true;
  };
  Boot.prototype.after = function(func) {
    if (!func) {
      return this._loadRegistered();
    }
    this._addPlugin(_after.bind(this), {}, true);
    function _after(s, opts, done) {
      callWithCbOrNextTick.call(this, func, done);
    }
    return this;
  };
  Boot.prototype.onClose = function(func) {
    if (typeof func !== "function") {
      throw new AVV_ERR_CALLBACK_NOT_FN("onClose", typeof func);
    }
    func[kIsOnCloseHandler] = true;
    this._closeQ.unshift(func, (err) => {
      err && (this._error = err);
    });
    return this;
  };
  Boot.prototype.close = function(func) {
    let promise;
    if (func) {
      if (typeof func !== "function") {
        throw new AVV_ERR_CALLBACK_NOT_FN("close", typeof func);
      }
    } else {
      promise = new Promise(function(resolve5, reject) {
        func = function(err) {
          if (err) {
            return reject(err);
          }
          resolve5();
        };
      });
    }
    this.ready(() => {
      this._error = null;
      this._closeQ.push(func);
      process.nextTick(this._closeQ.resume.bind(this._closeQ));
    });
    return promise;
  };
  Boot.prototype.ready = function(func) {
    if (func) {
      if (typeof func !== "function") {
        throw new AVV_ERR_CALLBACK_NOT_FN("ready", typeof func);
      }
      this._readyQ.push(func);
      queueMicrotask(this.start.bind(this));
      return;
    }
    return new Promise((resolve5, reject) => {
      this._readyQ.push(readyPromiseCB);
      this.start();
      const relativeContext = this._current[0].server;
      function readyPromiseCB(err, context, done) {
        if (err) {
          reject(err);
        } else {
          resolve5(relativeContext);
        }
        process.nextTick(done);
      }
    });
  };
  Boot.prototype._trackPluginLoading = function(plugin) {
    const parentName = this._current[0]?.name || null;
    plugin.once("start", (serverName, funcName, time) => {
      const nodeId = this.pluginTree.start(parentName || null, funcName, time);
      plugin.once("loaded", (serverName2, funcName2, time2) => {
        this.pluginTree.stop(nodeId, time2);
      });
    });
  };
  Boot.prototype.prettyPrint = function() {
    return this.pluginTree.prettyPrint();
  };
  Boot.prototype.toJSON = function() {
    return this.pluginTree.toJSON();
  };
  Boot.prototype._loadPlugin = function(plugin, callback) {
    const instance = this;
    if (isPromiseLike(plugin.func)) {
      plugin.func.then((fn) => {
        if (typeof fn.default === "function") {
          fn = fn.default;
        }
        plugin.func = fn;
        this._loadPlugin(plugin, callback);
      }, callback);
      return;
    }
    const last = instance._current[0];
    instance._current.unshift(plugin);
    if (instance._error && !plugin.isAfter) {
      debug("skipping loading of plugin as instance errored and it is not an after", plugin.name);
      process.nextTick(execCallback);
      return;
    }
    let server = last && last.server || instance._server;
    if (!plugin.isAfter) {
      try {
        server = instance.override(server, plugin.func, plugin.options);
      } catch (overrideErr) {
        debug("override errored", plugin.name);
        return execCallback(overrideErr);
      }
    }
    plugin.exec(server, execCallback);
    function execCallback(err) {
      plugin.finish(err, (err2) => {
        instance._current.shift();
        callback(err2);
      });
    }
  };
  Boot.prototype._loadPluginNextTick = function(plugin, callback) {
    process.nextTick(this._loadPlugin.bind(this), plugin, callback);
  };
  module.exports = Boot;
  module.exports.express = function(app) {
    return Boot(app, {
      expose: {
        use: "load"
      }
    });
  };
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/symbols.js
var require_symbols3 = __commonJS((exports, module) => {
  var keys = {
    kAvvioBoot: Symbol("fastify.avvioBoot"),
    kChildren: Symbol("fastify.children"),
    kServerBindings: Symbol("fastify.serverBindings"),
    kBodyLimit: Symbol("fastify.bodyLimit"),
    kRoutePrefix: Symbol("fastify.routePrefix"),
    kLogLevel: Symbol("fastify.logLevel"),
    kLogSerializers: Symbol("fastify.logSerializers"),
    kHooks: Symbol("fastify.hooks"),
    kContentTypeParser: Symbol("fastify.contentTypeParser"),
    kState: Symbol("fastify.state"),
    kOptions: Symbol("fastify.options"),
    kDisableRequestLogging: Symbol("fastify.disableRequestLogging"),
    kPluginNameChain: Symbol("fastify.pluginNameChain"),
    kRouteContext: Symbol("fastify.context"),
    kPublicRouteContext: Symbol("fastify.routeOptions"),
    kGenReqId: Symbol("fastify.genReqId"),
    kSchemaController: Symbol("fastify.schemaController"),
    kSchemaHeaders: Symbol("headers-schema"),
    kSchemaParams: Symbol("params-schema"),
    kSchemaQuerystring: Symbol("querystring-schema"),
    kSchemaBody: Symbol("body-schema"),
    kSchemaResponse: Symbol("response-schema"),
    kSchemaErrorFormatter: Symbol("fastify.schemaErrorFormatter"),
    kSchemaVisited: Symbol("fastify.schemas.visited"),
    kRequest: Symbol("fastify.Request"),
    kRequestPayloadStream: Symbol("fastify.RequestPayloadStream"),
    kRequestAcceptVersion: Symbol("fastify.RequestAcceptVersion"),
    kRequestCacheValidateFns: Symbol("fastify.request.cache.validateFns"),
    kRequestOriginalUrl: Symbol("fastify.request.originalUrl"),
    kFourOhFour: Symbol("fastify.404"),
    kCanSetNotFoundHandler: Symbol("fastify.canSetNotFoundHandler"),
    kFourOhFourLevelInstance: Symbol("fastify.404LogLevelInstance"),
    kFourOhFourContext: Symbol("fastify.404ContextKey"),
    kDefaultJsonParse: Symbol("fastify.defaultJSONParse"),
    kReply: Symbol("fastify.Reply"),
    kReplySerializer: Symbol("fastify.reply.serializer"),
    kReplyIsError: Symbol("fastify.reply.isError"),
    kReplyHeaders: Symbol("fastify.reply.headers"),
    kReplyTrailers: Symbol("fastify.reply.trailers"),
    kReplyHasStatusCode: Symbol("fastify.reply.hasStatusCode"),
    kReplyHijacked: Symbol("fastify.reply.hijacked"),
    kReplyStartTime: Symbol("fastify.reply.startTime"),
    kReplyNextErrorHandler: Symbol("fastify.reply.nextErrorHandler"),
    kReplyEndTime: Symbol("fastify.reply.endTime"),
    kReplyErrorHandlerCalled: Symbol("fastify.reply.errorHandlerCalled"),
    kReplyIsRunningOnErrorHook: Symbol("fastify.reply.isRunningOnErrorHook"),
    kReplySerializerDefault: Symbol("fastify.replySerializerDefault"),
    kReplyCacheSerializeFns: Symbol("fastify.reply.cache.serializeFns"),
    kTestInternals: Symbol("fastify.testInternals"),
    kErrorHandler: Symbol("fastify.errorHandler"),
    kChildLoggerFactory: Symbol("fastify.childLoggerFactory"),
    kHasBeenDecorated: Symbol("fastify.hasBeenDecorated"),
    kKeepAliveConnections: Symbol("fastify.keepAliveConnections"),
    kRouteByFastify: Symbol("fastify.routeByFastify")
  };
  module.exports = keys;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fastify@4.26.0/node_modules/process-warning/index.js
var require_process_warning2 = __commonJS((exports, module) => {
  var createDeprecation = function(params) {
    return createWarning({ ...params, name: "DeprecationWarning" });
  };
  var createWarning = function({ name, code, message, unlimited = false } = {}) {
    if (!name)
      throw new Error("Warning name must not be empty");
    if (!code)
      throw new Error("Warning code must not be empty");
    if (!message)
      throw new Error("Warning message must not be empty");
    if (typeof unlimited !== "boolean")
      throw new Error("Warning opts.unlimited must be a boolean");
    code = code.toUpperCase();
    let warningContainer = {
      [name]: function(a, b, c) {
        if (warning.emitted === true && warning.unlimited !== true) {
          return;
        }
        warning.emitted = true;
        process.emitWarning(warning.format(a, b, c), warning.name, warning.code);
      }
    };
    if (unlimited) {
      warningContainer = {
        [name]: function(a, b, c) {
          warning.emitted = true;
          process.emitWarning(warning.format(a, b, c), warning.name, warning.code);
        }
      };
    }
    const warning = warningContainer[name];
    warning.emitted = false;
    warning.message = message;
    warning.unlimited = unlimited;
    warning.code = code;
    warning.format = function(a, b, c) {
      let formatted;
      if (a && b && c) {
        formatted = format3(message, a, b, c);
      } else if (a && b) {
        formatted = format3(message, a, b);
      } else if (a) {
        formatted = format3(message, a);
      } else {
        formatted = message;
      }
      return formatted;
    };
    return warning;
  };
  var { format: format3 } = __require("node:util");
  var out = { createWarning, createDeprecation };
  module.exports = out;
  module.exports.default = out;
  module.exports.processWarning = out;
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/warnings.js
var require_warnings = __commonJS((exports, module) => {
  var { createDeprecation, createWarning } = require_process_warning2();
  var FSTDEP005 = createDeprecation({
    code: "FSTDEP005",
    message: 'You are accessing the deprecated "request.connection" property. Use "request.socket" instead.'
  });
  var FSTDEP006 = createDeprecation({
    code: "FSTDEP006",
    message: "You are decorating Request/Reply with a reference type. This reference is shared amongst all requests. Use onRequest hook instead. Property: %s"
  });
  var FSTDEP007 = createDeprecation({
    code: "FSTDEP007",
    message: 'You are trying to set a HEAD route using "exposeHeadRoute" route flag when a sibling route is already set. See documentation for more info.'
  });
  var FSTDEP008 = createDeprecation({
    code: "FSTDEP008",
    message: 'You are using route constraints via the route { version: "..." } option, use { constraints: { version: "..." } } option instead.'
  });
  var FSTDEP009 = createDeprecation({
    code: "FSTDEP009",
    message: 'You are using a custom route versioning strategy via the server { versioning: "..." } option, use { constraints: { version: "..." } } option instead.'
  });
  var FSTDEP010 = createDeprecation({
    code: "FSTDEP010",
    message: 'Modifying the "reply.sent" property is deprecated. Use the "reply.hijack()" method instead.'
  });
  var FSTDEP011 = createDeprecation({
    code: "FSTDEP011",
    message: 'Variadic listen method is deprecated. Please use ".listen(optionsObject)" instead. The variadic signature will be removed in `fastify@5`.'
  });
  var FSTDEP012 = createDeprecation({
    code: "FSTDEP012",
    message: 'request.context property access is deprecated. Please use "request.routeOptions.config" or "request.routeOptions.schema" instead for accessing Route settings. The "request.context" will be removed in `fastify@5`.'
  });
  var FSTDEP013 = createDeprecation({
    code: "FSTDEP013",
    message: 'Direct return of "trailers" function is deprecated. Please use "callback" or "async-await" for return value. The support of direct return will removed in `fastify@5`.'
  });
  var FSTDEP014 = createDeprecation({
    code: "FSTDEP014",
    message: "You are trying to set/access the default route. This property is deprecated. Please, use setNotFoundHandler if you want to custom a 404 handler or the wildcard (*) to match all routes."
  });
  var FSTDEP015 = createDeprecation({
    code: "FSTDEP015",
    message: 'You are accessing the deprecated "request.routeSchema" property. Use "request.routeOptions.schema" instead. Property "req.routeSchema" will be removed in `fastify@5`.'
  });
  var FSTDEP016 = createDeprecation({
    code: "FSTDEP016",
    message: 'You are accessing the deprecated "request.routeConfig" property. Use "request.routeOptions.config" instead. Property "req.routeConfig" will be removed in `fastify@5`.'
  });
  var FSTDEP017 = createDeprecation({
    code: "FSTDEP017",
    message: 'You are accessing the deprecated "request.routerPath" property. Use "request.routeOptions.url" instead. Property "req.routerPath" will be removed in `fastify@5`.'
  });
  var FSTDEP018 = createDeprecation({
    code: "FSTDEP018",
    message: 'You are accessing the deprecated "request.routerMethod" property. Use "request.routeOptions.method" instead. Property "req.routerMethod" will be removed in `fastify@5`.'
  });
  var FSTDEP019 = createDeprecation({
    code: "FSTDEP019",
    message: 'reply.context property access is deprecated. Please use "request.routeOptions.config" or "request.routeOptions.schema" instead for accessing Route settings. The "reply.context" will be removed in `fastify@5`.'
  });
  var FSTDEP020 = createDeprecation({
    code: "FSTDEP020",
    message: 'You are using the deprecated "reply.getResponseTime()"" method. Use the "request.elapsedTime" property instead. Method "reply.getResponseTime()" will be removed in `fastify@5`.'
  });
  var FSTWRN001 = createWarning({
    name: "FastifyWarning",
    code: "FSTWRN001",
    message: "The %s schema for %s: %s is missing. This may indicate the schema is not well specified.",
    unlimited: true
  });
  var FSTWRN002 = createWarning({
    name: "FastifyWarning",
    code: "FSTWRN002",
    message: "The %s plugin being registered mixes async and callback styles, which will result in an error in `fastify@5`",
    unlimited: true
  });
  module.exports = {
    FSTDEP005,
    FSTDEP006,
    FSTDEP007,
    FSTDEP008,
    FSTDEP009,
    FSTDEP010,
    FSTDEP011,
    FSTDEP012,
    FSTDEP013,
    FSTDEP014,
    FSTDEP015,
    FSTDEP016,
    FSTDEP017,
    FSTDEP018,
    FSTDEP019,
    FSTDEP020,
    FSTWRN001,
    FSTWRN002
  };
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/errors.js
var require_errors4 = __commonJS((exports, module) => {
  var appendStackTrace = function(oldErr, newErr) {
    newErr.cause = oldErr;
    return newErr;
  };
  var createError = require_error2();
  var codes = {
    FST_ERR_NOT_FOUND: createError("FST_ERR_NOT_FOUND", "Not Found", 404),
    FST_ERR_OPTIONS_NOT_OBJ: createError("FST_ERR_OPTIONS_NOT_OBJ", "Options must be an object", 500, TypeError),
    FST_ERR_QSP_NOT_FN: createError("FST_ERR_QSP_NOT_FN", "querystringParser option should be a function, instead got '%s'", 500, TypeError),
    FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN: createError("FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN", "schemaController.bucket option should be a function, instead got '%s'", 500, TypeError),
    FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN: createError("FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN", "schemaErrorFormatter option should be a non async function. Instead got '%s'.", 500, TypeError),
    FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ: createError("FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ", "ajv.customOptions option should be an object, instead got '%s'", 500, TypeError),
    FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR: createError("FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR", "ajv.plugins option should be an array, instead got '%s'", 500, TypeError),
    FST_ERR_VERSION_CONSTRAINT_NOT_STR: createError("FST_ERR_VERSION_CONSTRAINT_NOT_STR", "Version constraint should be a string.", 500, TypeError),
    FST_ERR_VALIDATION: createError("FST_ERR_VALIDATION", "%s", 400),
    FST_ERR_LISTEN_OPTIONS_INVALID: createError("FST_ERR_LISTEN_OPTIONS_INVALID", "Invalid listen options: '%s'", 500, TypeError),
    FST_ERR_CTP_ALREADY_PRESENT: createError("FST_ERR_CTP_ALREADY_PRESENT", "Content type parser '%s' already present."),
    FST_ERR_CTP_INVALID_TYPE: createError("FST_ERR_CTP_INVALID_TYPE", "The content type should be a string or a RegExp", 500, TypeError),
    FST_ERR_CTP_EMPTY_TYPE: createError("FST_ERR_CTP_EMPTY_TYPE", "The content type cannot be an empty string", 500, TypeError),
    FST_ERR_CTP_INVALID_HANDLER: createError("FST_ERR_CTP_INVALID_HANDLER", "The content type handler should be a function", 500, TypeError),
    FST_ERR_CTP_INVALID_PARSE_TYPE: createError("FST_ERR_CTP_INVALID_PARSE_TYPE", "The body parser can only parse your data as 'string' or 'buffer', you asked '%s' which is not supported.", 500, TypeError),
    FST_ERR_CTP_BODY_TOO_LARGE: createError("FST_ERR_CTP_BODY_TOO_LARGE", "Request body is too large", 413, RangeError),
    FST_ERR_CTP_INVALID_MEDIA_TYPE: createError("FST_ERR_CTP_INVALID_MEDIA_TYPE", "Unsupported Media Type: %s", 415),
    FST_ERR_CTP_INVALID_CONTENT_LENGTH: createError("FST_ERR_CTP_INVALID_CONTENT_LENGTH", "Request body size did not match Content-Length", 400, RangeError),
    FST_ERR_CTP_EMPTY_JSON_BODY: createError("FST_ERR_CTP_EMPTY_JSON_BODY", "Body cannot be empty when content-type is set to 'application/json'", 400),
    FST_ERR_CTP_INSTANCE_ALREADY_STARTED: createError("FST_ERR_CTP_INSTANCE_ALREADY_STARTED", 'Cannot call "%s" when fastify instance is already started!', 400),
    FST_ERR_DEC_ALREADY_PRESENT: createError("FST_ERR_DEC_ALREADY_PRESENT", "The decorator '%s' has already been added!"),
    FST_ERR_DEC_DEPENDENCY_INVALID_TYPE: createError("FST_ERR_DEC_DEPENDENCY_INVALID_TYPE", "The dependencies of decorator '%s' must be of type Array.", 500, TypeError),
    FST_ERR_DEC_MISSING_DEPENDENCY: createError("FST_ERR_DEC_MISSING_DEPENDENCY", "The decorator is missing dependency '%s'."),
    FST_ERR_DEC_AFTER_START: createError("FST_ERR_DEC_AFTER_START", "The decorator '%s' has been added after start!"),
    FST_ERR_HOOK_INVALID_TYPE: createError("FST_ERR_HOOK_INVALID_TYPE", "The hook name must be a string", 500, TypeError),
    FST_ERR_HOOK_INVALID_HANDLER: createError("FST_ERR_HOOK_INVALID_HANDLER", "%s hook should be a function, instead got %s", 500, TypeError),
    FST_ERR_HOOK_INVALID_ASYNC_HANDLER: createError("FST_ERR_HOOK_INVALID_ASYNC_HANDLER", "Async function has too many arguments. Async hooks should not use the \'done\' argument.", 500, TypeError),
    FST_ERR_HOOK_NOT_SUPPORTED: createError("FST_ERR_HOOK_NOT_SUPPORTED", "%s hook not supported!", 500, TypeError),
    FST_ERR_MISSING_MIDDLEWARE: createError("FST_ERR_MISSING_MIDDLEWARE", "You must register a plugin for handling middlewares, visit fastify.dev/docs/latest/Reference/Middleware/ for more info.", 500),
    FST_ERR_HOOK_TIMEOUT: createError("FST_ERR_HOOK_TIMEOUT", "A callback for '%s' hook timed out. You may have forgotten to call 'done' function or to resolve a Promise"),
    FST_ERR_LOG_INVALID_DESTINATION: createError("FST_ERR_LOG_INVALID_DESTINATION", "Cannot specify both logger.stream and logger.file options"),
    FST_ERR_LOG_INVALID_LOGGER: createError("FST_ERR_LOG_INVALID_LOGGER", "Invalid logger object provided. The logger instance should have these functions(s): '%s'.", 500, TypeError),
    FST_ERR_REP_INVALID_PAYLOAD_TYPE: createError("FST_ERR_REP_INVALID_PAYLOAD_TYPE", "Attempted to send payload of invalid type '%s'. Expected a string or Buffer.", 500, TypeError),
    FST_ERR_REP_RESPONSE_BODY_CONSUMED: createError("FST_ERR_REP_RESPONSE_BODY_CONSUMED", "Response.body is already consumed."),
    FST_ERR_REP_ALREADY_SENT: createError("FST_ERR_REP_ALREADY_SENT", 'Reply was already sent, did you forget to "return reply" in "%s" (%s)?'),
    FST_ERR_REP_SENT_VALUE: createError("FST_ERR_REP_SENT_VALUE", "The only possible value for reply.sent is true.", 500, TypeError),
    FST_ERR_SEND_INSIDE_ONERR: createError("FST_ERR_SEND_INSIDE_ONERR", "You cannot use `send` inside the `onError` hook"),
    FST_ERR_SEND_UNDEFINED_ERR: createError("FST_ERR_SEND_UNDEFINED_ERR", "Undefined error has occurred"),
    FST_ERR_BAD_STATUS_CODE: createError("FST_ERR_BAD_STATUS_CODE", "Called reply with an invalid status code: %s"),
    FST_ERR_BAD_TRAILER_NAME: createError("FST_ERR_BAD_TRAILER_NAME", "Called reply.trailer with an invalid header name: %s"),
    FST_ERR_BAD_TRAILER_VALUE: createError("FST_ERR_BAD_TRAILER_VALUE", "Called reply.trailer('%s', fn) with an invalid type: %s. Expected a function."),
    FST_ERR_FAILED_ERROR_SERIALIZATION: createError("FST_ERR_FAILED_ERROR_SERIALIZATION", "Failed to serialize an error. Error: %s. Original error: %s"),
    FST_ERR_MISSING_SERIALIZATION_FN: createError("FST_ERR_MISSING_SERIALIZATION_FN", 'Missing serialization function. Key "%s"'),
    FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN: createError("FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN", 'Missing serialization function. Key "%s:%s"'),
    FST_ERR_REQ_INVALID_VALIDATION_INVOCATION: createError("FST_ERR_REQ_INVALID_VALIDATION_INVOCATION", 'Invalid validation invocation. Missing validation function for HTTP part "%s" nor schema provided.'),
    FST_ERR_SCH_MISSING_ID: createError("FST_ERR_SCH_MISSING_ID", "Missing schema $id property"),
    FST_ERR_SCH_ALREADY_PRESENT: createError("FST_ERR_SCH_ALREADY_PRESENT", "Schema with id '%s' already declared!"),
    FST_ERR_SCH_CONTENT_MISSING_SCHEMA: createError("FST_ERR_SCH_CONTENT_MISSING_SCHEMA", "Schema is missing for the content type '%s'"),
    FST_ERR_SCH_DUPLICATE: createError("FST_ERR_SCH_DUPLICATE", "Schema with '%s' already present!"),
    FST_ERR_SCH_VALIDATION_BUILD: createError("FST_ERR_SCH_VALIDATION_BUILD", "Failed building the validation schema for %s: %s, due to error %s"),
    FST_ERR_SCH_SERIALIZATION_BUILD: createError("FST_ERR_SCH_SERIALIZATION_BUILD", "Failed building the serialization schema for %s: %s, due to error %s"),
    FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX: createError("FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX", 'response schemas should be nested under a valid status code, e.g { 2xx: { type: "object" } }'),
    FST_ERR_HTTP2_INVALID_VERSION: createError("FST_ERR_HTTP2_INVALID_VERSION", "HTTP2 is available only from node >= 8.8.1"),
    FST_ERR_INIT_OPTS_INVALID: createError("FST_ERR_INIT_OPTS_INVALID", "Invalid initialization options: '%s'"),
    FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE: createError("FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE", "Cannot set forceCloseConnections to 'idle' as your HTTP server does not support closeIdleConnections method"),
    FST_ERR_DUPLICATED_ROUTE: createError("FST_ERR_DUPLICATED_ROUTE", "Method '%s' already declared for route '%s'"),
    FST_ERR_BAD_URL: createError("FST_ERR_BAD_URL", "'%s' is not a valid url component", 400, URIError),
    FST_ERR_ASYNC_CONSTRAINT: createError("FST_ERR_ASYNC_CONSTRAINT", "Unexpected error from async constraint", 500),
    FST_ERR_DEFAULT_ROUTE_INVALID_TYPE: createError("FST_ERR_DEFAULT_ROUTE_INVALID_TYPE", "The defaultRoute type should be a function", 500, TypeError),
    FST_ERR_INVALID_URL: createError("FST_ERR_INVALID_URL", "URL must be a string. Received '%s'", 400, TypeError),
    FST_ERR_ROUTE_OPTIONS_NOT_OBJ: createError("FST_ERR_ROUTE_OPTIONS_NOT_OBJ", 'Options for "%s:%s" route must be an object', 500, TypeError),
    FST_ERR_ROUTE_DUPLICATED_HANDLER: createError("FST_ERR_ROUTE_DUPLICATED_HANDLER", 'Duplicate handler for "%s:%s" route is not allowed!', 500),
    FST_ERR_ROUTE_HANDLER_NOT_FN: createError("FST_ERR_ROUTE_HANDLER_NOT_FN", "Error Handler for %s:%s route, if defined, must be a function", 500, TypeError),
    FST_ERR_ROUTE_MISSING_HANDLER: createError("FST_ERR_ROUTE_MISSING_HANDLER", 'Missing handler function for "%s:%s" route.', 500),
    FST_ERR_ROUTE_METHOD_INVALID: createError("FST_ERR_ROUTE_METHOD_INVALID", "Provided method is invalid!", 500, TypeError),
    FST_ERR_ROUTE_METHOD_NOT_SUPPORTED: createError("FST_ERR_ROUTE_METHOD_NOT_SUPPORTED", "%s method is not supported.", 500),
    FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED: createError("FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED", "Body validation schema for %s:%s route is not supported!", 500),
    FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT: createError("FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT", "'bodyLimit' option must be an integer > 0. Got '%s'", 500, TypeError),
    FST_ERR_ROUTE_REWRITE_NOT_STR: createError("FST_ERR_ROUTE_REWRITE_NOT_STR", 'Rewrite url for "%s" needs to be of type "string" but received "%s"', 500, TypeError),
    FST_ERR_REOPENED_CLOSE_SERVER: createError("FST_ERR_REOPENED_CLOSE_SERVER", "Fastify has already been closed and cannot be reopened"),
    FST_ERR_REOPENED_SERVER: createError("FST_ERR_REOPENED_SERVER", "Fastify is already listening"),
    FST_ERR_INSTANCE_ALREADY_LISTENING: createError("FST_ERR_INSTANCE_ALREADY_LISTENING", "Fastify instance is already listening. %s"),
    FST_ERR_PLUGIN_VERSION_MISMATCH: createError("FST_ERR_PLUGIN_VERSION_MISMATCH", "fastify-plugin: %s - expected '%s' fastify version, '%s' is installed"),
    FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE: createError("FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE", "The decorator '%s'%s is not present in %s"),
    FST_ERR_PLUGIN_CALLBACK_NOT_FN: createError("FST_ERR_PLUGIN_CALLBACK_NOT_FN", "fastify-plugin: %s", 500, TypeError),
    FST_ERR_PLUGIN_NOT_VALID: createError("FST_ERR_PLUGIN_NOT_VALID", "fastify-plugin: %s"),
    FST_ERR_ROOT_PLG_BOOTED: createError("FST_ERR_ROOT_PLG_BOOTED", "fastify-plugin: %s"),
    FST_ERR_PARENT_PLUGIN_BOOTED: createError("FST_ERR_PARENT_PLUGIN_BOOTED", "fastify-plugin: %s"),
    FST_ERR_PLUGIN_TIMEOUT: createError("FST_ERR_PLUGIN_TIMEOUT", "fastify-plugin: %s")
  };
  module.exports = codes;
  module.exports.appendStackTrace = appendStackTrace;
  module.exports.AVVIO_ERRORS_MAP = {
    AVV_ERR_CALLBACK_NOT_FN: codes.FST_ERR_PLUGIN_CALLBACK_NOT_FN,
    AVV_ERR_PLUGIN_NOT_VALID: codes.FST_ERR_PLUGIN_NOT_VALID,
    AVV_ERR_ROOT_PLG_BOOTED: codes.FST_ERR_ROOT_PLG_BOOTED,
    AVV_ERR_PARENT_PLG_LOADED: codes.FST_ERR_PARENT_PLUGIN_BOOTED,
    AVV_ERR_READY_TIMEOUT: codes.FST_ERR_PLUGIN_TIMEOUT
  };
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/hooks.js
var require_hooks2 = __commonJS((exports, module) => {
  var Hooks = function() {
    this.onRequest = [];
    this.preParsing = [];
    this.preValidation = [];
    this.preSerialization = [];
    this.preHandler = [];
    this.onResponse = [];
    this.onSend = [];
    this.onError = [];
    this.onRoute = [];
    this.onRegister = [];
    this.onReady = [];
    this.onListen = [];
    this.onTimeout = [];
    this.onRequestAbort = [];
    this.preClose = [];
  };
  var buildHooks = function(h) {
    const hooks = new Hooks;
    hooks.onRequest = h.onRequest.slice();
    hooks.preParsing = h.preParsing.slice();
    hooks.preValidation = h.preValidation.slice();
    hooks.preSerialization = h.preSerialization.slice();
    hooks.preHandler = h.preHandler.slice();
    hooks.onSend = h.onSend.slice();
    hooks.onResponse = h.onResponse.slice();
    hooks.onError = h.onError.slice();
    hooks.onRoute = h.onRoute.slice();
    hooks.onRegister = h.onRegister.slice();
    hooks.onTimeout = h.onTimeout.slice();
    hooks.onRequestAbort = h.onRequestAbort.slice();
    hooks.onReady = [];
    hooks.onListen = [];
    hooks.preClose = [];
    return hooks;
  };
  var hookRunnerApplication = function(hookName, boot, server, cb) {
    const hooks = server[kHooks][hookName];
    let i = 0;
    let c = 0;
    next();
    function exit(err) {
      if (err) {
        if (err.code === "AVV_ERR_READY_TIMEOUT") {
          err = appendStackTrace(err, new FST_ERR_HOOK_TIMEOUT(hookName));
        } else {
          err = AVVIO_ERRORS_MAP[err.code] != null ? appendStackTrace(err, new AVVIO_ERRORS_MAP[err.code](err.message)) : err;
        }
        cb(err);
        return;
      }
      cb();
    }
    function next(err) {
      if (err) {
        exit(err);
        return;
      }
      if (i === hooks.length && c === server[kChildren].length) {
        if (i === 0 && c === 0) {
          exit();
        } else {
          boot(function manageTimeout(err2, done) {
            exit(err2);
            done(err2);
          });
        }
        return;
      }
      if (i === hooks.length && c < server[kChildren].length) {
        const child = server[kChildren][c++];
        hookRunnerApplication(hookName, boot, child, next);
        return;
      }
      boot(wrap2(hooks[i++], server));
      next();
    }
    function wrap2(fn, server2) {
      return function(err, done) {
        if (err) {
          done(err);
          return;
        }
        if (fn.length === 1) {
          try {
            fn.call(server2, done);
          } catch (error) {
            done(error);
          }
          return;
        }
        try {
          const ret2 = fn.call(server2);
          if (ret2 && typeof ret2.then === "function") {
            ret2.then(done, done);
            return;
          }
        } catch (error) {
          err = error;
        }
        done(err);
      };
    }
  };
  var onListenHookRunner = function(server) {
    const hooks = server[kHooks].onListen;
    const hooksLen = hooks.length;
    let i = 0;
    let c = 0;
    next();
    function next(err) {
      err && server.log.error(err);
      if (i === hooksLen) {
        while (c < server[kChildren].length) {
          const child = server[kChildren][c++];
          onListenHookRunner(child);
        }
        return;
      }
      wrap2(hooks[i++], server, next);
    }
    async function wrap2(fn, server2, done) {
      if (fn.length === 1) {
        try {
          fn.call(server2, done);
        } catch (e) {
          done(e);
        }
        return;
      }
      try {
        const ret2 = fn.call(server2);
        if (ret2 && typeof ret2.then === "function") {
          ret2.then(done, done);
          return;
        }
        done();
      } catch (error) {
        done(error);
      }
    }
  };
  var hookRunnerGenerator = function(iterator) {
    return function hookRunner(functions, request5, reply, cb) {
      let i = 0;
      function next(err) {
        if (err || i === functions.length) {
          cb(err, request5, reply);
          return;
        }
        let result;
        try {
          result = iterator(functions[i++], request5, reply, next);
        } catch (error) {
          cb(error, request5, reply);
          return;
        }
        if (result && typeof result.then === "function") {
          result.then(handleResolve, handleReject);
        }
      }
      function handleResolve() {
        next();
      }
      function handleReject(err) {
        if (!err) {
          err = new FST_ERR_SEND_UNDEFINED_ERR;
        }
        cb(err, request5, reply);
      }
      next();
    };
  };
  var onResponseHookIterator = function(fn, request5, reply, next) {
    return fn(request5, reply, next);
  };
  var onSendHookRunner = function(functions, request5, reply, payload, cb) {
    let i = 0;
    function next(err, newPayload) {
      if (err) {
        cb(err, request5, reply, payload);
        return;
      }
      if (newPayload !== undefined) {
        payload = newPayload;
      }
      if (i === functions.length) {
        cb(null, request5, reply, payload);
        return;
      }
      let result;
      try {
        result = functions[i++](request5, reply, payload, next);
      } catch (error) {
        cb(error, request5, reply);
        return;
      }
      if (result && typeof result.then === "function") {
        result.then(handleResolve, handleReject);
      }
    }
    function handleResolve(newPayload) {
      next(null, newPayload);
    }
    function handleReject(err) {
      if (!err) {
        err = new FST_ERR_SEND_UNDEFINED_ERR;
      }
      cb(err, request5, reply, payload);
    }
    next();
  };
  var preParsingHookRunner = function(functions, request5, reply, cb) {
    let i = 0;
    function next(err, newPayload) {
      if (reply.sent) {
        return;
      }
      if (newPayload !== undefined) {
        request5[kRequestPayloadStream] = newPayload;
      }
      if (err || i === functions.length) {
        cb(err, request5, reply);
        return;
      }
      let result;
      try {
        result = functions[i++](request5, reply, request5[kRequestPayloadStream], next);
      } catch (error) {
        cb(error, request5, reply);
        return;
      }
      if (result && typeof result.then === "function") {
        result.then(handleResolve, handleReject);
      }
    }
    function handleResolve(newPayload) {
      next(null, newPayload);
    }
    function handleReject(err) {
      if (!err) {
        err = new FST_ERR_SEND_UNDEFINED_ERR;
      }
      cb(err, request5, reply);
    }
    next();
  };
  var onRequestAbortHookRunner = function(functions, request5, cb) {
    let i = 0;
    function next(err) {
      if (err || i === functions.length) {
        cb(err, request5);
        return;
      }
      let result;
      try {
        result = functions[i++](request5, next);
      } catch (error) {
        cb(error, request5);
        return;
      }
      if (result && typeof result.then === "function") {
        result.then(handleResolve, handleReject);
      }
    }
    function handleResolve() {
      next();
    }
    function handleReject(err) {
      if (!err) {
        err = new FST_ERR_SEND_UNDEFINED_ERR;
      }
      cb(err, request5);
    }
    next();
  };
  var hookIterator = function(fn, request5, reply, next) {
    if (reply.sent === true)
      return;
    return fn(request5, reply, next);
  };
  var applicationHooks = [
    "onRoute",
    "onRegister",
    "onReady",
    "onListen",
    "preClose",
    "onClose"
  ];
  var lifecycleHooks = [
    "onTimeout",
    "onRequest",
    "preParsing",
    "preValidation",
    "preSerialization",
    "preHandler",
    "onSend",
    "onResponse",
    "onError",
    "onRequestAbort"
  ];
  var supportedHooks = lifecycleHooks.concat(applicationHooks);
  var {
    FST_ERR_HOOK_INVALID_TYPE,
    FST_ERR_HOOK_INVALID_HANDLER,
    FST_ERR_SEND_UNDEFINED_ERR,
    FST_ERR_HOOK_TIMEOUT,
    FST_ERR_HOOK_NOT_SUPPORTED,
    AVVIO_ERRORS_MAP,
    appendStackTrace
  } = require_errors4();
  var {
    kChildren,
    kHooks,
    kRequestPayloadStream
  } = require_symbols3();
  Hooks.prototype = Object.create(null);
  Hooks.prototype.validate = function(hook, fn) {
    if (typeof hook !== "string")
      throw new FST_ERR_HOOK_INVALID_TYPE;
    if (Array.isArray(this[hook]) === false) {
      throw new FST_ERR_HOOK_NOT_SUPPORTED(hook);
    }
    if (typeof fn !== "function")
      throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(fn));
  };
  Hooks.prototype.add = function(hook, fn) {
    this.validate(hook, fn);
    this[hook].push(fn);
  };
  var onResponseHookRunner = hookRunnerGenerator(onResponseHookIterator);
  var preValidationHookRunner = hookRunnerGenerator(hookIterator);
  var preHandlerHookRunner = hookRunnerGenerator(hookIterator);
  var onTimeoutHookRunner = hookRunnerGenerator(hookIterator);
  var onRequestHookRunner = hookRunnerGenerator(hookIterator);
  var preSerializationHookRunner = onSendHookRunner;
  module.exports = {
    Hooks,
    buildHooks,
    hookRunnerGenerator,
    preParsingHookRunner,
    onResponseHookRunner,
    onSendHookRunner,
    preSerializationHookRunner,
    onRequestAbortHookRunner,
    hookIterator,
    hookRunnerApplication,
    onListenHookRunner,
    preHandlerHookRunner,
    preValidationHookRunner,
    onRequestHookRunner,
    onTimeoutHookRunner,
    lifecycleHooks,
    supportedHooks
  };
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/server.js
var require_server = __commonJS((exports, module) => {
  var defaultResolveServerListeningText = function(address10) {
    return `Server listening at ${address10}`;
  };
  var createServer = function(options, httpHandler) {
    const server = getServerInstance(options, httpHandler);
    function listen(listenOptions, ...args) {
      let cb = args.slice(-1).pop();
      const firstArgType = Object.prototype.toString.call(arguments[0]);
      if (arguments.length === 0) {
        listenOptions = normalizeListenArgs([]);
      } else if (arguments.length > 0 && (firstArgType !== "[object Object]" && firstArgType !== "[object Function]")) {
        FSTDEP011();
        listenOptions = normalizeListenArgs(Array.from(arguments));
        cb = listenOptions.cb;
      } else if (args.length > 1) {
        FSTDEP011();
        const hostPath = listenOptions.path ? [listenOptions.path] : [listenOptions.port ?? 0, listenOptions.host ?? "localhost"];
        Object.assign(listenOptions, normalizeListenArgs([...hostPath, ...args]));
      } else {
        listenOptions.cb = cb;
      }
      if (listenOptions.signal) {
        if (typeof listenOptions.signal.on !== "function" && typeof listenOptions.signal.addEventListener !== "function") {
          throw new FST_ERR_LISTEN_OPTIONS_INVALID("Invalid options.signal");
        }
        if (listenOptions.signal.aborted) {
          this.close();
        } else {
          const onAborted = () => {
            this.close();
          };
          listenOptions.signal.addEventListener("abort", onAborted, { once: true });
        }
      }
      let host;
      if (listenOptions.path == null) {
        host = listenOptions.host ?? "localhost";
      } else {
        host = listenOptions.host;
      }
      if (Object.prototype.hasOwnProperty.call(listenOptions, "host") === false) {
        listenOptions.host = host;
      }
      if (host === "localhost") {
        listenOptions.cb = (err, address10) => {
          if (err) {
            cb(err, address10);
            return;
          }
          multipleBindings.call(this, server, httpHandler, options, listenOptions, () => {
            this[kState].listening = true;
            cb(null, address10);
            onListenHookRunner(this);
          });
        };
      } else {
        listenOptions.cb = (err, address10) => {
          if (err) {
            cb(err, address10);
            return;
          }
          this[kState].listening = true;
          cb(null, address10);
          onListenHookRunner(this);
        };
      }
      if (cb === undefined) {
        const listening = listenPromise.call(this, server, listenOptions);
        return listening.then((address10) => {
          return new Promise((resolve5, reject) => {
            if (host === "localhost") {
              multipleBindings.call(this, server, httpHandler, options, listenOptions, () => {
                this[kState].listening = true;
                resolve5(address10);
                onListenHookRunner(this);
              });
            } else {
              resolve5(address10);
              onListenHookRunner(this);
            }
          });
        });
      }
      this.ready(listenCallback.call(this, server, listenOptions));
    }
    return { server, listen };
  };
  var multipleBindings = function(mainServer, httpHandler, serverOpts, listenOptions, onListen) {
    this[kState].listening = false;
    dns.lookup(listenOptions.host, { all: true }, (dnsErr, addresses) => {
      if (dnsErr) {
        onListen();
        return;
      }
      const isMainServerListening = mainServer.listening && serverOpts.serverFactory;
      let binding = 0;
      let bound = 0;
      if (!isMainServerListening) {
        const primaryAddress = mainServer.address();
        for (const adr of addresses) {
          if (adr.address !== primaryAddress.address) {
            binding++;
            const secondaryOpts = Object.assign({}, listenOptions, {
              host: adr.address,
              port: primaryAddress.port,
              cb: (_ignoreErr) => {
                bound++;
                if (!_ignoreErr) {
                  this[kServerBindings].push(secondaryServer);
                }
                if (bound === binding) {
                  onListen();
                }
              }
            });
            const secondaryServer = getServerInstance(serverOpts, httpHandler);
            const closeSecondary = () => {
              secondaryServer.close(() => {
              });
              if (serverOpts.forceCloseConnections === "idle") {
                secondaryServer.closeIdleConnections();
              } else if (typeof secondaryServer.closeAllConnections === "function" && serverOpts.forceCloseConnections) {
                secondaryServer.closeAllConnections();
              }
            };
            secondaryServer.on("upgrade", mainServer.emit.bind(mainServer, "upgrade"));
            mainServer.on("unref", closeSecondary);
            mainServer.on("close", closeSecondary);
            mainServer.on("error", closeSecondary);
            this[kState].listening = false;
            listenCallback.call(this, secondaryServer, secondaryOpts)();
          }
        }
      }
      if (binding === 0) {
        onListen();
        return;
      }
      const originUnref = mainServer.unref;
      mainServer.unref = function() {
        originUnref.call(mainServer);
        mainServer.emit("unref");
      };
    });
  };
  var listenCallback = function(server, listenOptions) {
    const wrap2 = (err) => {
      server.removeListener("error", wrap2);
      if (!err) {
        const address10 = logServerAddress.call(this, server, listenOptions.listenTextResolver || defaultResolveServerListeningText);
        listenOptions.cb(null, address10);
      } else {
        this[kState].listening = false;
        listenOptions.cb(err, null);
      }
    };
    return (err) => {
      if (err != null)
        return listenOptions.cb(err);
      if (this[kState].listening && this[kState].closing) {
        return listenOptions.cb(new FST_ERR_REOPENED_CLOSE_SERVER, null);
      } else if (this[kState].listening) {
        return listenOptions.cb(new FST_ERR_REOPENED_SERVER, null);
      }
      server.once("error", wrap2);
      if (!this[kState].closing) {
        server.listen(listenOptions, wrap2);
        this[kState].listening = true;
      }
    };
  };
  var listenPromise = function(server, listenOptions) {
    if (this[kState].listening && this[kState].closing) {
      return Promise.reject(new FST_ERR_REOPENED_CLOSE_SERVER);
    } else if (this[kState].listening) {
      return Promise.reject(new FST_ERR_REOPENED_SERVER);
    }
    return this.ready().then(() => {
      let errEventHandler;
      const errEvent = new Promise((resolve5, reject) => {
        errEventHandler = (err) => {
          this[kState].listening = false;
          reject(err);
        };
        server.once("error", errEventHandler);
      });
      const listen = new Promise((resolve5, reject) => {
        server.listen(listenOptions, () => {
          server.removeListener("error", errEventHandler);
          resolve5(logServerAddress.call(this, server, listenOptions.listenTextResolver || defaultResolveServerListeningText));
        });
        this[kState].listening = true;
      });
      return Promise.race([
        errEvent,
        listen
      ]);
    });
  };
  var compileValidateHTTPVersion = function(options) {
    let bypass = false;
    const map = new Map;
    if (options.serverFactory) {
      bypass = true;
    }
    if (options.http2) {
      map.set("2.0", true);
      if (options.https && options.https.allowHTTP1 === true) {
        map.set("1.1", true);
        map.set("1.0", true);
      }
    } else {
      map.set("1.1", true);
      map.set("1.0", true);
    }
    return function validateHTTPVersion(httpVersion) {
      return bypass || map.has(httpVersion);
    };
  };
  var getServerInstance = function(options, httpHandler) {
    let server = null;
    const httpsOptions = options.https === true ? {} : options.https;
    if (options.serverFactory) {
      server = options.serverFactory(httpHandler, options);
    } else if (options.http2) {
      if (typeof httpsOptions === "object") {
        server = http22().createSecureServer(httpsOptions, httpHandler);
      } else {
        server = http22().createServer(httpHandler);
      }
      server.on("session", sessionTimeout(options.http2SessionTimeout));
    } else {
      if (httpsOptions) {
        server = https.createServer(httpsOptions, httpHandler);
      } else {
        server = http2.createServer(options.http, httpHandler);
      }
      server.keepAliveTimeout = options.keepAliveTimeout;
      server.requestTimeout = options.requestTimeout;
      if (options.maxRequestsPerSocket > 0) {
        server.maxRequestsPerSocket = options.maxRequestsPerSocket;
      }
    }
    if (!options.serverFactory) {
      server.setTimeout(options.connectionTimeout);
    }
    return server;
  };
  var normalizeListenArgs = function(args) {
    if (args.length === 0) {
      return { port: 0, host: "localhost" };
    }
    const cb = typeof args[args.length - 1] === "function" ? args.pop() : undefined;
    const options = { cb };
    const firstArg = args[0];
    const argsLength = args.length;
    const lastArg = args[argsLength - 1];
    if (typeof firstArg === "string" && isNaN(firstArg)) {
      options.path = firstArg;
      options.backlog = argsLength > 1 ? lastArg : undefined;
    } else {
      options.port = argsLength >= 1 && Number.isInteger(firstArg) ? firstArg : normalizePort(firstArg);
      options.host = argsLength >= 2 && args[1] ? args[1] : "localhost";
      options.backlog = argsLength >= 3 ? args[2] : undefined;
    }
    return options;
  };
  var normalizePort = function(firstArg) {
    const port = Number(firstArg);
    return port >= 0 && !Number.isNaN(port) && Number.isInteger(port) ? port : 0;
  };
  var logServerAddress = function(server, listenTextResolver) {
    let address10 = server.address();
    const isUnixSocket = typeof address10 === "string";
    if (!isUnixSocket) {
      if (address10.address.indexOf(":") === -1) {
        address10 = address10.address + ":" + address10.port;
      } else {
        address10 = "[" + address10.address + "]:" + address10.port;
      }
    }
    address10 = (isUnixSocket ? "" : "http" + (this[kOptions].https ? "s" : "") + "://") + address10;
    const serverListeningText = listenTextResolver(address10);
    this.log.info(serverListeningText);
    return address10;
  };
  var http22 = function() {
    try {
      return __require("node:http2");
    } catch (err) {
      throw new FST_ERR_HTTP2_INVALID_VERSION;
    }
  };
  var sessionTimeout = function(timeout) {
    return function(session) {
      session.setTimeout(timeout, close);
    };
  };
  var close = function() {
    this.close();
  };
  var http2 = __require("node:http");
  var https = __require("node:https");
  var dns = __require("node:dns");
  var { FSTDEP011 } = require_warnings();
  var { kState, kOptions, kServerBindings } = require_symbols3();
  var { onListenHookRunner } = require_hooks2();
  var {
    FST_ERR_HTTP2_INVALID_VERSION,
    FST_ERR_REOPENED_CLOSE_SERVER,
    FST_ERR_REOPENED_SERVER,
    FST_ERR_LISTEN_OPTIONS_INVALID
  } = require_errors4();
  exports.createServer = createServer;
  exports.compileValidateHTTPVersion = compileValidateHTTPVersion;
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/validation.js
var require_validation2 = __commonJS((exports, module) => {
  var compileSchemasForSerialization = function(context, compile) {
    if (!context.schema || !context.schema.response) {
      return;
    }
    const { method, url } = context.config || {};
    context[responseSchema] = Object.keys(context.schema.response).reduce(function(acc, statusCode) {
      const schema = context.schema.response[statusCode];
      statusCode = statusCode.toLowerCase();
      if (!scChecker.exec(statusCode)) {
        throw new FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX;
      }
      if (schema.content) {
        const contentTypesSchemas = {};
        for (const mediaName of Object.keys(schema.content)) {
          const contentSchema = schema.content[mediaName].schema;
          contentTypesSchemas[mediaName] = compile({
            schema: contentSchema,
            url,
            method,
            httpStatus: statusCode,
            contentType: mediaName
          });
        }
        acc[statusCode] = contentTypesSchemas;
      } else {
        acc[statusCode] = compile({
          schema,
          url,
          method,
          httpStatus: statusCode
        });
      }
      return acc;
    }, {});
  };
  var compileSchemasForValidation = function(context, compile, isCustom) {
    const { schema } = context;
    if (!schema) {
      return;
    }
    const { method, url } = context.config || {};
    const headers = schema.headers;
    if (headers && (isCustom || Object.getPrototypeOf(headers) !== Object.prototype)) {
      context[headersSchema] = compile({ schema: headers, method, url, httpPart: "headers" });
    } else if (headers) {
      const headersSchemaLowerCase = {};
      Object.keys(headers).forEach((k) => {
        headersSchemaLowerCase[k] = headers[k];
      });
      if (headersSchemaLowerCase.required instanceof Array) {
        headersSchemaLowerCase.required = headersSchemaLowerCase.required.map((h) => h.toLowerCase());
      }
      if (headers.properties) {
        headersSchemaLowerCase.properties = {};
        Object.keys(headers.properties).forEach((k) => {
          headersSchemaLowerCase.properties[k.toLowerCase()] = headers.properties[k];
        });
      }
      context[headersSchema] = compile({ schema: headersSchemaLowerCase, method, url, httpPart: "headers" });
    } else if (Object.prototype.hasOwnProperty.call(schema, "headers")) {
      FSTWRN001("headers", method, url);
    }
    if (schema.body) {
      context[bodySchema] = compile({ schema: schema.body, method, url, httpPart: "body" });
    } else if (Object.prototype.hasOwnProperty.call(schema, "body")) {
      FSTWRN001("body", method, url);
    }
    if (schema.querystring) {
      context[querystringSchema] = compile({ schema: schema.querystring, method, url, httpPart: "querystring" });
    } else if (Object.prototype.hasOwnProperty.call(schema, "querystring")) {
      FSTWRN001("querystring", method, url);
    }
    if (schema.params) {
      context[paramsSchema] = compile({ schema: schema.params, method, url, httpPart: "params" });
    } else if (Object.prototype.hasOwnProperty.call(schema, "params")) {
      FSTWRN001("params", method, url);
    }
  };
  var validateParam = function(validatorFunction, request5, paramName) {
    const isUndefined = request5[paramName] === undefined;
    const ret2 = validatorFunction && validatorFunction(isUndefined ? null : request5[paramName]);
    if (ret2?.then) {
      return ret2.then((res) => {
        return answer(res);
      }).catch((err) => {
        return err;
      });
    }
    return answer(ret2);
    function answer(ret3) {
      if (ret3 === false)
        return validatorFunction.errors;
      if (ret3 && ret3.error)
        return ret3.error;
      if (ret3 && ret3.value)
        request5[paramName] = ret3.value;
      return false;
    }
  };
  var validate = function(context, request5, execution) {
    const runExecution = execution === undefined;
    if (runExecution || !execution.skipParams) {
      const params = validateParam(context[paramsSchema], request5, "params");
      if (params) {
        if (typeof params.then !== "function") {
          return wrapValidationError(params, "params", context.schemaErrorFormatter);
        } else {
          return validateAsyncParams(params, context, request5);
        }
      }
    }
    if (runExecution || !execution.skipBody) {
      const body = validateParam(context[bodySchema], request5, "body");
      if (body) {
        if (typeof body.then !== "function") {
          return wrapValidationError(body, "body", context.schemaErrorFormatter);
        } else {
          return validateAsyncBody(body, context, request5);
        }
      }
    }
    if (runExecution || !execution.skipQuery) {
      const query = validateParam(context[querystringSchema], request5, "query");
      if (query) {
        if (typeof query.then !== "function") {
          return wrapValidationError(query, "querystring", context.schemaErrorFormatter);
        } else {
          return validateAsyncQuery(query, context, request5);
        }
      }
    }
    const headers = validateParam(context[headersSchema], request5, "headers");
    if (headers) {
      if (typeof headers.then !== "function") {
        return wrapValidationError(headers, "headers", context.schemaErrorFormatter);
      } else {
        return validateAsyncHeaders(headers, context, request5);
      }
    }
    return false;
  };
  var validateAsyncParams = function(validatePromise, context, request5) {
    return validatePromise.then((paramsResult) => {
      if (paramsResult) {
        return wrapValidationError(paramsResult, "params", context.schemaErrorFormatter);
      }
      return validate(context, request5, { skipParams: true });
    });
  };
  var validateAsyncBody = function(validatePromise, context, request5) {
    return validatePromise.then((bodyResult) => {
      if (bodyResult) {
        return wrapValidationError(bodyResult, "body", context.schemaErrorFormatter);
      }
      return validate(context, request5, { skipParams: true, skipBody: true });
    });
  };
  var validateAsyncQuery = function(validatePromise, context, request5) {
    return validatePromise.then((queryResult) => {
      if (queryResult) {
        return wrapValidationError(queryResult, "querystring", context.schemaErrorFormatter);
      }
      return validate(context, request5, { skipParams: true, skipBody: true, skipQuery: true });
    });
  };
  var validateAsyncHeaders = function(validatePromise, context, request5) {
    return validatePromise.then((headersResult) => {
      if (headersResult) {
        return wrapValidationError(headersResult, "headers", context.schemaErrorFormatter);
      }
      return false;
    });
  };
  var wrapValidationError = function(result, dataVar, schemaErrorFormatter) {
    if (result instanceof Error) {
      result.statusCode = result.statusCode || 400;
      result.code = result.code || "FST_ERR_VALIDATION";
      result.validationContext = result.validationContext || dataVar;
      return result;
    }
    const error = schemaErrorFormatter(result, dataVar);
    error.statusCode = error.statusCode || 400;
    error.code = error.code || "FST_ERR_VALIDATION";
    error.validation = result;
    error.validationContext = dataVar;
    return error;
  };
  var {
    kSchemaHeaders: headersSchema,
    kSchemaParams: paramsSchema,
    kSchemaQuerystring: querystringSchema,
    kSchemaBody: bodySchema,
    kSchemaResponse: responseSchema
  } = require_symbols3();
  var scChecker = /^[1-5]{1}[0-9]{2}$|^[1-5]xx$|^default$/;
  var {
    FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX
  } = require_errors4();
  var { FSTWRN001 } = require_warnings();
  module.exports = {
    symbols: { bodySchema, querystringSchema, responseSchema, paramsSchema, headersSchema },
    compileSchemasForValidation,
    compileSchemasForSerialization,
    validate
  };
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/wrapThenable.js
var require_wrapThenable = __commonJS((exports, module) => {
  var wrapThenable = function(thenable, reply) {
    thenable.then(function(payload) {
      if (reply[kReplyHijacked] === true) {
        return;
      }
      if (payload !== undefined || reply.sent === false && reply.raw.headersSent === false && reply.request.raw.aborted === false) {
        try {
          reply.send(payload);
        } catch (err) {
          reply[kReplyIsError] = true;
          reply.send(err);
        }
      }
    }, function(err) {
      if (reply.sent === true) {
        reply.log.error({ err }, "Promise errored, but reply.sent = true was set");
        return;
      }
      reply[kReplyIsError] = true;
      try {
        reply.send(err);
      } catch (err2) {
        reply.send(err2);
      }
    });
  };
  var {
    kReplyIsError,
    kReplyHijacked
  } = require_symbols3();
  module.exports = wrapThenable;
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/handleRequest.js
var require_handleRequest = __commonJS((exports, module) => {
  var handleRequest = function(err, request5, reply) {
    if (reply.sent === true)
      return;
    if (err != null) {
      reply[kReplyIsError] = true;
      reply.send(err);
      return;
    }
    const method = request5.raw.method;
    const headers = request5.headers;
    const context = request5[kRouteContext];
    if (method === "GET" || method === "HEAD") {
      handler(request5, reply);
      return;
    }
    const contentType = headers["content-type"];
    if (method === "POST" || method === "PUT" || method === "PATCH" || method === "TRACE" || method === "SEARCH") {
      if (contentType === undefined) {
        if (headers["transfer-encoding"] === undefined && (headers["content-length"] === "0" || headers["content-length"] === undefined)) {
          handler(request5, reply);
        } else {
          context.contentTypeParser.run("", handler, request5, reply);
        }
      } else {
        context.contentTypeParser.run(contentType, handler, request5, reply);
      }
      return;
    }
    if (method === "OPTIONS" || method === "DELETE") {
      if (contentType !== undefined && (headers["transfer-encoding"] !== undefined || headers["content-length"] !== undefined)) {
        context.contentTypeParser.run(contentType, handler, request5, reply);
      } else {
        handler(request5, reply);
      }
      return;
    }
    handler(request5, reply);
  };
  var handler = function(request5, reply) {
    try {
      if (request5[kRouteContext].preValidation !== null) {
        preValidationHookRunner(request5[kRouteContext].preValidation, request5, reply, preValidationCallback);
      } else {
        preValidationCallback(null, request5, reply);
      }
    } catch (err) {
      preValidationCallback(err, request5, reply);
    }
  };
  var preValidationCallback = function(err, request5, reply) {
    if (reply.sent === true)
      return;
    if (err != null) {
      reply[kReplyIsError] = true;
      reply.send(err);
      return;
    }
    const validationErr = validateSchema(reply[kRouteContext], request5);
    const isAsync2 = validationErr && typeof validationErr.then === "function" || false;
    if (isAsync2) {
      const cb = validationCompleted.bind(null, request5, reply);
      validationErr.then(cb, cb);
    } else {
      validationCompleted(request5, reply, validationErr);
    }
  };
  var validationCompleted = function(request5, reply, validationErr) {
    if (validationErr) {
      if (reply[kRouteContext].attachValidation === false) {
        reply.send(validationErr);
        return;
      }
      reply.request.validationError = validationErr;
    }
    if (request5[kRouteContext].preHandler !== null) {
      preHandlerHookRunner(request5[kRouteContext].preHandler, request5, reply, preHandlerCallback);
    } else {
      preHandlerCallback(null, request5, reply);
    }
  };
  var preHandlerCallback = function(err, request5, reply) {
    if (reply.sent)
      return;
    if (err != null) {
      reply[kReplyIsError] = true;
      reply.send(err);
      return;
    }
    let result;
    try {
      result = request5[kRouteContext].handler(request5, reply);
    } catch (err2) {
      reply[kReplyIsError] = true;
      reply.send(err2);
      return;
    }
    if (result !== undefined) {
      if (result !== null && typeof result.then === "function") {
        wrapThenable(result, reply);
      } else {
        reply.send(result);
      }
    }
  };
  var { validate: validateSchema } = require_validation2();
  var { preValidationHookRunner, preHandlerHookRunner } = require_hooks2();
  var wrapThenable = require_wrapThenable();
  var {
    kReplyIsError,
    kRouteContext
  } = require_symbols3();
  module.exports = handleRequest;
  module.exports[Symbol.for("internals")] = { handler, preHandlerCallback };
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fastify@4.26.0/node_modules/abstract-logging/index.js
var require_abstract_logging = __commonJS((exports, module) => {
  var noop = function() {
  };
  var proto = {
    fatal: noop,
    error: noop,
    warn: noop,
    info: noop,
    debug: noop,
    trace: noop
  };
  Object.defineProperty(module, "exports", {
    get() {
      return Object.create(proto);
    }
  });
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/logger.js
var require_logger2 = __commonJS((exports, module) => {
  var createPinoLogger = function(opts) {
    if (opts.stream && opts.file) {
      throw new FST_ERR_LOG_INVALID_DESTINATION;
    } else if (opts.file) {
      opts.stream = pino.destination(opts.file);
      delete opts.file;
    }
    const prevLogger = opts.logger;
    const prevGenReqId = opts.genReqId;
    let logger3 = null;
    if (prevLogger) {
      opts.logger = undefined;
      opts.genReqId = undefined;
      if (prevLogger[serializersSym]) {
        opts.serializers = Object.assign({}, opts.serializers, prevLogger[serializersSym]);
      }
      logger3 = prevLogger.child({}, opts);
      opts.logger = prevLogger;
      opts.genReqId = prevGenReqId;
    } else {
      logger3 = pino(opts, opts.stream);
    }
    return logger3;
  };
  var now = function() {
    const ts = process.hrtime();
    return ts[0] * 1000 + ts[1] / 1e6;
  };
  var createLogger = function(options) {
    if (!options.logger) {
      const logger4 = nullLogger;
      logger4.child = () => logger4;
      return { logger: logger4, hasLogger: false };
    }
    if (validateLogger(options.logger)) {
      const logger4 = createPinoLogger({
        logger: options.logger,
        serializers: Object.assign({}, serializers4, options.logger.serializers)
      });
      return { logger: logger4, hasLogger: true };
    }
    const localLoggerOptions = {};
    if (Object.prototype.toString.call(options.logger) === "[object Object]") {
      Reflect.ownKeys(options.logger).forEach((prop) => {
        Object.defineProperty(localLoggerOptions, prop, {
          value: options.logger[prop],
          writable: true,
          enumerable: true,
          configurable: true
        });
      });
    }
    localLoggerOptions.level = localLoggerOptions.level || "info";
    localLoggerOptions.serializers = Object.assign({}, serializers4, localLoggerOptions.serializers);
    options.logger = localLoggerOptions;
    const logger3 = createPinoLogger(options.logger);
    return { logger: logger3, hasLogger: true };
  };
  var validateLogger = function(logger3, strict) {
    const methods = ["info", "error", "debug", "fatal", "warn", "trace", "child"];
    const missingMethods = logger3 ? methods.filter((method) => !logger3[method] || typeof logger3[method] !== "function") : methods;
    if (!missingMethods.length) {
      return true;
    } else if (missingMethods.length === methods.length && !strict) {
      return false;
    } else {
      throw FST_ERR_LOG_INVALID_LOGGER(missingMethods.join(","));
    }
  };
  var createChildLogger = function(context, logger3, req, reqId, loggerOpts) {
    const loggerBindings = {
      [context.requestIdLogLabel]: reqId
    };
    const child = context.childLoggerFactory.call(context.server, logger3, loggerBindings, loggerOpts || {}, req);
    if (context.childLoggerFactory !== defaultChildLoggerFactory) {
      validateLogger(child, true);
    }
    return child;
  };
  var defaultChildLoggerFactory = function(logger3, bindings, opts) {
    return logger3.child(bindings, opts);
  };
  var nullLogger = require_abstract_logging();
  var pino = require_pino();
  var { serializersSym } = pino.symbols;
  var {
    FST_ERR_LOG_INVALID_DESTINATION,
    FST_ERR_LOG_INVALID_LOGGER
  } = require_errors4();
  var serializers4 = {
    req: function asReqValue(req) {
      return {
        method: req.method,
        url: req.url,
        version: req.headers && req.headers["accept-version"],
        hostname: req.hostname,
        remoteAddress: req.ip,
        remotePort: req.socket ? req.socket.remotePort : undefined
      };
    },
    err: pino.stdSerializers.err,
    res: function asResValue(reply) {
      return {
        statusCode: reply.statusCode
      };
    }
  };
  module.exports = {
    createLogger,
    createChildLogger,
    defaultChildLoggerFactory,
    serializers: serializers4,
    now
  };
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fastify@4.26.0/node_modules/rfdc/index.js
var require_rfdc = __commonJS((exports, module) => {
  var copyBuffer = function(cur) {
    if (cur instanceof Buffer) {
      return Buffer.from(cur);
    }
    return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
  };
  var rfdc = function(opts) {
    opts = opts || {};
    if (opts.circles)
      return rfdcCircles(opts);
    return opts.proto ? cloneProto : clone;
    function cloneArray(a, fn) {
      var keys = Object.keys(a);
      var a2 = new Array(keys.length);
      for (var i = 0;i < keys.length; i++) {
        var k = keys[i];
        var cur = a[k];
        if (typeof cur !== "object" || cur === null) {
          a2[k] = cur;
        } else if (cur instanceof Date) {
          a2[k] = new Date(cur);
        } else if (ArrayBuffer.isView(cur)) {
          a2[k] = copyBuffer(cur);
        } else {
          a2[k] = fn(cur);
        }
      }
      return a2;
    }
    function clone(o) {
      if (typeof o !== "object" || o === null)
        return o;
      if (o instanceof Date)
        return new Date(o);
      if (Array.isArray(o))
        return cloneArray(o, clone);
      if (o instanceof Map)
        return new Map(cloneArray(Array.from(o), clone));
      if (o instanceof Set)
        return new Set(cloneArray(Array.from(o), clone));
      var o2 = {};
      for (var k in o) {
        if (Object.hasOwnProperty.call(o, k) === false)
          continue;
        var cur = o[k];
        if (typeof cur !== "object" || cur === null) {
          o2[k] = cur;
        } else if (cur instanceof Date) {
          o2[k] = new Date(cur);
        } else if (cur instanceof Map) {
          o2[k] = new Map(cloneArray(Array.from(cur), clone));
        } else if (cur instanceof Set) {
          o2[k] = new Set(cloneArray(Array.from(cur), clone));
        } else if (ArrayBuffer.isView(cur)) {
          o2[k] = copyBuffer(cur);
        } else {
          o2[k] = clone(cur);
        }
      }
      return o2;
    }
    function cloneProto(o) {
      if (typeof o !== "object" || o === null)
        return o;
      if (o instanceof Date)
        return new Date(o);
      if (Array.isArray(o))
        return cloneArray(o, cloneProto);
      if (o instanceof Map)
        return new Map(cloneArray(Array.from(o), cloneProto));
      if (o instanceof Set)
        return new Set(cloneArray(Array.from(o), cloneProto));
      var o2 = {};
      for (var k in o) {
        var cur = o[k];
        if (typeof cur !== "object" || cur === null) {
          o2[k] = cur;
        } else if (cur instanceof Date) {
          o2[k] = new Date(cur);
        } else if (cur instanceof Map) {
          o2[k] = new Map(cloneArray(Array.from(cur), cloneProto));
        } else if (cur instanceof Set) {
          o2[k] = new Set(cloneArray(Array.from(cur), cloneProto));
        } else if (ArrayBuffer.isView(cur)) {
          o2[k] = copyBuffer(cur);
        } else {
          o2[k] = cloneProto(cur);
        }
      }
      return o2;
    }
  };
  var rfdcCircles = function(opts) {
    var refs = [];
    var refsNew = [];
    return opts.proto ? cloneProto : clone;
    function cloneArray(a, fn) {
      var keys = Object.keys(a);
      var a2 = new Array(keys.length);
      for (var i = 0;i < keys.length; i++) {
        var k = keys[i];
        var cur = a[k];
        if (typeof cur !== "object" || cur === null) {
          a2[k] = cur;
        } else if (cur instanceof Date) {
          a2[k] = new Date(cur);
        } else if (ArrayBuffer.isView(cur)) {
          a2[k] = copyBuffer(cur);
        } else {
          var index2 = refs.indexOf(cur);
          if (index2 !== -1) {
            a2[k] = refsNew[index2];
          } else {
            a2[k] = fn(cur);
          }
        }
      }
      return a2;
    }
    function clone(o) {
      if (typeof o !== "object" || o === null)
        return o;
      if (o instanceof Date)
        return new Date(o);
      if (Array.isArray(o))
        return cloneArray(o, clone);
      if (o instanceof Map)
        return new Map(cloneArray(Array.from(o), clone));
      if (o instanceof Set)
        return new Set(cloneArray(Array.from(o), clone));
      var o2 = {};
      refs.push(o);
      refsNew.push(o2);
      for (var k in o) {
        if (Object.hasOwnProperty.call(o, k) === false)
          continue;
        var cur = o[k];
        if (typeof cur !== "object" || cur === null) {
          o2[k] = cur;
        } else if (cur instanceof Date) {
          o2[k] = new Date(cur);
        } else if (cur instanceof Map) {
          o2[k] = new Map(cloneArray(Array.from(cur), clone));
        } else if (cur instanceof Set) {
          o2[k] = new Set(cloneArray(Array.from(cur), clone));
        } else if (ArrayBuffer.isView(cur)) {
          o2[k] = copyBuffer(cur);
        } else {
          var i = refs.indexOf(cur);
          if (i !== -1) {
            o2[k] = refsNew[i];
          } else {
            o2[k] = clone(cur);
          }
        }
      }
      refs.pop();
      refsNew.pop();
      return o2;
    }
    function cloneProto(o) {
      if (typeof o !== "object" || o === null)
        return o;
      if (o instanceof Date)
        return new Date(o);
      if (Array.isArray(o))
        return cloneArray(o, cloneProto);
      if (o instanceof Map)
        return new Map(cloneArray(Array.from(o), cloneProto));
      if (o instanceof Set)
        return new Set(cloneArray(Array.from(o), cloneProto));
      var o2 = {};
      refs.push(o);
      refsNew.push(o2);
      for (var k in o) {
        var cur = o[k];
        if (typeof cur !== "object" || cur === null) {
          o2[k] = cur;
        } else if (cur instanceof Date) {
          o2[k] = new Date(cur);
        } else if (cur instanceof Map) {
          o2[k] = new Map(cloneArray(Array.from(cur), cloneProto));
        } else if (cur instanceof Set) {
          o2[k] = new Set(cloneArray(Array.from(cur), cloneProto));
        } else if (ArrayBuffer.isView(cur)) {
          o2[k] = copyBuffer(cur);
        } else {
          var i = refs.indexOf(cur);
          if (i !== -1) {
            o2[k] = refsNew[i];
          } else {
            o2[k] = cloneProto(cur);
          }
        }
      }
      refs.pop();
      refsNew.pop();
      return o2;
    }
  };
  module.exports = rfdc;
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/schemas.js
var require_schemas = __commonJS((exports, module) => {
  var Schemas = function(initStore) {
    this.store = initStore || {};
  };
  var isCustomSchemaPrototype = function(schema) {
    return typeof schema === "object" && Object.getPrototypeOf(schema) !== Object.prototype;
  };
  var normalizeSchema = function(routeSchemas, serverOptions) {
    if (routeSchemas[kSchemaVisited]) {
      return routeSchemas;
    }
    if (routeSchemas.query) {
      if (routeSchemas.querystring) {
        throw new FST_ERR_SCH_DUPLICATE("querystring");
      }
      routeSchemas.querystring = routeSchemas.query;
    }
    generateFluentSchema(routeSchemas);
    for (const key of SCHEMAS_SOURCE) {
      const schema = routeSchemas[key];
      if (schema && !isCustomSchemaPrototype(schema)) {
        routeSchemas[key] = getSchemaAnyway(schema, serverOptions.jsonShorthand);
      }
    }
    if (routeSchemas.response) {
      const httpCodes = Object.keys(routeSchemas.response);
      for (const code of httpCodes) {
        if (isCustomSchemaPrototype(routeSchemas.response[code])) {
          continue;
        }
        const contentProperty = routeSchemas.response[code].content;
        let hasContentMultipleContentTypes = false;
        if (contentProperty) {
          const keys = Object.keys(contentProperty);
          for (let i = 0;i < keys.length; i++) {
            const mediaName = keys[i];
            if (!contentProperty[mediaName].schema) {
              if (keys.length === 1) {
                break;
              }
              throw new FST_ERR_SCH_CONTENT_MISSING_SCHEMA(mediaName);
            }
            routeSchemas.response[code].content[mediaName].schema = getSchemaAnyway(contentProperty[mediaName].schema, serverOptions.jsonShorthand);
            if (i === keys.length - 1) {
              hasContentMultipleContentTypes = true;
            }
          }
        }
        if (!hasContentMultipleContentTypes) {
          routeSchemas.response[code] = getSchemaAnyway(routeSchemas.response[code], serverOptions.jsonShorthand);
        }
      }
    }
    routeSchemas[kSchemaVisited] = true;
    return routeSchemas;
  };
  var generateFluentSchema = function(schema) {
    for (const key of SCHEMAS_SOURCE) {
      if (schema[key] && (schema[key].isFluentSchema || schema[key][kFluentSchema])) {
        schema[key] = schema[key].valueOf();
      }
    }
    if (schema.response) {
      const httpCodes = Object.keys(schema.response);
      for (const code of httpCodes) {
        if (schema.response[code].isFluentSchema || schema.response[code][kFluentSchema]) {
          schema.response[code] = schema.response[code].valueOf();
        }
      }
    }
  };
  var getSchemaAnyway = function(schema, jsonShorthand) {
    if (!jsonShorthand || schema.$ref || schema.oneOf || schema.allOf || schema.anyOf || schema.$merge || schema.$patch)
      return schema;
    if (!schema.type && !schema.properties) {
      return {
        type: "object",
        properties: schema
      };
    }
    return schema;
  };
  var getSchemaSerializer = function(context, statusCode, contentType) {
    const responseSchemaDef = context[kSchemaResponse];
    if (!responseSchemaDef) {
      return false;
    }
    if (responseSchemaDef[statusCode]) {
      if (responseSchemaDef[statusCode].constructor === Object && contentType) {
        const mediaName = contentType.split(";", 1)[0];
        if (responseSchemaDef[statusCode][mediaName]) {
          return responseSchemaDef[statusCode][mediaName];
        }
        return false;
      }
      return responseSchemaDef[statusCode];
    }
    const fallbackStatusCode = (statusCode + "")[0] + "xx";
    if (responseSchemaDef[fallbackStatusCode]) {
      if (responseSchemaDef[fallbackStatusCode].constructor === Object && contentType) {
        const mediaName = contentType.split(";", 1)[0];
        if (responseSchemaDef[fallbackStatusCode][mediaName]) {
          return responseSchemaDef[fallbackStatusCode][mediaName];
        }
        return false;
      }
      return responseSchemaDef[fallbackStatusCode];
    }
    if (responseSchemaDef.default) {
      if (responseSchemaDef.default.constructor === Object && contentType) {
        const mediaName = contentType.split(";", 1)[0];
        if (responseSchemaDef.default[mediaName]) {
          return responseSchemaDef.default[mediaName];
        }
        return false;
      }
      return responseSchemaDef.default;
    }
    return false;
  };
  var fastClone = require_rfdc()({ circles: false, proto: true });
  var { kSchemaVisited, kSchemaResponse } = require_symbols3();
  var kFluentSchema = Symbol.for("fluent-schema-object");
  var {
    FST_ERR_SCH_MISSING_ID,
    FST_ERR_SCH_ALREADY_PRESENT,
    FST_ERR_SCH_DUPLICATE,
    FST_ERR_SCH_CONTENT_MISSING_SCHEMA
  } = require_errors4();
  var SCHEMAS_SOURCE = ["params", "body", "querystring", "query", "headers"];
  Schemas.prototype.add = function(inputSchema) {
    const schema = fastClone(inputSchema.isFluentSchema || inputSchema.isFluentJSONSchema || inputSchema[kFluentSchema] ? inputSchema.valueOf() : inputSchema);
    const id2 = schema.$id;
    if (!id2) {
      throw new FST_ERR_SCH_MISSING_ID;
    }
    if (this.store[id2]) {
      throw new FST_ERR_SCH_ALREADY_PRESENT(id2);
    }
    this.store[id2] = schema;
  };
  Schemas.prototype.getSchemas = function() {
    return Object.assign({}, this.store);
  };
  Schemas.prototype.getSchema = function(schemaId) {
    return this.store[schemaId];
  };
  module.exports = {
    buildSchemas(initStore) {
      return new Schemas(initStore);
    },
    getSchemaSerializer,
    normalizeSchema
  };
});

// ../node_modules/.pnpm/fast-json-stringify@5.12.0/node_modules/fast-json-stringify/lib/serializer.js
var require_serializer = __commonJS((exports, module) => {
  var STR_ESCAPE = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/;
  module.exports = class Serializer {
    constructor(options) {
      switch (options && options.rounding) {
        case "floor":
          this.parseInteger = Math.floor;
          break;
        case "ceil":
          this.parseInteger = Math.ceil;
          break;
        case "round":
          this.parseInteger = Math.round;
          break;
        case "trunc":
        default:
          this.parseInteger = Math.trunc;
          break;
      }
      this._options = options;
    }
    asInteger(i) {
      if (typeof i === "number") {
        if (i === Infinity || i === (-Infinity)) {
          throw new Error(`The value "${i}" cannot be converted to an integer.`);
        }
        if (Number.isInteger(i)) {
          return "" + i;
        }
        if (Number.isNaN(i)) {
          throw new Error(`The value "${i}" cannot be converted to an integer.`);
        }
        return this.parseInteger(i);
      } else if (i === null) {
        return "0";
      } else if (typeof i === "bigint") {
        return i.toString();
      } else {
        const integer = this.parseInteger(i);
        if (Number.isFinite(integer)) {
          return "" + integer;
        } else {
          throw new Error(`The value "${i}" cannot be converted to an integer.`);
        }
      }
    }
    asNumber(i) {
      const num = Number(i);
      if (Number.isNaN(num)) {
        throw new Error(`The value "${i}" cannot be converted to a number.`);
      } else if (!Number.isFinite(num)) {
        return "null";
      } else {
        return "" + num;
      }
    }
    asBoolean(bool) {
      return bool && "true" || "false";
    }
    asDateTime(date) {
      if (date === null)
        return '""';
      if (date instanceof Date) {
        return '"' + date.toISOString() + '"';
      }
      if (typeof date === "string") {
        return '"' + date + '"';
      }
      throw new Error(`The value "${date}" cannot be converted to a date-time.`);
    }
    asDate(date) {
      if (date === null)
        return '""';
      if (date instanceof Date) {
        return '"' + new Date(date.getTime() - date.getTimezoneOffset() * 60000).toISOString().slice(0, 10) + '"';
      }
      if (typeof date === "string") {
        return '"' + date + '"';
      }
      throw new Error(`The value "${date}" cannot be converted to a date.`);
    }
    asTime(date) {
      if (date === null)
        return '""';
      if (date instanceof Date) {
        return '"' + new Date(date.getTime() - date.getTimezoneOffset() * 60000).toISOString().slice(11, 19) + '"';
      }
      if (typeof date === "string") {
        return '"' + date + '"';
      }
      throw new Error(`The value "${date}" cannot be converted to a time.`);
    }
    asString(str) {
      if (typeof str !== "string") {
        if (str === null) {
          return '""';
        }
        if (str instanceof Date) {
          return '"' + str.toISOString() + '"';
        }
        if (str instanceof RegExp) {
          str = str.source;
        } else {
          str = str.toString();
        }
      }
      if (str.length < 42) {
        return this.asStringSmall(str);
      } else if (STR_ESCAPE.test(str) === false) {
        return '"' + str + '"';
      } else {
        return JSON.stringify(str);
      }
    }
    asStringSmall(str) {
      const len = str.length;
      let result = "";
      let last = -1;
      let point = 255;
      for (var i = 0;i < len; i++) {
        point = str.charCodeAt(i);
        if (point < 32) {
          return JSON.stringify(str);
        }
        if (point >= 55296 && point <= 57343) {
          return JSON.stringify(str);
        }
        if (point === 34 || point === 92) {
          last === -1 && (last = 0);
          result += str.slice(last, i) + "\\";
          last = i;
        }
      }
      return last === -1 && '"' + str + '"' || '"' + result + str.slice(last) + '"';
    }
    getState() {
      return this._options;
    }
    static restoreFromState(state) {
      return new Serializer(state);
    }
  };
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS((exports) => {
  var _ = function(strs, ...args) {
    const code = [strs[0]];
    let i = 0;
    while (i < args.length) {
      addCodeArg(code, args[i]);
      code.push(strs[++i]);
    }
    return new _Code(code);
  };
  var str = function(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args.length) {
      expr.push(plus);
      addCodeArg(expr, args[i]);
      expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
  };
  var addCodeArg = function(code, arg) {
    if (arg instanceof _Code)
      code.push(...arg._items);
    else if (arg instanceof Name)
      code.push(arg);
    else
      code.push(interpolate(arg));
  };
  var optimize = function(expr) {
    let i = 1;
    while (i < expr.length - 1) {
      if (expr[i] === plus) {
        const res = mergeExprItems(expr[i - 1], expr[i + 1]);
        if (res !== undefined) {
          expr.splice(i - 1, 3, res);
          continue;
        }
        expr[i++] = "+";
      }
      i++;
    }
  };
  var mergeExprItems = function(a, b) {
    if (b === '""')
      return a;
    if (a === '""')
      return b;
    if (typeof a == "string") {
      if (b instanceof Name || a[a.length - 1] !== '"')
        return;
      if (typeof b != "string")
        return `${a.slice(0, -1)}${b}"`;
      if (b[0] === '"')
        return a.slice(0, -1) + b.slice(1);
      return;
    }
    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
      return `"${a}${b.slice(1)}`;
    return;
  };
  var strConcat = function(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
  };
  var interpolate = function(x) {
    return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
  };
  var stringify14 = function(x) {
    return new _Code(safeStringify(x));
  };
  var safeStringify = function(x) {
    return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  };
  var getProperty = function(key) {
    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
  };
  var getEsmExportName = function(key) {
    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
      return new _Code(`${key}`);
    }
    throw new Error(`CodeGen: invalid export name: ${key}, use explicit \$id name mapping`);
  };
  var regexpCode = function(rx) {
    return new _Code(rx.toString());
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = undefined;

  class _CodeOrName {
  }
  exports._CodeOrName = _CodeOrName;
  exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;

  class Name extends _CodeOrName {
    constructor(s) {
      super();
      if (!exports.IDENTIFIER.test(s))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports.Name = Name;

  class _Code extends _CodeOrName {
    constructor(code) {
      super();
      this._items = typeof code === "string" ? [code] : code;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a2;
      return (_a2 = this._str) !== null && _a2 !== undefined ? _a2 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
    }
    get names() {
      var _a2;
      return (_a2 = this._names) !== null && _a2 !== undefined ? _a2 : this._names = this._items.reduce((names, c) => {
        if (c instanceof Name)
          names[c.str] = (names[c.str] || 0) + 1;
        return names;
      }, {});
    }
  }
  exports._Code = _Code;
  exports.nil = new _Code("");
  exports._ = _;
  var plus = new _Code("+");
  exports.str = str;
  exports.addCodeArg = addCodeArg;
  exports.strConcat = strConcat;
  exports.stringify = stringify14;
  exports.safeStringify = safeStringify;
  exports.getProperty = getProperty;
  exports.getEsmExportName = getEsmExportName;
  exports.regexpCode = regexpCode;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = undefined;
  var code_1 = require_code();

  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
  exports.varKinds = {
    const: new code_1.Name("const"),
    let: new code_1.Name("let"),
    var: new code_1.Name("var")
  };

  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
      return new code_1.Name(this._newName(prefix));
    }
    _newName(prefix) {
      const ng = this._names[prefix] || this._nameGroup(prefix);
      return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
      var _a2, _b2;
      if (((_b2 = (_a2 = this._parent) === null || _a2 === undefined ? undefined : _a2._prefixes) === null || _b2 === undefined ? undefined : _b2.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
        throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
      }
      return this._names[prefix] = { prefix, index: 0 };
    }
  }
  exports.Scope = Scope;

  class ValueScopeName extends code_1.Name {
    constructor(prefix, nameStr) {
      super(nameStr);
      this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
    }
  }
  exports.ValueScopeName = ValueScopeName;
  var line = (0, code_1._)`\n`;

  class ValueScope extends Scope {
    constructor(opts) {
      super(opts);
      this._values = {};
      this._scope = opts.scope;
      this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
    }
    get() {
      return this._scope;
    }
    name(prefix) {
      return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
      var _a2;
      if (value.ref === undefined)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix } = name;
      const valueKey = (_a2 = value.key) !== null && _a2 !== undefined ? _a2 : value.ref;
      let vs = this._values[prefix];
      if (vs) {
        const _name = vs.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs = this._values[prefix] = new Map;
      }
      vs.set(valueKey, name);
      const s = this._scope[prefix] || (this._scope[prefix] = []);
      const itemIndex = s.length;
      s[itemIndex] = value.ref;
      name.setValue(value, { property: prefix, itemIndex });
      return name;
    }
    getValue(prefix, keyOrRef) {
      const vs = this._values[prefix];
      if (!vs)
        return;
      return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name) => {
        if (name.scopePath === undefined)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return (0, code_1._)`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name) => {
        if (name.value === undefined)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code = code_1.nil;
      for (const prefix in values) {
        const vs = values[prefix];
        if (!vs)
          continue;
        const nameSet = usedValues[prefix] = usedValues[prefix] || new Map;
        vs.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c = valueCode(name);
          if (c) {
            const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
            code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
          } else if (c = getCode === null || getCode === undefined ? undefined : getCode(name)) {
            code = (0, code_1._)`${code}${c}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code;
    }
  }
  exports.ValueScope = ValueScope;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS((exports) => {
  var addNames = function(names, from) {
    for (const n in from)
      names[n] = (names[n] || 0) + (from[n] || 0);
    return names;
  };
  var addExprNames = function(names, from) {
    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
  };
  var optimizeExpr = function(expr, names, constants) {
    if (expr instanceof code_1.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_1._Code(expr._items.reduce((items, c) => {
      if (c instanceof code_1.Name)
        c = replaceName(c);
      if (c instanceof code_1._Code)
        items.push(...c._items);
      else
        items.push(c);
      return items;
    }, []));
    function replaceName(n) {
      const c = constants[n.str];
      if (c === undefined || names[n.str] !== 1)
        return n;
      delete names[n.str];
      return c;
    }
    function canOptimize(e) {
      return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined);
    }
  };
  var subtractNames = function(names, from) {
    for (const n in from)
      names[n] = (names[n] || 0) - (from[n] || 0);
  };
  var not = function(x) {
    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
  };
  var and = function(...args) {
    return args.reduce(andCode);
  };
  var or = function(...args) {
    return args.reduce(orCode);
  };
  var mappend = function(op) {
    return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
  };
  var par = function(x) {
    return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = undefined;
  var code_1 = require_code();
  var scope_1 = require_scope2();
  var code_2 = require_code();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = require_scope2();
  Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports.operators = {
    GT: new code_1._Code(">"),
    GTE: new code_1._Code(">="),
    LT: new code_1._Code("<"),
    LTE: new code_1._Code("<="),
    EQ: new code_1._Code("==="),
    NEQ: new code_1._Code("!=="),
    NOT: new code_1._Code("!"),
    OR: new code_1._Code("||"),
    AND: new code_1._Code("&&"),
    ADD: new code_1._Code("+")
  };

  class Node {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }

  class Def extends Node {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names, constants) {
      if (!names[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names, constants);
      return this;
    }
    get names() {
      return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
    }
  }

  class Assign extends Node {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n }) {
      return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names, constants) {
      if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names, constants);
      return this;
    }
    get names() {
      const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
      return addExprNames(names, this.rhs);
    }
  }

  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
  }

  class Label extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      return `${this.label}:` + _n;
    }
  }

  class Break extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n;
    }
  }

  class Throw extends Node {
    constructor(error) {
      super();
      this.error = error;
    }
    render({ _n }) {
      return `throw ${this.error};` + _n;
    }
    get names() {
      return this.error.names;
    }
  }

  class AnyCode extends Node {
    constructor(code) {
      super();
      this.code = code;
    }
    render({ _n }) {
      return `${this.code};` + _n;
    }
    optimizeNodes() {
      return `${this.code}` ? this : undefined;
    }
    optimizeNames(names, constants) {
      this.code = optimizeExpr(this.code, names, constants);
      return this;
    }
    get names() {
      return this.code instanceof code_1._CodeOrName ? this.code.names : {};
    }
  }

  class ParentNode extends Node {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts) {
      return this.nodes.reduce((code, n) => code + n.render(opts), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i].optimizeNodes();
        if (Array.isArray(n))
          nodes.splice(i, 1, ...n);
        else if (n)
          nodes[i] = n;
        else
          nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : undefined;
    }
    optimizeNames(names, constants) {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i];
        if (n.optimizeNames(names, constants))
          continue;
        subtractNames(names, n.names);
        nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : undefined;
    }
    get names() {
      return this.nodes.reduce((names, n) => addNames(names, n.names), {});
    }
  }

  class BlockNode extends ParentNode {
    render(opts) {
      return "{" + opts._n + super.render(opts) + "}" + opts._n;
    }
  }

  class Root extends ParentNode {
  }

  class Else extends BlockNode {
  }
  Else.kind = "else";

  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts) {
      let code = `if(${this.condition})` + super.render(opts);
      if (this.else)
        code += "else " + this.else.render(opts);
      return code;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e = this.else;
      if (e) {
        const ns = e.optimizeNodes();
        e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
      }
      if (e) {
        if (cond === false)
          return e instanceof If ? e : e.nodes;
        if (this.nodes.length)
          return this;
        return new If(not(cond), e instanceof If ? [e] : e.nodes);
      }
      if (cond === false || !this.nodes.length)
        return;
      return this;
    }
    optimizeNames(names, constants) {
      var _a2;
      this.else = (_a2 = this.else) === null || _a2 === undefined ? undefined : _a2.optimizeNames(names, constants);
      if (!(super.optimizeNames(names, constants) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names, constants);
      return this;
    }
    get names() {
      const names = super.names;
      addExprNames(names, this.condition);
      if (this.else)
        addNames(names, this.else.names);
      return names;
    }
  }
  If.kind = "if";

  class For extends BlockNode {
  }
  For.kind = "for";

  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts) {
      return `for(${this.iteration})` + super.render(opts);
    }
    optimizeNames(names, constants) {
      if (!super.optimizeNames(names, constants))
        return;
      this.iteration = optimizeExpr(this.iteration, names, constants);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }

  class ForRange extends For {
    constructor(varKind, name, from, to) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from;
      this.to = to;
    }
    render(opts) {
      const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from, to } = this;
      return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
    }
    get names() {
      const names = addExprNames(super.names, this.from);
      return addExprNames(names, this.to);
    }
  }

  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
    }
    optimizeNames(names, constants) {
      if (!super.optimizeNames(names, constants))
        return;
      this.iterable = optimizeExpr(this.iterable, names, constants);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }

  class Func extends BlockNode {
    constructor(name, args, async) {
      super();
      this.name = name;
      this.args = args;
      this.async = async;
    }
    render(opts) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts);
    }
  }
  Func.kind = "func";

  class Return extends ParentNode {
    render(opts) {
      return "return " + super.render(opts);
    }
  }
  Return.kind = "return";

  class Try extends BlockNode {
    render(opts) {
      let code = "try" + super.render(opts);
      if (this.catch)
        code += this.catch.render(opts);
      if (this.finally)
        code += this.finally.render(opts);
      return code;
    }
    optimizeNodes() {
      var _a2, _b2;
      super.optimizeNodes();
      (_a2 = this.catch) === null || _a2 === undefined || _a2.optimizeNodes();
      (_b2 = this.finally) === null || _b2 === undefined || _b2.optimizeNodes();
      return this;
    }
    optimizeNames(names, constants) {
      var _a2, _b2;
      super.optimizeNames(names, constants);
      (_a2 = this.catch) === null || _a2 === undefined || _a2.optimizeNames(names, constants);
      (_b2 = this.finally) === null || _b2 === undefined || _b2.optimizeNames(names, constants);
      return this;
    }
    get names() {
      const names = super.names;
      if (this.catch)
        addNames(names, this.catch.names);
      if (this.finally)
        addNames(names, this.finally.names);
      return names;
    }
  }

  class Catch extends BlockNode {
    constructor(error) {
      super();
      this.error = error;
    }
    render(opts) {
      return `catch(${this.error})` + super.render(opts);
    }
  }
  Catch.kind = "catch";

  class Finally extends BlockNode {
    render(opts) {
      return "finally" + super.render(opts);
    }
  }
  Finally.kind = "finally";

  class CodeGen {
    constructor(extScope, opts = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root];
    }
    toString() {
      return this._root.render(this.opts);
    }
    name(prefix) {
      return this._scope.name(prefix);
    }
    scopeName(prefix) {
      return this._extScope.name(prefix);
    }
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set);
      vs.add(name);
      return name;
    }
    getScopeValue(prefix, keyOrRef) {
      return this._extScope.getValue(prefix, keyOrRef);
    }
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== undefined && constant)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
    }
    code(c) {
      if (typeof c == "function")
        c();
      else if (c !== code_1.nil)
        this._leafNode(new AnyCode(c));
      return this;
    }
    object(...keyValues) {
      const code = ["{"];
      for (const [key, value] of keyValues) {
        if (code.length > 1)
          code.push(",");
        code.push(key);
        if (key !== value || this.opts.es5) {
          code.push(":");
          (0, code_1.addCodeArg)(code, value);
        }
      }
      code.push("}");
      return new code_1._Code(code);
    }
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    else() {
      return this._elseNode(new Else);
    }
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node9, forBody) {
      this._blockNode(node9);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    }
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
          this.var(name, (0, code_1._)`${arr}[${i}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    endFor() {
      return this._endBlockNode(For);
    }
    label(label) {
      return this._leafNode(new Label(label));
    }
    break(label) {
      return this._leafNode(new Break(label));
    }
    return(value) {
      const node9 = new Return;
      this._blockNode(node9);
      this.code(value);
      if (node9.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node9 = new Try;
      this._blockNode(node9);
      this.code(tryBody);
      if (catchCode) {
        const error = this.name("e");
        this._currNode = node9.catch = new Catch(error);
        catchCode(error);
      }
      if (finallyCode) {
        this._currNode = node9.finally = new Finally;
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    throw(error) {
      return this._leafNode(new Throw(error));
    }
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === undefined)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== undefined && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    func(name, args = code_1.nil, async, funcBody) {
      this._blockNode(new Func(name, args, async));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n = 1) {
      while (n-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node9) {
      this._currNode.nodes.push(node9);
      return this;
    }
    _blockNode(node9) {
      this._currNode.nodes.push(node9);
      this._nodes.push(node9);
    }
    _endBlockNode(N1, N2) {
      const n = this._currNode;
      if (n instanceof N1 || N2 && n instanceof N2) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node9) {
      const n = this._currNode;
      if (!(n instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n.else = node9;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns = this._nodes;
      return ns[ns.length - 1];
    }
    set _currNode(node9) {
      const ns = this._nodes;
      ns[ns.length - 1] = node9;
    }
  }
  exports.CodeGen = CodeGen;
  exports.not = not;
  var andCode = mappend(exports.operators.AND);
  exports.and = and;
  var orCode = mappend(exports.operators.OR);
  exports.or = or;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/util.js
var require_util3 = __commonJS((exports) => {
  var toHash = function(arr) {
    const hash4 = {};
    for (const item of arr)
      hash4[item] = true;
    return hash4;
  };
  var alwaysValidSchema = function(it, schema) {
    if (typeof schema == "boolean")
      return schema;
    if (Object.keys(schema).length === 0)
      return true;
    checkUnknownRules(it, schema);
    return !schemaHasRules(schema, it.self.RULES.all);
  };
  var checkUnknownRules = function(it, schema = it.schema) {
    const { opts, self: self2 } = it;
    if (!opts.strictSchema)
      return;
    if (typeof schema === "boolean")
      return;
    const rules = self2.RULES.keywords;
    for (const key in schema) {
      if (!rules[key])
        checkStrictMode(it, `unknown keyword: "${key}"`);
    }
  };
  var schemaHasRules = function(schema, rules) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (rules[key])
        return true;
    return false;
  };
  var schemaHasRulesButRef = function(schema, RULES) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (key !== "$ref" && RULES.all[key])
        return true;
    return false;
  };
  var schemaRefOrVal = function({ topSchemaRef, schemaPath }, schema, keyword, $data) {
    if (!$data) {
      if (typeof schema == "number" || typeof schema == "boolean")
        return schema;
      if (typeof schema == "string")
        return (0, codegen_1._)`${schema}`;
    }
    return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
  };
  var unescapeFragment = function(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
  };
  var escapeFragment = function(str) {
    return encodeURIComponent(escapeJsonPointer(str));
  };
  var escapeJsonPointer = function(str) {
    if (typeof str == "number")
      return `${str}`;
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  };
  var unescapeJsonPointer = function(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
  };
  var eachItem = function(xs, f) {
    if (Array.isArray(xs)) {
      for (const x of xs)
        f(x);
    } else {
      f(xs);
    }
  };
  var makeMergeEvaluated = function({ mergeNames, mergeToName, mergeValues: mergeValues2, resultToName }) {
    return (gen2, from, to, toName) => {
      const res = to === undefined ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen2, from, to) : mergeToName(gen2, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen2, to, from), from) : mergeValues2(from, to);
      return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen2, res) : res;
    };
  };
  var evaluatedPropsToName = function(gen2, ps) {
    if (ps === true)
      return gen2.var("props", true);
    const props = gen2.var("props", (0, codegen_1._)`{}`);
    if (ps !== undefined)
      setEvaluated(gen2, props, ps);
    return props;
  };
  var setEvaluated = function(gen2, props, ps) {
    Object.keys(ps).forEach((p) => gen2.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
  };
  var useFunc = function(gen2, f) {
    return gen2.scopeValue("func", {
      ref: f,
      code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
    });
  };
  var getErrorPath = function(dataProp, dataPropType, jsPropertySyntax) {
    if (dataProp instanceof codegen_1.Name) {
      const isNumber = dataPropType === Type.Num;
      return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
  };
  var checkStrictMode = function(it, msg, mode = it.opts.strictSchema) {
    if (!mode)
      return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
      throw new Error(msg);
    it.self.logger.warn(msg);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = undefined;
  var codegen_1 = require_codegen();
  var code_1 = require_code();
  exports.toHash = toHash;
  exports.alwaysValidSchema = alwaysValidSchema;
  exports.checkUnknownRules = checkUnknownRules;
  exports.schemaHasRules = schemaHasRules;
  exports.schemaHasRulesButRef = schemaHasRulesButRef;
  exports.schemaRefOrVal = schemaRefOrVal;
  exports.unescapeFragment = unescapeFragment;
  exports.escapeFragment = escapeFragment;
  exports.escapeJsonPointer = escapeJsonPointer;
  exports.unescapeJsonPointer = unescapeJsonPointer;
  exports.eachItem = eachItem;
  exports.mergeEvaluated = {
    props: makeMergeEvaluated({
      mergeNames: (gen2, from, to) => gen2.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
        gen2.if((0, codegen_1._)`${from} === true`, () => gen2.assign(to, true), () => gen2.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
      }),
      mergeToName: (gen2, from, to) => gen2.if((0, codegen_1._)`${to} !== true`, () => {
        if (from === true) {
          gen2.assign(to, true);
        } else {
          gen2.assign(to, (0, codegen_1._)`${to} || {}`);
          setEvaluated(gen2, to, from);
        }
      }),
      mergeValues: (from, to) => from === true ? true : { ...from, ...to },
      resultToName: evaluatedPropsToName
    }),
    items: makeMergeEvaluated({
      mergeNames: (gen2, from, to) => gen2.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen2.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
      mergeToName: (gen2, from, to) => gen2.if((0, codegen_1._)`${to} !== true`, () => gen2.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
      mergeValues: (from, to) => from === true ? true : Math.max(from, to),
      resultToName: (gen2, items) => gen2.var("items", items)
    })
  };
  exports.evaluatedPropsToName = evaluatedPropsToName;
  exports.setEvaluated = setEvaluated;
  var snippets = {};
  exports.useFunc = useFunc;
  var Type;
  (function(Type2) {
    Type2[Type2["Num"] = 0] = "Num";
    Type2[Type2["Str"] = 1] = "Str";
  })(Type = exports.Type || (exports.Type = {}));
  exports.getErrorPath = getErrorPath;
  exports.checkStrictMode = checkStrictMode;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/names.js
var require_names = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var names = {
    data: new codegen_1.Name("data"),
    valCxt: new codegen_1.Name("valCxt"),
    instancePath: new codegen_1.Name("instancePath"),
    parentData: new codegen_1.Name("parentData"),
    parentDataProperty: new codegen_1.Name("parentDataProperty"),
    rootData: new codegen_1.Name("rootData"),
    dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
    vErrors: new codegen_1.Name("vErrors"),
    errors: new codegen_1.Name("errors"),
    this: new codegen_1.Name("this"),
    self: new codegen_1.Name("self"),
    scope: new codegen_1.Name("scope"),
    json: new codegen_1.Name("json"),
    jsonPos: new codegen_1.Name("jsonPos"),
    jsonLen: new codegen_1.Name("jsonLen"),
    jsonPart: new codegen_1.Name("jsonPart")
  };
  exports.default = names;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/errors.js
var require_errors5 = __commonJS((exports) => {
  var reportError = function(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
    const { it } = cxt;
    const { gen: gen2, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== undefined ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen2, errObj);
    } else {
      returnErrors(it, (0, codegen_1._)`[${errObj}]`);
    }
  };
  var reportExtraError = function(cxt, error = exports.keywordError, errorPaths) {
    const { it } = cxt;
    const { gen: gen2, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error, errorPaths);
    addError(gen2, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it, names_1.default.vErrors);
    }
  };
  var resetErrorsCount = function(gen2, errsCount) {
    gen2.assign(names_1.default.errors, errsCount);
    gen2.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen2.if(errsCount, () => gen2.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen2.assign(names_1.default.vErrors, null)));
  };
  var extendErrors = function({ gen: gen2, keyword, schemaValue, data: data3, errsCount, it }) {
    if (errsCount === undefined)
      throw new Error("ajv implementation error");
    const err = gen2.name("err");
    gen2.forRange("i", errsCount, names_1.default.errors, (i) => {
      gen2.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
      gen2.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen2.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
      gen2.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
      if (it.opts.verbose) {
        gen2.assign((0, codegen_1._)`${err}.schema`, schemaValue);
        gen2.assign((0, codegen_1._)`${err}.data`, data3);
      }
    });
  };
  var addError = function(gen2, errObj) {
    const err = gen2.const("err", errObj);
    gen2.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen2.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
    gen2.code((0, codegen_1._)`${names_1.default.errors}++`);
  };
  var returnErrors = function(it, errs) {
    const { gen: gen2, validateName, schemaEnv } = it;
    if (schemaEnv.$async) {
      gen2.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
    } else {
      gen2.assign((0, codegen_1._)`${validateName}.errors`, errs);
      gen2.return(false);
    }
  };
  var errorObjectCode = function(cxt, error, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return (0, codegen_1._)`{}`;
    return errorObject(cxt, error, errorPaths);
  };
  var errorObject = function(cxt, error, errorPaths = {}) {
    const { gen: gen2, it } = cxt;
    const keyValues = [
      errorInstancePath(it, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error, keyValues);
    return gen2.object(...keyValues);
  };
  var errorInstancePath = function({ errorPath }, { instancePath }) {
    const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
  };
  var errorSchemaPath = function({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
    if (schemaPath) {
      schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
    }
    return [E.schemaPath, schPath];
  };
  var extraErrorProps = function(cxt, { params, message }, keyValues) {
    const { keyword, data: data3, schemaValue, it } = cxt;
    const { opts, propertyName, topSchemaRef, schemaPath } = it;
    keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
    if (opts.messages) {
      keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts.verbose) {
      keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data3]);
    }
    if (propertyName)
      keyValues.push([E.propertyName, propertyName]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util3();
  var names_1 = require_names();
  exports.keywordError = {
    message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
  };
  exports.keyword$DataError = {
    message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
  };
  exports.reportError = reportError;
  exports.reportExtraError = reportExtraError;
  exports.resetErrorsCount = resetErrorsCount;
  exports.extendErrors = extendErrors;
  var E = {
    keyword: new codegen_1.Name("keyword"),
    schemaPath: new codegen_1.Name("schemaPath"),
    params: new codegen_1.Name("params"),
    propertyName: new codegen_1.Name("propertyName"),
    message: new codegen_1.Name("message"),
    schema: new codegen_1.Name("schema"),
    parentSchema: new codegen_1.Name("parentSchema")
  };
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS((exports) => {
  var topBoolOrEmptySchema = function(it) {
    const { gen: gen2, schema, validateName } = it;
    if (schema === false) {
      falseSchemaError(it, false);
    } else if (typeof schema == "object" && schema.$async === true) {
      gen2.return(names_1.default.data);
    } else {
      gen2.assign((0, codegen_1._)`${validateName}.errors`, null);
      gen2.return(true);
    }
  };
  var boolOrEmptySchema = function(it, valid) {
    const { gen: gen2, schema } = it;
    if (schema === false) {
      gen2.var(valid, false);
      falseSchemaError(it);
    } else {
      gen2.var(valid, true);
    }
  };
  var falseSchemaError = function(it, overrideAllErrors) {
    const { gen: gen2, data: data3 } = it;
    const cxt = {
      gen: gen2,
      keyword: "false schema",
      data: data3,
      schema: false,
      schemaCode: false,
      schemaValue: false,
      params: {},
      it
    };
    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = undefined;
  var errors_1 = require_errors5();
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var boolError = {
    message: "boolean schema is false"
  };
  exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
  exports.boolOrEmptySchema = boolOrEmptySchema;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS((exports) => {
  var isJSONType = function(x) {
    return typeof x == "string" && jsonTypes.has(x);
  };
  var getRules = function() {
    const groups = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...groups, integer: true, boolean: true, null: true },
      rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRules = exports.isJSONType = undefined;
  var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
  var jsonTypes = new Set(_jsonTypes);
  exports.isJSONType = isJSONType;
  exports.getRules = getRules;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS((exports) => {
  var schemaHasRulesForType = function({ schema, self: self2 }, type) {
    const group = self2.RULES.types[type];
    return group && group !== true && shouldUseGroup(schema, group);
  };
  var shouldUseGroup = function(schema, group) {
    return group.rules.some((rule) => shouldUseRule(schema, rule));
  };
  var shouldUseRule = function(schema, rule) {
    var _a2;
    return schema[rule.keyword] !== undefined || ((_a2 = rule.definition.implements) === null || _a2 === undefined ? undefined : _a2.some((kwd) => schema[kwd] !== undefined));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = undefined;
  exports.schemaHasRulesForType = schemaHasRulesForType;
  exports.shouldUseGroup = shouldUseGroup;
  exports.shouldUseRule = shouldUseRule;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS((exports) => {
  var getSchemaTypes = function(schema) {
    const types12 = getJSONTypes(schema.type);
    const hasNull = types12.includes("null");
    if (hasNull) {
      if (schema.nullable === false)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!types12.length && schema.nullable !== undefined) {
        throw new Error('"nullable" cannot be used without "type"');
      }
      if (schema.nullable === true)
        types12.push("null");
    }
    return types12;
  };
  var getJSONTypes = function(ts) {
    const types12 = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types12.every(rules_1.isJSONType))
      return types12;
    throw new Error("type must be JSONType or JSONType[]: " + types12.join(","));
  };
  var coerceAndCheckDataType = function(it, types12) {
    const { gen: gen2, data: data3, opts } = it;
    const coerceTo = coerceToTypes(types12, opts.coerceTypes);
    const checkTypes = types12.length > 0 && !(coerceTo.length === 0 && types12.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types12[0]));
    if (checkTypes) {
      const wrongType = checkDataTypes(types12, data3, opts.strictNumbers, DataType.Wrong);
      gen2.if(wrongType, () => {
        if (coerceTo.length)
          coerceData(it, types12, coerceTo);
        else
          reportTypeError(it);
      });
    }
    return checkTypes;
  };
  var coerceToTypes = function(types12, coerceTypes) {
    return coerceTypes ? types12.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
  };
  var coerceData = function(it, types12, coerceTo) {
    const { gen: gen2, data: data3, opts } = it;
    const dataType = gen2.let("dataType", (0, codegen_1._)`typeof ${data3}`);
    const coerced = gen2.let("coerced", (0, codegen_1._)`undefined`);
    if (opts.coerceTypes === "array") {
      gen2.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data3}) && ${data3}.length == 1`, () => gen2.assign(data3, (0, codegen_1._)`${data3}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data3}`).if(checkDataTypes(types12, data3, opts.strictNumbers), () => gen2.assign(coerced, data3)));
    }
    gen2.if((0, codegen_1._)`${coerced} !== undefined`);
    for (const t of coerceTo) {
      if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
        coerceSpecificType(t);
      }
    }
    gen2.else();
    reportTypeError(it);
    gen2.endIf();
    gen2.if((0, codegen_1._)`${coerced} !== undefined`, () => {
      gen2.assign(data3, coerced);
      assignParentData(it, coerced);
    });
    function coerceSpecificType(t) {
      switch (t) {
        case "string":
          gen2.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data3}`).elseIf((0, codegen_1._)`${data3} === null`).assign(coerced, (0, codegen_1._)`""`);
          return;
        case "number":
          gen2.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data3} === null
              || (${dataType} == "string" && ${data3} && ${data3} == +${data3})`).assign(coerced, (0, codegen_1._)`+${data3}`);
          return;
        case "integer":
          gen2.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data3} === null
              || (${dataType} === "string" && ${data3} && ${data3} == +${data3} && !(${data3} % 1))`).assign(coerced, (0, codegen_1._)`+${data3}`);
          return;
        case "boolean":
          gen2.elseIf((0, codegen_1._)`${data3} === "false" || ${data3} === 0 || ${data3} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data3} === "true" || ${data3} === 1`).assign(coerced, true);
          return;
        case "null":
          gen2.elseIf((0, codegen_1._)`${data3} === "" || ${data3} === 0 || ${data3} === false`);
          gen2.assign(coerced, null);
          return;
        case "array":
          gen2.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data3} === null`).assign(coerced, (0, codegen_1._)`[${data3}]`);
      }
    }
  };
  var assignParentData = function({ gen: gen2, parentData, parentDataProperty }, expr) {
    gen2.if((0, codegen_1._)`${parentData} !== undefined`, () => gen2.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
  };
  var checkDataType = function(dataType, data3, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
    let cond;
    switch (dataType) {
      case "null":
        return (0, codegen_1._)`${data3} ${EQ} null`;
      case "array":
        cond = (0, codegen_1._)`Array.isArray(${data3})`;
        break;
      case "object":
        cond = (0, codegen_1._)`${data3} && typeof ${data3} == "object" && !Array.isArray(${data3})`;
        break;
      case "integer":
        cond = numCond((0, codegen_1._)`!(${data3} % 1) && !isNaN(${data3})`);
        break;
      case "number":
        cond = numCond();
        break;
      default:
        return (0, codegen_1._)`typeof ${data3} ${EQ} ${dataType}`;
    }
    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
    function numCond(_cond = codegen_1.nil) {
      return (0, codegen_1.and)((0, codegen_1._)`typeof ${data3} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data3})` : codegen_1.nil);
    }
  };
  var checkDataTypes = function(dataTypes, data3, strictNums, correct) {
    if (dataTypes.length === 1) {
      return checkDataType(dataTypes[0], data3, strictNums, correct);
    }
    let cond;
    const types12 = (0, util_1.toHash)(dataTypes);
    if (types12.array && types12.object) {
      const notObj = (0, codegen_1._)`typeof ${data3} != "object"`;
      cond = types12.null ? notObj : (0, codegen_1._)`!${data3} || ${notObj}`;
      delete types12.null;
      delete types12.array;
      delete types12.object;
    } else {
      cond = codegen_1.nil;
    }
    if (types12.number)
      delete types12.integer;
    for (const t in types12)
      cond = (0, codegen_1.and)(cond, checkDataType(t, data3, strictNums, correct));
    return cond;
  };
  var reportTypeError = function(it) {
    const cxt = getTypeErrorContext(it);
    (0, errors_1.reportError)(cxt, typeError);
  };
  var getTypeErrorContext = function(it) {
    const { gen: gen2, data: data3, schema } = it;
    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
    return {
      gen: gen2,
      keyword: "type",
      data: data3,
      schema: schema.type,
      schemaCode,
      schemaValue: schemaCode,
      parentSchema: schema,
      params: {},
      it
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = undefined;
  var rules_1 = require_rules();
  var applicability_1 = require_applicability();
  var errors_1 = require_errors5();
  var codegen_1 = require_codegen();
  var util_1 = require_util3();
  var DataType;
  (function(DataType2) {
    DataType2[DataType2["Correct"] = 0] = "Correct";
    DataType2[DataType2["Wrong"] = 1] = "Wrong";
  })(DataType = exports.DataType || (exports.DataType = {}));
  exports.getSchemaTypes = getSchemaTypes;
  exports.getJSONTypes = getJSONTypes;
  exports.coerceAndCheckDataType = coerceAndCheckDataType;
  var COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
  exports.checkDataType = checkDataType;
  exports.checkDataTypes = checkDataTypes;
  var typeError = {
    message: ({ schema }) => `must be ${schema}`,
    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
  };
  exports.reportTypeError = reportTypeError;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS((exports) => {
  var assignDefaults = function(it, ty) {
    const { properties, items } = it.schema;
    if (ty === "object" && properties) {
      for (const key in properties) {
        assignDefault(it, key, properties[key].default);
      }
    } else if (ty === "array" && Array.isArray(items)) {
      items.forEach((sch, i) => assignDefault(it, i, sch.default));
    }
  };
  var assignDefault = function(it, prop, defaultValue) {
    const { gen: gen2, compositeRule, data: data3, opts } = it;
    if (defaultValue === undefined)
      return;
    const childData = (0, codegen_1._)`${data3}${(0, codegen_1.getProperty)(prop)}`;
    if (compositeRule) {
      (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
      return;
    }
    let condition = (0, codegen_1._)`${childData} === undefined`;
    if (opts.useDefaults === "empty") {
      condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
    }
    gen2.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assignDefaults = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util3();
  exports.assignDefaults = assignDefaults;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS((exports) => {
  var checkReportMissingProp = function(cxt, prop) {
    const { gen: gen2, data: data3, it } = cxt;
    gen2.if(noPropertyInData(gen2, data3, prop, it.opts.ownProperties), () => {
      cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
      cxt.error();
    });
  };
  var checkMissingProp = function({ gen: gen2, data: data3, it: { opts } }, properties, missing) {
    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen2, data3, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
  };
  var reportMissingProp = function(cxt, missing) {
    cxt.setParams({ missingProperty: missing }, true);
    cxt.error();
  };
  var hasPropFunc = function(gen2) {
    return gen2.scopeValue("func", {
      ref: Object.prototype.hasOwnProperty,
      code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
    });
  };
  var isOwnProperty = function(gen2, data3, property) {
    return (0, codegen_1._)`${hasPropFunc(gen2)}.call(${data3}, ${property})`;
  };
  var propertyInData = function(gen2, data3, property, ownProperties) {
    const cond = (0, codegen_1._)`${data3}${(0, codegen_1.getProperty)(property)} !== undefined`;
    return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen2, data3, property)}` : cond;
  };
  var noPropertyInData = function(gen2, data3, property, ownProperties) {
    const cond = (0, codegen_1._)`${data3}${(0, codegen_1.getProperty)(property)} === undefined`;
    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen2, data3, property))) : cond;
  };
  var allSchemaProperties = function(schemaMap) {
    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
  };
  var schemaProperties = function(it, schemaMap) {
    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
  };
  var callValidateCode = function({ schemaCode, data: data3, it: { gen: gen2, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
    const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data3}, ${topSchemaRef}${schemaPath}` : data3;
    const valCxt = [
      [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
      [names_1.default.parentData, it.parentData],
      [names_1.default.parentDataProperty, it.parentDataProperty],
      [names_1.default.rootData, names_1.default.rootData]
    ];
    if (it.opts.dynamicRef)
      valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
    const args = (0, codegen_1._)`${dataAndSchema}, ${gen2.object(...valCxt)}`;
    return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
  };
  var usePattern = function({ gen: gen2, it: { opts } }, pattern) {
    const u = opts.unicodeRegExp ? "u" : "";
    const { regExp } = opts.code;
    const rx = regExp(pattern, u);
    return gen2.scopeValue("pattern", {
      key: rx.toString(),
      ref: rx,
      code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen2, regExp)}(${pattern}, ${u})`
    });
  };
  var validateArray = function(cxt) {
    const { gen: gen2, data: data3, keyword, it } = cxt;
    const valid = gen2.name("valid");
    if (it.allErrors) {
      const validArr = gen2.let("valid", true);
      validateItems(() => gen2.assign(validArr, false));
      return validArr;
    }
    gen2.var(valid, true);
    validateItems(() => gen2.break());
    return valid;
    function validateItems(notValid) {
      const len = gen2.const("len", (0, codegen_1._)`${data3}.length`);
      gen2.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword,
          dataProp: i,
          dataPropType: util_1.Type.Num
        }, valid);
        gen2.if((0, codegen_1.not)(valid), notValid);
      });
    }
  };
  var validateUnion = function(cxt) {
    const { gen: gen2, schema, keyword, it } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
    if (alwaysValid && !it.opts.unevaluated)
      return;
    const valid = gen2.let("valid", false);
    const schValid = gen2.name("_valid");
    gen2.block(() => schema.forEach((_sch, i) => {
      const schCxt = cxt.subschema({
        keyword,
        schemaProp: i,
        compositeRule: true
      }, schValid);
      gen2.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
      const merged = cxt.mergeValidEvaluated(schCxt, schValid);
      if (!merged)
        gen2.if((0, codegen_1.not)(valid));
    }));
    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util3();
  var names_1 = require_names();
  var util_2 = require_util3();
  exports.checkReportMissingProp = checkReportMissingProp;
  exports.checkMissingProp = checkMissingProp;
  exports.reportMissingProp = reportMissingProp;
  exports.hasPropFunc = hasPropFunc;
  exports.isOwnProperty = isOwnProperty;
  exports.propertyInData = propertyInData;
  exports.noPropertyInData = noPropertyInData;
  exports.allSchemaProperties = allSchemaProperties;
  exports.schemaProperties = schemaProperties;
  exports.callValidateCode = callValidateCode;
  var newRegExp = (0, codegen_1._)`new RegExp`;
  exports.usePattern = usePattern;
  exports.validateArray = validateArray;
  exports.validateUnion = validateUnion;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS((exports) => {
  var macroKeywordCode = function(cxt, def) {
    const { gen: gen2, keyword, schema, parentSchema, it } = cxt;
    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
    const schemaRef = useKeyword(gen2, keyword, macroSchema);
    if (it.opts.validateSchema !== false)
      it.self.validateSchema(macroSchema, true);
    const valid = gen2.name("valid");
    cxt.subschema({
      schema: macroSchema,
      schemaPath: codegen_1.nil,
      errSchemaPath: `${it.errSchemaPath}/${keyword}`,
      topSchemaRef: schemaRef,
      compositeRule: true
    }, valid);
    cxt.pass(valid, () => cxt.error(true));
  };
  var funcKeywordCode = function(cxt, def) {
    var _a2;
    const { gen: gen2, keyword, schema, parentSchema, $data, it } = cxt;
    checkAsyncKeyword(it, def);
    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
    const validateRef = useKeyword(gen2, keyword, validate);
    const valid = gen2.let("valid");
    cxt.block$data(valid, validateKeyword);
    cxt.ok((_a2 = def.valid) !== null && _a2 !== undefined ? _a2 : valid);
    function validateKeyword() {
      if (def.errors === false) {
        assignValid();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => cxt.error());
      } else {
        const ruleErrs = def.async ? validateAsync() : validateSync();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => addErrs(cxt, ruleErrs));
      }
    }
    function validateAsync() {
      const ruleErrs = gen2.let("ruleErrs", null);
      gen2.try(() => assignValid((0, codegen_1._)`await `), (e) => gen2.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen2.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen2.throw(e)));
      return ruleErrs;
    }
    function validateSync() {
      const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
      gen2.assign(validateErrs, null);
      assignValid(codegen_1.nil);
      return validateErrs;
    }
    function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
      const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
      const passSchema = !(("compile" in def) && !$data || def.schema === false);
      gen2.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
    }
    function reportErrs(errors4) {
      var _a3;
      gen2.if((0, codegen_1.not)((_a3 = def.valid) !== null && _a3 !== undefined ? _a3 : valid), errors4);
    }
  };
  var modifyData = function(cxt) {
    const { gen: gen2, data: data3, it } = cxt;
    gen2.if(it.parentData, () => gen2.assign(data3, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
  };
  var addErrs = function(cxt, errs) {
    const { gen: gen2 } = cxt;
    gen2.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
      gen2.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      (0, errors_1.extendErrors)(cxt);
    }, () => cxt.error());
  };
  var checkAsyncKeyword = function({ schemaEnv }, def) {
    if (def.async && !schemaEnv.$async)
      throw new Error("async keyword in sync schema");
  };
  var useKeyword = function(gen2, keyword, result) {
    if (result === undefined)
      throw new Error(`keyword "${keyword}" failed to compile`);
    return gen2.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
  };
  var validSchemaType = function(schema, schemaType, allowUndefined = false) {
    return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
  };
  var validateKeywordUsage = function({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
      throw new Error("ajv implementation error");
    }
    const deps = def.dependencies;
    if (deps === null || deps === undefined ? undefined : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
      throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
    }
    if (def.validateSchema) {
      const valid = def.validateSchema(schema[keyword]);
      if (!valid) {
        const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
        if (opts.validateSchema === "log")
          self2.logger.error(msg);
        else
          throw new Error(msg);
      }
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = undefined;
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var code_1 = require_code2();
  var errors_1 = require_errors5();
  exports.macroKeywordCode = macroKeywordCode;
  exports.funcKeywordCode = funcKeywordCode;
  exports.validSchemaType = validSchemaType;
  exports.validateKeywordUsage = validateKeywordUsage;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS((exports) => {
  var getSubschema = function(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
    if (keyword !== undefined && schema !== undefined) {
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    }
    if (keyword !== undefined) {
      const sch = it.schema[keyword];
      return schemaProp === undefined ? {
        schema: sch,
        schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`
      } : {
        schema: sch[schemaProp],
        schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
        errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
      };
    }
    if (schema !== undefined) {
      if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      }
      return {
        schema,
        schemaPath,
        topSchemaRef,
        errSchemaPath
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  };
  var extendSubschemaData = function(subschema, it, { dataProp, dataPropType: dpType, data: data3, dataTypes, propertyName }) {
    if (data3 !== undefined && dataProp !== undefined) {
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    }
    const { gen: gen2 } = it;
    if (dataProp !== undefined) {
      const { errorPath, dataPathArr, opts } = it;
      const nextData = gen2.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
      dataContextProps(nextData);
      subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
      subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
      subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
    }
    if (data3 !== undefined) {
      const nextData = data3 instanceof codegen_1.Name ? data3 : gen2.let("data", data3, true);
      dataContextProps(nextData);
      if (propertyName !== undefined)
        subschema.propertyName = propertyName;
    }
    if (dataTypes)
      subschema.dataTypes = dataTypes;
    function dataContextProps(_nextData) {
      subschema.data = _nextData;
      subschema.dataLevel = it.dataLevel + 1;
      subschema.dataTypes = [];
      it.definedProperties = new Set;
      subschema.parentData = it.data;
      subschema.dataNames = [...it.dataNames, _nextData];
    }
  };
  var extendSubschemaMode = function(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
    if (compositeRule !== undefined)
      subschema.compositeRule = compositeRule;
    if (createErrors !== undefined)
      subschema.createErrors = createErrors;
    if (allErrors !== undefined)
      subschema.allErrors = allErrors;
    subschema.jtdDiscriminator = jtdDiscriminator;
    subschema.jtdMetadata = jtdMetadata;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util3();
  exports.getSubschema = getSubschema;
  exports.extendSubschemaData = extendSubschemaData;
  exports.extendSubschemaMode = extendSubschemaMode;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/find-my-way@8.1.0/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS((exports, module) => {
  module.exports = function equal(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor)
        return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length;i-- !== 0; )
          if (!equal(a[i], b[i]))
            return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf)
        return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString)
        return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length)
        return false;
      for (i = length;i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
          return false;
      for (i = length;i-- !== 0; ) {
        var key = keys[i];
        if (!equal(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/ajv@8.12.0/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS((exports, module) => {
  var _traverse = function(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == "object" && !Array.isArray(schema)) {
      pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      for (var key in schema) {
        var sch = schema[key];
        if (Array.isArray(sch)) {
          if (key in traverse.arrayKeywords) {
            for (var i = 0;i < sch.length; i++)
              _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
          }
        } else if (key in traverse.propsKeywords) {
          if (sch && typeof sch == "object") {
            for (var prop in sch)
              _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          }
        } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
          _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
      }
      post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
  };
  var escapeJsonPtr = function(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  };
  var traverse = module.exports = function(schema, opts, cb) {
    if (typeof opts == "function") {
      cb = opts;
      opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == "function" ? cb : cb.pre || function() {
    };
    var post = cb.post || function() {
    };
    _traverse(opts, pre, post, schema, "", schema);
  };
  traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true,
    if: true,
    then: true,
    else: true
  };
  traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
  };
  traverse.propsKeywords = {
    $defs: true,
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
  };
  traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
  };
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS((exports) => {
  var inlineRef = function(schema, limit = true) {
    if (typeof schema == "boolean")
      return true;
    if (limit === true)
      return !hasRef(schema);
    if (!limit)
      return false;
    return countKeys(schema) <= limit;
  };
  var hasRef = function(schema) {
    for (const key in schema) {
      if (REF_KEYWORDS.has(key))
        return true;
      const sch = schema[key];
      if (Array.isArray(sch) && sch.some(hasRef))
        return true;
      if (typeof sch == "object" && hasRef(sch))
        return true;
    }
    return false;
  };
  var countKeys = function(schema) {
    let count = 0;
    for (const key in schema) {
      if (key === "$ref")
        return Infinity;
      count++;
      if (SIMPLE_INLINED.has(key))
        continue;
      if (typeof schema[key] == "object") {
        (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
      }
      if (count === Infinity)
        return Infinity;
    }
    return count;
  };
  var getFullPath = function(resolver, id2 = "", normalize2) {
    if (normalize2 !== false)
      id2 = normalizeId(id2);
    const p = resolver.parse(id2);
    return _getFullPath(resolver, p);
  };
  var _getFullPath = function(resolver, p) {
    const serialized = resolver.serialize(p);
    return serialized.split("#")[0] + "#";
  };
  var normalizeId = function(id2) {
    return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
  };
  var resolveUrl = function(resolver, baseId, id2) {
    id2 = normalizeId(id2);
    return resolver.resolve(baseId, id2);
  };
  var getSchemaRefs = function(schema, baseId) {
    if (typeof schema == "boolean")
      return {};
    const { schemaId, uriResolver } = this.opts;
    const schId = normalizeId(schema[schemaId] || baseId);
    const baseIds = { "": schId };
    const pathPrefix = getFullPath(uriResolver, schId, false);
    const localRefs = {};
    const schemaRefs = new Set;
    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
      if (parentJsonPtr === undefined)
        return;
      const fullPath = pathPrefix + jsonPtr;
      let baseId2 = baseIds[parentJsonPtr];
      if (typeof sch[schemaId] == "string")
        baseId2 = addRef.call(this, sch[schemaId]);
      addAnchor.call(this, sch.$anchor);
      addAnchor.call(this, sch.$dynamicAnchor);
      baseIds[jsonPtr] = baseId2;
      function addRef(ref) {
        const _resolve = this.opts.uriResolver.resolve;
        ref = normalizeId(baseId2 ? _resolve(baseId2, ref) : ref);
        if (schemaRefs.has(ref))
          throw ambiguos(ref);
        schemaRefs.add(ref);
        let schOrRef = this.refs[ref];
        if (typeof schOrRef == "string")
          schOrRef = this.refs[schOrRef];
        if (typeof schOrRef == "object") {
          checkAmbiguosRef(sch, schOrRef.schema, ref);
        } else if (ref !== normalizeId(fullPath)) {
          if (ref[0] === "#") {
            checkAmbiguosRef(sch, localRefs[ref], ref);
            localRefs[ref] = sch;
          } else {
            this.refs[ref] = fullPath;
          }
        }
        return ref;
      }
      function addAnchor(anchor) {
        if (typeof anchor == "string") {
          if (!ANCHOR.test(anchor))
            throw new Error(`invalid anchor "${anchor}"`);
          addRef.call(this, `#${anchor}`);
        }
      }
    });
    return localRefs;
    function checkAmbiguosRef(sch1, sch2, ref) {
      if (sch2 !== undefined && !equal(sch1, sch2))
        throw ambiguos(ref);
    }
    function ambiguos(ref) {
      return new Error(`reference "${ref}" resolves to more than one schema`);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = undefined;
  var util_1 = require_util3();
  var equal = require_fast_deep_equal();
  var traverse = require_json_schema_traverse();
  var SIMPLE_INLINED = new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  exports.inlineRef = inlineRef;
  var REF_KEYWORDS = new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  exports.getFullPath = getFullPath;
  exports._getFullPath = _getFullPath;
  var TRAILING_SLASH_HASH = /#\/?$/;
  exports.normalizeId = normalizeId;
  exports.resolveUrl = resolveUrl;
  var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
  exports.getSchemaRefs = getSchemaRefs;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS((exports) => {
  var validateFunctionCode = function(it) {
    if (isSchemaObj(it)) {
      checkKeywords(it);
      if (schemaCxtHasRules(it)) {
        topSchemaObjCode(it);
        return;
      }
    }
    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
  };
  var validateFunction = function({ gen: gen2, validateName, schema, schemaEnv, opts }, body) {
    if (opts.code.es5) {
      gen2.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
        gen2.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
        destructureValCxtES5(gen2, opts);
        gen2.code(body);
      });
    } else {
      gen2.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen2.code(funcSourceUrl(schema, opts)).code(body));
    }
  };
  var destructureValCxt = function(opts) {
    return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
  };
  var destructureValCxtES5 = function(gen2, opts) {
    gen2.if(names_1.default.valCxt, () => {
      gen2.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
      gen2.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
      gen2.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
      gen2.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
      if (opts.dynamicRef)
        gen2.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
    }, () => {
      gen2.var(names_1.default.instancePath, (0, codegen_1._)`""`);
      gen2.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
      gen2.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
      gen2.var(names_1.default.rootData, names_1.default.data);
      if (opts.dynamicRef)
        gen2.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
    });
  };
  var topSchemaObjCode = function(it) {
    const { schema, opts, gen: gen2 } = it;
    validateFunction(it, () => {
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      checkNoDefault(it);
      gen2.let(names_1.default.vErrors, null);
      gen2.let(names_1.default.errors, 0);
      if (opts.unevaluated)
        resetEvaluated(it);
      typeAndKeywords(it);
      returnResults(it);
    });
    return;
  };
  var resetEvaluated = function(it) {
    const { gen: gen2, validateName } = it;
    it.evaluated = gen2.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
    gen2.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen2.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
    gen2.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen2.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
  };
  var funcSourceUrl = function(schema, opts) {
    const schId = typeof schema == "object" && schema[opts.schemaId];
    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
  };
  var subschemaCode = function(it, valid) {
    if (isSchemaObj(it)) {
      checkKeywords(it);
      if (schemaCxtHasRules(it)) {
        subSchemaObjCode(it, valid);
        return;
      }
    }
    (0, boolSchema_1.boolOrEmptySchema)(it, valid);
  };
  var schemaCxtHasRules = function({ schema, self: self2 }) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (self2.RULES.all[key])
        return true;
    return false;
  };
  var isSchemaObj = function(it) {
    return typeof it.schema != "boolean";
  };
  var subSchemaObjCode = function(it, valid) {
    const { schema, gen: gen2, opts } = it;
    if (opts.$comment && schema.$comment)
      commentKeyword(it);
    updateContext(it);
    checkAsyncSchema(it);
    const errsCount = gen2.const("_errs", names_1.default.errors);
    typeAndKeywords(it, errsCount);
    gen2.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
  };
  var checkKeywords = function(it) {
    (0, util_1.checkUnknownRules)(it);
    checkRefsAndKeywords(it);
  };
  var typeAndKeywords = function(it, errsCount) {
    if (it.opts.jtd)
      return schemaKeywords(it, [], false, errsCount);
    const types12 = (0, dataType_1.getSchemaTypes)(it.schema);
    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types12);
    schemaKeywords(it, types12, !checkedTypes, errsCount);
  };
  var checkRefsAndKeywords = function(it) {
    const { schema, errSchemaPath, opts, self: self2 } = it;
    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
      self2.logger.warn(`\$ref: keywords ignored in schema at path "${errSchemaPath}"`);
    }
  };
  var checkNoDefault = function(it) {
    const { schema, opts } = it;
    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
      (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
    }
  };
  var updateContext = function(it) {
    const schId = it.schema[it.opts.schemaId];
    if (schId)
      it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
  };
  var checkAsyncSchema = function(it) {
    if (it.schema.$async && !it.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  };
  var commentKeyword = function({ gen: gen2, schemaEnv, schema, errSchemaPath, opts }) {
    const msg = schema.$comment;
    if (opts.$comment === true) {
      gen2.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
    } else if (typeof opts.$comment == "function") {
      const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
      const rootName = gen2.scopeValue("root", { ref: schemaEnv.root });
      gen2.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
    }
  };
  var returnResults = function(it) {
    const { gen: gen2, schemaEnv, validateName, ValidationError, opts } = it;
    if (schemaEnv.$async) {
      gen2.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen2.return(names_1.default.data), () => gen2.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
    } else {
      gen2.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
      if (opts.unevaluated)
        assignEvaluated(it);
      gen2.return((0, codegen_1._)`${names_1.default.errors} === 0`);
    }
  };
  var assignEvaluated = function({ gen: gen2, evaluated, props, items }) {
    if (props instanceof codegen_1.Name)
      gen2.assign((0, codegen_1._)`${evaluated}.props`, props);
    if (items instanceof codegen_1.Name)
      gen2.assign((0, codegen_1._)`${evaluated}.items`, items);
  };
  var schemaKeywords = function(it, types12, typeErrors, errsCount) {
    const { gen: gen2, schema, data: data3, allErrors, opts, self: self2 } = it;
    const { RULES } = self2;
    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
      gen2.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
      return;
    }
    if (!opts.jtd)
      checkStrictTypes(it, types12);
    gen2.block(() => {
      for (const group of RULES.rules)
        groupKeywords(group);
      groupKeywords(RULES.post);
    });
    function groupKeywords(group) {
      if (!(0, applicability_1.shouldUseGroup)(schema, group))
        return;
      if (group.type) {
        gen2.if((0, dataType_2.checkDataType)(group.type, data3, opts.strictNumbers));
        iterateKeywords(it, group);
        if (types12.length === 1 && types12[0] === group.type && typeErrors) {
          gen2.else();
          (0, dataType_2.reportTypeError)(it);
        }
        gen2.endIf();
      } else {
        iterateKeywords(it, group);
      }
      if (!allErrors)
        gen2.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
    }
  };
  var iterateKeywords = function(it, group) {
    const { gen: gen2, schema, opts: { useDefaults } } = it;
    if (useDefaults)
      (0, defaults_1.assignDefaults)(it, group.type);
    gen2.block(() => {
      for (const rule of group.rules) {
        if ((0, applicability_1.shouldUseRule)(schema, rule)) {
          keywordCode(it, rule.keyword, rule.definition, group.type);
        }
      }
    });
  };
  var checkStrictTypes = function(it, types12) {
    if (it.schemaEnv.meta || !it.opts.strictTypes)
      return;
    checkContextTypes(it, types12);
    if (!it.opts.allowUnionTypes)
      checkMultipleTypes(it, types12);
    checkKeywordTypes(it, it.dataTypes);
  };
  var checkContextTypes = function(it, types12) {
    if (!types12.length)
      return;
    if (!it.dataTypes.length) {
      it.dataTypes = types12;
      return;
    }
    types12.forEach((t) => {
      if (!includesType(it.dataTypes, t)) {
        strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
      }
    });
    narrowSchemaTypes(it, types12);
  };
  var checkMultipleTypes = function(it, ts) {
    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
      strictTypesError(it, "use allowUnionTypes to allow union type keyword");
    }
  };
  var checkKeywordTypes = function(it, ts) {
    const rules = it.self.RULES.all;
    for (const keyword in rules) {
      const rule = rules[keyword];
      if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
        const { type } = rule.definition;
        if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
          strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
        }
      }
    }
  };
  var hasApplicableType = function(schTs, kwdT) {
    return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
  };
  var includesType = function(ts, t) {
    return ts.includes(t) || t === "integer" && ts.includes("number");
  };
  var narrowSchemaTypes = function(it, withTypes) {
    const ts = [];
    for (const t of it.dataTypes) {
      if (includesType(withTypes, t))
        ts.push(t);
      else if (withTypes.includes("integer") && t === "number")
        ts.push("integer");
    }
    it.dataTypes = ts;
  };
  var strictTypesError = function(it, msg) {
    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
    msg += ` at "${schemaPath}" (strictTypes)`;
    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
  };
  var keywordCode = function(it, keyword, def, ruleType) {
    const cxt = new KeywordCxt(it, def, keyword);
    if ("code" in def) {
      def.code(cxt, ruleType);
    } else if (cxt.$data && def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    } else if ("macro" in def) {
      (0, keyword_1.macroKeywordCode)(cxt, def);
    } else if (def.compile || def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    }
  };
  var getData = function($data, { dataLevel, dataNames, dataPathArr }) {
    let jsonPointer;
    let data3;
    if ($data === "")
      return names_1.default.rootData;
    if ($data[0] === "/") {
      if (!JSON_POINTER.test($data))
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      jsonPointer = $data;
      data3 = names_1.default.rootData;
    } else {
      const matches = RELATIVE_JSON_POINTER.exec($data);
      if (!matches)
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      const up = +matches[1];
      jsonPointer = matches[2];
      if (jsonPointer === "#") {
        if (up >= dataLevel)
          throw new Error(errorMsg("property/index", up));
        return dataPathArr[dataLevel - up];
      }
      if (up > dataLevel)
        throw new Error(errorMsg("data", up));
      data3 = dataNames[dataLevel - up];
      if (!jsonPointer)
        return data3;
    }
    let expr = data3;
    const segments = jsonPointer.split("/");
    for (const segment of segments) {
      if (segment) {
        data3 = (0, codegen_1._)`${data3}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
        expr = (0, codegen_1._)`${expr} && ${data3}`;
      }
    }
    return expr;
    function errorMsg(pointerType, up) {
      return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getData = exports.KeywordCxt = exports.validateFunctionCode = undefined;
  var boolSchema_1 = require_boolSchema();
  var dataType_1 = require_dataType();
  var applicability_1 = require_applicability();
  var dataType_2 = require_dataType();
  var defaults_1 = require_defaults();
  var keyword_1 = require_keyword();
  var subschema_1 = require_subschema();
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var resolve_1 = require_resolve();
  var util_1 = require_util3();
  var errors_1 = require_errors5();
  exports.validateFunctionCode = validateFunctionCode;

  class KeywordCxt {
    constructor(it, def, keyword) {
      (0, keyword_1.validateKeywordUsage)(it, def, keyword);
      this.gen = it.gen;
      this.allErrors = it.allErrors;
      this.keyword = keyword;
      this.data = it.data;
      this.schema = it.schema[keyword];
      this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
      this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
      this.schemaType = def.schemaType;
      this.parentSchema = it.schema;
      this.params = {};
      this.it = it;
      this.def = def;
      if (this.$data) {
        this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
      } else {
        this.schemaCode = this.schemaValue;
        if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
          throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
        }
      }
      if ("code" in def ? def.trackErrors : def.errors !== false) {
        this.errsCount = it.gen.const("_errs", names_1.default.errors);
      }
    }
    result(condition, successAction, failAction) {
      this.failResult((0, codegen_1.not)(condition), successAction, failAction);
    }
    failResult(condition, successAction, failAction) {
      this.gen.if(condition);
      if (failAction)
        failAction();
      else
        this.error();
      if (successAction) {
        this.gen.else();
        successAction();
        if (this.allErrors)
          this.gen.endIf();
      } else {
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
    }
    pass(condition, failAction) {
      this.failResult((0, codegen_1.not)(condition), undefined, failAction);
    }
    fail(condition) {
      if (condition === undefined) {
        this.error();
        if (!this.allErrors)
          this.gen.if(false);
        return;
      }
      this.gen.if(condition);
      this.error();
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
    fail$data(condition) {
      if (!this.$data)
        return this.fail(condition);
      const { schemaCode } = this;
      this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
    }
    error(append, errorParams, errorPaths) {
      if (errorParams) {
        this.setParams(errorParams);
        this._error(append, errorPaths);
        this.setParams({});
        return;
      }
      this._error(append, errorPaths);
    }
    _error(append, errorPaths) {
      (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
    }
    $dataError() {
      (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
    }
    reset() {
      if (this.errsCount === undefined)
        throw new Error('add "trackErrors" to keyword definition');
      (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(cond) {
      if (!this.allErrors)
        this.gen.if(cond);
    }
    setParams(obj, assign) {
      if (assign)
        Object.assign(this.params, obj);
      else
        this.params = obj;
    }
    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
      this.gen.block(() => {
        this.check$data(valid, $dataValid);
        codeBlock();
      });
    }
    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
      if (!this.$data)
        return;
      const { gen: gen2, schemaCode, schemaType, def } = this;
      gen2.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
      if (valid !== codegen_1.nil)
        gen2.assign(valid, true);
      if (schemaType.length || def.validateSchema) {
        gen2.elseIf(this.invalid$data());
        this.$dataError();
        if (valid !== codegen_1.nil)
          gen2.assign(valid, false);
      }
      gen2.else();
    }
    invalid$data() {
      const { gen: gen2, schemaCode, schemaType, def, it } = this;
      return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
      function wrong$DataType() {
        if (schemaType.length) {
          if (!(schemaCode instanceof codegen_1.Name))
            throw new Error("ajv implementation error");
          const st = Array.isArray(schemaType) ? schemaType : [schemaType];
          return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
        }
        return codegen_1.nil;
      }
      function invalid$DataSchema() {
        if (def.validateSchema) {
          const validateSchemaRef = gen2.scopeValue("validate$data", { ref: def.validateSchema });
          return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
        }
        return codegen_1.nil;
      }
    }
    subschema(appl, valid) {
      const subschema = (0, subschema_1.getSubschema)(this.it, appl);
      (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
      (0, subschema_1.extendSubschemaMode)(subschema, appl);
      const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };
      subschemaCode(nextContext, valid);
      return nextContext;
    }
    mergeEvaluated(schemaCxt, toName) {
      const { it, gen: gen2 } = this;
      if (!it.opts.unevaluated)
        return;
      if (it.props !== true && schemaCxt.props !== undefined) {
        it.props = util_1.mergeEvaluated.props(gen2, schemaCxt.props, it.props, toName);
      }
      if (it.items !== true && schemaCxt.items !== undefined) {
        it.items = util_1.mergeEvaluated.items(gen2, schemaCxt.items, it.items, toName);
      }
    }
    mergeValidEvaluated(schemaCxt, valid) {
      const { it, gen: gen2 } = this;
      if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
        gen2.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
        return true;
      }
    }
  }
  exports.KeywordCxt = KeywordCxt;
  var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
  var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  exports.getData = getData;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class ValidationError extends Error {
    constructor(errors4) {
      super("validation failed");
      this.errors = errors4;
      this.ajv = this.validation = true;
    }
  }
  exports.default = ValidationError;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var resolve_1 = require_resolve();

  class MissingRefError extends Error {
    constructor(resolver, baseId, ref, msg) {
      super(msg || `can't resolve reference ${ref} from id ${baseId}`);
      this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
      this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
    }
  }
  exports.default = MissingRefError;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS((exports) => {
  var compileSchema = function(sch) {
    const _sch = getCompilingSchema.call(this, sch);
    if (_sch)
      return _sch;
    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen2 = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    let _ValidationError;
    if (sch.$async) {
      _ValidationError = gen2.scopeValue("Error", {
        ref: validation_error_1.default,
        code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
      });
    }
    const validateName = gen2.scopeName("validate");
    sch.validateName = validateName;
    const schemaCxt = {
      gen: gen2,
      allErrors: this.opts.allErrors,
      data: names_1.default.data,
      parentData: names_1.default.parentData,
      parentDataProperty: names_1.default.parentDataProperty,
      dataNames: [names_1.default.data],
      dataPathArr: [codegen_1.nil],
      dataLevel: 0,
      dataTypes: [],
      definedProperties: new Set,
      topSchemaRef: gen2.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
      validateName,
      ValidationError: _ValidationError,
      schema: sch.schema,
      schemaEnv: sch,
      rootId,
      baseId: sch.baseId || rootId,
      schemaPath: codegen_1.nil,
      errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, codegen_1._)`""`,
      opts: this.opts,
      self: this
    };
    let sourceCode;
    try {
      this._compilations.add(sch);
      (0, validate_1.validateFunctionCode)(schemaCxt);
      gen2.optimize(this.opts.code.optimize);
      const validateCode = gen2.toString();
      sourceCode = `${gen2.scopeRefs(names_1.default.scope)}return ${validateCode}`;
      if (this.opts.code.process)
        sourceCode = this.opts.code.process(sourceCode, sch);
      const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
      const validate = makeValidate(this, this.scope.get());
      this.scope.value(validateName, { ref: validate });
      validate.errors = null;
      validate.schema = sch.schema;
      validate.schemaEnv = sch;
      if (sch.$async)
        validate.$async = true;
      if (this.opts.code.source === true) {
        validate.source = { validateName, validateCode, scopeValues: gen2._values };
      }
      if (this.opts.unevaluated) {
        const { props, items } = schemaCxt;
        validate.evaluated = {
          props: props instanceof codegen_1.Name ? undefined : props,
          items: items instanceof codegen_1.Name ? undefined : items,
          dynamicProps: props instanceof codegen_1.Name,
          dynamicItems: items instanceof codegen_1.Name
        };
        if (validate.source)
          validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
      }
      sch.validate = validate;
      return sch;
    } catch (e) {
      delete sch.validate;
      delete sch.validateName;
      if (sourceCode)
        this.logger.error("Error compiling schema, function code:", sourceCode);
      throw e;
    } finally {
      this._compilations.delete(sch);
    }
  };
  var resolveRef = function(root, baseId, ref) {
    var _a2;
    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
    const schOrFunc = root.refs[ref];
    if (schOrFunc)
      return schOrFunc;
    let _sch = resolve5.call(this, root, ref);
    if (_sch === undefined) {
      const schema = (_a2 = root.localRefs) === null || _a2 === undefined ? undefined : _a2[ref];
      const { schemaId } = this.opts;
      if (schema)
        _sch = new SchemaEnv({ schema, schemaId, root, baseId });
    }
    if (_sch === undefined)
      return;
    return root.refs[ref] = inlineOrCompile.call(this, _sch);
  };
  var inlineOrCompile = function(sch) {
    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
      return sch.schema;
    return sch.validate ? sch : compileSchema.call(this, sch);
  };
  var getCompilingSchema = function(schEnv) {
    for (const sch of this._compilations) {
      if (sameSchemaEnv(sch, schEnv))
        return sch;
    }
  };
  var sameSchemaEnv = function(s1, s2) {
    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
  };
  var resolve5 = function(root, ref) {
    let sch;
    while (typeof (sch = this.refs[ref]) == "string")
      ref = sch;
    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
  };
  var resolveSchema = function(root, ref) {
    const p = this.opts.uriResolver.parse(ref);
    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);
    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
      return getJsonPointer.call(this, p, root);
    }
    const id2 = (0, resolve_1.normalizeId)(refPath);
    const schOrRef = this.refs[id2] || this.schemas[id2];
    if (typeof schOrRef == "string") {
      const sch = resolveSchema.call(this, root, schOrRef);
      if (typeof (sch === null || sch === undefined ? undefined : sch.schema) !== "object")
        return;
      return getJsonPointer.call(this, p, sch);
    }
    if (typeof (schOrRef === null || schOrRef === undefined ? undefined : schOrRef.schema) !== "object")
      return;
    if (!schOrRef.validate)
      compileSchema.call(this, schOrRef);
    if (id2 === (0, resolve_1.normalizeId)(ref)) {
      const { schema } = schOrRef;
      const { schemaId } = this.opts;
      const schId = schema[schemaId];
      if (schId)
        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
      return new SchemaEnv({ schema, schemaId, root, baseId });
    }
    return getJsonPointer.call(this, p, schOrRef);
  };
  var getJsonPointer = function(parsedRef, { baseId, schema, root }) {
    var _a2;
    if (((_a2 = parsedRef.fragment) === null || _a2 === undefined ? undefined : _a2[0]) !== "/")
      return;
    for (const part of parsedRef.fragment.slice(1).split("/")) {
      if (typeof schema === "boolean")
        return;
      const partSchema = schema[(0, util_1.unescapeFragment)(part)];
      if (partSchema === undefined)
        return;
      schema = partSchema;
      const schId = typeof schema === "object" && schema[this.opts.schemaId];
      if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
      }
    }
    let env2;
    if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
      const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
      env2 = resolveSchema.call(this, root, $ref);
    }
    const { schemaId } = this.opts;
    env2 = env2 || new SchemaEnv({ schema, schemaId, root, baseId });
    if (env2.schema !== env2.root.schema)
      return env2;
    return;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = undefined;
  var codegen_1 = require_codegen();
  var validation_error_1 = require_validation_error();
  var names_1 = require_names();
  var resolve_1 = require_resolve();
  var util_1 = require_util3();
  var validate_1 = require_validate();

  class SchemaEnv {
    constructor(env2) {
      var _a2;
      this.refs = {};
      this.dynamicAnchors = {};
      let schema;
      if (typeof env2.schema == "object")
        schema = env2.schema;
      this.schema = env2.schema;
      this.schemaId = env2.schemaId;
      this.root = env2.root || this;
      this.baseId = (_a2 = env2.baseId) !== null && _a2 !== undefined ? _a2 : (0, resolve_1.normalizeId)(schema === null || schema === undefined ? undefined : schema[env2.schemaId || "$id"]);
      this.schemaPath = env2.schemaPath;
      this.localRefs = env2.localRefs;
      this.meta = env2.meta;
      this.$async = schema === null || schema === undefined ? undefined : schema.$async;
      this.refs = {};
    }
  }
  exports.SchemaEnv = SchemaEnv;
  exports.compileSchema = compileSchema;
  exports.resolveRef = resolveRef;
  exports.getCompilingSchema = getCompilingSchema;
  exports.resolveSchema = resolveSchema;
  var PREVENT_SCOPE_CHANGE = new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/refs/data.json
var require_data = __commonJS((exports, module) => {
  module.exports = {
    $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
    type: "object",
    required: ["$data"],
    properties: {
      $data: {
        type: "string",
        anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
      }
    },
    additionalProperties: false
  };
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/ajv@8.12.0/node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.URI = global2.URI || {});
  })(exports, function(exports2) {
    function merge() {
      for (var _len = arguments.length, sets = Array(_len), _key = 0;_key < _len; _key++) {
        sets[_key] = arguments[_key];
      }
      if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1;x < xl; ++x) {
          sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join("");
      } else {
        return sets[0];
      }
    }
    function subexp(str) {
      return "(?:" + str + ")";
    }
    function typeOf(o) {
      return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
    }
    function toUpperCase(str) {
      return str.toUpperCase();
    }
    function toArray(obj) {
      return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
    }
    function assign(target, source) {
      var obj = target;
      if (source) {
        for (var key in source) {
          obj[key] = source[key];
        }
      }
      return obj;
    }
    function buildExps(isIRI2) {
      var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
      return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
      };
    }
    var URI_PROTOCOL = buildExps(false);
    var IRI_PROTOCOL = buildExps(true);
    var slicedToArray = function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = undefined;
        try {
          for (var _i = arr[Symbol.iterator](), _s;!(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var toConsumableArray = function(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length);i < arr.length; i++)
          arr2[i] = arr[i];
        return arr2;
      } else {
        return Array.from(arr);
      }
    };
    var maxInt = 2147483647;
    var base31 = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors4 = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base31 - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error$1(type) {
      throw new RangeError(errors4[type]);
    }
    function map(array, fn) {
      var result = [];
      var length = array.length;
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts = string.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output2 = [];
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          var extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output2.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output2.push(value);
            counter--;
          }
        } else {
          output2.push(value);
        }
      }
      return output2;
    }
    var ucs2encode = function ucs2encode(array) {
      return String.fromCodePoint.apply(String, toConsumableArray(array));
    };
    var basicToDigit = function basicToDigit(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base31;
    };
    var digitToBasic = function digitToBasic(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function adapt(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (;delta > baseMinusTMin * tMax >> 1; k += base31) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode = function decode(input) {
      var output2 = [];
      var inputLength = input.length;
      var i = 0;
      var n = initialN;
      var bias = initialBias;
      var basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (var j = 0;j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error$1("not-basic");
        }
        output2.push(input.charCodeAt(j));
      }
      for (var index2 = basic > 0 ? basic + 1 : 0;index2 < inputLength; ) {
        var oldi = i;
        for (var w = 1, k = base31;; k += base31) {
          if (index2 >= inputLength) {
            error$1("invalid-input");
          }
          var digit = basicToDigit(input.charCodeAt(index2++));
          if (digit >= base31 || digit > floor((maxInt - i) / w)) {
            error$1("overflow");
          }
          i += digit * w;
          var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          var baseMinusT = base31 - t;
          if (w > floor(maxInt / baseMinusT)) {
            error$1("overflow");
          }
          w *= baseMinusT;
        }
        var out = output2.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error$1("overflow");
        }
        n += floor(i / out);
        i %= out;
        output2.splice(i++, 0, n);
      }
      return String.fromCodePoint.apply(String, output2);
    };
    var encode = function encode(input) {
      var output2 = [];
      input = ucs2decode(input);
      var inputLength = input.length;
      var n = initialN;
      var delta = 0;
      var bias = initialBias;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;
      try {
        for (var _iterator = input[Symbol.iterator](), _step;!(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _currentValue2 = _step.value;
          if (_currentValue2 < 128) {
            output2.push(stringFromCharCode(_currentValue2));
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var basicLength = output2.length;
      var handledCPCount = basicLength;
      if (basicLength) {
        output2.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        var m = maxInt;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;
        try {
          for (var _iterator2 = input[Symbol.iterator](), _step2;!(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var currentValue = _step2.value;
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error$1("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;
        try {
          for (var _iterator3 = input[Symbol.iterator](), _step3;!(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _currentValue = _step3.value;
            if (_currentValue < n && ++delta > maxInt) {
              error$1("overflow");
            }
            if (_currentValue == n) {
              var q = delta;
              for (var k = base31;; k += base31) {
                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                var qMinusT = q - t;
                var baseMinusT = base31 - t;
                output2.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }
              output2.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
        ++delta;
        ++n;
      }
      return output2.join("");
    };
    var toUnicode = function toUnicode(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    var toASCII = function toASCII(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    var punycode = {
      version: "2.1.0",
      ucs2: {
        decode: ucs2decode,
        encode: ucs2encode
      },
      decode,
      encode,
      toASCII,
      toUnicode
    };
    var SCHEMES = {};
    function pctEncChar(chr) {
      var c = chr.charCodeAt(0);
      var e = undefined;
      if (c < 16)
        e = "%0" + c.toString(16).toUpperCase();
      else if (c < 128)
        e = "%" + c.toString(16).toUpperCase();
      else if (c < 2048)
        e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      else
        e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      return e;
    }
    function pctDecChars(str) {
      var newStr = "";
      var i = 0;
      var il = str.length;
      while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
          newStr += String.fromCharCode(c);
          i += 3;
        } else if (c >= 194 && c < 224) {
          if (il - i >= 6) {
            var c2 = parseInt(str.substr(i + 4, 2), 16);
            newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
          } else {
            newStr += str.substr(i, 6);
          }
          i += 6;
        } else if (c >= 224) {
          if (il - i >= 9) {
            var _c2 = parseInt(str.substr(i + 4, 2), 16);
            var c3 = parseInt(str.substr(i + 7, 2), 16);
            newStr += String.fromCharCode((c & 15) << 12 | (_c2 & 63) << 6 | c3 & 63);
          } else {
            newStr += str.substr(i, 9);
          }
          i += 9;
        } else {
          newStr += str.substr(i, 3);
          i += 3;
        }
      }
      return newStr;
    }
    function _normalizeComponentEncoding(components, protocol) {
      function decodeUnreserved2(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
      }
      if (components.scheme)
        components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
      if (components.userinfo !== undefined)
        components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.host !== undefined)
        components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.path !== undefined)
        components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.query !== undefined)
        components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.fragment !== undefined)
        components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      return components;
    }
    function _stripLeadingZeros(str) {
      return str.replace(/^0*(.*)/, "$1") || "0";
    }
    function _normalizeIPv4(host, protocol) {
      var matches = host.match(protocol.IPV4ADDRESS) || [];
      var _matches = slicedToArray(matches, 2), address10 = _matches[1];
      if (address10) {
        return address10.split(".").map(_stripLeadingZeros).join(".");
      } else {
        return host;
      }
    }
    function _normalizeIPv6(host, protocol) {
      var matches = host.match(protocol.IPV6ADDRESS) || [];
      var _matches2 = slicedToArray(matches, 3), address10 = _matches2[1], zone = _matches2[2];
      if (address10) {
        var _address$toLowerCase$ = address10.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0;x < fieldCount; ++x) {
          fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
        }
        if (isLastFieldIPv4Address) {
          fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function(acc, field, index2) {
          if (!field || field === "0") {
            var lastLongest = acc[acc.length - 1];
            if (lastLongest && lastLongest.index + lastLongest.length === index2) {
              lastLongest.length++;
            } else {
              acc.push({ index: index2, length: 1 });
            }
          }
          return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function(a, b) {
          return b.length - a.length;
        })[0];
        var newHost = undefined;
        if (longestZeroFields && longestZeroFields.length > 1) {
          var newFirst = fields.slice(0, longestZeroFields.index);
          var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
          newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
          newHost = fields.join(":");
        }
        if (zone) {
          newHost += "%" + zone;
        }
        return newHost;
      } else {
        return host;
      }
    }
    var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
    var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
    function parse(uriString) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var components = {};
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      if (options.reference === "suffix")
        uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
      var matches = uriString.match(URI_PARSE);
      if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
          components.scheme = matches[1];
          components.userinfo = matches[3];
          components.host = matches[4];
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = matches[7];
          components.fragment = matches[8];
          if (isNaN(components.port)) {
            components.port = matches[5];
          }
        } else {
          components.scheme = matches[1] || undefined;
          components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
          components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
          components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
          if (isNaN(components.port)) {
            components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
          }
        }
        if (components.host) {
          components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
          components.reference = "same-document";
        } else if (components.scheme === undefined) {
          components.reference = "relative";
        } else if (components.fragment === undefined) {
          components.reference = "absolute";
        } else {
          components.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
          components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
            try {
              components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
            }
          }
          _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
          _normalizeComponentEncoding(components, protocol);
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(components, options);
        }
      } else {
        components.error = components.error || "URI can not be parsed.";
      }
      return components;
    }
    function _recomposeAuthority(components, options) {
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      if (components.userinfo !== undefined) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== undefined) {
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
          return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : undefined;
    }
    var RDS1 = /^\.\.?\//;
    var RDS2 = /^\/\.(\/|$)/;
    var RDS3 = /^\/\.\.(\/|$)/;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
    function removeDotSegments(input) {
      var output2 = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output2.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          var im = input.match(RDS5);
          if (im) {
            var s = im[0];
            input = input.slice(s.length);
            output2.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output2.join("");
    }
    function serialize(components) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize)
        schemeHandler.serialize(components, options);
      if (components.host) {
        if (protocol.IPV6ADDRESS.test(components.host)) {
        } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
          try {
            components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }
        }
      }
      _normalizeComponentEncoding(components, protocol);
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
      }
      var authority = _recomposeAuthority(components, options);
      if (authority !== undefined) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== undefined) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === undefined) {
          s = s.replace(/^\/\//, "/%2F");
        }
        uriTokens.push(s);
      }
      if (components.query !== undefined) {
        uriTokens.push("?");
        uriTokens.push(components.query);
      }
      if (components.fragment !== undefined) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
      }
      return uriTokens.join("");
    }
    function resolveComponents(base32, relative2) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var skipNormalization = arguments[3];
      var target = {};
      if (!skipNormalization) {
        base32 = parse(serialize(base32, options), options);
        relative2 = parse(serialize(relative2, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative2.scheme) {
        target.scheme = relative2.scheme;
        target.userinfo = relative2.userinfo;
        target.host = relative2.host;
        target.port = relative2.port;
        target.path = removeDotSegments(relative2.path || "");
        target.query = relative2.query;
      } else {
        if (relative2.userinfo !== undefined || relative2.host !== undefined || relative2.port !== undefined) {
          target.userinfo = relative2.userinfo;
          target.host = relative2.host;
          target.port = relative2.port;
          target.path = removeDotSegments(relative2.path || "");
          target.query = relative2.query;
        } else {
          if (!relative2.path) {
            target.path = base32.path;
            if (relative2.query !== undefined) {
              target.query = relative2.query;
            } else {
              target.query = base32.query;
            }
          } else {
            if (relative2.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative2.path);
            } else {
              if ((base32.userinfo !== undefined || base32.host !== undefined || base32.port !== undefined) && !base32.path) {
                target.path = "/" + relative2.path;
              } else if (!base32.path) {
                target.path = relative2.path;
              } else {
                target.path = base32.path.slice(0, base32.path.lastIndexOf("/") + 1) + relative2.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative2.query;
          }
          target.userinfo = base32.userinfo;
          target.host = base32.host;
          target.port = base32.port;
        }
        target.scheme = base32.scheme;
      }
      target.fragment = relative2.fragment;
      return target;
    }
    function resolve5(baseURI, relativeURI, options) {
      var schemelessOptions = assign({ scheme: "null" }, options);
      return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
    }
    function normalize2(uri, options) {
      if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
      } else if (typeOf(uri) === "object") {
        uri = parse(serialize(uri, options), options);
      }
      return uri;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = serialize(parse(uriA, options), options);
      } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
      }
      if (typeof uriB === "string") {
        uriB = serialize(parse(uriB, options), options);
      } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
      }
      return uriA === uriB;
    }
    function escapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
    }
    function unescapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
    }
    var handler = {
      scheme: "http",
      domainHost: true,
      parse: function parse(components, options) {
        if (!components.host) {
          components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
      },
      serialize: function serialize(components, options) {
        var secure = String(components.scheme).toLowerCase() === "https";
        if (components.port === (secure ? 443 : 80) || components.port === "") {
          components.port = undefined;
        }
        if (!components.path) {
          components.path = "/";
        }
        return components;
      }
    };
    var handler$1 = {
      scheme: "https",
      domainHost: handler.domainHost,
      parse: handler.parse,
      serialize: handler.serialize
    };
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    var handler$2 = {
      scheme: "ws",
      domainHost: true,
      parse: function parse(components, options) {
        var wsComponents = components;
        wsComponents.secure = isSecure(wsComponents);
        wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
        wsComponents.path = undefined;
        wsComponents.query = undefined;
        return wsComponents;
      },
      serialize: function serialize(wsComponents, options) {
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
          wsComponents.port = undefined;
        }
        if (typeof wsComponents.secure === "boolean") {
          wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
          wsComponents.secure = undefined;
        }
        if (wsComponents.resourceName) {
          var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
          wsComponents.path = path && path !== "/" ? path : undefined;
          wsComponents.query = query;
          wsComponents.resourceName = undefined;
        }
        wsComponents.fragment = undefined;
        return wsComponents;
      }
    };
    var handler$3 = {
      scheme: "wss",
      domainHost: handler$2.domainHost,
      parse: handler$2.parse,
      serialize: handler$2.serialize
    };
    var O = {};
    var isIRI = true;
    var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
    var HEXDIG$$ = "[0-9A-Fa-f]";
    var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
    var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
    var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
    var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
    var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
    var UNRESERVED = new RegExp(UNRESERVED$$, "g");
    var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
    var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
    var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
    var NOT_HFVALUE = NOT_HFNAME;
    function decodeUnreserved(str) {
      var decStr = pctDecChars(str);
      return !decStr.match(UNRESERVED) ? str : decStr;
    }
    var handler$4 = {
      scheme: "mailto",
      parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = undefined;
        if (mailtoComponents.query) {
          var unknownHeaders = false;
          var headers = {};
          var hfields = mailtoComponents.query.split("&");
          for (var x = 0, xl = hfields.length;x < xl; ++x) {
            var hfield = hfields[x].split("=");
            switch (hfield[0]) {
              case "to":
                var toAddrs = hfield[1].split(",");
                for (var _x = 0, _xl = toAddrs.length;_x < _xl; ++_x) {
                  to.push(toAddrs[_x]);
                }
                break;
              case "subject":
                mailtoComponents.subject = unescapeComponent(hfield[1], options);
                break;
              case "body":
                mailtoComponents.body = unescapeComponent(hfield[1], options);
                break;
              default:
                unknownHeaders = true;
                headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                break;
            }
          }
          if (unknownHeaders)
            mailtoComponents.headers = headers;
        }
        mailtoComponents.query = undefined;
        for (var _x2 = 0, _xl2 = to.length;_x2 < _xl2; ++_x2) {
          var addr = to[_x2].split("@");
          addr[0] = unescapeComponent(addr[0]);
          if (!options.unicodeSupport) {
            try {
              addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
            } catch (e) {
              mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
            }
          } else {
            addr[1] = unescapeComponent(addr[1], options).toLowerCase();
          }
          to[_x2] = addr.join("@");
        }
        return mailtoComponents;
      },
      serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
          for (var x = 0, xl = to.length;x < xl; ++x) {
            var toAddr = String(to[x]);
            var atIdx = toAddr.lastIndexOf("@");
            var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
            var domain = toAddr.slice(atIdx + 1);
            try {
              domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
            } catch (e) {
              components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
            to[x] = localPart + "@" + domain;
          }
          components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject)
          headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body)
          headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
          if (headers[name] !== O[name]) {
            fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
          }
        }
        if (fields.length) {
          components.query = fields.join("&");
        }
        return components;
      }
    };
    var URN_PARSE = /^([^\:]+)\:(.*)/;
    var handler$5 = {
      scheme: "urn",
      parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = matches[1].toLowerCase();
          var nss = matches[2];
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          urnComponents.nid = nid;
          urnComponents.nss = nss;
          urnComponents.path = undefined;
          if (schemeHandler) {
            urnComponents = schemeHandler.parse(urnComponents, options);
          }
        } else {
          urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
      },
      serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
          urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
      }
    };
    var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
    var handler$6 = {
      scheme: "urn:uuid",
      parse: function parse(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = undefined;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
          uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
      },
      serialize: function serialize(uuidComponents, options) {
        var urnComponents = uuidComponents;
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
      }
    };
    SCHEMES[handler.scheme] = handler;
    SCHEMES[handler$1.scheme] = handler$1;
    SCHEMES[handler$2.scheme] = handler$2;
    SCHEMES[handler$3.scheme] = handler$3;
    SCHEMES[handler$4.scheme] = handler$4;
    SCHEMES[handler$5.scheme] = handler$5;
    SCHEMES[handler$6.scheme] = handler$6;
    exports2.SCHEMES = SCHEMES;
    exports2.pctEncChar = pctEncChar;
    exports2.pctDecChars = pctDecChars;
    exports2.parse = parse;
    exports2.removeDotSegments = removeDotSegments;
    exports2.serialize = serialize;
    exports2.resolveComponents = resolveComponents;
    exports2.resolve = resolve5;
    exports2.normalize = normalize2;
    exports2.equal = equal;
    exports2.escapeComponent = escapeComponent;
    exports2.unescapeComponent = unescapeComponent;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var uri = require_uri_all();
  uri.code = 'require("ajv/dist/runtime/uri").default';
  exports.default = uri;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/core.js
var require_core = __commonJS((exports) => {
  var requiredOptions = function(o) {
    var _a2, _b2, _c2, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
    const s = o.strict;
    const _optz = (_a2 = o.code) === null || _a2 === undefined ? undefined : _a2.optimize;
    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
    const regExp = (_c2 = (_b2 = o.code) === null || _b2 === undefined ? undefined : _b2.regExp) !== null && _c2 !== undefined ? _c2 : defaultRegExp;
    const uriResolver = (_d = o.uriResolver) !== null && _d !== undefined ? _d : uri_1.default;
    return {
      strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== undefined ? _e : s) !== null && _f !== undefined ? _f : true,
      strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== undefined ? _g : s) !== null && _h !== undefined ? _h : true,
      strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== undefined ? _j : s) !== null && _k !== undefined ? _k : "log",
      strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== undefined ? _l : s) !== null && _m !== undefined ? _m : "log",
      strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== undefined ? _o : s) !== null && _p !== undefined ? _p : false,
      code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
      loopRequired: (_q = o.loopRequired) !== null && _q !== undefined ? _q : MAX_EXPRESSION,
      loopEnum: (_r = o.loopEnum) !== null && _r !== undefined ? _r : MAX_EXPRESSION,
      meta: (_s = o.meta) !== null && _s !== undefined ? _s : true,
      messages: (_t = o.messages) !== null && _t !== undefined ? _t : true,
      inlineRefs: (_u = o.inlineRefs) !== null && _u !== undefined ? _u : true,
      schemaId: (_v = o.schemaId) !== null && _v !== undefined ? _v : "$id",
      addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== undefined ? _w : true,
      validateSchema: (_x = o.validateSchema) !== null && _x !== undefined ? _x : true,
      validateFormats: (_y = o.validateFormats) !== null && _y !== undefined ? _y : true,
      unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== undefined ? _z : true,
      int32range: (_0 = o.int32range) !== null && _0 !== undefined ? _0 : true,
      uriResolver
    };
  };
  var checkOptions = function(checkOpts, options, msg, log7 = "error") {
    for (const key in checkOpts) {
      const opt = key;
      if (opt in options)
        this.logger[log7](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
  };
  var getSchEnv = function(keyRef) {
    keyRef = (0, resolve_1.normalizeId)(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  };
  var addInitialSchemas = function() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key in optsSchemas)
        this.addSchema(optsSchemas[key], key);
  };
  var addInitialFormats = function() {
    for (const name in this.opts.formats) {
      const format3 = this.opts.formats[name];
      if (format3)
        this.addFormat(name, format3);
    }
  };
  var addInitialKeywords = function(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword in defs) {
      const def = defs[keyword];
      if (!def.keyword)
        def.keyword = keyword;
      this.addKeyword(def);
    }
  };
  var getMetaSchemaOptions = function() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  };
  var getLogger = function(logger3) {
    if (logger3 === false)
      return noLogs;
    if (logger3 === undefined)
      return console;
    if (logger3.log && logger3.warn && logger3.error)
      return logger3;
    throw new Error("logger must implement log, warn and error methods");
  };
  var checkKeyword = function(keyword, def) {
    const { RULES } = this;
    (0, util_1.eachItem)(keyword, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def)
      return;
    if (def.$data && !(("code" in def) || ("validate" in def))) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  };
  var addRule = function(keyword, definition, dataType) {
    var _a2;
    const post = definition === null || definition === undefined ? undefined : definition.post;
    if (dataType && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
    if (!ruleGroup) {
      ruleGroup = { type: dataType, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword] = true;
    if (!definition)
      return;
    const rule = {
      keyword,
      definition: {
        ...definition,
        type: (0, dataType_1.getJSONTypes)(definition.type),
        schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
      }
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword] = rule;
    (_a2 = definition.implements) === null || _a2 === undefined || _a2.forEach((kwd) => this.addKeyword(kwd));
  };
  var addBeforeRule = function(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
      ruleGroup.rules.splice(i, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  };
  var keywordMetaschema = function(def) {
    let { metaSchema } = def;
    if (metaSchema === undefined)
      return;
    if (def.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def.validateSchema = this.compile(metaSchema, true);
  };
  var schemaOrData = function(schema) {
    return { anyOf: [schema, $dataRef] };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = undefined;
  var validate_1 = require_validate();
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_1.KeywordCxt;
  } });
  var codegen_1 = require_codegen();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_1._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_1.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_1.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_1.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_1.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_1.CodeGen;
  } });
  var validation_error_1 = require_validation_error();
  var ref_error_1 = require_ref_error();
  var rules_1 = require_rules();
  var compile_1 = require_compile();
  var codegen_2 = require_codegen();
  var resolve_1 = require_resolve();
  var dataType_1 = require_dataType();
  var util_1 = require_util3();
  var $dataRefSchema = require_data();
  var uri_1 = require_uri();
  var defaultRegExp = (str, flags) => new RegExp(str, flags);
  defaultRegExp.code = "new RegExp";
  var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  var EXT_SCOPE_NAMES = new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  var removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  var deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  var MAX_EXPRESSION = 200;

  class Ajv {
    constructor(opts = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = new Set;
      this._loading = {};
      this._cache = new Map;
      opts = this.opts = { ...opts, ...requiredOptions(opts) };
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger(opts.logger);
      const formatOpt = opts.validateFormats;
      opts.validateFormats = false;
      this.RULES = (0, rules_1.getRules)();
      checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts.keywords)
        addInitialKeywords.call(this, opts.keywords);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      addInitialSchemas.call(this);
      opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = { ...$dataRefSchema };
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined;
    }
    validate(schemaKeyRef, data3) {
      let v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v = this.compile(schemaKeyRef);
      }
      const valid = v(data3);
      if (!("$async" in v))
        this.errors = v.errors;
      return valid;
    }
    compile(schema, _meta) {
      const sch = this._addSchema(schema, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema, meta) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema, meta);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e) {
          if (!(e instanceof ref_error_1.default))
            throw e;
          checkLoaded.call(this, e);
          await loadMissingSchema.call(this, e.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref, missingRef }) {
        if (this.refs[ref]) {
          throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref) {
        const _schema = await _loadSchema.call(this, ref);
        if (!this.refs[ref])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref])
          this.addSchema(_schema, ref, meta);
      }
      async function _loadSchema(ref) {
        const p = this._loading[ref];
        if (p)
          return p;
        try {
          return await (this._loading[ref] = loadSchema(ref));
        } finally {
          delete this._loading[ref];
        }
      }
    }
    addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema)) {
        for (const sch of schema)
          this.addSchema(sch, undefined, _meta, _validateSchema);
        return this;
      }
      let id2;
      if (typeof schema === "object") {
        const { schemaId } = this.opts;
        id2 = schema[schemaId];
        if (id2 !== undefined && typeof id2 != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key = (0, resolve_1.normalizeId)(key || id2);
      this._checkUnique(key);
      this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
      return this;
    }
    addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema, key, true, _validateSchema);
      return this;
    }
    validateSchema(schema, throwOrLogError) {
      if (typeof schema == "boolean")
        return true;
      let $schema;
      $schema = schema.$schema;
      if ($schema !== undefined && typeof $schema != "string") {
        throw new Error("$schema must be a string");
      }
      $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid = this.validate($schema, schema);
      if (!valid && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid;
    }
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === undefined) {
        const { schemaId } = this.opts;
        const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
        sch = compile_1.resolveSchema.call(this, root, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey2 = schemaKeyRef;
          this._cache.delete(cacheKey2);
          let id2 = schemaKeyRef[this.opts.schemaId];
          if (id2) {
            id2 = (0, resolve_1.normalizeId)(id2);
            delete this.schemas[id2];
            delete this.refs[id2];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    addVocabulary(definitions) {
      for (const def of definitions)
        this.addKeyword(def);
      return this;
    }
    addKeyword(kwdOrDef, def) {
      let keyword;
      if (typeof kwdOrDef == "string") {
        keyword = kwdOrDef;
        if (typeof def == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def.keyword = keyword;
        }
      } else if (typeof kwdOrDef == "object" && def === undefined) {
        def = kwdOrDef;
        keyword = def.keyword;
        if (Array.isArray(keyword) && !keyword.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword, def);
      if (!def) {
        (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def);
      const definition = {
        ...def,
        type: (0, dataType_1.getJSONTypes)(def.type),
        schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
      };
      (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
      return this;
    }
    getKeyword(keyword) {
      const rule = this.RULES.all[keyword];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    removeKeyword(keyword) {
      const { RULES } = this;
      delete RULES.keywords[keyword];
      delete RULES.all[keyword];
      for (const group of RULES.rules) {
        const i = group.rules.findIndex((rule) => rule.keyword === keyword);
        if (i >= 0)
          group.rules.splice(i, 1);
      }
      return this;
    }
    addFormat(name, format3) {
      if (typeof format3 == "string")
        format3 = new RegExp(format3);
      this.formats[name] = format3;
      return this;
    }
    errorsText(errors4 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors4 || errors4.length === 0)
        return "No errors";
      return errors4.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key in rules) {
          const rule = rules[key];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema = keywords[key];
          if ($data && schema)
            keywords[key] = schemaOrData(schema);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas5, regex3) {
      for (const keyRef in schemas5) {
        const sch = schemas5[keyRef];
        if (!regex3 || regex3.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas5[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas5[keyRef];
          }
        }
      }
    }
    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id2;
      const { schemaId } = this.opts;
      if (typeof schema == "object") {
        id2 = schema[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema);
      if (sch !== undefined)
        return sch;
      baseId = (0, resolve_1.normalizeId)(id2 || baseId);
      const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
      sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema, true);
      return sch;
    }
    _checkUnique(id2) {
      if (this.schemas[id2] || this.refs[id2]) {
        throw new Error(`schema with key or id "${id2}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_1.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_1.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  exports.default = Ajv;
  Ajv.ValidationError = validation_error_1.default;
  Ajv.MissingRefError = ref_error_1.default;
  var noLogs = { log() {
  }, warn() {
  }, error() {
  } };
  var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  var $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var def = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS((exports) => {
  var getValidate = function(cxt, sch) {
    const { gen: gen2 } = cxt;
    return sch.validate ? gen2.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen2.scopeValue("wrapper", { ref: sch })}.validate`;
  };
  var callRef = function(cxt, v, sch, $async) {
    const { gen: gen2, it } = cxt;
    const { allErrors, schemaEnv: env2, opts } = it;
    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
    if ($async)
      callAsyncRef();
    else
      callSyncRef();
    function callAsyncRef() {
      if (!env2.$async)
        throw new Error("async schema referenced by sync schema");
      const valid = gen2.let("valid");
      gen2.try(() => {
        gen2.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
        addEvaluatedFrom(v);
        if (!allErrors)
          gen2.assign(valid, true);
      }, (e) => {
        gen2.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen2.throw(e));
        addErrorsFrom(e);
        if (!allErrors)
          gen2.assign(valid, false);
      });
      cxt.ok(valid);
    }
    function callSyncRef() {
      cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
    }
    function addErrorsFrom(source) {
      const errs = (0, codegen_1._)`${source}.errors`;
      gen2.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
      gen2.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
    }
    function addEvaluatedFrom(source) {
      var _a2;
      if (!it.opts.unevaluated)
        return;
      const schEvaluated = (_a2 = sch === null || sch === undefined ? undefined : sch.validate) === null || _a2 === undefined ? undefined : _a2.evaluated;
      if (it.props !== true) {
        if (schEvaluated && !schEvaluated.dynamicProps) {
          if (schEvaluated.props !== undefined) {
            it.props = util_1.mergeEvaluated.props(gen2, schEvaluated.props, it.props);
          }
        } else {
          const props = gen2.var("props", (0, codegen_1._)`${source}.evaluated.props`);
          it.props = util_1.mergeEvaluated.props(gen2, props, it.props, codegen_1.Name);
        }
      }
      if (it.items !== true) {
        if (schEvaluated && !schEvaluated.dynamicItems) {
          if (schEvaluated.items !== undefined) {
            it.items = util_1.mergeEvaluated.items(gen2, schEvaluated.items, it.items);
          }
        } else {
          const items = gen2.var("items", (0, codegen_1._)`${source}.evaluated.items`);
          it.items = util_1.mergeEvaluated.items(gen2, items, it.items, codegen_1.Name);
        }
      }
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.callRef = exports.getValidate = undefined;
  var ref_error_1 = require_ref_error();
  var code_1 = require_code2();
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var compile_1 = require_compile();
  var util_1 = require_util3();
  var def = {
    keyword: "$ref",
    schemaType: "string",
    code(cxt) {
      const { gen: gen2, schema: $ref, it } = cxt;
      const { baseId, schemaEnv: env2, validateName, opts, self: self2 } = it;
      const { root } = env2;
      if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
        return callRootRef();
      const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
      if (schOrEnv === undefined)
        throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
      if (schOrEnv instanceof compile_1.SchemaEnv)
        return callValidate(schOrEnv);
      return inlineRefSchema(schOrEnv);
      function callRootRef() {
        if (env2 === root)
          return callRef(cxt, validateName, env2, env2.$async);
        const rootName = gen2.scopeValue("root", { ref: root });
        return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
      }
      function callValidate(sch) {
        const v = getValidate(cxt, sch);
        callRef(cxt, v, sch, sch.$async);
      }
      function inlineRefSchema(sch) {
        const schName = gen2.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
        const valid = gen2.name("valid");
        const schCxt = cxt.subschema({
          schema: sch,
          dataTypes: [],
          schemaPath: codegen_1.nil,
          topSchemaRef: schName,
          errSchemaPath: $ref
        }, valid);
        cxt.mergeEvaluated(schCxt);
        cxt.ok(valid);
      }
    }
  };
  exports.getValidate = getValidate;
  exports.callRef = callRef;
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var id_1 = require_id();
  var ref_1 = require_ref();
  var core = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    id_1.default,
    ref_1.default
  ];
  exports.default = core;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var ops = codegen_1.operators;
  var KWDs = {
    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
  };
  var error = {
    message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
  };
  var def = {
    keyword: Object.keys(KWDs),
    type: "number",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword, data: data3, schemaCode } = cxt;
      cxt.fail$data((0, codegen_1._)`${data3} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data3})`);
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var error = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
    params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
  };
  var def = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { gen: gen2, data: data3, schemaCode, it } = cxt;
      const prec = it.opts.multipleOfPrecision;
      const res = gen2.let("res");
      const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
      cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data3}/${schemaCode}, ${invalid}))`);
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS((exports) => {
  var ucs2length = function(str) {
    const len = str.length;
    let length = 0;
    let pos = 0;
    let value;
    while (pos < len) {
      length++;
      value = str.charCodeAt(pos++);
      if (value >= 55296 && value <= 56319 && pos < len) {
        value = str.charCodeAt(pos);
        if ((value & 64512) === 56320)
          pos++;
      }
    }
    return length;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = ucs2length;
  ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util3();
  var ucs2length_1 = require_ucs2length();
  var error = {
    message({ keyword, schemaCode }) {
      const comp = keyword === "maxLength" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  var def = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword, data: data3, schemaCode, it } = cxt;
      const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
      const len = it.opts.unicode === false ? (0, codegen_1._)`${data3}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data3})`;
      cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code2();
  var codegen_1 = require_codegen();
  var error = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
  };
  var def = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: true,
    error,
    code(cxt) {
      const { data: data3, $data, schema, schemaCode, it } = cxt;
      const u = it.opts.unicodeRegExp ? "u" : "";
      const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
      cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data3})`);
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var error = {
    message({ keyword, schemaCode }) {
      const comp = keyword === "maxProperties" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  var def = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword, data: data3, schemaCode } = cxt;
      const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`Object.keys(${data3}).length ${op} ${schemaCode}`);
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code2();
  var codegen_1 = require_codegen();
  var util_1 = require_util3();
  var error = {
    message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
    params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
  };
  var def = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: true,
    error,
    code(cxt) {
      const { gen: gen2, schema, schemaCode, data: data3, $data, it } = cxt;
      const { opts } = it;
      if (!$data && schema.length === 0)
        return;
      const useLoop = schema.length >= opts.loopRequired;
      if (it.allErrors)
        allErrorsMode();
      else
        exitOnErrorMode();
      if (opts.strictRequired) {
        const props = cxt.parentSchema.properties;
        const { definedProperties } = cxt.it;
        for (const requiredKey of schema) {
          if ((props === null || props === undefined ? undefined : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
            const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
            const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
            (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
          }
        }
      }
      function allErrorsMode() {
        if (useLoop || $data) {
          cxt.block$data(codegen_1.nil, loopAllRequired);
        } else {
          for (const prop of schema) {
            (0, code_1.checkReportMissingProp)(cxt, prop);
          }
        }
      }
      function exitOnErrorMode() {
        const missing = gen2.let("missing");
        if (useLoop || $data) {
          const valid = gen2.let("valid", true);
          cxt.block$data(valid, () => loopUntilMissing(missing, valid));
          cxt.ok(valid);
        } else {
          gen2.if((0, code_1.checkMissingProp)(cxt, schema, missing));
          (0, code_1.reportMissingProp)(cxt, missing);
          gen2.else();
        }
      }
      function loopAllRequired() {
        gen2.forOf("prop", schemaCode, (prop) => {
          cxt.setParams({ missingProperty: prop });
          gen2.if((0, code_1.noPropertyInData)(gen2, data3, prop, opts.ownProperties), () => cxt.error());
        });
      }
      function loopUntilMissing(missing, valid) {
        cxt.setParams({ missingProperty: missing });
        gen2.forOf(missing, schemaCode, () => {
          gen2.assign(valid, (0, code_1.propertyInData)(gen2, data3, missing, opts.ownProperties));
          gen2.if((0, codegen_1.not)(valid), () => {
            cxt.error();
            gen2.break();
          });
        }, codegen_1.nil);
      }
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var error = {
    message({ keyword, schemaCode }) {
      const comp = keyword === "maxItems" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  var def = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword, data: data3, schemaCode } = cxt;
      const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`${data3}.length ${op} ${schemaCode}`);
    }
  };
  exports.default = def;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fast-json-stringify@5.12.0/node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var equal = require_fast_deep_equal();
  equal.code = 'require("ajv/dist/runtime/equal").default';
  exports.default = equal;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var dataType_1 = require_dataType();
  var codegen_1 = require_codegen();
  var util_1 = require_util3();
  var equal_1 = require_equal();
  var error = {
    message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
    params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
  };
  var def = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: true,
    error,
    code(cxt) {
      const { gen: gen2, data: data3, $data, schema, parentSchema, schemaCode, it } = cxt;
      if (!$data && !schema)
        return;
      const valid = gen2.let("valid");
      const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
      cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
      cxt.ok(valid);
      function validateUniqueItems() {
        const i = gen2.let("i", (0, codegen_1._)`${data3}.length`);
        const j = gen2.let("j");
        cxt.setParams({ i, j });
        gen2.assign(valid, true);
        gen2.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
      }
      function canOptimize() {
        return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
      }
      function loopN(i, j) {
        const item = gen2.name("item");
        const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
        const indices = gen2.const("indices", (0, codegen_1._)`{}`);
        gen2.for((0, codegen_1._)`;${i}--;`, () => {
          gen2.let(item, (0, codegen_1._)`${data3}[${i}]`);
          gen2.if(wrongType, (0, codegen_1._)`continue`);
          if (itemTypes.length > 1)
            gen2.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
          gen2.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
            gen2.assign(j, (0, codegen_1._)`${indices}[${item}]`);
            cxt.error();
            gen2.assign(valid, false).break();
          }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
        });
      }
      function loopN2(i, j) {
        const eql = (0, util_1.useFunc)(gen2, equal_1.default);
        const outer = gen2.name("outer");
        gen2.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen2.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen2.if((0, codegen_1._)`${eql}(${data3}[${i}], ${data3}[${j}])`, () => {
          cxt.error();
          gen2.assign(valid, false).break(outer);
        })));
      }
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util3();
  var equal_1 = require_equal();
  var error = {
    message: "must be equal to constant",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
  };
  var def = {
    keyword: "const",
    $data: true,
    error,
    code(cxt) {
      const { gen: gen2, data: data3, $data, schemaCode, schema } = cxt;
      if ($data || schema && typeof schema == "object") {
        cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen2, equal_1.default)}(${data3}, ${schemaCode})`);
      } else {
        cxt.fail((0, codegen_1._)`${schema} !== ${data3}`);
      }
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util3();
  var equal_1 = require_equal();
  var error = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
  };
  var def = {
    keyword: "enum",
    schemaType: "array",
    $data: true,
    error,
    code(cxt) {
      const { gen: gen2, data: data3, $data, schema, schemaCode, it } = cxt;
      if (!$data && schema.length === 0)
        throw new Error("enum must have non-empty array");
      const useLoop = schema.length >= it.opts.loopEnum;
      let eql;
      const getEql = () => eql !== null && eql !== undefined ? eql : eql = (0, util_1.useFunc)(gen2, equal_1.default);
      let valid;
      if (useLoop || $data) {
        valid = gen2.let("valid");
        cxt.block$data(valid, loopEnum);
      } else {
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const vSchema = gen2.const("vSchema", schemaCode);
        valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
      }
      cxt.pass(valid);
      function loopEnum() {
        gen2.assign(valid, false);
        gen2.forOf("v", schemaCode, (v) => gen2.if((0, codegen_1._)`${getEql()}(${data3}, ${v})`, () => gen2.assign(valid, true).break()));
      }
      function equalCode(vSchema, i) {
        const sch = schema[i];
        return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data3}, ${vSchema}[${i}])` : (0, codegen_1._)`${data3} === ${sch}`;
      }
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var limitNumber_1 = require_limitNumber();
  var multipleOf_1 = require_multipleOf();
  var limitLength_1 = require_limitLength();
  var pattern_1 = require_pattern();
  var limitProperties_1 = require_limitProperties();
  var required_1 = require_required();
  var limitItems_1 = require_limitItems();
  var uniqueItems_1 = require_uniqueItems();
  var const_1 = require_const();
  var enum_1 = require_enum();
  var validation8 = [
    limitNumber_1.default,
    multipleOf_1.default,
    limitLength_1.default,
    pattern_1.default,
    limitProperties_1.default,
    required_1.default,
    limitItems_1.default,
    uniqueItems_1.default,
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    const_1.default,
    enum_1.default
  ];
  exports.default = validation8;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS((exports) => {
  var validateAdditionalItems = function(cxt, items) {
    const { gen: gen2, schema, data: data3, keyword, it } = cxt;
    it.items = true;
    const len = gen2.const("len", (0, codegen_1._)`${data3}.length`);
    if (schema === false) {
      cxt.setParams({ len: items.length });
      cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
    } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
      const valid = gen2.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
      gen2.if((0, codegen_1.not)(valid), () => validateItems(valid));
      cxt.ok(valid);
    }
    function validateItems(valid) {
      gen2.forRange("i", items.length, len, (i) => {
        cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
        if (!it.allErrors)
          gen2.if((0, codegen_1.not)(valid), () => gen2.break());
      });
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateAdditionalItems = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util3();
  var error = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  var def = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error,
    code(cxt) {
      const { parentSchema, it } = cxt;
      const { items } = parentSchema;
      if (!Array.isArray(items)) {
        (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      validateAdditionalItems(cxt, items);
    }
  };
  exports.validateAdditionalItems = validateAdditionalItems;
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS((exports) => {
  var validateTuple = function(cxt, extraItems, schArr = cxt.schema) {
    const { gen: gen2, parentSchema, data: data3, keyword, it } = cxt;
    checkStrictTuple(parentSchema);
    if (it.opts.unevaluated && schArr.length && it.items !== true) {
      it.items = util_1.mergeEvaluated.items(gen2, schArr.length, it.items);
    }
    const valid = gen2.name("valid");
    const len = gen2.const("len", (0, codegen_1._)`${data3}.length`);
    schArr.forEach((sch, i) => {
      if ((0, util_1.alwaysValidSchema)(it, sch))
        return;
      gen2.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
        keyword,
        schemaProp: i,
        dataProp: i
      }, valid));
      cxt.ok(valid);
    });
    function checkStrictTuple(sch) {
      const { opts, errSchemaPath } = it;
      const l = schArr.length;
      const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
      if (opts.strictTuples && !fullTuple) {
        const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
        (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
      }
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateTuple = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util3();
  var code_1 = require_code2();
  var def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(cxt) {
      const { schema, it } = cxt;
      if (Array.isArray(schema))
        return validateTuple(cxt, "additionalItems", schema);
      it.items = true;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  exports.validateTuple = validateTuple;
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var items_1 = require_items();
  var def = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util3();
  var code_1 = require_code2();
  var additionalItems_1 = require_additionalItems();
  var error = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  var def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error,
    code(cxt) {
      const { schema, parentSchema, it } = cxt;
      const { prefixItems } = parentSchema;
      it.items = true;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      if (prefixItems)
        (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
      else
        cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util3();
  var error = {
    message: ({ params: { min, max } }) => max === undefined ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
  };
  var def = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: true,
    error,
    code(cxt) {
      const { gen: gen2, schema, parentSchema, data: data3, it } = cxt;
      let min;
      let max;
      const { minContains, maxContains } = parentSchema;
      if (it.opts.next) {
        min = minContains === undefined ? 1 : minContains;
        max = maxContains;
      } else {
        min = 1;
      }
      const len = gen2.const("len", (0, codegen_1._)`${data3}.length`);
      cxt.setParams({ min, max });
      if (max === undefined && min === 0) {
        (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
        return;
      }
      if (max !== undefined && min > max) {
        (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
        cxt.fail();
        return;
      }
      if ((0, util_1.alwaysValidSchema)(it, schema)) {
        let cond = (0, codegen_1._)`${len} >= ${min}`;
        if (max !== undefined)
          cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
        cxt.pass(cond);
        return;
      }
      it.items = true;
      const valid = gen2.name("valid");
      if (max === undefined && min === 1) {
        validateItems(valid, () => gen2.if(valid, () => gen2.break()));
      } else if (min === 0) {
        gen2.let(valid, true);
        if (max !== undefined)
          gen2.if((0, codegen_1._)`${data3}.length > 0`, validateItemsWithCount);
      } else {
        gen2.let(valid, false);
        validateItemsWithCount();
      }
      cxt.result(valid, () => cxt.reset());
      function validateItemsWithCount() {
        const schValid = gen2.name("_valid");
        const count = gen2.let("count", 0);
        validateItems(schValid, () => gen2.if(schValid, () => checkLimits(count)));
      }
      function validateItems(_valid, block7) {
        gen2.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword: "contains",
            dataProp: i,
            dataPropType: util_1.Type.Num,
            compositeRule: true
          }, _valid);
          block7();
        });
      }
      function checkLimits(count) {
        gen2.code((0, codegen_1._)`${count}++`);
        if (max === undefined) {
          gen2.if((0, codegen_1._)`${count} >= ${min}`, () => gen2.assign(valid, true).break());
        } else {
          gen2.if((0, codegen_1._)`${count} > ${max}`, () => gen2.assign(valid, false).break());
          if (min === 1)
            gen2.assign(valid, true);
          else
            gen2.if((0, codegen_1._)`${count} >= ${min}`, () => gen2.assign(valid, true));
        }
      }
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS((exports) => {
  var splitDependencies = function({ schema }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema) {
      if (key === "__proto__")
        continue;
      const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
      deps[key] = schema[key];
    }
    return [propertyDeps, schemaDeps];
  };
  var validatePropertyDeps = function(cxt, propertyDeps = cxt.schema) {
    const { gen: gen2, data: data3, it } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen2.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = (0, code_1.propertyInData)(gen2, data3, prop, it.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it.allErrors) {
        gen2.if(hasProperty, () => {
          for (const depProp of deps) {
            (0, code_1.checkReportMissingProp)(cxt, depProp);
          }
        });
      } else {
        gen2.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
        (0, code_1.reportMissingProp)(cxt, missing);
        gen2.else();
      }
    }
  };
  var validateSchemaDeps = function(cxt, schemaDeps = cxt.schema) {
    const { gen: gen2, data: data3, keyword, it } = cxt;
    const valid = gen2.name("valid");
    for (const prop in schemaDeps) {
      if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
        continue;
      gen2.if((0, code_1.propertyInData)(gen2, data3, prop, it.opts.ownProperties), () => {
        const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
        cxt.mergeValidEvaluated(schCxt, valid);
      }, () => gen2.var(valid, true));
      cxt.ok(valid);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util3();
  var code_1 = require_code2();
  exports.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
  };
  var def = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  exports.validatePropertyDeps = validatePropertyDeps;
  exports.validateSchemaDeps = validateSchemaDeps;
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util3();
  var error = {
    message: "property name must be valid",
    params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
  };
  var def = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error,
    code(cxt) {
      const { gen: gen2, schema, data: data3, it } = cxt;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      const valid = gen2.name("valid");
      gen2.forIn("key", data3, (key) => {
        cxt.setParams({ propertyName: key });
        cxt.subschema({
          keyword: "propertyNames",
          data: key,
          dataTypes: ["string"],
          propertyName: key,
          compositeRule: true
        }, valid);
        gen2.if((0, codegen_1.not)(valid), () => {
          cxt.error(true);
          if (!it.allErrors)
            gen2.break();
        });
      });
      cxt.ok(valid);
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code2();
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var util_1 = require_util3();
  var error = {
    message: "must NOT have additional properties",
    params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
  };
  var def = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: true,
    trackErrors: true,
    error,
    code(cxt) {
      const { gen: gen2, schema, parentSchema, data: data3, errsCount, it } = cxt;
      if (!errsCount)
        throw new Error("ajv implementation error");
      const { allErrors, opts } = it;
      it.props = true;
      if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
        return;
      const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
      const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
      checkAdditionalProperties();
      cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
      function checkAdditionalProperties() {
        gen2.forIn("key", data3, (key) => {
          if (!props.length && !patProps.length)
            additionalPropertyCode(key);
          else
            gen2.if(isAdditional(key), () => additionalPropertyCode(key));
        });
      }
      function isAdditional(key) {
        let definedProp;
        if (props.length > 8) {
          const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
          definedProp = (0, code_1.isOwnProperty)(gen2, propsSchema, key);
        } else if (props.length) {
          definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
        } else {
          definedProp = codegen_1.nil;
        }
        if (patProps.length) {
          definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
        }
        return (0, codegen_1.not)(definedProp);
      }
      function deleteAdditional(key) {
        gen2.code((0, codegen_1._)`delete ${data3}[${key}]`);
      }
      function additionalPropertyCode(key) {
        if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
          deleteAdditional(key);
          return;
        }
        if (schema === false) {
          cxt.setParams({ additionalProperty: key });
          cxt.error();
          if (!allErrors)
            gen2.break();
          return;
        }
        if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
          const valid = gen2.name("valid");
          if (opts.removeAdditional === "failing") {
            applyAdditionalSchema(key, valid, false);
            gen2.if((0, codegen_1.not)(valid), () => {
              cxt.reset();
              deleteAdditional(key);
            });
          } else {
            applyAdditionalSchema(key, valid);
            if (!allErrors)
              gen2.if((0, codegen_1.not)(valid), () => gen2.break());
          }
        }
      }
      function applyAdditionalSchema(key, valid, errors4) {
        const subschema = {
          keyword: "additionalProperties",
          dataProp: key,
          dataPropType: util_1.Type.Str
        };
        if (errors4 === false) {
          Object.assign(subschema, {
            compositeRule: true,
            createErrors: false,
            allErrors: false
          });
        }
        cxt.subschema(subschema, valid);
      }
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var validate_1 = require_validate();
  var code_1 = require_code2();
  var util_1 = require_util3();
  var additionalProperties_1 = require_additionalProperties();
  var def = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen: gen2, schema, parentSchema, data: data3, it } = cxt;
      if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
        additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
      }
      const allProps = (0, code_1.allSchemaProperties)(schema);
      for (const prop of allProps) {
        it.definedProperties.add(prop);
      }
      if (it.opts.unevaluated && allProps.length && it.props !== true) {
        it.props = util_1.mergeEvaluated.props(gen2, (0, util_1.toHash)(allProps), it.props);
      }
      const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
      if (properties.length === 0)
        return;
      const valid = gen2.name("valid");
      for (const prop of properties) {
        if (hasDefault(prop)) {
          applyPropertySchema(prop);
        } else {
          gen2.if((0, code_1.propertyInData)(gen2, data3, prop, it.opts.ownProperties));
          applyPropertySchema(prop);
          if (!it.allErrors)
            gen2.else().var(valid, true);
          gen2.endIf();
        }
        cxt.it.definedProperties.add(prop);
        cxt.ok(valid);
      }
      function hasDefault(prop) {
        return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;
      }
      function applyPropertySchema(prop) {
        cxt.subschema({
          keyword: "properties",
          schemaProp: prop,
          dataProp: prop
        }, valid);
      }
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code2();
  var codegen_1 = require_codegen();
  var util_1 = require_util3();
  var util_2 = require_util3();
  var def = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen: gen2, schema, data: data3, parentSchema, it } = cxt;
      const { opts } = it;
      const patterns = (0, code_1.allSchemaProperties)(schema);
      const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
      if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
        return;
      }
      const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
      const valid = gen2.name("valid");
      if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
        it.props = (0, util_2.evaluatedPropsToName)(gen2, it.props);
      }
      const { props } = it;
      validatePatternProperties();
      function validatePatternProperties() {
        for (const pat of patterns) {
          if (checkProperties)
            checkMatchingProperties(pat);
          if (it.allErrors) {
            validateProperties(pat);
          } else {
            gen2.var(valid, true);
            validateProperties(pat);
            gen2.if(valid);
          }
        }
      }
      function checkMatchingProperties(pat) {
        for (const prop in checkProperties) {
          if (new RegExp(pat).test(prop)) {
            (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
          }
        }
      }
      function validateProperties(pat) {
        gen2.forIn("key", data3, (key) => {
          gen2.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
            const alwaysValid = alwaysValidPatterns.includes(pat);
            if (!alwaysValid) {
              cxt.subschema({
                keyword: "patternProperties",
                schemaProp: pat,
                dataProp: key,
                dataPropType: util_2.Type.Str
              }, valid);
            }
            if (it.opts.unevaluated && props !== true) {
              gen2.assign((0, codegen_1._)`${props}[${key}]`, true);
            } else if (!alwaysValid && !it.allErrors) {
              gen2.if((0, codegen_1.not)(valid), () => gen2.break());
            }
          });
        });
      }
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util3();
  var def = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    code(cxt) {
      const { gen: gen2, schema, it } = cxt;
      if ((0, util_1.alwaysValidSchema)(it, schema)) {
        cxt.fail();
        return;
      }
      const valid = gen2.name("valid");
      cxt.subschema({
        keyword: "not",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, valid);
      cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
    },
    error: { message: "must NOT be valid" }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code2();
  var def = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: true,
    code: code_1.validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util3();
  var error = {
    message: "must match exactly one schema in oneOf",
    params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
  };
  var def = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: true,
    error,
    code(cxt) {
      const { gen: gen2, schema, parentSchema, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      if (it.opts.discriminator && parentSchema.discriminator)
        return;
      const schArr = schema;
      const valid = gen2.let("valid", false);
      const passing = gen2.let("passing", null);
      const schValid = gen2.name("_valid");
      cxt.setParams({ passing });
      gen2.block(validateOneOf);
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
      function validateOneOf() {
        schArr.forEach((sch, i) => {
          let schCxt;
          if ((0, util_1.alwaysValidSchema)(it, sch)) {
            gen2.var(schValid, true);
          } else {
            schCxt = cxt.subschema({
              keyword: "oneOf",
              schemaProp: i,
              compositeRule: true
            }, schValid);
          }
          if (i > 0) {
            gen2.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
          }
          gen2.if(schValid, () => {
            gen2.assign(valid, true);
            gen2.assign(passing, i);
            if (schCxt)
              cxt.mergeEvaluated(schCxt, codegen_1.Name);
          });
        });
      }
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util3();
  var def = {
    keyword: "allOf",
    schemaType: "array",
    code(cxt) {
      const { gen: gen2, schema, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const valid = gen2.name("valid");
      schema.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
        cxt.ok(valid);
        cxt.mergeEvaluated(schCxt);
      });
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS((exports) => {
  var hasSchema = function(it, keyword) {
    const schema = it.schema[keyword];
    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util3();
  var error = {
    message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
    params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
  };
  var def = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    error,
    code(cxt) {
      const { gen: gen2, parentSchema, it } = cxt;
      if (parentSchema.then === undefined && parentSchema.else === undefined) {
        (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
      }
      const hasThen = hasSchema(it, "then");
      const hasElse = hasSchema(it, "else");
      if (!hasThen && !hasElse)
        return;
      const valid = gen2.let("valid", true);
      const schValid = gen2.name("_valid");
      validateIf();
      cxt.reset();
      if (hasThen && hasElse) {
        const ifClause = gen2.let("ifClause");
        cxt.setParams({ ifClause });
        gen2.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
      } else if (hasThen) {
        gen2.if(schValid, validateClause("then"));
      } else {
        gen2.if((0, codegen_1.not)(schValid), validateClause("else"));
      }
      cxt.pass(valid, () => cxt.error(true));
      function validateIf() {
        const schCxt = cxt.subschema({
          keyword: "if",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, schValid);
        cxt.mergeEvaluated(schCxt);
      }
      function validateClause(keyword, ifClause) {
        return () => {
          const schCxt = cxt.subschema({ keyword }, schValid);
          gen2.assign(valid, schValid);
          cxt.mergeValidEvaluated(schCxt, valid);
          if (ifClause)
            gen2.assign(ifClause, (0, codegen_1._)`${keyword}`);
          else
            cxt.setParams({ ifClause: keyword });
        };
      }
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util3();
  var def = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword, parentSchema, it }) {
      if (parentSchema.if === undefined)
        (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS((exports) => {
  var getApplicator = function(draft2020 = false) {
    const applicator = [
      not_1.default,
      anyOf_1.default,
      oneOf_1.default,
      allOf_1.default,
      if_1.default,
      thenElse_1.default,
      propertyNames_1.default,
      additionalProperties_1.default,
      dependencies_1.default,
      properties_1.default,
      patternProperties_1.default
    ];
    if (draft2020)
      applicator.push(prefixItems_1.default, items2020_1.default);
    else
      applicator.push(additionalItems_1.default, items_1.default);
    applicator.push(contains_1.default);
    return applicator;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var additionalItems_1 = require_additionalItems();
  var prefixItems_1 = require_prefixItems();
  var items_1 = require_items();
  var items2020_1 = require_items2020();
  var contains_1 = require_contains();
  var dependencies_1 = require_dependencies();
  var propertyNames_1 = require_propertyNames();
  var additionalProperties_1 = require_additionalProperties();
  var properties_1 = require_properties();
  var patternProperties_1 = require_patternProperties();
  var not_1 = require_not();
  var anyOf_1 = require_anyOf();
  var oneOf_1 = require_oneOf();
  var allOf_1 = require_allOf();
  var if_1 = require_if();
  var thenElse_1 = require_thenElse();
  exports.default = getApplicator;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var error = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
  };
  var def = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: true,
    error,
    code(cxt, ruleType) {
      const { gen: gen2, data: data3, $data, schema, schemaCode, it } = cxt;
      const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
      if (!opts.validateFormats)
        return;
      if ($data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen2.scopeValue("formats", {
          ref: self2.formats,
          code: opts.code.formats
        });
        const fDef = gen2.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
        const fType = gen2.let("fType");
        const format3 = gen2.let("format");
        gen2.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen2.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format3, (0, codegen_1._)`${fDef}.validate`), () => gen2.assign(fType, (0, codegen_1._)`"string"`).assign(format3, fDef));
        cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
        function unknownFmt() {
          if (opts.strictSchema === false)
            return codegen_1.nil;
          return (0, codegen_1._)`${schemaCode} && !${format3}`;
        }
        function invalidFmt() {
          const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format3}(${data3}) : ${format3}(${data3}))` : (0, codegen_1._)`${format3}(${data3})`;
          const validData = (0, codegen_1._)`(typeof ${format3} == "function" ? ${callFormat} : ${format3}.test(${data3}))`;
          return (0, codegen_1._)`${format3} && ${format3} !== true && ${fType} === ${ruleType} && !${validData}`;
        }
      }
      function validateFormat() {
        const formatDef = self2.formats[schema];
        if (!formatDef) {
          unknownFormat();
          return;
        }
        if (formatDef === true)
          return;
        const [fmtType, format3, fmtRef] = getFormat(formatDef);
        if (fmtType === ruleType)
          cxt.pass(validCondition());
        function unknownFormat() {
          if (opts.strictSchema === false) {
            self2.logger.warn(unknownMsg());
            return;
          }
          throw new Error(unknownMsg());
          function unknownMsg() {
            return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
          }
        }
        function getFormat(fmtDef) {
          const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : undefined;
          const fmt = gen2.scopeValue("formats", { key: schema, ref: fmtDef, code });
          if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
            return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
          }
          return ["string", fmtDef, fmt];
        }
        function validCondition() {
          if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
            if (!schemaEnv.$async)
              throw new Error("async format in sync schema");
            return (0, codegen_1._)`await ${fmtRef}(${data3})`;
          }
          return typeof format3 == "function" ? (0, codegen_1._)`${fmtRef}(${data3})` : (0, codegen_1._)`${fmtRef}.test(${data3})`;
        }
      }
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var format_1 = require_format();
  var format3 = [format_1.default];
  exports.default = format3;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.contentVocabulary = exports.metadataVocabulary = undefined;
  exports.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ];
  exports.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ];
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var core_1 = require_core2();
  var validation_1 = require_validation3();
  var applicator_1 = require_applicator();
  var format_1 = require_format2();
  var metadata_1 = require_metadata3();
  var draft7Vocabularies = [
    core_1.default,
    validation_1.default,
    (0, applicator_1.default)(),
    format_1.default,
    metadata_1.metadataVocabulary,
    metadata_1.contentVocabulary
  ];
  exports.default = draft7Vocabularies;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiscrError = undefined;
  var DiscrError;
  (function(DiscrError2) {
    DiscrError2["Tag"] = "tag";
    DiscrError2["Mapping"] = "mapping";
  })(DiscrError = exports.DiscrError || (exports.DiscrError = {}));
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var types_1 = require_types3();
  var compile_1 = require_compile();
  var util_1 = require_util3();
  var error = {
    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
  };
  var def = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error,
    code(cxt) {
      const { gen: gen2, data: data3, schema, parentSchema, it } = cxt;
      const { oneOf } = parentSchema;
      if (!it.opts.discriminator) {
        throw new Error("discriminator: requires discriminator option");
      }
      const tagName = schema.propertyName;
      if (typeof tagName != "string")
        throw new Error("discriminator: requires propertyName");
      if (schema.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!oneOf)
        throw new Error("discriminator: requires oneOf keyword");
      const valid = gen2.let("valid", false);
      const tag = gen2.const("tag", (0, codegen_1._)`${data3}${(0, codegen_1.getProperty)(tagName)}`);
      gen2.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
      cxt.ok(valid);
      function validateMapping() {
        const mapping = getMapping();
        gen2.if(false);
        for (const tagValue in mapping) {
          gen2.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
          gen2.assign(valid, applyTagSchema(mapping[tagValue]));
        }
        gen2.else();
        cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
        gen2.endIf();
      }
      function applyTagSchema(schemaProp) {
        const _valid = gen2.name("valid");
        const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
        cxt.mergeEvaluated(schCxt, codegen_1.Name);
        return _valid;
      }
      function getMapping() {
        var _a2;
        const oneOfMapping = {};
        const topRequired = hasRequired(parentSchema);
        let tagRequired = true;
        for (let i = 0;i < oneOf.length; i++) {
          let sch = oneOf[i];
          if ((sch === null || sch === undefined ? undefined : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
            sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === undefined ? undefined : sch.$ref);
            if (sch instanceof compile_1.SchemaEnv)
              sch = sch.schema;
          }
          const propSch = (_a2 = sch === null || sch === undefined ? undefined : sch.properties) === null || _a2 === undefined ? undefined : _a2[tagName];
          if (typeof propSch != "object") {
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
          }
          tagRequired = tagRequired && (topRequired || hasRequired(sch));
          addMappings(propSch, i);
        }
        if (!tagRequired)
          throw new Error(`discriminator: "${tagName}" must be required`);
        return oneOfMapping;
        function hasRequired({ required }) {
          return Array.isArray(required) && required.includes(tagName);
        }
        function addMappings(sch, i) {
          if (sch.const) {
            addMapping(sch.const, i);
          } else if (sch.enum) {
            for (const tagValue of sch.enum) {
              addMapping(tagValue, i);
            }
          } else {
            throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
          }
        }
        function addMapping(tagValue, i) {
          if (typeof tagValue != "string" || tagValue in oneOfMapping) {
            throw new Error(`discriminator: "${tagName}" values must be unique strings`);
          }
          oneOfMapping[tagValue] = i;
        }
      }
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS((exports, module) => {
  module.exports = {
    $schema: "http://json-schema.org/draft-07/schema#",
    $id: "http://json-schema.org/draft-07/schema#",
    title: "Core schema meta-schema",
    definitions: {
      schemaArray: {
        type: "array",
        minItems: 1,
        items: { $ref: "#" }
      },
      nonNegativeInteger: {
        type: "integer",
        minimum: 0
      },
      nonNegativeIntegerDefault0: {
        allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
      },
      simpleTypes: {
        enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
      },
      stringArray: {
        type: "array",
        items: { type: "string" },
        uniqueItems: true,
        default: []
      }
    },
    type: ["object", "boolean"],
    properties: {
      $id: {
        type: "string",
        format: "uri-reference"
      },
      $schema: {
        type: "string",
        format: "uri"
      },
      $ref: {
        type: "string",
        format: "uri-reference"
      },
      $comment: {
        type: "string"
      },
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      default: true,
      readOnly: {
        type: "boolean",
        default: false
      },
      examples: {
        type: "array",
        items: true
      },
      multipleOf: {
        type: "number",
        exclusiveMinimum: 0
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "number"
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "number"
      },
      maxLength: { $ref: "#/definitions/nonNegativeInteger" },
      minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      pattern: {
        type: "string",
        format: "regex"
      },
      additionalItems: { $ref: "#" },
      items: {
        anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
        default: true
      },
      maxItems: { $ref: "#/definitions/nonNegativeInteger" },
      minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      uniqueItems: {
        type: "boolean",
        default: false
      },
      contains: { $ref: "#" },
      maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
      minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      required: { $ref: "#/definitions/stringArray" },
      additionalProperties: { $ref: "#" },
      definitions: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      properties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      patternProperties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        propertyNames: { format: "regex" },
        default: {}
      },
      dependencies: {
        type: "object",
        additionalProperties: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
        }
      },
      propertyNames: { $ref: "#" },
      const: true,
      enum: {
        type: "array",
        items: true,
        minItems: 1,
        uniqueItems: true
      },
      type: {
        anyOf: [
          { $ref: "#/definitions/simpleTypes" },
          {
            type: "array",
            items: { $ref: "#/definitions/simpleTypes" },
            minItems: 1,
            uniqueItems: true
          }
        ]
      },
      format: { type: "string" },
      contentMediaType: { type: "string" },
      contentEncoding: { type: "string" },
      if: { $ref: "#" },
      then: { $ref: "#" },
      else: { $ref: "#" },
      allOf: { $ref: "#/definitions/schemaArray" },
      anyOf: { $ref: "#/definitions/schemaArray" },
      oneOf: { $ref: "#/definitions/schemaArray" },
      not: { $ref: "#" }
    },
    default: true
  };
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/@fastify+ajv-compiler@3.5.0/node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = undefined;
  var core_1 = require_core();
  var draft7_1 = require_draft7();
  var discriminator_1 = require_discriminator();
  var draft7MetaSchema = require_json_schema_draft_07();
  var META_SUPPORT_DATA = ["/properties"];
  var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";

  class Ajv extends core_1.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v) => this.addVocabulary(v));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined);
    }
  }
  module.exports = exports = Ajv;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = Ajv;
  var validate_1 = require_validate();
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_1.KeywordCxt;
  } });
  var codegen_1 = require_codegen();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_1._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_1.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_1.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_1.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_1.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_1.CodeGen;
  } });
  var validation_error_1 = require_validation_error();
  Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
    return validation_error_1.default;
  } });
  var ref_error_1 = require_ref_error();
  Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
    return ref_error_1.default;
  } });
});

// ../node_modules/.pnpm/fast-uri@2.3.0/node_modules/fast-uri/lib/scopedChars.js
var require_scopedChars = __commonJS((exports, module) => {
  var HEX = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  module.exports = {
    HEX
  };
});

// ../node_modules/.pnpm/fast-uri@2.3.0/node_modules/fast-uri/lib/utils.js
var require_utils5 = __commonJS((exports, module) => {
  var normalizeIPv4 = function(host) {
    if (findToken(host, ".") < 3) {
      return { host, isIPV4: false };
    }
    const matches = host.match(/^(\b[01]?\d{1,2}|\b2[0-4]\d|\b25[0-5])(\.([01]?\d{1,2}|2[0-4]\d|25[0-5])){3}$/u) || [];
    const [address10] = matches;
    if (address10) {
      return { host: stripLeadingZeros(address10, "."), isIPV4: true };
    } else {
      return { host, isIPV4: false };
    }
  };
  var stringToHexStripped = function(input) {
    let acc = "";
    let strip = true;
    for (const c of input) {
      if (c !== "0" && strip === true)
        strip = false;
      if (HEX[c] === undefined)
        return;
      if (!strip)
        acc += c;
    }
    return acc;
  };
  var getIPV6 = function(input) {
    let tokenCount = 0;
    const output2 = { error: false, address: "", zone: "" };
    const address10 = [];
    const buffer2 = [];
    let isZone = false;
    let endipv6Encountered = false;
    let endIpv6 = false;
    function consume() {
      if (buffer2.length) {
        if (isZone === false) {
          const hex = stringToHexStripped(buffer2.join(""));
          if (hex !== undefined) {
            address10.push(hex);
          } else {
            output2.error = true;
            return false;
          }
        }
        buffer2.length = 0;
      }
      return true;
    }
    for (let i = 0;i < input.length; i++) {
      const cursor3 = input[i];
      if (cursor3 === "[" || cursor3 === "]") {
        continue;
      }
      if (cursor3 === ":") {
        if (endipv6Encountered === true) {
          endIpv6 = true;
        }
        if (!consume()) {
          break;
        }
        tokenCount++;
        address10.push(":");
        if (tokenCount > 7) {
          output2.error = true;
          break;
        }
        if (i - 1 >= 0 && input[i - 1] === ":") {
          endipv6Encountered = true;
        }
        continue;
      } else if (cursor3 === "%") {
        if (!consume()) {
          break;
        }
        isZone = true;
      } else {
        buffer2.push(cursor3);
        continue;
      }
    }
    if (buffer2.length) {
      if (isZone) {
        output2.zone = buffer2.join("");
      } else if (endIpv6) {
        address10.push(buffer2.join(""));
      } else {
        address10.push(stringToHexStripped(buffer2.join("")));
      }
    }
    output2.address = address10.join("");
    return output2;
  };
  var normalizeIPv6 = function(host, opts = {}) {
    if (findToken(host, ":") < 2) {
      return { host, isIPV6: false };
    }
    const ipv6 = getIPV6(host);
    if (!ipv6.error) {
      let newHost = ipv6.address;
      let escapedHost = ipv6.address;
      if (ipv6.zone) {
        newHost += "%" + ipv6.zone;
        escapedHost += "%25" + ipv6.zone;
      }
      return { host: newHost, escapedHost, isIPV6: true };
    } else {
      return { host, isIPV6: false };
    }
  };
  var stripLeadingZeros = function(str, token) {
    let out = "";
    let skip = true;
    const l = str.length;
    for (let i = 0;i < l; i++) {
      const c = str[i];
      if (c === "0" && skip) {
        if (i + 1 <= l && str[i + 1] === token || i + 1 === l) {
          out += c;
          skip = false;
        }
      } else {
        if (c === token) {
          skip = true;
        } else {
          skip = false;
        }
        out += c;
      }
    }
    return out;
  };
  var findToken = function(str, token) {
    let ind = 0;
    for (let i = 0;i < str.length; i++) {
      if (str[i] === token)
        ind++;
    }
    return ind;
  };
  var removeDotSegments = function(input) {
    const output2 = [];
    while (input.length) {
      if (input.match(RDS1)) {
        input = input.replace(RDS1, "");
      } else if (input.match(RDS2)) {
        input = input.replace(RDS2, "/");
      } else if (input.match(RDS3)) {
        input = input.replace(RDS3, "/");
        output2.pop();
      } else if (input === "." || input === "..") {
        input = "";
      } else {
        const im = input.match(RDS5);
        if (im) {
          const s = im[0];
          input = input.slice(s.length);
          output2.push(s);
        } else {
          throw new Error("Unexpected dot segment condition");
        }
      }
    }
    return output2.join("");
  };
  var normalizeComponentEncoding = function(components, esc) {
    const func = esc !== true ? escape : unescape;
    if (components.scheme !== undefined) {
      components.scheme = func(components.scheme);
    }
    if (components.userinfo !== undefined) {
      components.userinfo = func(components.userinfo);
    }
    if (components.host !== undefined) {
      components.host = func(components.host);
    }
    if (components.path !== undefined) {
      components.path = func(components.path);
    }
    if (components.query !== undefined) {
      components.query = func(components.query);
    }
    if (components.fragment !== undefined) {
      components.fragment = func(components.fragment);
    }
    return components;
  };
  var recomposeAuthority = function(components, options) {
    const uriTokens = [];
    if (components.userinfo !== undefined) {
      uriTokens.push(components.userinfo);
      uriTokens.push("@");
    }
    if (components.host !== undefined) {
      let host = unescape(components.host);
      const ipV4res = normalizeIPv4(host);
      if (ipV4res.isIPV4) {
        host = ipV4res.host;
      } else {
        const ipV6res = normalizeIPv6(ipV4res.host, { isIPV4: false });
        if (ipV6res.isIPV6 === true) {
          host = `[${ipV6res.escapedHost}]`;
        } else {
          host = components.host;
        }
      }
      uriTokens.push(host);
    }
    if (typeof components.port === "number" || typeof components.port === "string") {
      uriTokens.push(":");
      uriTokens.push(String(components.port));
    }
    return uriTokens.length ? uriTokens.join("") : undefined;
  };
  var { HEX } = require_scopedChars();
  var RDS1 = /^\.\.?\//u;
  var RDS2 = /^\/\.(?:\/|$)/u;
  var RDS3 = /^\/\.\.(?:\/|$)/u;
  var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
  module.exports = {
    recomposeAuthority,
    normalizeComponentEncoding,
    removeDotSegments,
    normalizeIPv4,
    normalizeIPv6,
    stringToHexStripped
  };
});

// ../node_modules/.pnpm/fast-uri@2.3.0/node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS((exports, module) => {
  var isSecure = function(wsComponents) {
    return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
  };
  var httpParse = function(components) {
    if (!components.host) {
      components.error = components.error || "HTTP URIs must have a host.";
    }
    return components;
  };
  var httpSerialize = function(components) {
    const secure = String(components.scheme).toLowerCase() === "https";
    if (components.port === (secure ? 443 : 80) || components.port === "") {
      components.port = undefined;
    }
    if (!components.path) {
      components.path = "/";
    }
    return components;
  };
  var wsParse = function(wsComponents) {
    wsComponents.secure = isSecure(wsComponents);
    wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
    wsComponents.path = undefined;
    wsComponents.query = undefined;
    return wsComponents;
  };
  var wsSerialize = function(wsComponents) {
    if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
      wsComponents.port = undefined;
    }
    if (typeof wsComponents.secure === "boolean") {
      wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
      wsComponents.secure = undefined;
    }
    if (wsComponents.resourceName) {
      const [path, query] = wsComponents.resourceName.split("?");
      wsComponents.path = path && path !== "/" ? path : undefined;
      wsComponents.query = query;
      wsComponents.resourceName = undefined;
    }
    wsComponents.fragment = undefined;
    return wsComponents;
  };
  var urnParse = function(urnComponents, options) {
    if (!urnComponents.path) {
      urnComponents.error = "URN can not be parsed";
      return urnComponents;
    }
    const matches = urnComponents.path.match(URN_REG);
    if (matches) {
      const scheme = options.scheme || urnComponents.scheme || "urn";
      urnComponents.nid = matches[1].toLowerCase();
      urnComponents.nss = matches[2];
      const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
      const schemeHandler = SCHEMES[urnScheme];
      urnComponents.path = undefined;
      if (schemeHandler) {
        urnComponents = schemeHandler.parse(urnComponents, options);
      }
    } else {
      urnComponents.error = urnComponents.error || "URN can not be parsed.";
    }
    return urnComponents;
  };
  var urnSerialize = function(urnComponents, options) {
    const scheme = options.scheme || urnComponents.scheme || "urn";
    const nid = urnComponents.nid.toLowerCase();
    const urnScheme = `${scheme}:${options.nid || nid}`;
    const schemeHandler = SCHEMES[urnScheme];
    if (schemeHandler) {
      urnComponents = schemeHandler.serialize(urnComponents, options);
    }
    const uriComponents = urnComponents;
    const nss = urnComponents.nss;
    uriComponents.path = `${nid || options.nid}:${nss}`;
    options.skipEscape = true;
    return uriComponents;
  };
  var urnuuidParse = function(urnComponents, options) {
    const uuidComponents = urnComponents;
    uuidComponents.uuid = uuidComponents.nss;
    uuidComponents.nss = undefined;
    if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
      uuidComponents.error = uuidComponents.error || "UUID is not valid.";
    }
    return uuidComponents;
  };
  var urnuuidSerialize = function(uuidComponents) {
    const urnComponents = uuidComponents;
    urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
    return urnComponents;
  };
  var UUID_REG = /^[\da-f]{8}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{12}$/iu;
  var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
  var http2 = {
    scheme: "http",
    domainHost: true,
    parse: httpParse,
    serialize: httpSerialize
  };
  var https = {
    scheme: "https",
    domainHost: http2.domainHost,
    parse: httpParse,
    serialize: httpSerialize
  };
  var ws = {
    scheme: "ws",
    domainHost: true,
    parse: wsParse,
    serialize: wsSerialize
  };
  var wss = {
    scheme: "wss",
    domainHost: ws.domainHost,
    parse: ws.parse,
    serialize: ws.serialize
  };
  var urn = {
    scheme: "urn",
    parse: urnParse,
    serialize: urnSerialize,
    skipNormalize: true
  };
  var urnuuid = {
    scheme: "urn:uuid",
    parse: urnuuidParse,
    serialize: urnuuidSerialize,
    skipNormalize: true
  };
  var SCHEMES = {
    http: http2,
    https,
    ws,
    wss,
    urn,
    "urn:uuid": urnuuid
  };
  module.exports = SCHEMES;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/@fastify+ajv-compiler@3.5.0/node_modules/fast-uri/index.js
var require_fast_uri = __commonJS((exports, module) => {
  var normalize2 = function(uri, options) {
    if (typeof uri === "string") {
      uri = serialize(parse(uri, options), options);
    } else if (typeof uri === "object") {
      uri = parse(serialize(uri, options), options);
    }
    return uri;
  };
  var resolve5 = function(baseURI, relativeURI, options) {
    const schemelessOptions = Object.assign({ scheme: "null" }, options);
    const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
    return serialize(resolved, { ...schemelessOptions, skipEscape: true });
  };
  var resolveComponents = function(base31, relative2, options, skipNormalization) {
    const target = {};
    if (!skipNormalization) {
      base31 = parse(serialize(base31, options), options);
      relative2 = parse(serialize(relative2, options), options);
    }
    options = options || {};
    if (!options.tolerant && relative2.scheme) {
      target.scheme = relative2.scheme;
      target.userinfo = relative2.userinfo;
      target.host = relative2.host;
      target.port = relative2.port;
      target.path = removeDotSegments(relative2.path || "");
      target.query = relative2.query;
    } else {
      if (relative2.userinfo !== undefined || relative2.host !== undefined || relative2.port !== undefined) {
        target.userinfo = relative2.userinfo;
        target.host = relative2.host;
        target.port = relative2.port;
        target.path = removeDotSegments(relative2.path || "");
        target.query = relative2.query;
      } else {
        if (!relative2.path) {
          target.path = base31.path;
          if (relative2.query !== undefined) {
            target.query = relative2.query;
          } else {
            target.query = base31.query;
          }
        } else {
          if (relative2.path.charAt(0) === "/") {
            target.path = removeDotSegments(relative2.path);
          } else {
            if ((base31.userinfo !== undefined || base31.host !== undefined || base31.port !== undefined) && !base31.path) {
              target.path = "/" + relative2.path;
            } else if (!base31.path) {
              target.path = relative2.path;
            } else {
              target.path = base31.path.slice(0, base31.path.lastIndexOf("/") + 1) + relative2.path;
            }
            target.path = removeDotSegments(target.path);
          }
          target.query = relative2.query;
        }
        target.userinfo = base31.userinfo;
        target.host = base31.host;
        target.port = base31.port;
      }
      target.scheme = base31.scheme;
    }
    target.fragment = relative2.fragment;
    return target;
  };
  var equal = function(uriA, uriB, options) {
    if (typeof uriA === "string") {
      uriA = unescape(uriA);
      uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
    } else if (typeof uriA === "object") {
      uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
    }
    if (typeof uriB === "string") {
      uriB = unescape(uriB);
      uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
    } else if (typeof uriB === "object") {
      uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
    }
    return uriA.toLowerCase() === uriB.toLowerCase();
  };
  var serialize = function(cmpts, opts) {
    const components = {
      host: cmpts.host,
      scheme: cmpts.scheme,
      userinfo: cmpts.userinfo,
      port: cmpts.port,
      path: cmpts.path,
      query: cmpts.query,
      nid: cmpts.nid,
      nss: cmpts.nss,
      uuid: cmpts.uuid,
      fragment: cmpts.fragment,
      reference: cmpts.reference,
      resourceName: cmpts.resourceName,
      secure: cmpts.secure,
      error: ""
    };
    const options = Object.assign({}, opts);
    const uriTokens = [];
    const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
    if (schemeHandler && schemeHandler.serialize)
      schemeHandler.serialize(components, options);
    if (components.path !== undefined) {
      if (!options.skipEscape) {
        components.path = escape(components.path);
        if (components.scheme !== undefined) {
          components.path = components.path.split("%3A").join(":");
        }
      } else {
        components.path = unescape(components.path);
      }
    }
    if (options.reference !== "suffix" && components.scheme) {
      uriTokens.push(components.scheme);
      uriTokens.push(":");
    }
    const authority = recomposeAuthority(components, options);
    if (authority !== undefined) {
      if (options.reference !== "suffix") {
        uriTokens.push("//");
      }
      uriTokens.push(authority);
      if (components.path && components.path.charAt(0) !== "/") {
        uriTokens.push("/");
      }
    }
    if (components.path !== undefined) {
      let s = components.path;
      if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
        s = removeDotSegments(s);
      }
      if (authority === undefined) {
        s = s.replace(/^\/\//u, "/%2F");
      }
      uriTokens.push(s);
    }
    if (components.query !== undefined) {
      uriTokens.push("?");
      uriTokens.push(components.query);
    }
    if (components.fragment !== undefined) {
      uriTokens.push("#");
      uriTokens.push(components.fragment);
    }
    return uriTokens.join("");
  };
  var nonSimpleDomain = function(value) {
    let code = 0;
    for (let i = 0, len = value.length;i < len; ++i) {
      code = value.charCodeAt(i);
      if (code > 126 || hexLookUp[code]) {
        return true;
      }
    }
    return false;
  };
  var parse = function(uri, opts) {
    const options = Object.assign({}, opts);
    const parsed = {
      scheme: undefined,
      userinfo: undefined,
      host: "",
      port: undefined,
      path: "",
      query: undefined,
      fragment: undefined
    };
    const gotEncoding = uri.indexOf("%") !== -1;
    if (options.reference === "suffix")
      uri = (options.scheme ? options.scheme + ":" : "") + "//" + uri;
    const matches = uri.match(URI_PARSE);
    if (matches) {
      parsed.scheme = matches[1];
      parsed.userinfo = matches[3];
      parsed.host = matches[4];
      parsed.port = parseInt(matches[5], 10);
      parsed.path = matches[6] || "";
      parsed.query = matches[7];
      parsed.fragment = matches[8];
      if (isNaN(parsed.port)) {
        parsed.port = matches[5];
      }
      if (parsed.host) {
        const ipv4result = normalizeIPv4(parsed.host);
        if (ipv4result.isIPV4 === false) {
          parsed.host = normalizeIPv6(ipv4result.host, { isIPV4: false }).host.toLowerCase();
        } else {
          parsed.host = ipv4result.host;
        }
      }
      if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && !parsed.path && parsed.query === undefined) {
        parsed.reference = "same-document";
      } else if (parsed.scheme === undefined) {
        parsed.reference = "relative";
      } else if (parsed.fragment === undefined) {
        parsed.reference = "absolute";
      } else {
        parsed.reference = "uri";
      }
      if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
        parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
      }
      const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
      if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
        if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && nonSimpleDomain(parsed.host)) {
          try {
            parsed.host = URL2.domainToASCII(parsed.host.toLowerCase());
          } catch (e) {
            parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
          }
        }
      }
      if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
        if (gotEncoding && parsed.scheme !== undefined) {
          parsed.scheme = unescape(parsed.scheme);
        }
        if (gotEncoding && parsed.userinfo !== undefined) {
          parsed.userinfo = unescape(parsed.userinfo);
        }
        if (gotEncoding && parsed.host !== undefined) {
          parsed.host = unescape(parsed.host);
        }
        if (parsed.path !== undefined && parsed.path.length) {
          parsed.path = encodeURI(parsed.path);
        }
        if (parsed.fragment !== undefined && parsed.fragment.length) {
          parsed.fragment = encodeURI(decodeURI(parsed.fragment));
        }
      }
      if (schemeHandler && schemeHandler.parse) {
        schemeHandler.parse(parsed, options);
      }
    } else {
      parsed.error = parsed.error || "URI can not be parsed.";
    }
    return parsed;
  };
  var URL2 = __require("node:url");
  var { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require_utils5();
  var SCHEMES = require_schemes();
  var hexLookUp = Array.from({ length: 127 }, (v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
  var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  var fastUri = {
    normalize: normalize2,
    resolve: resolve5,
    resolveComponents,
    equal,
    serialize,
    parse
  };
  module.exports = fastUri;
  module.exports.default = fastUri;
  module.exports.fastUri = fastUri;
});

// ../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.12.0/node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS((exports) => {
  var fmtDef = function(validate, compare) {
    return { validate, compare };
  };
  var isLeapYear = function(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  };
  var date = function(str) {
    const matches = DATE.exec(str);
    if (!matches)
      return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
  };
  var compareDate = function(d1, d2) {
    if (!(d1 && d2))
      return;
    if (d1 > d2)
      return 1;
    if (d1 < d2)
      return -1;
    return 0;
  };
  var time = function(str, withTimeZone) {
    const matches = TIME.exec(str);
    if (!matches)
      return false;
    const hour = +matches[1];
    const minute = +matches[2];
    const second = +matches[3];
    const timeZone = matches[5];
    return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
  };
  var compareTime = function(t1, t2) {
    if (!(t1 && t2))
      return;
    const a1 = TIME.exec(t1);
    const a2 = TIME.exec(t2);
    if (!(a1 && a2))
      return;
    t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
    t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
    if (t1 > t2)
      return 1;
    if (t1 < t2)
      return -1;
    return 0;
  };
  var date_time = function(str) {
    const dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
  };
  var compareDateTime = function(dt1, dt2) {
    if (!(dt1 && dt2))
      return;
    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
    const res = compareDate(d1, d2);
    if (res === undefined)
      return;
    return res || compareTime(t1, t2);
  };
  var uri = function(str) {
    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
  };
  var byte = function(str) {
    BYTE.lastIndex = 0;
    return BYTE.test(str);
  };
  var validateInt32 = function(value) {
    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
  };
  var validateInt64 = function(value) {
    return Number.isInteger(value);
  };
  var validateNumber = function() {
    return true;
  };
  var regex3 = function(str) {
    if (Z_ANCHOR.test(str))
      return false;
    try {
      new RegExp(str);
      return true;
    } catch (e) {
      return false;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatNames = exports.fastFormats = exports.fullFormats = undefined;
  exports.fullFormats = {
    date: fmtDef(date, compareDate),
    time: fmtDef(time, compareTime),
    "date-time": fmtDef(date_time, compareDateTime),
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex: regex3,
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    byte,
    int32: { type: "number", validate: validateInt32 },
    int64: { type: "number", validate: validateInt64 },
    float: { type: "number", validate: validateNumber },
    double: { type: "number", validate: validateNumber },
    password: true,
    binary: true
  };
  exports.fastFormats = {
    ...exports.fullFormats,
    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  };
  exports.formatNames = Object.keys(exports.fullFormats);
  var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  var DATE_TIME_SEPARATOR = /t|\s/i;
  var NOT_URI_FRAGMENT = /\/|:/;
  var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  var MIN_INT32 = -(2 ** 31);
  var MAX_INT32 = 2 ** 31 - 1;
  var Z_ANCHOR = /[^\\]\\Z/;
});

// ../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.12.0/node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatLimitDefinition = undefined;
  var ajv_1 = require_ajv();
  var codegen_1 = require_codegen();
  var ops = codegen_1.operators;
  var KWDs = {
    formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
  };
  var error = {
    message: ({ keyword, schemaCode }) => codegen_1.str`should be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => codegen_1._`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
  };
  exports.formatLimitDefinition = {
    keyword: Object.keys(KWDs),
    type: "string",
    schemaType: "string",
    $data: true,
    error,
    code(cxt) {
      const { gen: gen2, data: data3, schemaCode, keyword, it } = cxt;
      const { opts, self: self2 } = it;
      if (!opts.validateFormats)
        return;
      const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
      if (fCxt.$data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen2.scopeValue("formats", {
          ref: self2.formats,
          code: opts.code.formats
        });
        const fmt = gen2.const("fmt", codegen_1._`${fmts}[${fCxt.schemaCode}]`);
        cxt.fail$data(codegen_1.or(codegen_1._`typeof ${fmt} != "object"`, codegen_1._`${fmt} instanceof RegExp`, codegen_1._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
      }
      function validateFormat() {
        const format3 = fCxt.schema;
        const fmtDef = self2.formats[format3];
        if (!fmtDef || fmtDef === true)
          return;
        if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
          throw new Error(`"${keyword}": format "${format3}" does not define "compare" function`);
        }
        const fmt = gen2.scopeValue("formats", {
          key: format3,
          ref: fmtDef,
          code: opts.code.formats ? codegen_1._`${opts.code.formats}${codegen_1.getProperty(format3)}` : undefined
        });
        cxt.fail$data(compareCode(fmt));
      }
      function compareCode(fmt) {
        return codegen_1._`${fmt}.compare(${data3}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
      }
    },
    dependencies: ["format"]
  };
  var formatLimitPlugin = (ajv) => {
    ajv.addKeyword(exports.formatLimitDefinition);
    return ajv;
  };
  exports.default = formatLimitPlugin;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/@fastify+ajv-compiler@3.5.0/node_modules/ajv-formats/dist/index.js
var require_dist = __commonJS((exports, module) => {
  var addFormats = function(ajv, list, fs, exportName) {
    var _a2;
    var _b2;
    (_a2 = (_b2 = ajv.opts.code).formats) !== null && _a2 !== undefined || (_b2.formats = codegen_1._`require("ajv-formats/dist/formats").${exportName}`);
    for (const f of list)
      ajv.addFormat(f, fs[f]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var formats_1 = require_formats();
  var limit_1 = require_limit();
  var codegen_1 = require_codegen();
  var fullName = new codegen_1.Name("fullFormats");
  var fastName = new codegen_1.Name("fastFormats");
  var formatsPlugin = (ajv, opts = { keywords: true }) => {
    if (Array.isArray(opts)) {
      addFormats(ajv, opts, formats_1.fullFormats, fullName);
      return ajv;
    }
    const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
    const list = opts.formats || formats_1.formatNames;
    addFormats(ajv, list, formats, exportName);
    if (opts.keywords)
      limit_1.default(ajv);
    return ajv;
  };
  formatsPlugin.get = (name, mode = "full") => {
    const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
    const f = formats[name];
    if (!f)
      throw new Error(`Unknown format "${name}"`);
    return f;
  };
  module.exports = exports = formatsPlugin;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = formatsPlugin;
});

// ../node_modules/.pnpm/fast-json-stringify@5.12.0/node_modules/fast-json-stringify/lib/validator.js
var require_validator2 = __commonJS((exports, module) => {
  var Ajv = require_ajv();
  var fastUri = require_fast_uri();
  var ajvFormats = require_dist();
  var clone = require_rfdc()({ proto: true });

  class Validator {
    constructor(ajvOptions) {
      this.ajv = new Ajv({
        ...ajvOptions,
        strictSchema: false,
        validateSchema: false,
        allowUnionTypes: true,
        uriResolver: fastUri
      });
      ajvFormats(this.ajv);
      this.ajv.addKeyword({
        keyword: "fjs_type",
        type: "object",
        errors: false,
        validate: (type, date) => {
          return date instanceof Date;
        }
      });
      this._ajvSchemas = {};
      this._ajvOptions = ajvOptions || {};
    }
    addSchema(schema, schemaName) {
      let schemaKey = schema.$id || schemaName;
      if (schema.$id !== undefined && schema.$id[0] === "#") {
        schemaKey = schemaName + schema.$id;
      }
      if (this.ajv.refs[schemaKey] === undefined && this.ajv.schemas[schemaKey] === undefined) {
        const ajvSchema = clone(schema);
        this.convertSchemaToAjvFormat(ajvSchema);
        this.ajv.addSchema(ajvSchema, schemaKey);
        this._ajvSchemas[schemaKey] = schema;
      }
    }
    validate(schemaRef, data3) {
      return this.ajv.validate(schemaRef, data3);
    }
    convertSchemaToAjvFormat(schema) {
      if (schema === null)
        return;
      if (schema.type === "string") {
        schema.fjs_type = "string";
        schema.type = ["string", "object"];
      } else if (Array.isArray(schema.type) && schema.type.includes("string") && !schema.type.includes("object")) {
        schema.fjs_type = "string";
        schema.type.push("object");
      }
      for (const property in schema) {
        if (typeof schema[property] === "object") {
          this.convertSchemaToAjvFormat(schema[property]);
        }
      }
    }
    getState() {
      return {
        ajvOptions: this._ajvOptions,
        ajvSchemas: this._ajvSchemas
      };
    }
    static restoreFromState(state) {
      const validator = new Validator(state.ajvOptions);
      for (const [id2, ajvSchema] of Object.entries(state.ajvSchemas)) {
        validator.ajv.addSchema(ajvSchema, id2);
      }
      return validator;
    }
  }
  module.exports = Validator;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fastify@4.26.0/node_modules/fast-json-stringify/lib/standalone.js
var require_standalone = __commonJS((exports, module) => {
  var buildStandaloneCode = function(contextFunc, context, serializer, validator) {
    let ajvDependencyCode = "";
    if (context.validatorSchemasIds.size > 0) {
      ajvDependencyCode += `const validatorState = ${JSON.stringify(validator.getState())}\n`;
      ajvDependencyCode += "const validator = Validator.restoreFromState(validatorState)\n";
    } else {
      ajvDependencyCode += "const validator = null\n";
    }
    return `
  'use strict'
  const { dependencies } = require('fast-json-stringify/lib/standalone')

  const { Serializer, Validator } = dependencies

  const serializerState = ${JSON.stringify(serializer.getState())}
  const serializer = Serializer.restoreFromState(serializerState)

  ${ajvDependencyCode}

  module.exports = ${contextFunc.toString()}(validator, serializer)`;
  };
  module.exports = buildStandaloneCode;
  module.exports.dependencies = {
    Serializer: require_serializer(),
    Validator: require_validator2()
  };
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/error-serializer.js
var require_error_serializer = __commonJS((exports, module) => {
  var { dependencies } = require_standalone();
  var { Serializer, Validator } = dependencies;
  var serializerState = { mode: "standalone" };
  var serializer = Serializer.restoreFromState(serializerState);
  var validator = null;
  module.exports = function anonymous(validator2, serializer2) {
    function anonymous0(input) {
      const obj = input && typeof input.toJSON === "function" ? input.toJSON() : input;
      if (obj === null)
        return "{}";
      let addComma = false;
      let json = "{";
      if (obj["statusCode"] !== undefined) {
        !addComma && (addComma = true) || (json += ",");
        json += "\"statusCode\":";
        json += serializer2.asNumber(obj["statusCode"]);
      }
      if (obj["code"] !== undefined) {
        !addComma && (addComma = true) || (json += ",");
        json += "\"code\":";
        json += serializer2.asString(obj["code"]);
      }
      if (obj["error"] !== undefined) {
        !addComma && (addComma = true) || (json += ",");
        json += "\"error\":";
        json += serializer2.asString(obj["error"]);
      }
      if (obj["message"] !== undefined) {
        !addComma && (addComma = true) || (json += ",");
        json += "\"message\":";
        json += serializer2.asString(obj["message"]);
      }
      return json + "}";
    }
    const main = anonymous0;
    return main;
  }(validator, serializer);
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/error-handler.js
var require_error_handler = __commonJS((exports, module) => {
  var handleError = function(reply, error, cb) {
    reply[kReplyIsRunningOnErrorHook] = false;
    const context = reply[kRouteContext];
    if (reply[kReplyNextErrorHandler] === false) {
      fallbackErrorHandler(error, reply, function(reply2, payload) {
        try {
          reply2.raw.writeHead(reply2.raw.statusCode, reply2[kReplyHeaders]);
        } catch (error2) {
          reply2.log.warn({ req: reply2.request, res: reply2, err: error2 }, error2 && error2.message);
          reply2.raw.writeHead(reply2.raw.statusCode);
        }
        reply2.raw.end(payload);
      });
      return;
    }
    const errorHandler = reply[kReplyNextErrorHandler] || context.errorHandler;
    reply[kReplyNextErrorHandler] = Object.getPrototypeOf(errorHandler);
    delete reply[kReplyHeaders]["content-type"];
    delete reply[kReplyHeaders]["content-length"];
    const func = errorHandler.func;
    if (!func) {
      reply[kReplyNextErrorHandler] = false;
      fallbackErrorHandler(error, reply, cb);
      return;
    }
    const result = func(error, reply.request, reply);
    if (result !== undefined) {
      if (result !== null && typeof result.then === "function") {
        wrapThenable(result, reply);
      } else {
        reply.send(result);
      }
    }
  };
  var defaultErrorHandler = function(error, request5, reply) {
    setErrorHeaders(error, reply);
    if (!reply[kReplyHasStatusCode] || reply.statusCode === 200) {
      const statusCode = error.statusCode || error.status;
      reply.code(statusCode >= 400 ? statusCode : 500);
    }
    if (reply.statusCode < 500) {
      reply.log.info({ res: reply, err: error }, error && error.message);
    } else {
      reply.log.error({ req: request5, res: reply, err: error }, error && error.message);
    }
    reply.send(error);
  };
  var fallbackErrorHandler = function(error, reply, cb) {
    const res = reply.raw;
    const statusCode = reply.statusCode;
    reply[kReplyHeaders]["content-type"] = reply[kReplyHeaders]["content-type"] ?? "application/json; charset=utf-8";
    let payload;
    try {
      const serializerFn = getSchemaSerializer(reply[kRouteContext], statusCode, reply[kReplyHeaders]["content-type"]);
      payload = serializerFn === false ? serializeError({
        error: statusCodes[statusCode + ""],
        code: error.code,
        message: error.message,
        statusCode
      }) : serializerFn(Object.create(error, {
        error: { value: statusCodes[statusCode + ""] },
        message: { value: error.message },
        statusCode: { value: statusCode }
      }));
    } catch (err) {
      reply.log.error({ err, statusCode: res.statusCode }, "The serializer for the given status code failed");
      reply.code(500);
      payload = serializeError(new FST_ERR_FAILED_ERROR_SERIALIZATION(err.message, error.message));
    }
    if (typeof payload !== "string" && !Buffer.isBuffer(payload)) {
      payload = serializeError(new FST_ERR_REP_INVALID_PAYLOAD_TYPE(typeof payload));
    }
    reply[kReplyHeaders]["content-length"] = "" + Buffer.byteLength(payload);
    cb(reply, payload);
  };
  var buildErrorHandler = function(parent = rootErrorHandler, func) {
    if (!func) {
      return parent;
    }
    const errorHandler = Object.create(parent);
    errorHandler.func = func;
    return errorHandler;
  };
  var setErrorHeaders = function(error, reply) {
    const res = reply.raw;
    let statusCode = res.statusCode;
    statusCode = statusCode >= 400 ? statusCode : 500;
    if (error != null) {
      if (error.headers !== undefined) {
        reply.headers(error.headers);
      }
      if (error.status >= 400) {
        statusCode = error.status;
      } else if (error.statusCode >= 400) {
        statusCode = error.statusCode;
      }
    }
    res.statusCode = statusCode;
  };
  var statusCodes = __require("node:http").STATUS_CODES;
  var wrapThenable = require_wrapThenable();
  var {
    kReplyHeaders,
    kReplyNextErrorHandler,
    kReplyIsRunningOnErrorHook,
    kReplyHasStatusCode,
    kRouteContext
  } = require_symbols3();
  var {
    FST_ERR_REP_INVALID_PAYLOAD_TYPE,
    FST_ERR_FAILED_ERROR_SERIALIZATION
  } = require_errors4();
  var { getSchemaSerializer } = require_schemas();
  var serializeError = require_error_serializer();
  var rootErrorHandler = {
    func: defaultErrorHandler,
    toJSON() {
      return this.func.name.toString() + "()";
    }
  };
  module.exports = {
    buildErrorHandler,
    handleError
  };
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/reply.js
var require_reply = __commonJS((exports, module) => {
  var Reply = function(res, request5, log7) {
    this.raw = res;
    this[kReplySerializer] = null;
    this[kReplyErrorHandlerCalled] = false;
    this[kReplyIsError] = false;
    this[kReplyIsRunningOnErrorHook] = false;
    this.request = request5;
    this[kReplyHeaders] = {};
    this[kReplyTrailers] = null;
    this[kReplyHasStatusCode] = false;
    this[kReplyStartTime] = undefined;
    this.log = log7;
  };
  var preSerializationHook = function(reply, payload) {
    if (reply[kRouteContext].preSerialization !== null) {
      preSerializationHookRunner(reply[kRouteContext].preSerialization, reply.request, reply, payload, preSerializationHookEnd);
    } else {
      preSerializationHookEnd(null, reply.request, reply, payload);
    }
  };
  var preSerializationHookEnd = function(err, request5, reply, payload) {
    if (err != null) {
      onErrorHook(reply, err);
      return;
    }
    try {
      if (reply[kReplySerializer] !== null) {
        payload = reply[kReplySerializer](payload);
      } else if (reply[kRouteContext] && reply[kRouteContext][kReplySerializerDefault]) {
        payload = reply[kRouteContext][kReplySerializerDefault](payload, reply.raw.statusCode);
      } else {
        payload = serialize(reply[kRouteContext], payload, reply.raw.statusCode, reply[kReplyHeaders]["content-type"]);
      }
    } catch (e) {
      wrapSerializationError(e, reply);
      onErrorHook(reply, e);
      return;
    }
    onSendHook(reply, payload);
  };
  var wrapSerializationError = function(error, reply) {
    error.serialization = reply[kRouteContext].config;
  };
  var onSendHook = function(reply, payload) {
    if (reply[kRouteContext].onSend !== null) {
      onSendHookRunner(reply[kRouteContext].onSend, reply.request, reply, payload, wrapOnSendEnd);
    } else {
      onSendEnd(reply, payload);
    }
  };
  var wrapOnSendEnd = function(err, request5, reply, payload) {
    if (err != null) {
      onErrorHook(reply, err);
    } else {
      onSendEnd(reply, payload);
    }
  };
  var safeWriteHead = function(reply, statusCode) {
    const res = reply.raw;
    try {
      res.writeHead(statusCode, reply[kReplyHeaders]);
    } catch (err) {
      if (err.code === "ERR_HTTP_HEADERS_SENT") {
        reply.log.warn(`Reply was already sent, did you forget to "return reply" in the "${reply.request.raw.url}" (${reply.request.raw.method}) route?`);
      }
      throw err;
    }
  };
  var onSendEnd = function(reply, payload) {
    const res = reply.raw;
    const req = reply.request;
    if (reply[kReplyTrailers] !== null) {
      const trailerHeaders = Object.keys(reply[kReplyTrailers]);
      let header = "";
      for (const trailerName of trailerHeaders) {
        if (typeof reply[kReplyTrailers][trailerName] !== "function")
          continue;
        header += " ";
        header += trailerName;
      }
      reply.header("Transfer-Encoding", "chunked");
      reply.header("Trailer", header.trim());
    }
    const isResponse = toString.call(payload) === "[object Response]";
    if (isResponse) {
      if (typeof payload.status === "number") {
        reply.code(payload.status);
      }
    }
    const statusCode = res.statusCode;
    if (payload === undefined || payload === null) {
      if (statusCode >= 200 && statusCode !== 204 && statusCode !== 304 && req.method !== "HEAD" && reply[kReplyTrailers] === null) {
        reply[kReplyHeaders]["content-length"] = "0";
      }
      safeWriteHead(reply, statusCode);
      sendTrailer(payload, res, reply);
      return;
    }
    if (statusCode >= 100 && statusCode < 200 || statusCode === 204) {
      reply.removeHeader("content-type");
      reply.removeHeader("content-length");
      safeWriteHead(reply, statusCode);
      sendTrailer(undefined, res, reply);
      if (typeof payload.resume === "function") {
        payload.on("error", noop);
        payload.resume();
      }
      return;
    }
    if (typeof payload.pipe === "function") {
      sendStream(payload, res, reply);
      return;
    }
    if (typeof payload.getReader === "function") {
      sendWebStream(payload, res, reply);
      return;
    }
    if (isResponse) {
      if (typeof payload.headers === "object" && typeof payload.headers.forEach === "function") {
        for (const [headerName, headerValue] of payload.headers) {
          reply.header(headerName, headerValue);
        }
      }
      if (payload.body != null) {
        if (payload.bodyUsed) {
          throw new FST_ERR_REP_RESPONSE_BODY_CONSUMED;
        }
        sendWebStream(payload.body, res, reply);
      }
      return;
    }
    if (typeof payload !== "string" && !Buffer.isBuffer(payload)) {
      throw new FST_ERR_REP_INVALID_PAYLOAD_TYPE(typeof payload);
    }
    if (reply[kReplyTrailers] === null) {
      const contentLength = reply[kReplyHeaders]["content-length"];
      if (!contentLength || req.raw.method !== "HEAD" && Number(contentLength) !== Buffer.byteLength(payload)) {
        reply[kReplyHeaders]["content-length"] = "" + Buffer.byteLength(payload);
      }
    }
    safeWriteHead(reply, statusCode);
    res.write(payload);
    sendTrailer(payload, res, reply);
  };
  var logStreamError = function(logger3, err, res) {
    if (err.code === "ERR_STREAM_PREMATURE_CLOSE") {
      if (!logger3[kDisableRequestLogging]) {
        logger3.info({ res }, "stream closed prematurely");
      }
    } else {
      logger3.warn({ err }, "response terminated with an error with headers already sent");
    }
  };
  var sendWebStream = function(payload, res, reply) {
    const nodeStream = Readable.fromWeb(payload);
    sendStream(nodeStream, res, reply);
  };
  var sendStream = function(payload, res, reply) {
    let sourceOpen = true;
    let errorLogged = false;
    sendStreamTrailer(payload, res, reply);
    eos(payload, { readable: true, writable: false }, function(err) {
      sourceOpen = false;
      if (err != null) {
        if (res.headersSent || reply.request.raw.aborted === true) {
          if (!errorLogged) {
            errorLogged = true;
            logStreamError(reply.log, err, res);
          }
          res.destroy();
        } else {
          onErrorHook(reply, err);
        }
      }
    });
    eos(res, function(err) {
      if (sourceOpen) {
        if (err != null && res.headersSent && !errorLogged) {
          errorLogged = true;
          logStreamError(reply.log, err, res);
        }
        if (typeof payload.destroy === "function") {
          payload.destroy();
        } else if (typeof payload.close === "function") {
          payload.close(noop);
        } else if (typeof payload.abort === "function") {
          payload.abort();
        } else {
          reply.log.warn("stream payload does not end properly");
        }
      }
    });
    if (!res.headersSent) {
      for (const key in reply[kReplyHeaders]) {
        res.setHeader(key, reply[kReplyHeaders][key]);
      }
    } else {
      reply.log.warn("response will send, but you shouldn\'t use res.writeHead in stream mode");
    }
    payload.pipe(res);
  };
  var sendTrailer = function(payload, res, reply) {
    if (reply[kReplyTrailers] === null) {
      res.end(null, null, null);
      return;
    }
    const trailerHeaders = Object.keys(reply[kReplyTrailers]);
    const trailers = {};
    let handled = 0;
    let skipped = true;
    function send() {
      if (handled === 0) {
        res.addTrailers(trailers);
        res.end(null, null, null);
      }
    }
    for (const trailerName of trailerHeaders) {
      let cb = function(err, value) {
        handled++;
        if (err)
          reply.log.debug(err);
        else
          trailers[trailerName] = value;
        process.nextTick(send);
      };
      if (typeof reply[kReplyTrailers][trailerName] !== "function")
        continue;
      skipped = false;
      handled--;
      const result = reply[kReplyTrailers][trailerName](reply, payload, cb);
      if (typeof result === "object" && typeof result.then === "function") {
        result.then((v) => cb(null, v), cb);
      } else if (result !== null && result !== undefined) {
        FSTDEP013();
        cb(null, result);
      }
    }
    if (skipped)
      res.end(null, null, null);
  };
  var sendStreamTrailer = function(payload, res, reply) {
    if (reply[kReplyTrailers] === null)
      return;
    payload.on("end", () => sendTrailer(null, res, reply));
  };
  var onErrorHook = function(reply, error, cb) {
    if (reply[kRouteContext].onError !== null && !reply[kReplyNextErrorHandler]) {
      reply[kReplyIsRunningOnErrorHook] = true;
      onSendHookRunner(reply[kRouteContext].onError, reply.request, reply, error, () => handleError(reply, error, cb));
    } else {
      handleError(reply, error, cb);
    }
  };
  var setupResponseListeners = function(reply) {
    reply[kReplyStartTime] = now();
    const onResFinished = (err) => {
      reply[kReplyEndTime] = now();
      reply.raw.removeListener("finish", onResFinished);
      reply.raw.removeListener("error", onResFinished);
      const ctx = reply[kRouteContext];
      if (ctx && ctx.onResponse !== null) {
        onResponseHookRunner(ctx.onResponse, reply.request, reply, onResponseCallback);
      } else {
        onResponseCallback(err, reply.request, reply);
      }
    };
    reply.raw.on("finish", onResFinished);
    reply.raw.on("error", onResFinished);
  };
  var onResponseCallback = function(err, request5, reply) {
    if (reply.log[kDisableRequestLogging]) {
      return;
    }
    const responseTime = reply.elapsedTime;
    if (err != null) {
      reply.log.error({
        res: reply,
        err,
        responseTime
      }, "request errored");
      return;
    }
    reply.log.info({
      res: reply,
      responseTime
    }, "request completed");
  };
  var buildReply = function(R) {
    const props = R.props.slice();
    function _Reply(res, request5, log7) {
      this.raw = res;
      this[kReplyIsError] = false;
      this[kReplyErrorHandlerCalled] = false;
      this[kReplyHijacked] = false;
      this[kReplySerializer] = null;
      this.request = request5;
      this[kReplyHeaders] = {};
      this[kReplyTrailers] = null;
      this[kReplyStartTime] = undefined;
      this[kReplyEndTime] = undefined;
      this.log = log7;
      var prop;
      for (var i = 0;i < props.length; i++) {
        prop = props[i];
        this[prop.key] = prop.value;
      }
    }
    Object.setPrototypeOf(_Reply.prototype, R.prototype);
    Object.setPrototypeOf(_Reply, R);
    _Reply.parent = R;
    _Reply.props = props;
    return _Reply;
  };
  var notFound = function(reply) {
    if (reply[kRouteContext][kFourOhFourContext] === null) {
      reply.log.warn("Trying to send a NotFound error inside a 404 handler. Sending basic 404 response.");
      reply.code(404).send("404 Not Found");
      return;
    }
    reply.request[kRouteContext] = reply[kRouteContext][kFourOhFourContext];
    if (reply[kRouteContext].preHandler !== null) {
      preHandlerHookRunner(reply[kRouteContext].preHandler, reply.request, reply, internals.preHandlerCallback);
    } else {
      internals.preHandlerCallback(null, reply.request, reply);
    }
  };
  var serialize = function(context, data3, statusCode, contentType) {
    const fnSerialize = getSchemaSerializer(context, statusCode, contentType);
    if (fnSerialize) {
      return fnSerialize(data3);
    }
    return JSON.stringify(data3);
  };
  var noop = function() {
  };
  var eos = __require("node:stream").finished;
  var Readable = __require("node:stream").Readable;
  var {
    kFourOhFourContext,
    kPublicRouteContext,
    kReplyErrorHandlerCalled,
    kReplyHijacked,
    kReplyStartTime,
    kReplyEndTime,
    kReplySerializer,
    kReplySerializerDefault,
    kReplyIsError,
    kReplyHeaders,
    kReplyTrailers,
    kReplyHasStatusCode,
    kReplyIsRunningOnErrorHook,
    kReplyNextErrorHandler,
    kDisableRequestLogging,
    kSchemaResponse,
    kReplyCacheSerializeFns,
    kSchemaController,
    kOptions,
    kRouteContext
  } = require_symbols3();
  var {
    onSendHookRunner,
    onResponseHookRunner,
    preHandlerHookRunner,
    preSerializationHookRunner
  } = require_hooks2();
  var internals = require_handleRequest()[Symbol.for("internals")];
  var loggerUtils = require_logger2();
  var now = loggerUtils.now;
  var { handleError } = require_error_handler();
  var { getSchemaSerializer } = require_schemas();
  var CONTENT_TYPE = {
    JSON: "application/json; charset=utf-8",
    PLAIN: "text/plain; charset=utf-8",
    OCTET: "application/octet-stream"
  };
  var {
    FST_ERR_REP_INVALID_PAYLOAD_TYPE,
    FST_ERR_REP_RESPONSE_BODY_CONSUMED,
    FST_ERR_REP_ALREADY_SENT,
    FST_ERR_REP_SENT_VALUE,
    FST_ERR_SEND_INSIDE_ONERR,
    FST_ERR_BAD_STATUS_CODE,
    FST_ERR_BAD_TRAILER_NAME,
    FST_ERR_BAD_TRAILER_VALUE,
    FST_ERR_MISSING_SERIALIZATION_FN,
    FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN
  } = require_errors4();
  var { FSTDEP010, FSTDEP013, FSTDEP019, FSTDEP020 } = require_warnings();
  var toString = Object.prototype.toString;
  Reply.props = [];
  Object.defineProperties(Reply.prototype, {
    [kRouteContext]: {
      get() {
        return this.request[kRouteContext];
      }
    },
    context: {
      get() {
        FSTDEP019();
        return this.request[kRouteContext];
      }
    },
    elapsedTime: {
      get() {
        if (this[kReplyStartTime] === undefined) {
          return 0;
        }
        return (this[kReplyEndTime] || now()) - this[kReplyStartTime];
      }
    },
    server: {
      get() {
        return this.request[kRouteContext].server;
      }
    },
    sent: {
      enumerable: true,
      get() {
        return (this[kReplyHijacked] || this.raw.writableEnded) === true;
      },
      set(value) {
        FSTDEP010();
        if (value !== true) {
          throw new FST_ERR_REP_SENT_VALUE;
        }
        if (this.sent && this[kReplyHijacked]) {
          throw new FST_ERR_REP_ALREADY_SENT(this.request.url, this.request.method);
        }
        this[kReplyHijacked] = true;
      }
    },
    statusCode: {
      get() {
        return this.raw.statusCode;
      },
      set(value) {
        this.code(value);
      }
    },
    [kPublicRouteContext]: {
      get() {
        return this.request[kPublicRouteContext];
      }
    }
  });
  Reply.prototype.hijack = function() {
    this[kReplyHijacked] = true;
    return this;
  };
  Reply.prototype.send = function(payload) {
    if (this[kReplyIsRunningOnErrorHook] === true) {
      throw new FST_ERR_SEND_INSIDE_ONERR;
    }
    if (this.sent) {
      this.log.warn({ err: new FST_ERR_REP_ALREADY_SENT(this.request.url, this.request.method) });
      return this;
    }
    if (payload instanceof Error || this[kReplyIsError] === true) {
      this[kReplyIsError] = false;
      onErrorHook(this, payload, onSendHook);
      return this;
    }
    if (payload === undefined) {
      onSendHook(this, payload);
      return this;
    }
    const contentType = this.getHeader("content-type");
    const hasContentType = contentType !== undefined;
    if (payload !== null) {
      if (typeof payload.pipe === "function" || typeof payload.getReader === "function" || toString.call(payload) === "[object Response]") {
        onSendHook(this, payload);
        return this;
      }
      if (payload?.buffer instanceof ArrayBuffer) {
        if (hasContentType === false) {
          this[kReplyHeaders]["content-type"] = CONTENT_TYPE.OCTET;
        }
        const payloadToSend = Buffer.isBuffer(payload) ? payload : Buffer.from(payload.buffer, payload.byteOffset, payload.byteLength);
        onSendHook(this, payloadToSend);
        return this;
      }
      if (hasContentType === false && typeof payload === "string") {
        this[kReplyHeaders]["content-type"] = CONTENT_TYPE.PLAIN;
        onSendHook(this, payload);
        return this;
      }
    }
    if (this[kReplySerializer] !== null) {
      if (typeof payload !== "string") {
        preSerializationHook(this, payload);
        return this;
      } else {
        payload = this[kReplySerializer](payload);
      }
    } else if (hasContentType === false || contentType.indexOf("json") > -1) {
      if (hasContentType === false) {
        this[kReplyHeaders]["content-type"] = CONTENT_TYPE.JSON;
      } else {
        if (contentType.indexOf("charset") === -1) {
          const customContentType = contentType.trim();
          if (customContentType.endsWith(";")) {
            this[kReplyHeaders]["content-type"] = `${customContentType} charset=utf-8`;
          } else {
            this[kReplyHeaders]["content-type"] = `${customContentType}; charset=utf-8`;
          }
        }
      }
      if (typeof payload !== "string") {
        preSerializationHook(this, payload);
        return this;
      }
    }
    onSendHook(this, payload);
    return this;
  };
  Reply.prototype.getHeader = function(key) {
    key = key.toLowerCase();
    const res = this.raw;
    let value = this[kReplyHeaders][key];
    if (value === undefined && res.hasHeader(key)) {
      value = res.getHeader(key);
    }
    return value;
  };
  Reply.prototype.getHeaders = function() {
    return {
      ...this.raw.getHeaders(),
      ...this[kReplyHeaders]
    };
  };
  Reply.prototype.hasHeader = function(key) {
    key = key.toLowerCase();
    return this[kReplyHeaders][key] !== undefined || this.raw.hasHeader(key);
  };
  Reply.prototype.removeHeader = function(key) {
    delete this[kReplyHeaders][key.toLowerCase()];
    return this;
  };
  Reply.prototype.header = function(key, value = "") {
    key = key.toLowerCase();
    if (this[kReplyHeaders][key] && key === "set-cookie") {
      if (typeof this[kReplyHeaders][key] === "string") {
        this[kReplyHeaders][key] = [this[kReplyHeaders][key]];
      }
      if (Array.isArray(value)) {
        Array.prototype.push.apply(this[kReplyHeaders][key], value);
      } else {
        this[kReplyHeaders][key].push(value);
      }
    } else {
      this[kReplyHeaders][key] = value;
    }
    return this;
  };
  Reply.prototype.headers = function(headers) {
    const keys = Object.keys(headers);
    for (var i = 0;i !== keys.length; ++i) {
      const key = keys[i];
      this.header(key, headers[key]);
    }
    return this;
  };
  var INVALID_TRAILERS = new Set([
    "transfer-encoding",
    "content-length",
    "host",
    "cache-control",
    "max-forwards",
    "te",
    "authorization",
    "set-cookie",
    "content-encoding",
    "content-type",
    "content-range",
    "trailer"
  ]);
  Reply.prototype.trailer = function(key, fn) {
    key = key.toLowerCase();
    if (INVALID_TRAILERS.has(key)) {
      throw new FST_ERR_BAD_TRAILER_NAME(key);
    }
    if (typeof fn !== "function") {
      throw new FST_ERR_BAD_TRAILER_VALUE(key, typeof fn);
    }
    if (this[kReplyTrailers] === null)
      this[kReplyTrailers] = {};
    this[kReplyTrailers][key] = fn;
    return this;
  };
  Reply.prototype.hasTrailer = function(key) {
    return this[kReplyTrailers]?.[key.toLowerCase()] !== undefined;
  };
  Reply.prototype.removeTrailer = function(key) {
    if (this[kReplyTrailers] === null)
      return this;
    this[kReplyTrailers][key.toLowerCase()] = undefined;
    return this;
  };
  Reply.prototype.code = function(code) {
    const intValue = Number(code);
    if (isNaN(intValue) || intValue < 100 || intValue > 599) {
      throw new FST_ERR_BAD_STATUS_CODE(code || String(code));
    }
    this.raw.statusCode = intValue;
    this[kReplyHasStatusCode] = true;
    return this;
  };
  Reply.prototype.status = Reply.prototype.code;
  Reply.prototype.getSerializationFunction = function(schemaOrStatus, contentType) {
    let serialize2;
    if (typeof schemaOrStatus === "string" || typeof schemaOrStatus === "number") {
      if (typeof contentType === "string") {
        serialize2 = this[kRouteContext][kSchemaResponse]?.[schemaOrStatus]?.[contentType];
      } else {
        serialize2 = this[kRouteContext][kSchemaResponse]?.[schemaOrStatus];
      }
    } else if (typeof schemaOrStatus === "object") {
      serialize2 = this[kRouteContext][kReplyCacheSerializeFns]?.get(schemaOrStatus);
    }
    return serialize2;
  };
  Reply.prototype.compileSerializationSchema = function(schema, httpStatus = null, contentType = null) {
    const { request: request5 } = this;
    const { method, url } = request5;
    if (this[kRouteContext][kReplyCacheSerializeFns]?.has(schema)) {
      return this[kRouteContext][kReplyCacheSerializeFns].get(schema);
    }
    const serializerCompiler = this[kRouteContext].serializerCompiler || this.server[kSchemaController].serializerCompiler || (this.server[kSchemaController].setupSerializer(this.server[kOptions]) || this.server[kSchemaController].serializerCompiler);
    const serializeFn = serializerCompiler({
      schema,
      method,
      url,
      httpStatus,
      contentType
    });
    if (this[kRouteContext][kReplyCacheSerializeFns] == null) {
      this[kRouteContext][kReplyCacheSerializeFns] = new WeakMap;
    }
    this[kRouteContext][kReplyCacheSerializeFns].set(schema, serializeFn);
    return serializeFn;
  };
  Reply.prototype.serializeInput = function(input, schema, httpStatus, contentType) {
    const possibleContentType = httpStatus;
    let serialize2;
    httpStatus = typeof schema === "string" || typeof schema === "number" ? schema : httpStatus;
    contentType = httpStatus && possibleContentType !== httpStatus ? possibleContentType : contentType;
    if (httpStatus != null) {
      if (contentType != null) {
        serialize2 = this[kRouteContext][kSchemaResponse]?.[httpStatus]?.[contentType];
      } else {
        serialize2 = this[kRouteContext][kSchemaResponse]?.[httpStatus];
      }
      if (serialize2 == null) {
        if (contentType)
          throw new FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN(httpStatus, contentType);
        throw new FST_ERR_MISSING_SERIALIZATION_FN(httpStatus);
      }
    } else {
      if (this[kRouteContext][kReplyCacheSerializeFns]?.has(schema)) {
        serialize2 = this[kRouteContext][kReplyCacheSerializeFns].get(schema);
      } else {
        serialize2 = this.compileSerializationSchema(schema, httpStatus, contentType);
      }
    }
    return serialize2(input);
  };
  Reply.prototype.serialize = function(payload) {
    if (this[kReplySerializer] !== null) {
      return this[kReplySerializer](payload);
    } else {
      if (this[kRouteContext] && this[kRouteContext][kReplySerializerDefault]) {
        return this[kRouteContext][kReplySerializerDefault](payload, this.raw.statusCode);
      } else {
        return serialize(this[kRouteContext], payload, this.raw.statusCode);
      }
    }
  };
  Reply.prototype.serializer = function(fn) {
    this[kReplySerializer] = fn;
    return this;
  };
  Reply.prototype.type = function(type) {
    this[kReplyHeaders]["content-type"] = type;
    return this;
  };
  Reply.prototype.redirect = function(code, url) {
    if (typeof code === "string") {
      url = code;
      code = this[kReplyHasStatusCode] ? this.raw.statusCode : 302;
    }
    return this.header("location", url).code(code).send();
  };
  Reply.prototype.callNotFound = function() {
    notFound(this);
    return this;
  };
  Reply.prototype.getResponseTime = function() {
    FSTDEP020();
    return this.elapsedTime;
  };
  Reply.prototype.then = function(fulfilled, rejected) {
    if (this.sent) {
      fulfilled();
      return;
    }
    eos(this.raw, (err) => {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        if (rejected) {
          rejected(err);
        } else {
          this.log && this.log.warn("unhandled rejection on reply.then");
        }
      } else {
        fulfilled();
      }
    });
  };
  module.exports = Reply;
  module.exports.buildReply = buildReply;
  module.exports.setupResponseListeners = setupResponseListeners;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/proxy-addr@2.0.7/node_modules/forwarded/index.js
var require_forwarded = __commonJS((exports, module) => {
  var forwarded = function(req) {
    if (!req) {
      throw new TypeError("argument req is required");
    }
    var proxyAddrs = parse(req.headers["x-forwarded-for"] || "");
    var socketAddr = getSocketAddr(req);
    var addrs = [socketAddr].concat(proxyAddrs);
    return addrs;
  };
  var getSocketAddr = function(req) {
    return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
  };
  var parse = function(header) {
    var end = header.length;
    var list = [];
    var start = header.length;
    for (var i = header.length - 1;i >= 0; i--) {
      switch (header.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i;
          }
          break;
        case 44:
          if (start !== end) {
            list.push(header.substring(start, end));
          }
          start = end = i;
          break;
        default:
          start = i;
          break;
      }
    }
    if (start !== end) {
      list.push(header.substring(start, end));
    }
    return list;
  };
  /*!
   * forwarded
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = forwarded;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/proxy-addr@2.0.7/node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS((exports, module) => {
  (function() {
    var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;
    ipaddr = {};
    root = this;
    if (typeof module !== "undefined" && module !== null && exports) {
      module.exports = ipaddr;
    } else {
      root["ipaddr"] = ipaddr;
    }
    matchCIDR = function(first, second, partSize, cidrBits) {
      var part, shift;
      if (first.length !== second.length) {
        throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
      }
      part = 0;
      while (cidrBits > 0) {
        shift = partSize - cidrBits;
        if (shift < 0) {
          shift = 0;
        }
        if (first[part] >> shift !== second[part] >> shift) {
          return false;
        }
        cidrBits -= partSize;
        part += 1;
      }
      return true;
    };
    ipaddr.subnetMatch = function(address10, rangeList, defaultName) {
      var k, len, rangeName, rangeSubnets, subnet;
      if (defaultName == null) {
        defaultName = "unicast";
      }
      for (rangeName in rangeList) {
        rangeSubnets = rangeList[rangeName];
        if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
          rangeSubnets = [rangeSubnets];
        }
        for (k = 0, len = rangeSubnets.length;k < len; k++) {
          subnet = rangeSubnets[k];
          if (address10.kind() === subnet[0].kind()) {
            if (address10.match.apply(address10, subnet)) {
              return rangeName;
            }
          }
        }
      }
      return defaultName;
    };
    ipaddr.IPv4 = function() {
      function IPv4(octets) {
        var k, len, octet;
        if (octets.length !== 4) {
          throw new Error("ipaddr: ipv4 octet count should be 4");
        }
        for (k = 0, len = octets.length;k < len; k++) {
          octet = octets[k];
          if (!(0 <= octet && octet <= 255)) {
            throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
          }
        }
        this.octets = octets;
      }
      IPv4.prototype.kind = function() {
        return "ipv4";
      };
      IPv4.prototype.toString = function() {
        return this.octets.join(".");
      };
      IPv4.prototype.toNormalizedString = function() {
        return this.toString();
      };
      IPv4.prototype.toByteArray = function() {
        return this.octets.slice(0);
      };
      IPv4.prototype.match = function(other, cidrRange) {
        var ref;
        if (cidrRange === undefined) {
          ref = other, other = ref[0], cidrRange = ref[1];
        }
        if (other.kind() !== "ipv4") {
          throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
        }
        return matchCIDR(this.octets, other.octets, 8, cidrRange);
      };
      IPv4.prototype.SpecialRanges = {
        unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
        broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
        multicast: [[new IPv4([224, 0, 0, 0]), 4]],
        linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
        loopback: [[new IPv4([127, 0, 0, 0]), 8]],
        carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
        private: [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
        reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
      };
      IPv4.prototype.range = function() {
        return ipaddr.subnetMatch(this, this.SpecialRanges);
      };
      IPv4.prototype.toIPv4MappedAddress = function() {
        return ipaddr.IPv6.parse("::ffff:" + this.toString());
      };
      IPv4.prototype.prefixLengthFromSubnetMask = function() {
        var cidr, i, k, octet, stop, zeros, zerotable;
        zerotable = {
          0: 8,
          128: 7,
          192: 6,
          224: 5,
          240: 4,
          248: 3,
          252: 2,
          254: 1,
          255: 0
        };
        cidr = 0;
        stop = false;
        for (i = k = 3;k >= 0; i = k += -1) {
          octet = this.octets[i];
          if (octet in zerotable) {
            zeros = zerotable[octet];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 8) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 32 - cidr;
      };
      return IPv4;
    }();
    ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
    ipv4Regexes = {
      fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
      longValue: new RegExp("^" + ipv4Part + "$", "i")
    };
    ipaddr.IPv4.parser = function(string) {
      var match, parseIntAuto, part, shift, value;
      parseIntAuto = function(string2) {
        if (string2[0] === "0" && string2[1] !== "x") {
          return parseInt(string2, 8);
        } else {
          return parseInt(string2);
        }
      };
      if (match = string.match(ipv4Regexes.fourOctet)) {
        return function() {
          var k, len, ref, results;
          ref = match.slice(1, 6);
          results = [];
          for (k = 0, len = ref.length;k < len; k++) {
            part = ref[k];
            results.push(parseIntAuto(part));
          }
          return results;
        }();
      } else if (match = string.match(ipv4Regexes.longValue)) {
        value = parseIntAuto(match[1]);
        if (value > 4294967295 || value < 0) {
          throw new Error("ipaddr: address outside defined range");
        }
        return function() {
          var k, results;
          results = [];
          for (shift = k = 0;k <= 24; shift = k += 8) {
            results.push(value >> shift & 255);
          }
          return results;
        }().reverse();
      } else {
        return null;
      }
    };
    ipaddr.IPv6 = function() {
      function IPv6(parts, zoneId) {
        var i, k, l, len, part, ref;
        if (parts.length === 16) {
          this.parts = [];
          for (i = k = 0;k <= 14; i = k += 2) {
            this.parts.push(parts[i] << 8 | parts[i + 1]);
          }
        } else if (parts.length === 8) {
          this.parts = parts;
        } else {
          throw new Error("ipaddr: ipv6 part count should be 8 or 16");
        }
        ref = this.parts;
        for (l = 0, len = ref.length;l < len; l++) {
          part = ref[l];
          if (!(0 <= part && part <= 65535)) {
            throw new Error("ipaddr: ipv6 part should fit in 16 bits");
          }
        }
        if (zoneId) {
          this.zoneId = zoneId;
        }
      }
      IPv6.prototype.kind = function() {
        return "ipv6";
      };
      IPv6.prototype.toString = function() {
        return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
      };
      IPv6.prototype.toRFC5952String = function() {
        var bestMatchIndex, bestMatchLength, match, regex3, string;
        regex3 = /((^|:)(0(:|$)){2,})/g;
        string = this.toNormalizedString();
        bestMatchIndex = 0;
        bestMatchLength = -1;
        while (match = regex3.exec(string)) {
          if (match[0].length > bestMatchLength) {
            bestMatchIndex = match.index;
            bestMatchLength = match[0].length;
          }
        }
        if (bestMatchLength < 0) {
          return string;
        }
        return string.substring(0, bestMatchIndex) + "::" + string.substring(bestMatchIndex + bestMatchLength);
      };
      IPv6.prototype.toByteArray = function() {
        var bytes2, k, len, part, ref;
        bytes2 = [];
        ref = this.parts;
        for (k = 0, len = ref.length;k < len; k++) {
          part = ref[k];
          bytes2.push(part >> 8);
          bytes2.push(part & 255);
        }
        return bytes2;
      };
      IPv6.prototype.toNormalizedString = function() {
        var addr, part, suffix;
        addr = function() {
          var k, len, ref, results;
          ref = this.parts;
          results = [];
          for (k = 0, len = ref.length;k < len; k++) {
            part = ref[k];
            results.push(part.toString(16));
          }
          return results;
        }.call(this).join(":");
        suffix = "";
        if (this.zoneId) {
          suffix = "%" + this.zoneId;
        }
        return addr + suffix;
      };
      IPv6.prototype.toFixedLengthString = function() {
        var addr, part, suffix;
        addr = function() {
          var k, len, ref, results;
          ref = this.parts;
          results = [];
          for (k = 0, len = ref.length;k < len; k++) {
            part = ref[k];
            results.push(part.toString(16).padStart(4, "0"));
          }
          return results;
        }.call(this).join(":");
        suffix = "";
        if (this.zoneId) {
          suffix = "%" + this.zoneId;
        }
        return addr + suffix;
      };
      IPv6.prototype.match = function(other, cidrRange) {
        var ref;
        if (cidrRange === undefined) {
          ref = other, other = ref[0], cidrRange = ref[1];
        }
        if (other.kind() !== "ipv6") {
          throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
        }
        return matchCIDR(this.parts, other.parts, 16, cidrRange);
      };
      IPv6.prototype.SpecialRanges = {
        unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
        linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
        multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
        loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
        uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
        ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
        rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
        rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
        "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
        teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
        reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
      };
      IPv6.prototype.range = function() {
        return ipaddr.subnetMatch(this, this.SpecialRanges);
      };
      IPv6.prototype.isIPv4MappedAddress = function() {
        return this.range() === "ipv4Mapped";
      };
      IPv6.prototype.toIPv4Address = function() {
        var high, low, ref;
        if (!this.isIPv4MappedAddress()) {
          throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
        }
        ref = this.parts.slice(-2), high = ref[0], low = ref[1];
        return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
      };
      IPv6.prototype.prefixLengthFromSubnetMask = function() {
        var cidr, i, k, part, stop, zeros, zerotable;
        zerotable = {
          0: 16,
          32768: 15,
          49152: 14,
          57344: 13,
          61440: 12,
          63488: 11,
          64512: 10,
          65024: 9,
          65280: 8,
          65408: 7,
          65472: 6,
          65504: 5,
          65520: 4,
          65528: 3,
          65532: 2,
          65534: 1,
          65535: 0
        };
        cidr = 0;
        stop = false;
        for (i = k = 7;k >= 0; i = k += -1) {
          part = this.parts[i];
          if (part in zerotable) {
            zeros = zerotable[part];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 16) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 128 - cidr;
      };
      return IPv6;
    }();
    ipv6Part = "(?:[0-9a-f]+::?)+";
    zoneIndex = "%[0-9a-z]{1,}";
    ipv6Regexes = {
      zoneIndex: new RegExp(zoneIndex, "i"),
      native: new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", "i"),
      transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), "i")
    };
    expandIPv6 = function(string, parts) {
      var colonCount, lastColon, part, replacement, replacementCount, zoneId;
      if (string.indexOf("::") !== string.lastIndexOf("::")) {
        return null;
      }
      zoneId = (string.match(ipv6Regexes["zoneIndex"]) || [])[0];
      if (zoneId) {
        zoneId = zoneId.substring(1);
        string = string.replace(/%.+$/, "");
      }
      colonCount = 0;
      lastColon = -1;
      while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
        colonCount++;
      }
      if (string.substr(0, 2) === "::") {
        colonCount--;
      }
      if (string.substr(-2, 2) === "::") {
        colonCount--;
      }
      if (colonCount > parts) {
        return null;
      }
      replacementCount = parts - colonCount;
      replacement = ":";
      while (replacementCount--) {
        replacement += "0:";
      }
      string = string.replace("::", replacement);
      if (string[0] === ":") {
        string = string.slice(1);
      }
      if (string[string.length - 1] === ":") {
        string = string.slice(0, -1);
      }
      parts = function() {
        var k, len, ref, results;
        ref = string.split(":");
        results = [];
        for (k = 0, len = ref.length;k < len; k++) {
          part = ref[k];
          results.push(parseInt(part, 16));
        }
        return results;
      }();
      return {
        parts,
        zoneId
      };
    };
    ipaddr.IPv6.parser = function(string) {
      var addr, k, len, match, octet, octets, zoneId;
      if (ipv6Regexes["native"].test(string)) {
        return expandIPv6(string, 8);
      } else if (match = string.match(ipv6Regexes["transitional"])) {
        zoneId = match[6] || "";
        addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
        if (addr.parts) {
          octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
          for (k = 0, len = octets.length;k < len; k++) {
            octet = octets[k];
            if (!(0 <= octet && octet <= 255)) {
              return null;
            }
          }
          addr.parts.push(octets[0] << 8 | octets[1]);
          addr.parts.push(octets[2] << 8 | octets[3]);
          return {
            parts: addr.parts,
            zoneId: addr.zoneId
          };
        }
      }
      return null;
    };
    ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
      return this.parser(string) !== null;
    };
    ipaddr.IPv4.isValid = function(string) {
      var e;
      try {
        new this(this.parser(string));
        return true;
      } catch (error1) {
        e = error1;
        return false;
      }
    };
    ipaddr.IPv4.isValidFourPartDecimal = function(string) {
      if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
        return true;
      } else {
        return false;
      }
    };
    ipaddr.IPv6.isValid = function(string) {
      var addr, e;
      if (typeof string === "string" && string.indexOf(":") === -1) {
        return false;
      }
      try {
        addr = this.parser(string);
        new this(addr.parts, addr.zoneId);
        return true;
      } catch (error1) {
        e = error1;
        return false;
      }
    };
    ipaddr.IPv4.parse = function(string) {
      var parts;
      parts = this.parser(string);
      if (parts === null) {
        throw new Error("ipaddr: string is not formatted like ip address");
      }
      return new this(parts);
    };
    ipaddr.IPv6.parse = function(string) {
      var addr;
      addr = this.parser(string);
      if (addr.parts === null) {
        throw new Error("ipaddr: string is not formatted like ip address");
      }
      return new this(addr.parts, addr.zoneId);
    };
    ipaddr.IPv4.parseCIDR = function(string) {
      var maskLength, match, parsed;
      if (match = string.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match[2]);
        if (maskLength >= 0 && maskLength <= 32) {
          parsed = [this.parse(match[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
    };
    ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
      var filledOctetCount, j, octets;
      prefix = parseInt(prefix);
      if (prefix < 0 || prefix > 32) {
        throw new Error("ipaddr: invalid IPv4 prefix length");
      }
      octets = [0, 0, 0, 0];
      j = 0;
      filledOctetCount = Math.floor(prefix / 8);
      while (j < filledOctetCount) {
        octets[j] = 255;
        j++;
      }
      if (filledOctetCount < 4) {
        octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
      }
      return new this(octets);
    };
    ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
      var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i = 0;
        while (i < 4) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
          i++;
        }
        return new this(octets);
      } catch (error1) {
        error = error1;
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr.IPv4.networkAddressFromCIDR = function(string) {
      var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i = 0;
        while (i < 4) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
          i++;
        }
        return new this(octets);
      } catch (error1) {
        error = error1;
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr.IPv6.parseCIDR = function(string) {
      var maskLength, match, parsed;
      if (match = string.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match[2]);
        if (maskLength >= 0 && maskLength <= 128) {
          parsed = [this.parse(match[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
    };
    ipaddr.isValid = function(string) {
      return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
    };
    ipaddr.parse = function(string) {
      if (ipaddr.IPv6.isValid(string)) {
        return ipaddr.IPv6.parse(string);
      } else if (ipaddr.IPv4.isValid(string)) {
        return ipaddr.IPv4.parse(string);
      } else {
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
      }
    };
    ipaddr.parseCIDR = function(string) {
      var e;
      try {
        return ipaddr.IPv6.parseCIDR(string);
      } catch (error1) {
        e = error1;
        try {
          return ipaddr.IPv4.parseCIDR(string);
        } catch (error12) {
          e = error12;
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
        }
      }
    };
    ipaddr.fromByteArray = function(bytes2) {
      var length;
      length = bytes2.length;
      if (length === 4) {
        return new ipaddr.IPv4(bytes2);
      } else if (length === 16) {
        return new ipaddr.IPv6(bytes2);
      } else {
        throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
      }
    };
    ipaddr.process = function(string) {
      var addr;
      addr = this.parse(string);
      if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
        return addr.toIPv4Address();
      } else {
        return addr;
      }
    };
  }).call(exports);
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fastify@4.26.0/node_modules/proxy-addr/index.js
var require_proxy_addr = __commonJS((exports, module) => {
  var alladdrs = function(req, trust) {
    var addrs = forwarded(req);
    if (!trust) {
      return addrs;
    }
    if (typeof trust !== "function") {
      trust = compile(trust);
    }
    for (var i = 0;i < addrs.length - 1; i++) {
      if (trust(addrs[i], i))
        continue;
      addrs.length = i + 1;
    }
    return addrs;
  };
  var compile = function(val) {
    if (!val) {
      throw new TypeError("argument is required");
    }
    var trust;
    if (typeof val === "string") {
      trust = [val];
    } else if (Array.isArray(val)) {
      trust = val.slice();
    } else {
      throw new TypeError("unsupported trust argument");
    }
    for (var i = 0;i < trust.length; i++) {
      val = trust[i];
      if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
        continue;
      }
      val = IP_RANGES[val];
      trust.splice.apply(trust, [i, 1].concat(val));
      i += val.length - 1;
    }
    return compileTrust(compileRangeSubnets(trust));
  };
  var compileRangeSubnets = function(arr) {
    var rangeSubnets = new Array(arr.length);
    for (var i = 0;i < arr.length; i++) {
      rangeSubnets[i] = parseipNotation(arr[i]);
    }
    return rangeSubnets;
  };
  var compileTrust = function(rangeSubnets) {
    var len = rangeSubnets.length;
    return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
  };
  var parseipNotation = function(note) {
    var pos = note.lastIndexOf("/");
    var str = pos !== -1 ? note.substring(0, pos) : note;
    if (!isip(str)) {
      throw new TypeError("invalid IP address: " + str);
    }
    var ip = parseip(str);
    if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) {
      ip = ip.toIPv4Address();
    }
    var max = ip.kind() === "ipv6" ? 128 : 32;
    var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;
    if (range === null) {
      range = max;
    } else if (DIGIT_REGEXP.test(range)) {
      range = parseInt(range, 10);
    } else if (ip.kind() === "ipv4" && isip(range)) {
      range = parseNetmask(range);
    } else {
      range = null;
    }
    if (range <= 0 || range > max) {
      throw new TypeError("invalid range on address: " + note);
    }
    return [ip, range];
  };
  var parseNetmask = function(netmask) {
    var ip = parseip(netmask);
    var kind = ip.kind();
    return kind === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
  };
  var proxyaddr = function(req, trust) {
    if (!req) {
      throw new TypeError("req argument is required");
    }
    if (!trust) {
      throw new TypeError("trust argument is required");
    }
    var addrs = alladdrs(req, trust);
    var addr = addrs[addrs.length - 1];
    return addr;
  };
  var trustNone = function() {
    return false;
  };
  var trustMulti = function(subnets) {
    return function trust(addr) {
      if (!isip(addr))
        return false;
      var ip = parseip(addr);
      var ipconv;
      var kind = ip.kind();
      for (var i = 0;i < subnets.length; i++) {
        var subnet = subnets[i];
        var subnetip = subnet[0];
        var subnetkind = subnetip.kind();
        var subnetrange = subnet[1];
        var trusted = ip;
        if (kind !== subnetkind) {
          if (subnetkind === "ipv4" && !ip.isIPv4MappedAddress()) {
            continue;
          }
          if (!ipconv) {
            ipconv = subnetkind === "ipv4" ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
          }
          trusted = ipconv;
        }
        if (trusted.match(subnetip, subnetrange)) {
          return true;
        }
      }
      return false;
    };
  };
  var trustSingle = function(subnet) {
    var subnetip = subnet[0];
    var subnetkind = subnetip.kind();
    var subnetisipv4 = subnetkind === "ipv4";
    var subnetrange = subnet[1];
    return function trust(addr) {
      if (!isip(addr))
        return false;
      var ip = parseip(addr);
      var kind = ip.kind();
      if (kind !== subnetkind) {
        if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
          return false;
        }
        ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
      }
      return ip.match(subnetip, subnetrange);
    };
  };
  /*!
   * proxy-addr
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = proxyaddr;
  module.exports.all = alladdrs;
  module.exports.compile = compile;
  var forwarded = require_forwarded();
  var ipaddr = require_ipaddr();
  var DIGIT_REGEXP = /^[0-9]+$/;
  var isip = ipaddr.isValid;
  var parseip = ipaddr.parse;
  var IP_RANGES = {
    linklocal: ["169.254.0.0/16", "fe80::/10"],
    loopback: ["127.0.0.1/8", "::1/128"],
    uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
  };
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/constants.js
var require_constants4 = __commonJS((exports, module) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/debug.js
var require_debug2 = __commonJS((exports, module) => {
  var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  module.exports = debug;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/re.js
var require_re = __commonJS((exports, module) => {
  var {
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_LENGTH
  } = require_constants4();
  var debug = require_debug2();
  exports = module.exports = {};
  var re = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var t = exports.t = {};
  var R = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  var makeSafeRegex = (value) => {
    for (const [token, max] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
  };
  var createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index2 = R++;
    debug(name, index2, value);
    t[name] = index2;
    src[index2] = value;
    re[index2] = new RegExp(value, isGlobal ? "g" : undefined);
    safeRe[index2] = new RegExp(safe, isGlobal ? "g" : undefined);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
  createToken("FULL", `^${src[t.FULLPLAIN]}\$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
  createToken("LOOSE", `^${src[t.LOOSEPLAIN]}\$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}\$`);
  createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}\$`);
  createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\$|[^\\d])`);
  createToken("COERCERTL", src[t.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}\$`);
  createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}\$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}\$`);
  createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}\$`);
  createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})\$|^\$`);
  createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})\$|^\$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*\$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*\$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports, module) => {
  var looseOption = Object.freeze({ loose: true });
  var emptyOpts = Object.freeze({});
  var parseOptions = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  module.exports = parseOptions;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports, module) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a, b) => {
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/semver.js
var require_semver = __commonJS((exports, module) => {
  var debug = require_debug2();
  var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants4();
  var { safeRe: re, t } = require_re();
  var parseOptions = require_parse_options();
  var { compareIdentifiers } = require_identifiers();

  class SemVer {
    constructor(version3, options) {
      options = parseOptions(options);
      if (version3 instanceof SemVer) {
        if (version3.loose === !!options.loose && version3.includePrerelease === !!options.includePrerelease) {
          return version3;
        } else {
          version3 = version3.version;
        }
      } else if (typeof version3 !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version3}".`);
      }
      if (version3.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug("SemVer", version3, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m = version3.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version3}`);
      }
      this.raw = version3;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id2) => {
          if (/^[0-9]+$/.test(id2)) {
            const num = +id2;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id2;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a = this.prerelease[i];
        const b = other.prerelease[i];
        debug("prerelease compare", i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a = this.build[i];
        const b = other.build[i];
        debug("prerelease compare", i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    inc(release, identifier, identifierBase) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre": {
          const base31 = Number(identifierBase) ? 1 : 0;
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (this.prerelease.length === 0) {
            this.prerelease = [base31];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base31);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base31];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  module.exports = SemVer;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/parse.js
var require_parse2 = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse = (version3, options, throwErrors = false) => {
    if (version3 instanceof SemVer) {
      return version3;
    }
    try {
      return new SemVer(version3, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  module.exports = parse;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports, module) => {
  var parse = require_parse2();
  var valid = (version3, options) => {
    const v = parse(version3, options);
    return v ? v.version : null;
  };
  module.exports = valid;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/clean.js
var require_clean = __commonJS((exports, module) => {
  var parse = require_parse2();
  var clean = (version3, options) => {
    const s = parse(version3.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  module.exports = clean;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var inc = (version3, release, options, identifier, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier;
      identifier = options;
      options = undefined;
    }
    try {
      return new SemVer(version3 instanceof SemVer ? version3.version : version3, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
      return null;
    }
  };
  module.exports = inc;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports, module) => {
  var parse = require_parse2();
  var diff = (version1, version22) => {
    const v1 = parse(version1, null, true);
    const v2 = parse(version22, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (highVersion.patch) {
        return "patch";
      }
      if (highVersion.minor) {
        return "minor";
      }
      return "major";
    }
    const prefix = highHasPre ? "pre" : "";
    if (v1.major !== v2.major) {
      return prefix + "major";
    }
    if (v1.minor !== v2.minor) {
      return prefix + "minor";
    }
    if (v1.patch !== v2.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  };
  module.exports = diff;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/major.js
var require_major = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var major = (a, loose) => new SemVer(a, loose).major;
  module.exports = major;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var minor = (a, loose) => new SemVer(a, loose).minor;
  module.exports = minor;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var patch = (a, loose) => new SemVer(a, loose).patch;
  module.exports = patch;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports, module) => {
  var parse = require_parse2();
  var prerelease = (version3, options) => {
    const parsed = parse(version3, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  module.exports = prerelease;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  module.exports = compare;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports, module) => {
  var compare = require_compare();
  var rcompare = (a, b, loose) => compare(b, a, loose);
  module.exports = rcompare;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports, module) => {
  var compare = require_compare();
  var compareLoose = (a, b) => compare(a, b, true);
  module.exports = compareLoose;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compareBuild = (a, b, loose) => {
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  module.exports = compareBuild;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/sort.js
var require_sort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
  module.exports = sort;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
  module.exports = rsort;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports, module) => {
  var compare = require_compare();
  var gt = (a, b, loose) => compare(a, b, loose) > 0;
  module.exports = gt;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports, module) => {
  var compare = require_compare();
  var lt = (a, b, loose) => compare(a, b, loose) < 0;
  module.exports = lt;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports, module) => {
  var compare = require_compare();
  var eq = (a, b, loose) => compare(a, b, loose) === 0;
  module.exports = eq;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports, module) => {
  var compare = require_compare();
  var neq = (a, b, loose) => compare(a, b, loose) !== 0;
  module.exports = neq;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports, module) => {
  var compare = require_compare();
  var gte = (a, b, loose) => compare(a, b, loose) >= 0;
  module.exports = gte;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports, module) => {
  var compare = require_compare();
  var lte = (a, b, loose) => compare(a, b, loose) <= 0;
  module.exports = lte;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports, module) => {
  var eq = require_eq();
  var neq = require_neq();
  var gt = require_gt();
  var gte = require_gte();
  var lt = require_lt();
  var lte = require_lte();
  var cmp = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a === b;
      case "!==":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module.exports = cmp;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse = require_parse2();
  var { safeRe: re, t } = require_re();
  var coerce2 = (version3, options) => {
    if (version3 instanceof SemVer) {
      return version3;
    }
    if (typeof version3 === "number") {
      version3 = String(version3);
    }
    if (typeof version3 !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version3.match(re[t.COERCE]);
    } else {
      let next;
      while ((next = re[t.COERCERTL].exec(version3)) && (!match || match.index + match[0].length !== version3.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      re[t.COERCERTL].lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
  };
  module.exports = coerce2;
});

// ../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js
var require_iterator = __commonJS((exports, module) => {
  module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head;walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/lru-cache@6.0.0/node_modules/yallist/yallist.js
var require_yallist = __commonJS((exports, module) => {
  var Yallist = function(list) {
    var self2 = this;
    if (!(self2 instanceof Yallist)) {
      self2 = new Yallist;
    }
    self2.tail = null;
    self2.head = null;
    self2.length = 0;
    if (list && typeof list.forEach === "function") {
      list.forEach(function(item) {
        self2.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length;i < l; i++) {
        self2.push(arguments[i]);
      }
    }
    return self2;
  };
  var insert = function(self2, node9, value) {
    var inserted = node9 === self2.head ? new Node(value, null, node9, self2) : new Node(value, node9, node9.next, self2);
    if (inserted.next === null) {
      self2.tail = inserted;
    }
    if (inserted.prev === null) {
      self2.head = inserted;
    }
    self2.length++;
    return inserted;
  };
  var push = function(self2, item) {
    self2.tail = new Node(item, self2.tail, null, self2);
    if (!self2.head) {
      self2.head = self2.tail;
    }
    self2.length++;
  };
  var unshift = function(self2, item) {
    self2.head = new Node(item, null, self2.head, self2);
    if (!self2.tail) {
      self2.tail = self2.head;
    }
    self2.length++;
  };
  var Node = function(value, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  };
  module.exports = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;
  Yallist.prototype.removeNode = function(node9) {
    if (node9.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next = node9.next;
    var prev = node9.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node9 === this.head) {
      this.head = next;
    }
    if (node9 === this.tail) {
      this.tail = prev;
    }
    node9.list.length--;
    node9.next = null;
    node9.prev = null;
    node9.list = null;
    return next;
  };
  Yallist.prototype.unshiftNode = function(node9) {
    if (node9 === this.head) {
      return;
    }
    if (node9.list) {
      node9.list.removeNode(node9);
    }
    var head = this.head;
    node9.list = this;
    node9.next = head;
    if (head) {
      head.prev = node9;
    }
    this.head = node9;
    if (!this.tail) {
      this.tail = node9;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node9) {
    if (node9 === this.tail) {
      return;
    }
    if (node9.list) {
      node9.list.removeNode(node9);
    }
    var tail = this.tail;
    node9.list = this;
    node9.prev = tail;
    if (tail) {
      tail.next = node9;
    }
    this.tail = node9;
    if (!this.head) {
      this.head = node9;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i = 0, l = arguments.length;i < l; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i = 0, l = arguments.length;i < l; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail) {
      return;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head) {
      return;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0;walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1;walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n) {
    for (var i = 0, walker = this.head;walker !== null && i < n; i++) {
      walker = walker.next;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n) {
    for (var i = 0, walker = this.tail;walker !== null && i < n; i++) {
      walker = walker.prev;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.head;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.tail;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0;walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = this.length - 1;walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret2 = new Yallist;
    if (to < from || to < 0) {
      return ret2;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head;walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (;walker !== null && i < to; i++, walker = walker.next) {
      ret2.push(walker.value);
    }
    return ret2;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret2 = new Yallist;
    if (to < from || to < 0) {
      return ret2;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail;walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (;walker !== null && i > from; i--, walker = walker.prev) {
      ret2.push(walker.value);
    }
    return ret2;
  };
  Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    for (var i = 0, walker = this.head;walker !== null && i < start; i++) {
      walker = walker.next;
    }
    var ret2 = [];
    for (var i = 0;walker && i < deleteCount; i++) {
      ret2.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i = 0;i < nodes.length; i++) {
      walker = insert(this, walker, nodes[i]);
    }
    return ret2;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head;walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  try {
    require_iterator()(Yallist);
  } catch (er) {
  }
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/semver@7.5.4/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS((exports, module) => {
  var Yallist = require_yallist();
  var MAX = Symbol("max");
  var LENGTH = Symbol("length");
  var LENGTH_CALCULATOR = Symbol("lengthCalculator");
  var ALLOW_STALE = Symbol("allowStale");
  var MAX_AGE = Symbol("maxAge");
  var DISPOSE = Symbol("dispose");
  var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
  var LRU_LIST = Symbol("lruList");
  var CACHE = Symbol("cache");
  var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
  var naiveLength = () => 1;

  class LRUCache {
    constructor(options) {
      if (typeof options === "number")
        options = { max: options };
      if (!options)
        options = {};
      if (options.max && (typeof options.max !== "number" || options.max < 0))
        throw new TypeError("max must be a non-negative number");
      const max = this[MAX] = options.max || Infinity;
      const lc = options.length || naiveLength;
      this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
      this[ALLOW_STALE] = options.stale || false;
      if (options.maxAge && typeof options.maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
      this.reset();
    }
    set max(mL) {
      if (typeof mL !== "number" || mL < 0)
        throw new TypeError("max must be a non-negative number");
      this[MAX] = mL || Infinity;
      trim8(this);
    }
    get max() {
      return this[MAX];
    }
    set allowStale(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
      return this[ALLOW_STALE];
    }
    set maxAge(mA) {
      if (typeof mA !== "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[MAX_AGE] = mA;
      trim8(this);
    }
    get maxAge() {
      return this[MAX_AGE];
    }
    set lengthCalculator(lC) {
      if (typeof lC !== "function")
        lC = naiveLength;
      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach((hit) => {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
          this[LENGTH] += hit.length;
        });
      }
      trim8(this);
    }
    get lengthCalculator() {
      return this[LENGTH_CALCULATOR];
    }
    get length() {
      return this[LENGTH];
    }
    get itemCount() {
      return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].tail;walker !== null; ) {
        const prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
    forEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].head;walker !== null; ) {
        const next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
    keys() {
      return this[LRU_LIST].toArray().map((k) => k.key);
    }
    values() {
      return this[LRU_LIST].toArray().map((k) => k.value);
    }
    reset() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
      }
      this[CACHE] = new Map;
      this[LRU_LIST] = new Yallist;
      this[LENGTH] = 0;
    }
    dump() {
      return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter((h) => h);
    }
    dumpLru() {
      return this[LRU_LIST];
    }
    set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      const now = maxAge ? Date.now() : 0;
      const len = this[LENGTH_CALCULATOR](value, key);
      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          del(this, this[CACHE].get(key));
          return false;
        }
        const node9 = this[CACHE].get(key);
        const item = node9.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET])
            this[DISPOSE](key, item.value);
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim8(this);
        return true;
      }
      const hit = new Entry(key, value, len, now, maxAge);
      if (hit.length > this[MAX]) {
        if (this[DISPOSE])
          this[DISPOSE](key, value);
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim8(this);
      return true;
    }
    has(key) {
      if (!this[CACHE].has(key))
        return false;
      const hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
    get(key) {
      return get(this, key, true);
    }
    peek(key) {
      return get(this, key, false);
    }
    pop() {
      const node9 = this[LRU_LIST].tail;
      if (!node9)
        return null;
      del(this, node9);
      return node9.value;
    }
    del(key) {
      del(this, this[CACHE].get(key));
    }
    load(arr) {
      this.reset();
      const now = Date.now();
      for (let l = arr.length - 1;l >= 0; l--) {
        const hit = arr[l];
        const expiresAt = hit.e || 0;
        if (expiresAt === 0)
          this.set(hit.k, hit.v);
        else {
          const maxAge = expiresAt - now;
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
    prune() {
      this[CACHE].forEach((value, key) => get(this, key, false));
    }
  }
  var get = (self2, key, doUse) => {
    const node9 = self2[CACHE].get(key);
    if (node9) {
      const hit = node9.value;
      if (isStale(self2, hit)) {
        del(self2, node9);
        if (!self2[ALLOW_STALE])
          return;
      } else {
        if (doUse) {
          if (self2[UPDATE_AGE_ON_GET])
            node9.value.now = Date.now();
          self2[LRU_LIST].unshiftNode(node9);
        }
      }
      return hit.value;
    }
  };
  var isStale = (self2, hit) => {
    if (!hit || !hit.maxAge && !self2[MAX_AGE])
      return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
  };
  var trim8 = (self2) => {
    if (self2[LENGTH] > self2[MAX]) {
      for (let walker = self2[LRU_LIST].tail;self2[LENGTH] > self2[MAX] && walker !== null; ) {
        const prev = walker.prev;
        del(self2, walker);
        walker = prev;
      }
    }
  };
  var del = (self2, node9) => {
    if (node9) {
      const hit = node9.value;
      if (self2[DISPOSE])
        self2[DISPOSE](hit.key, hit.value);
      self2[LENGTH] -= hit.length;
      self2[CACHE].delete(hit.key);
      self2[LRU_LIST].removeNode(node9);
    }
  };

  class Entry {
    constructor(key, value, length, now, maxAge) {
      this.key = key;
      this.value = value;
      this.length = length;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  }
  var forEachStep = (self2, fn, node9, thisp) => {
    let hit = node9.value;
    if (isStale(self2, hit)) {
      del(self2, node9);
      if (!self2[ALLOW_STALE])
        hit = undefined;
    }
    if (hit)
      fn.call(thisp, hit.value, hit.key, self2);
  };
  module.exports = LRUCache;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/range.js
var require_range = __commonJS((exports, module) => {
  class Range {
    constructor(range, options) {
      options = parseOptions(options);
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.format();
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      debug("tilde trim", range);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      debug("caret trim", range);
      let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug("loose invalid filter", comp, this.options);
          return !!comp.match(re[t.COMPARATORLOOSE]);
        });
      }
      debug("range list", rangeList);
      const rangeMap = new Map;
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version3) {
      if (!version3) {
        return false;
      }
      if (typeof version3 === "string") {
        try {
          version3 = new SemVer(version3, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0;i < this.set.length; i++) {
        if (testSet(this.set[i], version3, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  module.exports = Range;
  var LRU = require_lru_cache();
  var cache = new LRU({ max: 1000 });
  var parseOptions = require_parse_options();
  var Comparator = require_comparator();
  var debug = require_debug2();
  var SemVer = require_semver();
  var {
    safeRe: re,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants4();
  var isNullSet = (c) => c.value === "<0.0.0-0";
  var isAny = (c) => c.value === "";
  var isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options) => {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  var isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
  var replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  var replaceTilde = (comp, options) => {
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("tilde", comp, _, M, m, p, pr);
      let ret2;
      if (isX(M)) {
        ret2 = "";
      } else if (isX(m)) {
        ret2 = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret2 = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret2 = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret2 = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug("tilde return", ret2);
      return ret2;
    });
  };
  var replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  var replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z2 = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("caret", comp, _, M, m, p, pr);
      let ret2;
      if (isX(M)) {
        ret2 = "";
      } else if (isX(m)) {
        ret2 = `>=${M}.0.0${z2} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret2 = `>=${M}.${m}.0${z2} <${M}.${+m + 1}.0-0`;
        } else {
          ret2 = `>=${M}.${m}.0${z2} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret2 = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret2 = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret2 = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret2 = `>=${M}.${m}.${p}${z2} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret2 = `>=${M}.${m}.${p}${z2} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret2 = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug("caret return", ret2);
      return ret2;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret2, gtlt, M, m, p, pr) => {
      debug("xRange", comp, ret2, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret2 = "<0.0.0-0";
        } else {
          ret2 = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret2 = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret2 = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret2 = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug("xRange return", ret2);
      return ret2;
    });
  };
  var replaceStars = (comp, options) => {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[t.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  var testSet = (set, version3, options) => {
    for (let i = 0;i < set.length; i++) {
      if (!set[i].test(version3)) {
        return false;
      }
    }
    if (version3.prerelease.length && !options.includePrerelease) {
      for (let i = 0;i < set.length; i++) {
        debug(set[i].semver);
        if (set[i].semver === Comparator.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports, module) => {
  var ANY = Symbol("SemVer ANY");

  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== undefined ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version3) {
      debug("Comparator.test", version3, this.options.loose);
      if (this.semver === ANY || version3 === ANY) {
        return true;
      }
      if (typeof version3 === "string") {
        try {
          version3 = new SemVer(version3, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version3, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  module.exports = Comparator;
  var parseOptions = require_parse_options();
  var { safeRe: re, t } = require_re();
  var cmp = require_cmp();
  var debug = require_debug2();
  var SemVer = require_semver();
  var Range = require_range();
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports, module) => {
  var Range = require_range();
  var satisfies = (version3, range, options) => {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version3);
  };
  module.exports = satisfies;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports, module) => {
  var Range = require_range();
  var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
  module.exports = toComparators;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var maxSatisfying = (versions, range, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  module.exports = maxSatisfying;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var minSatisfying = (versions, range, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  module.exports = minSatisfying;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var gt = require_gt();
  var minVersion = (range, loose) => {
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let setMin = null;
      comparators.forEach((comparator) => {
        const compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  module.exports = minVersion;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports, module) => {
  var Range = require_range();
  var validRange = (range, options) => {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  module.exports = validRange;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var Range = require_range();
  var satisfies = require_satisfies();
  var gt = require_gt();
  var lt = require_lt();
  var lte = require_lte();
  var gte = require_gte();
  var outside = (version3, range, hilo, options) => {
    version3 = new SemVer(version3, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version3, range, options)) {
      return false;
    }
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator) => {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version3, low.semver)) {
        return false;
      }
    }
    return true;
  };
  module.exports = outside;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports, module) => {
  var outside = require_outside();
  var gtr = (version3, range, options) => outside(version3, range, ">", options);
  module.exports = gtr;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports, module) => {
  var outside = require_outside();
  var ltr = (version3, range, options) => outside(version3, range, "<", options);
  module.exports = ltr;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports, module) => {
  var Range = require_range();
  var intersects = (r1, r2, options) => {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
  };
  module.exports = intersects;
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports, module) => {
  var satisfies = require_satisfies();
  var compare = require_compare();
  module.exports = (versions, range, options) => {
    const set = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b) => compare(a, b, options));
    for (const version3 of v) {
      const included = satisfies(version3, range, options);
      if (included) {
        prev = version3;
        if (!first) {
          first = version3;
        }
      } else {
        if (prev) {
          set.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set.push([first, null]);
    }
    const ranges = [];
    for (const [min, max] of set) {
      if (min === max) {
        ranges.push(min);
      } else if (!max && min === v[0]) {
        ranges.push("*");
      } else if (!max) {
        ranges.push(`>=${min}`);
      } else if (min === v[0]) {
        ranges.push(`<=${max}`);
      } else {
        ranges.push(`${min} - ${max}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };
});

// ../node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports, module) => {
  var Range = require_range();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var satisfies = require_satisfies();
  var compare = require_compare();
  var subset = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER:
      for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
    return true;
  };
  var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  var minimumVersion = [new Comparator(">=0.0.0")];
  var simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = new Set;
    let gt, lt;
    for (const c of sub) {
      if (c.operator === ">" || c.operator === ">=") {
        gt = higherGT(gt, c, options);
      } else if (c.operator === "<" || c.operator === "<=") {
        lt = lowerLT(lt, c, options);
      } else {
        eqSet.add(c.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
        return null;
      }
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options)) {
        return null;
      }
      if (lt && !satisfies(eq, String(lt), options)) {
        return null;
      }
      for (const c of dom) {
        if (!satisfies(eq, String(c), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
      hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
      if (gt) {
        if (needDomGTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c.operator === ">" || c.operator === ">=") {
          higher = higherGT(gt, c, options);
          if (higher === c && higher !== gt) {
            return false;
          }
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
          return false;
        }
      }
      if (lt) {
        if (needDomLTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c.operator === "<" || c.operator === "<=") {
          lower = lowerLT(lt, c, options);
          if (lower === c && lower !== lt) {
            return false;
          }
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
          return false;
        }
      }
      if (!c.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
      return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  var higherGT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
  };
  var lowerLT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
  };
  module.exports = subset;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fastify@4.26.0/node_modules/semver/index.js
var require_semver2 = __commonJS((exports, module) => {
  var internalRe = require_re();
  var constants = require_constants4();
  var SemVer = require_semver();
  var identifiers = require_identifiers();
  var parse = require_parse2();
  var valid = require_valid();
  var clean = require_clean();
  var inc = require_inc();
  var diff = require_diff();
  var major = require_major();
  var minor = require_minor();
  var patch = require_patch();
  var prerelease = require_prerelease();
  var compare = require_compare();
  var rcompare = require_rcompare();
  var compareLoose = require_compare_loose();
  var compareBuild = require_compare_build();
  var sort = require_sort();
  var rsort = require_rsort();
  var gt = require_gt();
  var lt = require_lt();
  var eq = require_eq();
  var neq = require_neq();
  var gte = require_gte();
  var lte = require_lte();
  var cmp = require_cmp();
  var coerce2 = require_coerce();
  var Comparator = require_comparator();
  var Range = require_range();
  var satisfies = require_satisfies();
  var toComparators = require_to_comparators();
  var maxSatisfying = require_max_satisfying();
  var minSatisfying = require_min_satisfying();
  var minVersion = require_min_version();
  var validRange = require_valid2();
  var outside = require_outside();
  var gtr = require_gtr();
  var ltr = require_ltr();
  var intersects = require_intersects();
  var simplifyRange = require_simplify();
  var subset = require_subset();
  module.exports = {
    parse,
    valid,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce: coerce2,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
  };
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/request.js
var require_request3 = __commonJS((exports, module) => {
  var Request2 = function(id2, params, req, query, log7, context) {
    this.id = id2;
    this[kRouteContext] = context;
    this.params = params;
    this.raw = req;
    this.query = query;
    this.log = log7;
    this.body = undefined;
  };
  var getTrustProxyFn = function(tp) {
    if (typeof tp === "function") {
      return tp;
    }
    if (tp === true) {
      return function() {
        return true;
      };
    }
    if (typeof tp === "number") {
      return function(a, i) {
        return i < tp;
      };
    }
    if (typeof tp === "string") {
      const values = tp.split(",").map((it) => it.trim());
      return proxyAddr.compile(values);
    }
    return proxyAddr.compile(tp);
  };
  var buildRequest3 = function(R, trustProxy) {
    if (trustProxy) {
      return buildRequestWithTrustProxy(R, trustProxy);
    }
    return buildRegularRequest(R);
  };
  var buildRegularRequest = function(R) {
    const props = R.props.slice();
    function _Request(id2, params, req, query, log7, context) {
      this.id = id2;
      this[kRouteContext] = context;
      this.params = params;
      this.raw = req;
      this.query = query;
      this.log = log7;
      this.body = undefined;
      var prop;
      for (var i = 0;i < props.length; i++) {
        prop = props[i];
        this[prop.key] = prop.value;
      }
    }
    Object.setPrototypeOf(_Request.prototype, R.prototype);
    Object.setPrototypeOf(_Request, R);
    _Request.props = props;
    _Request.parent = R;
    return _Request;
  };
  var getLastEntryInMultiHeaderValue = function(headerValue) {
    const lastIndex = headerValue.lastIndexOf(",");
    return lastIndex === -1 ? headerValue.trim() : headerValue.slice(lastIndex + 1).trim();
  };
  var buildRequestWithTrustProxy = function(R, trustProxy) {
    const _Request = buildRegularRequest(R);
    const proxyFn = getTrustProxyFn(trustProxy);
    _Request[kHasBeenDecorated] = true;
    Object.defineProperties(_Request.prototype, {
      ip: {
        get() {
          return proxyAddr(this.raw, proxyFn);
        }
      },
      ips: {
        get() {
          return proxyAddr.all(this.raw, proxyFn);
        }
      },
      hostname: {
        get() {
          if (this.ip !== undefined && this.headers["x-forwarded-host"]) {
            return getLastEntryInMultiHeaderValue(this.headers["x-forwarded-host"]);
          }
          return this.headers.host || this.headers[":authority"];
        }
      },
      protocol: {
        get() {
          if (this.headers["x-forwarded-proto"]) {
            return getLastEntryInMultiHeaderValue(this.headers["x-forwarded-proto"]);
          }
          if (this.socket) {
            return this.socket.encrypted ? "https" : "http";
          }
        }
      }
    });
    return _Request;
  };
  var proxyAddr = require_proxy_addr();
  var semver = require_semver2();
  var {
    FSTDEP005,
    FSTDEP012,
    FSTDEP015,
    FSTDEP016,
    FSTDEP017,
    FSTDEP018
  } = require_warnings();
  var {
    kHasBeenDecorated,
    kSchemaBody,
    kSchemaHeaders,
    kSchemaParams,
    kSchemaQuerystring,
    kSchemaController,
    kOptions,
    kRequestCacheValidateFns,
    kRouteContext,
    kPublicRouteContext,
    kRequestOriginalUrl
  } = require_symbols3();
  var { FST_ERR_REQ_INVALID_VALIDATION_INVOCATION } = require_errors4();
  var HTTP_PART_SYMBOL_MAP = {
    body: kSchemaBody,
    headers: kSchemaHeaders,
    params: kSchemaParams,
    querystring: kSchemaQuerystring,
    query: kSchemaQuerystring
  };
  Request2.props = [];
  Object.defineProperties(Request2.prototype, {
    server: {
      get() {
        return this[kRouteContext].server;
      }
    },
    url: {
      get() {
        return this.raw.url;
      }
    },
    originalUrl: {
      get() {
        if (!this[kRequestOriginalUrl]) {
          this[kRequestOriginalUrl] = this.raw.originalUrl || this.raw.url;
        }
        return this[kRequestOriginalUrl];
      }
    },
    method: {
      get() {
        return this.raw.method;
      }
    },
    context: {
      get() {
        FSTDEP012();
        return this[kRouteContext];
      }
    },
    routerPath: {
      get() {
        FSTDEP017();
        return this[kRouteContext].config?.url;
      }
    },
    routeOptions: {
      get() {
        const context = this[kRouteContext];
        const routeLimit = context._parserOptions.limit;
        const serverLimit = context.server.initialConfig.bodyLimit;
        const version3 = context.server.hasConstraintStrategy("version") ? this.raw.headers["accept-version"] : undefined;
        const options = {
          method: context.config?.method,
          url: context.config?.url,
          bodyLimit: routeLimit || serverLimit,
          attachValidation: context.attachValidation,
          logLevel: context.logLevel,
          exposeHeadRoute: context.exposeHeadRoute,
          prefixTrailingSlash: context.prefixTrailingSlash,
          handler: context.handler,
          version: version3
        };
        Object.defineProperties(options, {
          config: {
            get: () => context.config
          },
          schema: {
            get: () => context.schema
          }
        });
        return Object.freeze(options);
      }
    },
    routerMethod: {
      get() {
        FSTDEP018();
        return this[kRouteContext].config?.method;
      }
    },
    routeConfig: {
      get() {
        FSTDEP016();
        return this[kRouteContext][kPublicRouteContext]?.config;
      }
    },
    routeSchema: {
      get() {
        FSTDEP015();
        return this[kRouteContext][kPublicRouteContext].schema;
      }
    },
    is404: {
      get() {
        return this[kRouteContext].config?.url === undefined;
      }
    },
    connection: {
      get() {
        if (semver.gte(process.versions.node, "13.0.0")) {
          FSTDEP005();
        }
        return this.raw.connection;
      }
    },
    socket: {
      get() {
        return this.raw.socket;
      }
    },
    ip: {
      get() {
        if (this.socket) {
          return this.socket.remoteAddress;
        }
      }
    },
    hostname: {
      get() {
        return this.raw.headers.host || this.raw.headers[":authority"];
      }
    },
    protocol: {
      get() {
        if (this.socket) {
          return this.socket.encrypted ? "https" : "http";
        }
      }
    },
    headers: {
      get() {
        if (this.additionalHeaders) {
          return Object.assign({}, this.raw.headers, this.additionalHeaders);
        }
        return this.raw.headers;
      },
      set(headers) {
        this.additionalHeaders = headers;
      }
    },
    getValidationFunction: {
      value: function(httpPartOrSchema) {
        if (typeof httpPartOrSchema === "string") {
          const symbol = HTTP_PART_SYMBOL_MAP[httpPartOrSchema];
          return this[kRouteContext][symbol];
        } else if (typeof httpPartOrSchema === "object") {
          return this[kRouteContext][kRequestCacheValidateFns]?.get(httpPartOrSchema);
        }
      }
    },
    compileValidationSchema: {
      value: function(schema, httpPart = null) {
        const { method, url } = this;
        if (this[kRouteContext][kRequestCacheValidateFns]?.has(schema)) {
          return this[kRouteContext][kRequestCacheValidateFns].get(schema);
        }
        const validatorCompiler = this[kRouteContext].validatorCompiler || this.server[kSchemaController].validatorCompiler || (this.server[kSchemaController].setupValidator(this.server[kOptions]) || this.server[kSchemaController].validatorCompiler);
        const validateFn = validatorCompiler({
          schema,
          method,
          url,
          httpPart
        });
        if (this[kRouteContext][kRequestCacheValidateFns] == null) {
          this[kRouteContext][kRequestCacheValidateFns] = new WeakMap;
        }
        this[kRouteContext][kRequestCacheValidateFns].set(schema, validateFn);
        return validateFn;
      }
    },
    validateInput: {
      value: function(input, schema, httpPart) {
        httpPart = typeof schema === "string" ? schema : httpPart;
        const symbol = httpPart != null && typeof httpPart === "string" && HTTP_PART_SYMBOL_MAP[httpPart];
        let validate;
        if (symbol) {
          validate = this[kRouteContext][symbol];
        }
        if (validate == null && (schema == null || typeof schema !== "object" || Array.isArray(schema))) {
          throw new FST_ERR_REQ_INVALID_VALIDATION_INVOCATION(httpPart);
        }
        if (validate == null) {
          if (this[kRouteContext][kRequestCacheValidateFns]?.has(schema)) {
            validate = this[kRouteContext][kRequestCacheValidateFns].get(schema);
          } else {
            validate = this.compileValidationSchema(schema, httpPart);
          }
        }
        return validate(input);
      }
    }
  });
  module.exports = Request2;
  module.exports.buildRequest = buildRequest3;
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/context.js
var require_context2 = __commonJS((exports, module) => {
  var Context = function({
    schema,
    handler,
    config,
    requestIdLogLabel,
    childLoggerFactory,
    errorHandler,
    bodyLimit,
    logLevel: logLevel3,
    logSerializers,
    attachValidation,
    validatorCompiler,
    serializerCompiler,
    replySerializer,
    schemaErrorFormatter,
    exposeHeadRoute,
    prefixTrailingSlash,
    server,
    isFastify
  }) {
    this.schema = schema;
    this.handler = handler;
    this.Reply = server[kReply];
    this.Request = server[kRequest];
    this.contentTypeParser = server[kContentTypeParser];
    this.onRequest = null;
    this.onSend = null;
    this.onError = null;
    this.onTimeout = null;
    this.preHandler = null;
    this.onResponse = null;
    this.preSerialization = null;
    this.onRequestAbort = null;
    this.config = config;
    this.errorHandler = errorHandler || server[kErrorHandler];
    this.requestIdLogLabel = requestIdLogLabel || server[kOptions].requestIdLogLabel;
    this.childLoggerFactory = childLoggerFactory || server[kChildLoggerFactory];
    this._middie = null;
    this._parserOptions = {
      limit: bodyLimit || server[kBodyLimit]
    };
    this.exposeHeadRoute = exposeHeadRoute;
    this.prefixTrailingSlash = prefixTrailingSlash;
    this.logLevel = logLevel3 || server[kLogLevel];
    this.logSerializers = logSerializers;
    this[kFourOhFourContext] = null;
    this.attachValidation = attachValidation;
    this[kReplySerializerDefault] = replySerializer;
    this.schemaErrorFormatter = schemaErrorFormatter || server[kSchemaErrorFormatter] || defaultSchemaErrorFormatter;
    this[kRouteByFastify] = isFastify;
    this[kRequestCacheValidateFns] = null;
    this[kReplyCacheSerializeFns] = null;
    this.validatorCompiler = validatorCompiler || null;
    this.serializerCompiler = serializerCompiler || null;
    this[kPublicRouteContext] = getPublicRouteContext(this);
    this.server = server;
  };
  var getPublicRouteContext = function(context) {
    return Object.create(null, {
      schema: {
        enumerable: true,
        get() {
          return context.schema;
        }
      },
      config: {
        enumerable: true,
        get() {
          return context.config;
        }
      }
    });
  };
  var defaultSchemaErrorFormatter = function(errors4, dataVar) {
    let text = "";
    const separator = ", ";
    for (var i = 0;i !== errors4.length; ++i) {
      const e = errors4[i];
      text += dataVar + (e.instancePath || "") + " " + e.message + separator;
    }
    return new Error(text.slice(0, -separator.length));
  };
  var {
    kFourOhFourContext,
    kReplySerializerDefault,
    kSchemaErrorFormatter,
    kErrorHandler,
    kChildLoggerFactory,
    kOptions,
    kReply,
    kRequest,
    kBodyLimit,
    kLogLevel,
    kContentTypeParser,
    kRouteByFastify,
    kRequestCacheValidateFns,
    kReplyCacheSerializeFns,
    kPublicRouteContext
  } = require_symbols3();
  module.exports = Context;
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/httpMethods.js
var require_httpMethods = __commonJS((exports, module) => {
  module.exports = {
    supportedMethods: [
      "DELETE",
      "GET",
      "HEAD",
      "PATCH",
      "POST",
      "PUT",
      "OPTIONS",
      "PROPFIND",
      "PROPPATCH",
      "MKCOL",
      "COPY",
      "MOVE",
      "LOCK",
      "UNLOCK",
      "TRACE",
      "SEARCH"
    ]
  };
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/decorate.js
var require_decorate = __commonJS((exports, module) => {
  var decorate = function(instance, name, fn, dependencies) {
    if (Object.prototype.hasOwnProperty.call(instance, name)) {
      throw new FST_ERR_DEC_ALREADY_PRESENT(name);
    }
    checkDependencies(instance, name, dependencies);
    if (fn && (typeof fn.getter === "function" || typeof fn.setter === "function")) {
      Object.defineProperty(instance, name, {
        get: fn.getter,
        set: fn.setter
      });
    } else {
      instance[name] = fn;
    }
  };
  var decorateConstructor = function(konstructor, name, fn, dependencies) {
    const instance = konstructor.prototype;
    if (Object.prototype.hasOwnProperty.call(instance, name) || hasKey(konstructor, name)) {
      throw new FST_ERR_DEC_ALREADY_PRESENT(name);
    }
    konstructor[kHasBeenDecorated] = true;
    checkDependencies(konstructor, name, dependencies);
    if (fn && (typeof fn.getter === "function" || typeof fn.setter === "function")) {
      Object.defineProperty(instance, name, {
        get: fn.getter,
        set: fn.setter
      });
    } else if (typeof fn === "function") {
      instance[name] = fn;
    } else {
      konstructor.props.push({ key: name, value: fn });
    }
  };
  var checkReferenceType = function(name, fn) {
    if (typeof fn === "object" && fn && !(typeof fn.getter === "function" || typeof fn.setter === "function")) {
      FSTDEP006(name);
    }
  };
  var decorateFastify = function(name, fn, dependencies) {
    assertNotStarted(this, name);
    decorate(this, name, fn, dependencies);
    return this;
  };
  var checkExistence = function(instance, name) {
    if (name) {
      return name in instance || instance.prototype && name in instance.prototype || hasKey(instance, name);
    }
    return instance in this;
  };
  var hasKey = function(fn, name) {
    if (fn.props) {
      return fn.props.find(({ key }) => key === name);
    }
    return false;
  };
  var checkRequestExistence = function(name) {
    if (name && hasKey(this[kRequest], name))
      return true;
    return checkExistence(this[kRequest].prototype, name);
  };
  var checkReplyExistence = function(name) {
    if (name && hasKey(this[kReply], name))
      return true;
    return checkExistence(this[kReply].prototype, name);
  };
  var checkDependencies = function(instance, name, deps) {
    if (deps === undefined || deps === null) {
      return;
    }
    if (!Array.isArray(deps)) {
      throw new FST_ERR_DEC_DEPENDENCY_INVALID_TYPE(name);
    }
    for (var i = 0;i !== deps.length; ++i) {
      if (!checkExistence(instance, deps[i])) {
        throw new FST_ERR_DEC_MISSING_DEPENDENCY(deps[i]);
      }
    }
  };
  var decorateReply = function(name, fn, dependencies) {
    assertNotStarted(this, name);
    checkReferenceType(name, fn);
    decorateConstructor(this[kReply], name, fn, dependencies);
    return this;
  };
  var decorateRequest = function(name, fn, dependencies) {
    assertNotStarted(this, name);
    checkReferenceType(name, fn);
    decorateConstructor(this[kRequest], name, fn, dependencies);
    return this;
  };
  var assertNotStarted = function(instance, name) {
    if (instance[kState].started) {
      throw new FST_ERR_DEC_AFTER_START(name);
    }
  };
  var {
    kReply,
    kRequest,
    kState,
    kHasBeenDecorated
  } = require_symbols3();
  var {
    FST_ERR_DEC_ALREADY_PRESENT,
    FST_ERR_DEC_MISSING_DEPENDENCY,
    FST_ERR_DEC_AFTER_START,
    FST_ERR_DEC_DEPENDENCY_INVALID_TYPE
  } = require_errors4();
  var { FSTDEP006 } = require_warnings();
  module.exports = {
    add: decorateFastify,
    exist: checkExistence,
    existRequest: checkRequestExistence,
    existReply: checkReplyExistence,
    dependencies: checkDependencies,
    decorateReply,
    decorateRequest
  };
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fastify@4.26.0/node_modules/toad-cache/dist/toad-cache.cjs
var require_toad_cache = __commonJS((exports) => {
  var getTimestamp = function(date) {
    return `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, "0")}-${date.getDate().toString().padStart(2, "0")}`;
  };

  class FifoMap {
    constructor(max = 1000, ttlInMsecs = 0) {
      if (isNaN(max) || max < 0) {
        throw new Error("Invalid max value");
      }
      if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
        throw new Error("Invalid ttl value");
      }
      this.first = null;
      this.items = new Map;
      this.last = null;
      this.max = max;
      this.ttl = ttlInMsecs;
    }
    get size() {
      return this.items.size;
    }
    clear() {
      this.items = new Map;
      this.first = null;
      this.last = null;
    }
    delete(key) {
      if (this.items.has(key)) {
        const deletedItem = this.items.get(key);
        this.items.delete(key);
        if (deletedItem.prev !== null) {
          deletedItem.prev.next = deletedItem.next;
        }
        if (deletedItem.next !== null) {
          deletedItem.next.prev = deletedItem.prev;
        }
        if (this.first === deletedItem) {
          this.first = deletedItem.next;
        }
        if (this.last === deletedItem) {
          this.last = deletedItem.prev;
        }
      }
    }
    deleteMany(keys) {
      for (var i = 0;i < keys.length; i++) {
        this.delete(keys[i]);
      }
    }
    evict() {
      if (this.size > 0) {
        const item = this.first;
        this.items.delete(item.key);
        if (this.size === 0) {
          this.first = null;
          this.last = null;
        } else {
          this.first = item.next;
          this.first.prev = null;
        }
      }
    }
    expiresAt(key) {
      if (this.items.has(key)) {
        return this.items.get(key).expiry;
      }
    }
    get(key) {
      if (this.items.has(key)) {
        const item = this.items.get(key);
        if (this.ttl > 0 && item.expiry <= Date.now()) {
          this.delete(key);
          return;
        }
        return item.value;
      }
    }
    getMany(keys) {
      const result = [];
      for (var i = 0;i < keys.length; i++) {
        result.push(this.get(keys[i]));
      }
      return result;
    }
    keys() {
      return this.items.keys();
    }
    set(key, value) {
      if (this.items.has(key)) {
        const item2 = this.items.get(key);
        item2.value = value;
        item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
        return;
      }
      if (this.max > 0 && this.size === this.max) {
        this.evict();
      }
      const item = {
        expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
        key,
        prev: this.last,
        next: null,
        value
      };
      this.items.set(key, item);
      if (this.size === 1) {
        this.first = item;
      } else {
        this.last.next = item;
      }
      this.last = item;
    }
  }

  class LruMap {
    constructor(max = 1000, ttlInMsecs = 0) {
      if (isNaN(max) || max < 0) {
        throw new Error("Invalid max value");
      }
      if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
        throw new Error("Invalid ttl value");
      }
      this.first = null;
      this.items = new Map;
      this.last = null;
      this.max = max;
      this.ttl = ttlInMsecs;
    }
    get size() {
      return this.items.size;
    }
    bumpLru(item) {
      if (this.last === item) {
        return;
      }
      const last = this.last;
      const next = item.next;
      const prev = item.prev;
      if (this.first === item) {
        this.first = next;
      }
      item.next = null;
      item.prev = last;
      last.next = item;
      if (prev !== null) {
        prev.next = next;
      }
      if (next !== null) {
        next.prev = prev;
      }
      this.last = item;
    }
    clear() {
      this.items = new Map;
      this.first = null;
      this.last = null;
    }
    delete(key) {
      if (this.items.has(key)) {
        const item = this.items.get(key);
        this.items.delete(key);
        if (item.prev !== null) {
          item.prev.next = item.next;
        }
        if (item.next !== null) {
          item.next.prev = item.prev;
        }
        if (this.first === item) {
          this.first = item.next;
        }
        if (this.last === item) {
          this.last = item.prev;
        }
      }
    }
    deleteMany(keys) {
      for (var i = 0;i < keys.length; i++) {
        this.delete(keys[i]);
      }
    }
    evict() {
      if (this.size > 0) {
        const item = this.first;
        this.items.delete(item.key);
        if (this.size === 0) {
          this.first = null;
          this.last = null;
        } else {
          this.first = item.next;
          this.first.prev = null;
        }
      }
    }
    expiresAt(key) {
      if (this.items.has(key)) {
        return this.items.get(key).expiry;
      }
    }
    get(key) {
      if (this.items.has(key)) {
        const item = this.items.get(key);
        if (this.ttl > 0 && item.expiry <= Date.now()) {
          this.delete(key);
          return;
        }
        this.bumpLru(item);
        return item.value;
      }
    }
    getMany(keys) {
      const result = [];
      for (var i = 0;i < keys.length; i++) {
        result.push(this.get(keys[i]));
      }
      return result;
    }
    keys() {
      return this.items.keys();
    }
    set(key, value) {
      if (this.items.has(key)) {
        const item2 = this.items.get(key);
        item2.value = value;
        item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
        if (this.last !== item2) {
          this.bumpLru(item2);
        }
        return;
      }
      if (this.max > 0 && this.size === this.max) {
        this.evict();
      }
      const item = {
        expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
        key,
        prev: this.last,
        next: null,
        value
      };
      this.items.set(key, item);
      if (this.size === 1) {
        this.first = item;
      } else {
        this.last.next = item;
      }
      this.last = item;
    }
  }

  class LruObject {
    constructor(max = 1000, ttlInMsecs = 0) {
      if (isNaN(max) || max < 0) {
        throw new Error("Invalid max value");
      }
      if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
        throw new Error("Invalid ttl value");
      }
      this.first = null;
      this.items = Object.create(null);
      this.last = null;
      this.size = 0;
      this.max = max;
      this.ttl = ttlInMsecs;
    }
    bumpLru(item) {
      if (this.last === item) {
        return;
      }
      const last = this.last;
      const next = item.next;
      const prev = item.prev;
      if (this.first === item) {
        this.first = next;
      }
      item.next = null;
      item.prev = last;
      last.next = item;
      if (prev !== null) {
        prev.next = next;
      }
      if (next !== null) {
        next.prev = prev;
      }
      this.last = item;
    }
    clear() {
      this.items = Object.create(null);
      this.first = null;
      this.last = null;
      this.size = 0;
    }
    delete(key) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        const item = this.items[key];
        delete this.items[key];
        this.size--;
        if (item.prev !== null) {
          item.prev.next = item.next;
        }
        if (item.next !== null) {
          item.next.prev = item.prev;
        }
        if (this.first === item) {
          this.first = item.next;
        }
        if (this.last === item) {
          this.last = item.prev;
        }
      }
    }
    deleteMany(keys) {
      for (var i = 0;i < keys.length; i++) {
        this.delete(keys[i]);
      }
    }
    evict() {
      if (this.size > 0) {
        const item = this.first;
        delete this.items[item.key];
        if (--this.size === 0) {
          this.first = null;
          this.last = null;
        } else {
          this.first = item.next;
          this.first.prev = null;
        }
      }
    }
    expiresAt(key) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        return this.items[key].expiry;
      }
    }
    get(key) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        const item = this.items[key];
        if (this.ttl > 0 && item.expiry <= Date.now()) {
          this.delete(key);
          return;
        }
        this.bumpLru(item);
        return item.value;
      }
    }
    getMany(keys) {
      const result = [];
      for (var i = 0;i < keys.length; i++) {
        result.push(this.get(keys[i]));
      }
      return result;
    }
    keys() {
      return Object.keys(this.items);
    }
    set(key, value) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        const item2 = this.items[key];
        item2.value = value;
        item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
        if (this.last !== item2) {
          this.bumpLru(item2);
        }
        return;
      }
      if (this.max > 0 && this.size === this.max) {
        this.evict();
      }
      const item = {
        expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
        key,
        prev: this.last,
        next: null,
        value
      };
      this.items[key] = item;
      if (++this.size === 1) {
        this.first = item;
      } else {
        this.last.next = item;
      }
      this.last = item;
    }
  }

  class HitStatisticsRecord {
    constructor() {
      this.records = {};
    }
    initForCache(cacheId, currentTimeStamp) {
      this.records[cacheId] = {
        [currentTimeStamp]: {
          cacheSize: 0,
          hits: 0,
          falsyHits: 0,
          emptyHits: 0,
          misses: 0,
          expirations: 0,
          evictions: 0,
          invalidateOne: 0,
          invalidateAll: 0,
          sets: 0
        }
      };
    }
    resetForCache(cacheId) {
      for (let key of Object.keys(this.records[cacheId])) {
        this.records[cacheId][key] = {
          cacheSize: 0,
          hits: 0,
          falsyHits: 0,
          emptyHits: 0,
          misses: 0,
          expirations: 0,
          evictions: 0,
          invalidateOne: 0,
          invalidateAll: 0,
          sets: 0
        };
      }
    }
    getStatistics() {
      return this.records;
    }
  }

  class HitStatistics {
    constructor(cacheId, statisticTtlInHours, globalStatisticsRecord) {
      this.cacheId = cacheId;
      this.statisticTtlInHours = statisticTtlInHours;
      this.collectionStart = new Date;
      this.currentTimeStamp = getTimestamp(this.collectionStart);
      this.records = globalStatisticsRecord || new HitStatisticsRecord;
      this.records.initForCache(this.cacheId, this.currentTimeStamp);
    }
    get currentRecord() {
      if (!this.records.records[this.cacheId][this.currentTimeStamp]) {
        this.records.records[this.cacheId][this.currentTimeStamp] = {
          cacheSize: 0,
          hits: 0,
          falsyHits: 0,
          emptyHits: 0,
          misses: 0,
          expirations: 0,
          evictions: 0,
          sets: 0,
          invalidateOne: 0,
          invalidateAll: 0
        };
      }
      return this.records.records[this.cacheId][this.currentTimeStamp];
    }
    hoursPassed() {
      return (Date.now() - this.collectionStart) / 1000 / 60 / 60;
    }
    addHit() {
      this.archiveIfNeeded();
      this.currentRecord.hits++;
    }
    addFalsyHit() {
      this.archiveIfNeeded();
      this.currentRecord.falsyHits++;
    }
    addEmptyHit() {
      this.archiveIfNeeded();
      this.currentRecord.emptyHits++;
    }
    addMiss() {
      this.archiveIfNeeded();
      this.currentRecord.misses++;
    }
    addEviction() {
      this.archiveIfNeeded();
      this.currentRecord.evictions++;
    }
    setCacheSize(currentSize) {
      this.archiveIfNeeded();
      this.currentRecord.cacheSize = currentSize;
    }
    addExpiration() {
      this.archiveIfNeeded();
      this.currentRecord.expirations++;
    }
    addSet() {
      this.archiveIfNeeded();
      this.currentRecord.sets++;
    }
    addInvalidateOne() {
      this.archiveIfNeeded();
      this.currentRecord.invalidateOne++;
    }
    addInvalidateAll() {
      this.archiveIfNeeded();
      this.currentRecord.invalidateAll++;
    }
    getStatistics() {
      return this.records.getStatistics();
    }
    archiveIfNeeded() {
      if (this.hoursPassed() >= this.statisticTtlInHours) {
        this.collectionStart = new Date;
        this.currentTimeStamp = getTimestamp(this.collectionStart);
        this.records.initForCache(this.cacheId, this.currentTimeStamp);
      }
    }
  }

  class LruObjectHitStatistics extends LruObject {
    constructor(max, ttlInMsecs, cacheId, globalStatisticsRecord, statisticTtlInHours) {
      super(max || 1000, ttlInMsecs || 0);
      if (!cacheId) {
        throw new Error("Cache id is mandatory");
      }
      this.hitStatistics = new HitStatistics(cacheId, statisticTtlInHours !== undefined ? statisticTtlInHours : 24, globalStatisticsRecord);
    }
    getStatistics() {
      return this.hitStatistics.getStatistics();
    }
    set(key, value) {
      super.set(key, value);
      this.hitStatistics.addSet();
      this.hitStatistics.setCacheSize(this.size);
    }
    evict() {
      super.evict();
      this.hitStatistics.addEviction();
      this.hitStatistics.setCacheSize(this.size);
    }
    delete(key, isExpiration = false) {
      super.delete(key);
      if (!isExpiration) {
        this.hitStatistics.addInvalidateOne();
      }
      this.hitStatistics.setCacheSize(this.size);
    }
    clear() {
      super.clear();
      this.hitStatistics.addInvalidateAll();
      this.hitStatistics.setCacheSize(this.size);
    }
    get(key) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        const item = this.items[key];
        if (this.ttl > 0 && item.expiry <= Date.now()) {
          this.delete(key, true);
          this.hitStatistics.addExpiration();
          return;
        }
        this.bumpLru(item);
        if (!item.value) {
          this.hitStatistics.addFalsyHit();
        }
        if (item.value === undefined || item.value === null || item.value === "") {
          this.hitStatistics.addEmptyHit();
        }
        this.hitStatistics.addHit();
        return item.value;
      }
      this.hitStatistics.addMiss();
    }
  }

  class FifoObject {
    constructor(max = 1000, ttlInMsecs = 0) {
      if (isNaN(max) || max < 0) {
        throw new Error("Invalid max value");
      }
      if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
        throw new Error("Invalid ttl value");
      }
      this.first = null;
      this.items = Object.create(null);
      this.last = null;
      this.size = 0;
      this.max = max;
      this.ttl = ttlInMsecs;
    }
    clear() {
      this.items = Object.create(null);
      this.first = null;
      this.last = null;
      this.size = 0;
    }
    delete(key) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        const deletedItem = this.items[key];
        delete this.items[key];
        this.size--;
        if (deletedItem.prev !== null) {
          deletedItem.prev.next = deletedItem.next;
        }
        if (deletedItem.next !== null) {
          deletedItem.next.prev = deletedItem.prev;
        }
        if (this.first === deletedItem) {
          this.first = deletedItem.next;
        }
        if (this.last === deletedItem) {
          this.last = deletedItem.prev;
        }
      }
    }
    deleteMany(keys) {
      for (var i = 0;i < keys.length; i++) {
        this.delete(keys[i]);
      }
    }
    evict() {
      if (this.size > 0) {
        const item = this.first;
        delete this.items[item.key];
        if (--this.size === 0) {
          this.first = null;
          this.last = null;
        } else {
          this.first = item.next;
          this.first.prev = null;
        }
      }
    }
    expiresAt(key) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        return this.items[key].expiry;
      }
    }
    get(key) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        const item = this.items[key];
        if (this.ttl > 0 && item.expiry <= Date.now()) {
          this.delete(key);
          return;
        }
        return item.value;
      }
    }
    getMany(keys) {
      const result = [];
      for (var i = 0;i < keys.length; i++) {
        result.push(this.get(keys[i]));
      }
      return result;
    }
    keys() {
      return Object.keys(this.items);
    }
    set(key, value) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        const item2 = this.items[key];
        item2.value = value;
        item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
        return;
      }
      if (this.max > 0 && this.size === this.max) {
        this.evict();
      }
      const item = {
        expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
        key,
        prev: this.last,
        next: null,
        value
      };
      this.items[key] = item;
      if (++this.size === 1) {
        this.first = item;
      } else {
        this.last.next = item;
      }
      this.last = item;
    }
  }
  exports.Fifo = FifoObject;
  exports.FifoMap = FifoMap;
  exports.FifoObject = FifoObject;
  exports.HitStatisticsRecord = HitStatisticsRecord;
  exports.Lru = LruObject;
  exports.LruHitStatistics = LruObjectHitStatistics;
  exports.LruMap = LruMap;
  exports.LruObject = LruObject;
  exports.LruObjectHitStatistics = LruObjectHitStatistics;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fastify@4.26.0/node_modules/fast-content-type-parse/index.js
var require_fast_content_type_parse = __commonJS((exports, module) => {
  var parse = function(header) {
    if (typeof header !== "string") {
      throw new TypeError("argument header is required and must be a string");
    }
    let index2 = header.indexOf(";");
    const type = index2 !== -1 ? header.slice(0, index2).trim() : header.trim();
    if (mediaTypeRE.test(type) === false) {
      throw new TypeError("invalid media type");
    }
    const result = {
      type: type.toLowerCase(),
      parameters: new NullObject
    };
    if (index2 === -1) {
      return result;
    }
    let key;
    let match;
    let value;
    paramRE.lastIndex = index2;
    while (match = paramRE.exec(header)) {
      if (match.index !== index2) {
        throw new TypeError("invalid parameter format");
      }
      index2 += match[0].length;
      key = match[1].toLowerCase();
      value = match[2];
      if (value[0] === '"') {
        value = value.slice(1, value.length - 1);
        quotedPairRE.test(value) && (value = value.replace(quotedPairRE, "$1"));
      }
      result.parameters[key] = value;
    }
    if (index2 !== header.length) {
      throw new TypeError("invalid parameter format");
    }
    return result;
  };
  var safeParse = function(header) {
    if (typeof header !== "string") {
      return defaultContentType;
    }
    let index2 = header.indexOf(";");
    const type = index2 !== -1 ? header.slice(0, index2).trim() : header.trim();
    if (mediaTypeRE.test(type) === false) {
      return defaultContentType;
    }
    const result = {
      type: type.toLowerCase(),
      parameters: new NullObject
    };
    if (index2 === -1) {
      return result;
    }
    let key;
    let match;
    let value;
    paramRE.lastIndex = index2;
    while (match = paramRE.exec(header)) {
      if (match.index !== index2) {
        return defaultContentType;
      }
      index2 += match[0].length;
      key = match[1].toLowerCase();
      value = match[2];
      if (value[0] === '"') {
        value = value.slice(1, value.length - 1);
        quotedPairRE.test(value) && (value = value.replace(quotedPairRE, "$1"));
      }
      result.parameters[key] = value;
    }
    if (index2 !== header.length) {
      return defaultContentType;
    }
    return result;
  };
  var NullObject = function NullObject() {
  };
  NullObject.prototype = Object.create(null);
  var paramRE = /; *([!#$%&'*+.^\w`|~-]+)=("(?:[\v\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\v\u0020-\u00ff])*"|[!#$%&'*+.^\w`|~-]+) */gu;
  var quotedPairRE = /\\([\v\u0020-\u00ff])/gu;
  var mediaTypeRE = /^[!#$%&'*+.^\w|~-]+\/[!#$%&'*+.^\w|~-]+$/u;
  var defaultContentType = { type: "", parameters: new NullObject };
  Object.freeze(defaultContentType.parameters);
  Object.freeze(defaultContentType);
  exports.default = { parse, safeParse };
  exports.parse = parse;
  exports.safeParse = safeParse;
  exports.defaultContentType = defaultContentType;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fastify@4.26.0/node_modules/secure-json-parse/index.js
var require_secure_json_parse = __commonJS((exports, module) => {
  var _parse = function(text, reviver, options) {
    if (options == null) {
      if (reviver !== null && typeof reviver === "object") {
        options = reviver;
        reviver = undefined;
      }
    }
    if (hasBuffer && Buffer.isBuffer(text)) {
      text = text.toString();
    }
    if (text && text.charCodeAt(0) === 65279) {
      text = text.slice(1);
    }
    const obj = JSON.parse(text, reviver);
    if (obj === null || typeof obj !== "object") {
      return obj;
    }
    const protoAction = options && options.protoAction || "error";
    const constructorAction = options && options.constructorAction || "error";
    if (protoAction === "ignore" && constructorAction === "ignore") {
      return obj;
    }
    if (protoAction !== "ignore" && constructorAction !== "ignore") {
      if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
        return obj;
      }
    } else if (protoAction !== "ignore" && constructorAction === "ignore") {
      if (suspectProtoRx.test(text) === false) {
        return obj;
      }
    } else {
      if (suspectConstructorRx.test(text) === false) {
        return obj;
      }
    }
    return filter(obj, { protoAction, constructorAction, safe: options && options.safe });
  };
  var filter = function(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
    let next = [obj];
    while (next.length) {
      const nodes = next;
      next = [];
      for (const node9 of nodes) {
        if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node9, "__proto__")) {
          if (safe === true) {
            return null;
          } else if (protoAction === "error") {
            throw new SyntaxError("Object contains forbidden prototype property");
          }
          delete node9.__proto__;
        }
        if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node9, "constructor") && Object.prototype.hasOwnProperty.call(node9.constructor, "prototype")) {
          if (safe === true) {
            return null;
          } else if (constructorAction === "error") {
            throw new SyntaxError("Object contains forbidden prototype property");
          }
          delete node9.constructor;
        }
        for (const key in node9) {
          const value = node9[key];
          if (value && typeof value === "object") {
            next.push(value);
          }
        }
      }
    }
    return obj;
  };
  var parse = function(text, reviver, options) {
    const stackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    try {
      return _parse(text, reviver, options);
    } finally {
      Error.stackTraceLimit = stackTraceLimit;
    }
  };
  var safeParse = function(text, reviver) {
    const stackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    try {
      return _parse(text, reviver, { safe: true });
    } catch (_e) {
      return null;
    } finally {
      Error.stackTraceLimit = stackTraceLimit;
    }
  };
  var hasBuffer = typeof Buffer !== "undefined";
  var suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
  var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
  module.exports = parse;
  module.exports.default = parse;
  module.exports.parse = parse;
  module.exports.safeParse = safeParse;
  module.exports.scan = filter;
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/contentTypeParser.js
var require_contentTypeParser = __commonJS((exports, module) => {
  var ContentTypeParser = function(bodyLimit, onProtoPoisoning, onConstructorPoisoning) {
    this[kDefaultJsonParse] = getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning);
    this.customParsers = new Map;
    this.customParsers.set("application/json", new Parser2(true, false, bodyLimit, this[kDefaultJsonParse]));
    this.customParsers.set("text/plain", new Parser2(true, false, bodyLimit, defaultPlainTextParser));
    this.parserList = [new ParserListItem("application/json"), new ParserListItem("text/plain")];
    this.parserRegExpList = [];
    this.cache = new Fifo(100);
  };
  var rawBody = function(request5, reply, options, parser2, done) {
    const asString = parser2.asString;
    const limit = options.limit === null ? parser2.bodyLimit : options.limit;
    const contentLength = request5.headers["content-length"] === undefined ? NaN : Number(request5.headers["content-length"]);
    if (contentLength > limit) {
      reply.header("connection", "close");
      reply.send(new FST_ERR_CTP_BODY_TOO_LARGE);
      return;
    }
    let receivedLength = 0;
    let body = asString === true ? "" : [];
    const payload = request5[kRequestPayloadStream] || request5.raw;
    if (asString === true) {
      payload.setEncoding("utf8");
    }
    payload.on("data", onData);
    payload.on("end", onEnd);
    payload.on("error", onEnd);
    payload.resume();
    function onData(chunk) {
      receivedLength += chunk.length;
      const { receivedEncodedLength = 0 } = payload;
      if (receivedLength > limit || receivedEncodedLength > limit) {
        payload.removeListener("data", onData);
        payload.removeListener("end", onEnd);
        payload.removeListener("error", onEnd);
        reply.send(new FST_ERR_CTP_BODY_TOO_LARGE);
        return;
      }
      if (asString === true) {
        body += chunk;
      } else {
        body.push(chunk);
      }
    }
    function onEnd(err) {
      payload.removeListener("data", onData);
      payload.removeListener("end", onEnd);
      payload.removeListener("error", onEnd);
      if (err !== undefined) {
        if (!(typeof err.statusCode === "number" && err.statusCode >= 400)) {
          err.statusCode = 400;
        }
        reply[kReplyIsError] = true;
        reply.code(err.statusCode).send(err);
        return;
      }
      if (asString === true) {
        receivedLength = Buffer.byteLength(body);
      }
      if (!Number.isNaN(contentLength) && (payload.receivedEncodedLength || receivedLength) !== contentLength) {
        reply.header("connection", "close");
        reply.send(new FST_ERR_CTP_INVALID_CONTENT_LENGTH);
        return;
      }
      if (asString === false) {
        body = Buffer.concat(body);
      }
      const result = parser2.fn(request5, body, done);
      if (result && typeof result.then === "function") {
        result.then((body2) => done(null, body2), done);
      }
    }
  };
  var getDefaultJsonParser = function(onProtoPoisoning, onConstructorPoisoning) {
    return defaultJsonParser;
    function defaultJsonParser(req, body, done) {
      if (body === "" || body == null || Buffer.isBuffer(body) && body.length === 0) {
        return done(new FST_ERR_CTP_EMPTY_JSON_BODY, undefined);
      }
      let json;
      try {
        json = secureJson.parse(body, { protoAction: onProtoPoisoning, constructorAction: onConstructorPoisoning });
      } catch (err) {
        err.statusCode = 400;
        return done(err, undefined);
      }
      done(null, json);
    }
  };
  var defaultPlainTextParser = function(req, body, done) {
    done(null, body);
  };
  var Parser2 = function(asString, asBuffer, bodyLimit, fn) {
    this.asString = asString;
    this.asBuffer = asBuffer;
    this.bodyLimit = bodyLimit;
    this.fn = fn;
  };
  var buildContentTypeParser = function(c) {
    const contentTypeParser = new ContentTypeParser;
    contentTypeParser[kDefaultJsonParse] = c[kDefaultJsonParse];
    contentTypeParser.customParsers = new Map(c.customParsers.entries());
    contentTypeParser.parserList = c.parserList.slice();
    contentTypeParser.parserRegExpList = c.parserRegExpList.slice();
    return contentTypeParser;
  };
  var addContentTypeParser = function(contentType, opts, parser2) {
    if (this[kState].started) {
      throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED("addContentTypeParser");
    }
    if (typeof opts === "function") {
      parser2 = opts;
      opts = {};
    }
    if (!opts)
      opts = {};
    if (!opts.bodyLimit)
      opts.bodyLimit = this[kBodyLimit];
    if (Array.isArray(contentType)) {
      contentType.forEach((type) => this[kContentTypeParser].add(type, opts, parser2));
    } else {
      this[kContentTypeParser].add(contentType, opts, parser2);
    }
    return this;
  };
  var hasContentTypeParser = function(contentType) {
    return this[kContentTypeParser].hasParser(contentType);
  };
  var removeContentTypeParser = function(contentType) {
    if (this[kState].started) {
      throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED("removeContentTypeParser");
    }
    if (Array.isArray(contentType)) {
      for (const type of contentType) {
        this[kContentTypeParser].remove(type);
      }
    } else {
      this[kContentTypeParser].remove(contentType);
    }
  };
  var removeAllContentTypeParsers = function() {
    if (this[kState].started) {
      throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED("removeAllContentTypeParsers");
    }
    this[kContentTypeParser].removeAll();
  };
  var compareContentType = function(contentType, parserListItem) {
    if (parserListItem.isEssence) {
      return contentType.type.indexOf(parserListItem) !== -1;
    } else {
      if (contentType.type.indexOf(parserListItem.type) === -1)
        return false;
      for (const key of parserListItem.parameterKeys) {
        if (!(key in contentType.parameters))
          return false;
        if (contentType.parameters[key] !== parserListItem.parameters[key])
          return false;
      }
      return true;
    }
  };
  var compareRegExpContentType = function(contentType, essenceMIMEType, regexp) {
    if (regexp.isEssence) {
      return regexp.test(essenceMIMEType);
    } else {
      return regexp.test(contentType);
    }
  };
  var ParserListItem = function(contentType) {
    this.name = contentType;
    const parsed = safeParseContentType(contentType);
    this.isEssence = contentType.indexOf(";") === -1;
    if (this.isEssence === false && parsed.type === "") {
      const tmp = contentType.split(";", 1)[0];
      this.type = tmp === "" ? contentType : tmp;
    } else {
      this.type = parsed.type;
    }
    this.parameters = parsed.parameters;
    this.parameterKeys = Object.keys(parsed.parameters);
  };
  var { AsyncResource } = __require("node:async_hooks");
  var { Fifo } = require_toad_cache();
  var { safeParse: safeParseContentType, defaultContentType } = require_fast_content_type_parse();
  var secureJson = require_secure_json_parse();
  var {
    kDefaultJsonParse,
    kContentTypeParser,
    kBodyLimit,
    kRequestPayloadStream,
    kState,
    kTestInternals,
    kReplyIsError,
    kRouteContext
  } = require_symbols3();
  var {
    FST_ERR_CTP_INVALID_TYPE,
    FST_ERR_CTP_EMPTY_TYPE,
    FST_ERR_CTP_ALREADY_PRESENT,
    FST_ERR_CTP_INVALID_HANDLER,
    FST_ERR_CTP_INVALID_PARSE_TYPE,
    FST_ERR_CTP_BODY_TOO_LARGE,
    FST_ERR_CTP_INVALID_MEDIA_TYPE,
    FST_ERR_CTP_INVALID_CONTENT_LENGTH,
    FST_ERR_CTP_EMPTY_JSON_BODY,
    FST_ERR_CTP_INSTANCE_ALREADY_STARTED
  } = require_errors4();
  ContentTypeParser.prototype.add = function(contentType, opts, parserFn) {
    const contentTypeIsString = typeof contentType === "string";
    if (!contentTypeIsString && !(contentType instanceof RegExp))
      throw new FST_ERR_CTP_INVALID_TYPE;
    if (contentTypeIsString && contentType.length === 0)
      throw new FST_ERR_CTP_EMPTY_TYPE;
    if (typeof parserFn !== "function")
      throw new FST_ERR_CTP_INVALID_HANDLER;
    if (this.existingParser(contentType)) {
      throw new FST_ERR_CTP_ALREADY_PRESENT(contentType);
    }
    if (opts.parseAs !== undefined) {
      if (opts.parseAs !== "string" && opts.parseAs !== "buffer") {
        throw new FST_ERR_CTP_INVALID_PARSE_TYPE(opts.parseAs);
      }
    }
    const parser2 = new Parser2(opts.parseAs === "string", opts.parseAs === "buffer", opts.bodyLimit, parserFn);
    if (contentTypeIsString && contentType === "*") {
      this.customParsers.set("", parser2);
    } else {
      if (contentTypeIsString) {
        this.parserList.unshift(new ParserListItem(contentType));
      } else {
        contentType.isEssence = contentType.source.indexOf(";") === -1;
        this.parserRegExpList.unshift(contentType);
      }
      this.customParsers.set(contentType.toString(), parser2);
    }
  };
  ContentTypeParser.prototype.hasParser = function(contentType) {
    return this.customParsers.has(typeof contentType === "string" ? contentType : contentType.toString());
  };
  ContentTypeParser.prototype.existingParser = function(contentType) {
    if (contentType === "application/json" && this.customParsers.has(contentType)) {
      return this.customParsers.get(contentType).fn !== this[kDefaultJsonParse];
    }
    if (contentType === "text/plain" && this.customParsers.has(contentType)) {
      return this.customParsers.get(contentType).fn !== defaultPlainTextParser;
    }
    return this.hasParser(contentType);
  };
  ContentTypeParser.prototype.getParser = function(contentType) {
    if (this.hasParser(contentType)) {
      return this.customParsers.get(contentType);
    }
    const parser2 = this.cache.get(contentType);
    if (parser2 !== undefined)
      return parser2;
    const parsed = safeParseContentType(contentType);
    if (parsed === defaultContentType) {
      return this.customParsers.get("");
    }
    for (var i = 0;i !== this.parserList.length; ++i) {
      const parserListItem = this.parserList[i];
      if (compareContentType(parsed, parserListItem)) {
        const parser3 = this.customParsers.get(parserListItem.name);
        this.cache.set(contentType, parser3);
        return parser3;
      }
    }
    for (var j = 0;j !== this.parserRegExpList.length; ++j) {
      const parserRegExp = this.parserRegExpList[j];
      if (compareRegExpContentType(contentType, parsed.type, parserRegExp)) {
        const parser3 = this.customParsers.get(parserRegExp.toString());
        this.cache.set(contentType, parser3);
        return parser3;
      }
    }
    return this.customParsers.get("");
  };
  ContentTypeParser.prototype.removeAll = function() {
    this.customParsers = new Map;
    this.parserRegExpList = [];
    this.parserList = [];
    this.cache = new Fifo(100);
  };
  ContentTypeParser.prototype.remove = function(contentType) {
    if (!(typeof contentType === "string" || contentType instanceof RegExp))
      throw new FST_ERR_CTP_INVALID_TYPE;
    const removed = this.customParsers.delete(contentType.toString());
    const parsers = typeof contentType === "string" ? this.parserList : this.parserRegExpList;
    const idx = parsers.findIndex((ct) => ct.toString() === contentType.toString());
    if (idx > -1) {
      parsers.splice(idx, 1);
    }
    return removed || idx > -1;
  };
  ContentTypeParser.prototype.run = function(contentType, handler, request5, reply) {
    const parser2 = this.getParser(contentType);
    if (parser2 === undefined) {
      if (request5.is404) {
        handler(request5, reply);
      } else {
        reply.send(new FST_ERR_CTP_INVALID_MEDIA_TYPE(contentType || undefined));
      }
      return;
    }
    const resource = new AsyncResource("content-type-parser:run", request5);
    if (parser2.asString === true || parser2.asBuffer === true) {
      rawBody(request5, reply, reply[kRouteContext]._parserOptions, parser2, done);
    } else {
      const result = parser2.fn(request5, request5[kRequestPayloadStream], done);
      if (result && typeof result.then === "function") {
        result.then((body) => done(null, body), done);
      }
    }
    function done(error, body) {
      resource.runInAsyncScope(() => {
        resource.emitDestroy();
        if (error) {
          reply[kReplyIsError] = true;
          reply.send(error);
        } else {
          request5.body = body;
          handler(request5, reply);
        }
      });
    }
  };
  ParserListItem.prototype.toString = function() {
    return this.name;
  };
  module.exports = ContentTypeParser;
  module.exports.helpers = {
    buildContentTypeParser,
    addContentTypeParser,
    hasContentTypeParser,
    removeContentTypeParser,
    removeAllContentTypeParsers
  };
  module.exports.defaultParsers = {
    getDefaultJsonParser,
    defaultTextParser: defaultPlainTextParser
  };
  module.exports[kTestInternals] = { rawBody };
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fast-json-stringify@5.12.0/node_modules/json-schema-ref-resolver/index.js
var require_json_schema_ref_resolver = __commonJS((exports, module) => {
  var getDataByJSONPointer = function(data3, jsonPointer) {
    const parts = jsonPointer.split("/");
    let current = data3;
    for (const part of parts) {
      if (part === "" || part === "#")
        continue;
      if (typeof current !== "object" || current === null) {
        return null;
      }
      current = current[part];
    }
    return current ?? null;
  };
  var deepEqual = require_fast_deep_equal();
  var jsonSchemaRefSymbol = Symbol.for("json-schema-ref");

  class RefResolver {
    #schemas;
    #derefSchemas;
    #insertRefSymbol;
    #allowEqualDuplicates;
    #cloneSchemaWithoutRefs;
    constructor(opts = {}) {
      this.#schemas = {};
      this.#derefSchemas = {};
      this.#insertRefSymbol = opts.insertRefSymbol ?? false;
      this.#allowEqualDuplicates = opts.allowEqualDuplicates ?? true;
      this.#cloneSchemaWithoutRefs = opts.cloneSchemaWithoutRefs ?? false;
    }
    addSchema(schema, schemaId) {
      if (schema.$id !== undefined && schema.$id.charAt(0) !== "#") {
        schemaId = schema.$id;
      } else {
        this.#insertSchemaBySchemaId(schema, schemaId);
      }
      this.#addSchema(schema, schemaId);
    }
    getSchema(schemaId, jsonPointer = "#") {
      const schema = this.#schemas[schemaId];
      if (schema === undefined) {
        throw new Error(`Cannot resolve ref "${schemaId}${jsonPointer}". Schema with id "${schemaId}" is not found.`);
      }
      if (schema.anchors[jsonPointer] !== undefined) {
        return schema.anchors[jsonPointer];
      }
      return getDataByJSONPointer(schema.schema, jsonPointer);
    }
    hasSchema(schemaId) {
      return this.#schemas[schemaId] !== undefined;
    }
    getSchemaRefs(schemaId) {
      const schema = this.#schemas[schemaId];
      if (schema === undefined) {
        throw new Error(`Schema with id "${schemaId}" is not found.`);
      }
      return schema.refs;
    }
    getSchemaDependencies(schemaId, dependencies = {}) {
      const schema = this.#schemas[schemaId];
      for (const ref of schema.refs) {
        const dependencySchemaId = ref.schemaId;
        if (dependencies[dependencySchemaId] !== undefined)
          continue;
        dependencies[dependencySchemaId] = this.getSchema(dependencySchemaId);
        this.getSchemaDependencies(dependencySchemaId, dependencies);
      }
      return dependencies;
    }
    derefSchema(schemaId) {
      if (this.#derefSchemas[schemaId] !== undefined)
        return;
      const schema = this.#schemas[schemaId];
      if (schema === undefined) {
        throw new Error(`Schema with id "${schemaId}" is not found.`);
      }
      if (!this.#cloneSchemaWithoutRefs && schema.refs.length === 0) {
        this.#derefSchemas[schemaId] = {
          schema: schema.schema,
          anchors: schema.anchors
        };
      }
      const refs = [];
      this.#addDerefSchema(schema.schema, schemaId, refs);
      const dependencies = this.getSchemaDependencies(schemaId);
      for (const schemaId2 in dependencies) {
        const schema2 = dependencies[schemaId2];
        this.#addDerefSchema(schema2, schemaId2, refs);
      }
      for (const ref of refs) {
        const {
          refSchemaId,
          refJsonPointer
        } = this.#parseSchemaRef(ref.ref, ref.sourceSchemaId);
        const targetSchema = this.getDerefSchema(refSchemaId, refJsonPointer);
        if (targetSchema === null) {
          throw new Error(`Cannot resolve ref "${ref.ref}". Ref "${refJsonPointer}" is not found in schema "${refSchemaId}".`);
        }
        ref.targetSchema = targetSchema;
        ref.targetSchemaId = refSchemaId;
      }
      for (const ref of refs) {
        this.#resolveRef(ref, refs);
      }
    }
    getDerefSchema(schemaId, jsonPointer = "#") {
      let derefSchema = this.#derefSchemas[schemaId];
      if (derefSchema === undefined) {
        this.derefSchema(schemaId);
        derefSchema = this.#derefSchemas[schemaId];
      }
      if (derefSchema.anchors[jsonPointer] !== undefined) {
        return derefSchema.anchors[jsonPointer];
      }
      return getDataByJSONPointer(derefSchema.schema, jsonPointer);
    }
    #parseSchemaRef(ref, schemaId) {
      const sharpIndex = ref.indexOf("#");
      if (sharpIndex === -1) {
        return { refSchemaId: ref, refJsonPointer: "#" };
      }
      if (sharpIndex === 0) {
        return { refSchemaId: schemaId, refJsonPointer: ref };
      }
      return {
        refSchemaId: ref.slice(0, sharpIndex),
        refJsonPointer: ref.slice(sharpIndex)
      };
    }
    #addSchema(schema, rootSchemaId) {
      const schemaId = schema.$id;
      if (schemaId !== undefined && typeof schemaId === "string") {
        if (schemaId.charAt(0) === "#") {
          this.#insertSchemaByAnchor(schema, rootSchemaId, schemaId);
        } else {
          this.#insertSchemaBySchemaId(schema, schemaId);
          rootSchemaId = schemaId;
        }
      }
      const ref = schema.$ref;
      if (ref !== undefined && typeof ref === "string") {
        const { refSchemaId, refJsonPointer } = this.#parseSchemaRef(ref, rootSchemaId);
        this.#schemas[rootSchemaId].refs.push({
          schemaId: refSchemaId,
          jsonPointer: refJsonPointer
        });
      }
      for (const key in schema) {
        if (typeof schema[key] === "object" && schema[key] !== null) {
          this.#addSchema(schema[key], rootSchemaId);
        }
      }
    }
    #addDerefSchema(schema, rootSchemaId, refs = []) {
      const derefSchema = Array.isArray(schema) ? [...schema] : { ...schema };
      const schemaId = derefSchema.$id;
      if (schemaId !== undefined && typeof schemaId === "string") {
        if (schemaId.charAt(0) === "#") {
          this.#insertDerefSchemaByAnchor(derefSchema, rootSchemaId, schemaId);
        } else {
          this.#insertDerefSchemaBySchemaId(derefSchema, schemaId);
          rootSchemaId = schemaId;
        }
      }
      if (derefSchema.$ref !== undefined) {
        refs.push({
          ref: derefSchema.$ref,
          sourceSchemaId: rootSchemaId,
          sourceSchema: derefSchema
        });
      }
      for (const key in derefSchema) {
        const value = derefSchema[key];
        if (typeof value === "object" && value !== null) {
          derefSchema[key] = this.#addDerefSchema(value, rootSchemaId, refs);
        }
      }
      return derefSchema;
    }
    #resolveRef(ref, refs) {
      const { sourceSchema, targetSchema } = ref;
      if (!sourceSchema.$ref)
        return;
      if (this.#insertRefSymbol) {
        sourceSchema[jsonSchemaRefSymbol] = sourceSchema.$ref;
      }
      delete sourceSchema.$ref;
      if (targetSchema.$ref) {
        const targetSchemaRef = refs.find((ref2) => ref2.sourceSchema === targetSchema);
        this.#resolveRef(targetSchemaRef, refs);
      }
      for (const key in targetSchema) {
        if (key === "$id")
          continue;
        if (sourceSchema[key] !== undefined) {
          if (deepEqual(sourceSchema[key], targetSchema[key]))
            continue;
          throw new Error(`Cannot resolve ref "${ref.ref}". Property "${key}" is already exist in schema "${ref.sourceSchemaId}".`);
        }
        sourceSchema[key] = targetSchema[key];
      }
      ref.isResolved = true;
    }
    #insertSchemaBySchemaId(schema, schemaId) {
      const foundSchema = this.#schemas[schemaId];
      if (foundSchema !== undefined) {
        if (this.#allowEqualDuplicates && deepEqual(schema, foundSchema.schema))
          return;
        throw new Error(`There is already another schema with id "${schemaId}".`);
      }
      this.#schemas[schemaId] = { schema, anchors: {}, refs: [] };
    }
    #insertSchemaByAnchor(schema, schemaId, anchor) {
      const { anchors } = this.#schemas[schemaId];
      if (anchors[anchor] !== undefined) {
        throw new Error(`There is already another anchor "${anchor}" in a schema "${schemaId}".`);
      }
      anchors[anchor] = schema;
    }
    #insertDerefSchemaBySchemaId(schema, schemaId) {
      const foundSchema = this.#derefSchemas[schemaId];
      if (foundSchema !== undefined)
        return;
      this.#derefSchemas[schemaId] = { schema, anchors: {} };
    }
    #insertDerefSchemaByAnchor(schema, schemaId, anchor) {
      const { anchors } = this.#derefSchemas[schemaId];
      anchors[anchor] = schema;
    }
  }
  module.exports = { RefResolver };
});

// ../node_modules/.pnpm/fast-json-stringify@5.12.0/node_modules/fast-json-stringify/lib/location.js
var require_location = __commonJS((exports, module) => {
  class Location {
    constructor(schema, schemaId, jsonPointer = "#") {
      this.schema = schema;
      this.schemaId = schemaId;
      this.jsonPointer = jsonPointer;
    }
    getPropertyLocation(propertyName) {
      const propertyLocation = new Location(this.schema[propertyName], this.schemaId, this.jsonPointer + "/" + propertyName);
      return propertyLocation;
    }
    getSchemaRef() {
      return this.schemaId + this.jsonPointer;
    }
  }
  module.exports = Location;
});

// ../node_modules/.pnpm/fast-json-stringify@5.12.0/node_modules/fast-json-stringify/lib/schema-validator.js
var require_schema_validator = __commonJS((exports, module) => {
  var validate11 = function(data3, { instancePath = "", parentData, parentDataProperty, rootData = data3 } = {}) {
    let vErrors = null;
    let errors4 = 0;
    const _errs1 = errors4;
    if (!(typeof data3 == "number" && (!(data3 % 1) && !isNaN(data3)) && isFinite(data3))) {
      validate11.errors = [{ instancePath, schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
      return false;
    }
    if (errors4 === _errs1) {
      if (typeof data3 == "number" && isFinite(data3)) {
        if (data3 < 0 || isNaN(data3)) {
          validate11.errors = [{ instancePath, schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
          return false;
        }
      }
    }
    validate11.errors = vErrors;
    return errors4 === 0;
  };
  var validate13 = function(data3, { instancePath = "", parentData, parentDataProperty, rootData = data3 } = {}) {
    let vErrors = null;
    let errors4 = 0;
    if (errors4 === 0) {
      if (Array.isArray(data3)) {
        if (data3.length < 1) {
          validate13.errors = [{ instancePath, schemaPath: "#/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
          return false;
        } else {
          var valid0 = true;
          const len0 = data3.length;
          for (let i0 = 0;i0 < len0; i0++) {
            const _errs1 = errors4;
            if (!root1.validate(data3[i0], { instancePath: instancePath + "/" + i0, parentData: data3, parentDataProperty: i0, rootData })) {
              vErrors = vErrors === null ? root1.validate.errors : vErrors.concat(root1.validate.errors);
              errors4 = vErrors.length;
            }
            var valid0 = _errs1 === errors4;
            if (!valid0) {
              break;
            }
          }
        }
      } else {
        validate13.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
        return false;
      }
    }
    validate13.errors = vErrors;
    return errors4 === 0;
  };
  var validate10 = function(data3, { instancePath = "", parentData, parentDataProperty, rootData = data3 } = {}) {
    let vErrors = null;
    let errors4 = 0;
    if (!(data3 && typeof data3 == "object" && !Array.isArray(data3)) && typeof data3 !== "boolean") {
      validate10.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: schema11.type }, message: "must be object,boolean" }];
      return false;
    }
    if (errors4 === 0) {
      if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
        if (data3.$id !== undefined) {
          let data0 = data3.$id;
          const _errs1 = errors4;
          if (errors4 === _errs1) {
            if (errors4 === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0.test(data0)) {
                  validate10.errors = [{ instancePath: instancePath + "/$id", schemaPath: "#/properties/%24id/format", keyword: "format", params: { format: "uri-reference" }, message: "must match format \"uri-reference\"" }];
                  return false;
                }
              } else {
                validate10.errors = [{ instancePath: instancePath + "/$id", schemaPath: "#/properties/%24id/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors4;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data3.$schema !== undefined) {
            let data1 = data3.$schema;
            const _errs3 = errors4;
            if (errors4 === _errs3) {
              if (errors4 === _errs3) {
                if (typeof data1 === "string") {
                  if (!formats2(data1)) {
                    validate10.errors = [{ instancePath: instancePath + "/$schema", schemaPath: "#/properties/%24schema/format", keyword: "format", params: { format: "uri" }, message: "must match format \"uri\"" }];
                    return false;
                  }
                } else {
                  validate10.errors = [{ instancePath: instancePath + "/$schema", schemaPath: "#/properties/%24schema/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                  return false;
                }
              }
            }
            var valid0 = _errs3 === errors4;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data3.$ref !== undefined) {
              let data22 = data3.$ref;
              const _errs5 = errors4;
              if (errors4 === _errs5) {
                if (errors4 === _errs5) {
                  if (typeof data22 === "string") {
                    if (!formats0.test(data22)) {
                      validate10.errors = [{ instancePath: instancePath + "/$ref", schemaPath: "#/properties/%24ref/format", keyword: "format", params: { format: "uri-reference" }, message: "must match format \"uri-reference\"" }];
                      return false;
                    }
                  } else {
                    validate10.errors = [{ instancePath: instancePath + "/$ref", schemaPath: "#/properties/%24ref/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                    return false;
                  }
                }
              }
              var valid0 = _errs5 === errors4;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data3.$comment !== undefined) {
                const _errs7 = errors4;
                if (typeof data3.$comment !== "string") {
                  validate10.errors = [{ instancePath: instancePath + "/$comment", schemaPath: "#/properties/%24comment/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                  return false;
                }
                var valid0 = _errs7 === errors4;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data3.title !== undefined) {
                  const _errs9 = errors4;
                  if (typeof data3.title !== "string") {
                    validate10.errors = [{ instancePath: instancePath + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                    return false;
                  }
                  var valid0 = _errs9 === errors4;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data3.description !== undefined) {
                    const _errs11 = errors4;
                    if (typeof data3.description !== "string") {
                      validate10.errors = [{ instancePath: instancePath + "/description", schemaPath: "#/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                      return false;
                    }
                    var valid0 = _errs11 === errors4;
                  } else {
                    var valid0 = true;
                  }
                  if (valid0) {
                    if (data3.readOnly !== undefined) {
                      const _errs13 = errors4;
                      if (typeof data3.readOnly !== "boolean") {
                        validate10.errors = [{ instancePath: instancePath + "/readOnly", schemaPath: "#/properties/readOnly/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                        return false;
                      }
                      var valid0 = _errs13 === errors4;
                    } else {
                      var valid0 = true;
                    }
                    if (valid0) {
                      if (data3.examples !== undefined) {
                        const _errs15 = errors4;
                        if (errors4 === _errs15) {
                          if (!Array.isArray(data3.examples)) {
                            validate10.errors = [{ instancePath: instancePath + "/examples", schemaPath: "#/properties/examples/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                            return false;
                          }
                        }
                        var valid0 = _errs15 === errors4;
                      } else {
                        var valid0 = true;
                      }
                      if (valid0) {
                        if (data3.multipleOf !== undefined) {
                          let data8 = data3.multipleOf;
                          const _errs17 = errors4;
                          if (errors4 === _errs17) {
                            if (typeof data8 == "number" && isFinite(data8)) {
                              if (data8 <= 0 || isNaN(data8)) {
                                validate10.errors = [{ instancePath: instancePath + "/multipleOf", schemaPath: "#/properties/multipleOf/exclusiveMinimum", keyword: "exclusiveMinimum", params: { comparison: ">", limit: 0 }, message: "must be > 0" }];
                                return false;
                              }
                            } else {
                              validate10.errors = [{ instancePath: instancePath + "/multipleOf", schemaPath: "#/properties/multipleOf/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                              return false;
                            }
                          }
                          var valid0 = _errs17 === errors4;
                        } else {
                          var valid0 = true;
                        }
                        if (valid0) {
                          if (data3.maximum !== undefined) {
                            let data9 = data3.maximum;
                            const _errs19 = errors4;
                            if (!(typeof data9 == "number" && isFinite(data9))) {
                              validate10.errors = [{ instancePath: instancePath + "/maximum", schemaPath: "#/properties/maximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                              return false;
                            }
                            var valid0 = _errs19 === errors4;
                          } else {
                            var valid0 = true;
                          }
                          if (valid0) {
                            if (data3.exclusiveMaximum !== undefined) {
                              let data10 = data3.exclusiveMaximum;
                              const _errs21 = errors4;
                              if (!(typeof data10 == "number" && isFinite(data10))) {
                                validate10.errors = [{ instancePath: instancePath + "/exclusiveMaximum", schemaPath: "#/properties/exclusiveMaximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                return false;
                              }
                              var valid0 = _errs21 === errors4;
                            } else {
                              var valid0 = true;
                            }
                            if (valid0) {
                              if (data3.minimum !== undefined) {
                                let data11 = data3.minimum;
                                const _errs23 = errors4;
                                if (!(typeof data11 == "number" && isFinite(data11))) {
                                  validate10.errors = [{ instancePath: instancePath + "/minimum", schemaPath: "#/properties/minimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                  return false;
                                }
                                var valid0 = _errs23 === errors4;
                              } else {
                                var valid0 = true;
                              }
                              if (valid0) {
                                if (data3.exclusiveMinimum !== undefined) {
                                  let data12 = data3.exclusiveMinimum;
                                  const _errs25 = errors4;
                                  if (!(typeof data12 == "number" && isFinite(data12))) {
                                    validate10.errors = [{ instancePath: instancePath + "/exclusiveMinimum", schemaPath: "#/properties/exclusiveMinimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                    return false;
                                  }
                                  var valid0 = _errs25 === errors4;
                                } else {
                                  var valid0 = true;
                                }
                                if (valid0) {
                                  if (data3.maxLength !== undefined) {
                                    let data13 = data3.maxLength;
                                    const _errs27 = errors4;
                                    const _errs28 = errors4;
                                    if (!(typeof data13 == "number" && (!(data13 % 1) && !isNaN(data13)) && isFinite(data13))) {
                                      validate10.errors = [{ instancePath: instancePath + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                      return false;
                                    }
                                    if (errors4 === _errs28) {
                                      if (typeof data13 == "number" && isFinite(data13)) {
                                        if (data13 < 0 || isNaN(data13)) {
                                          validate10.errors = [{ instancePath: instancePath + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                          return false;
                                        }
                                      }
                                    }
                                    var valid0 = _errs27 === errors4;
                                  } else {
                                    var valid0 = true;
                                  }
                                  if (valid0) {
                                    if (data3.minLength !== undefined) {
                                      const _errs30 = errors4;
                                      if (!validate11(data3.minLength, { instancePath: instancePath + "/minLength", parentData: data3, parentDataProperty: "minLength", rootData })) {
                                        vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                                        errors4 = vErrors.length;
                                      }
                                      var valid0 = _errs30 === errors4;
                                    } else {
                                      var valid0 = true;
                                    }
                                    if (valid0) {
                                      if (data3.pattern !== undefined) {
                                        let data15 = data3.pattern;
                                        const _errs31 = errors4;
                                        if (errors4 === _errs31) {
                                          if (errors4 === _errs31) {
                                            if (typeof data15 === "string") {
                                              if (!formats6(data15)) {
                                                validate10.errors = [{ instancePath: instancePath + "/pattern", schemaPath: "#/properties/pattern/format", keyword: "format", params: { format: "regex" }, message: "must match format \"regex\"" }];
                                                return false;
                                              }
                                            } else {
                                              validate10.errors = [{ instancePath: instancePath + "/pattern", schemaPath: "#/properties/pattern/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                              return false;
                                            }
                                          }
                                        }
                                        var valid0 = _errs31 === errors4;
                                      } else {
                                        var valid0 = true;
                                      }
                                      if (valid0) {
                                        if (data3.additionalItems !== undefined) {
                                          const _errs33 = errors4;
                                          if (!validate10(data3.additionalItems, { instancePath: instancePath + "/additionalItems", parentData: data3, parentDataProperty: "additionalItems", rootData })) {
                                            vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                            errors4 = vErrors.length;
                                          }
                                          var valid0 = _errs33 === errors4;
                                        } else {
                                          var valid0 = true;
                                        }
                                        if (valid0) {
                                          if (data3.items !== undefined) {
                                            let data17 = data3.items;
                                            const _errs34 = errors4;
                                            const _errs35 = errors4;
                                            let valid2 = false;
                                            const _errs36 = errors4;
                                            if (!validate10(data17, { instancePath: instancePath + "/items", parentData: data3, parentDataProperty: "items", rootData })) {
                                              vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                              errors4 = vErrors.length;
                                            }
                                            var _valid0 = _errs36 === errors4;
                                            valid2 = valid2 || _valid0;
                                            if (!valid2) {
                                              const _errs37 = errors4;
                                              if (!validate13(data17, { instancePath: instancePath + "/items", parentData: data3, parentDataProperty: "items", rootData })) {
                                                vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                errors4 = vErrors.length;
                                              }
                                              var _valid0 = _errs37 === errors4;
                                              valid2 = valid2 || _valid0;
                                            }
                                            if (!valid2) {
                                              const err0 = { instancePath: instancePath + "/items", schemaPath: "#/properties/items/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                              if (vErrors === null) {
                                                vErrors = [err0];
                                              } else {
                                                vErrors.push(err0);
                                              }
                                              errors4++;
                                              validate10.errors = vErrors;
                                              return false;
                                            } else {
                                              errors4 = _errs35;
                                              if (vErrors !== null) {
                                                if (_errs35) {
                                                  vErrors.length = _errs35;
                                                } else {
                                                  vErrors = null;
                                                }
                                              }
                                            }
                                            var valid0 = _errs34 === errors4;
                                          } else {
                                            var valid0 = true;
                                          }
                                          if (valid0) {
                                            if (data3.maxItems !== undefined) {
                                              let data18 = data3.maxItems;
                                              const _errs38 = errors4;
                                              const _errs39 = errors4;
                                              if (!(typeof data18 == "number" && (!(data18 % 1) && !isNaN(data18)) && isFinite(data18))) {
                                                validate10.errors = [{ instancePath: instancePath + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                return false;
                                              }
                                              if (errors4 === _errs39) {
                                                if (typeof data18 == "number" && isFinite(data18)) {
                                                  if (data18 < 0 || isNaN(data18)) {
                                                    validate10.errors = [{ instancePath: instancePath + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                                    return false;
                                                  }
                                                }
                                              }
                                              var valid0 = _errs38 === errors4;
                                            } else {
                                              var valid0 = true;
                                            }
                                            if (valid0) {
                                              if (data3.minItems !== undefined) {
                                                const _errs41 = errors4;
                                                if (!validate11(data3.minItems, { instancePath: instancePath + "/minItems", parentData: data3, parentDataProperty: "minItems", rootData })) {
                                                  vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                                                  errors4 = vErrors.length;
                                                }
                                                var valid0 = _errs41 === errors4;
                                              } else {
                                                var valid0 = true;
                                              }
                                              if (valid0) {
                                                if (data3.uniqueItems !== undefined) {
                                                  const _errs42 = errors4;
                                                  if (typeof data3.uniqueItems !== "boolean") {
                                                    validate10.errors = [{ instancePath: instancePath + "/uniqueItems", schemaPath: "#/properties/uniqueItems/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                    return false;
                                                  }
                                                  var valid0 = _errs42 === errors4;
                                                } else {
                                                  var valid0 = true;
                                                }
                                                if (valid0) {
                                                  if (data3.contains !== undefined) {
                                                    const _errs44 = errors4;
                                                    if (!validate10(data3.contains, { instancePath: instancePath + "/contains", parentData: data3, parentDataProperty: "contains", rootData })) {
                                                      vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                      errors4 = vErrors.length;
                                                    }
                                                    var valid0 = _errs44 === errors4;
                                                  } else {
                                                    var valid0 = true;
                                                  }
                                                  if (valid0) {
                                                    if (data3.maxProperties !== undefined) {
                                                      let data22 = data3.maxProperties;
                                                      const _errs45 = errors4;
                                                      const _errs46 = errors4;
                                                      if (!(typeof data22 == "number" && (!(data22 % 1) && !isNaN(data22)) && isFinite(data22))) {
                                                        validate10.errors = [{ instancePath: instancePath + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                        return false;
                                                      }
                                                      if (errors4 === _errs46) {
                                                        if (typeof data22 == "number" && isFinite(data22)) {
                                                          if (data22 < 0 || isNaN(data22)) {
                                                            validate10.errors = [{ instancePath: instancePath + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                                            return false;
                                                          }
                                                        }
                                                      }
                                                      var valid0 = _errs45 === errors4;
                                                    } else {
                                                      var valid0 = true;
                                                    }
                                                    if (valid0) {
                                                      if (data3.minProperties !== undefined) {
                                                        const _errs48 = errors4;
                                                        if (!validate11(data3.minProperties, { instancePath: instancePath + "/minProperties", parentData: data3, parentDataProperty: "minProperties", rootData })) {
                                                          vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                                                          errors4 = vErrors.length;
                                                        }
                                                        var valid0 = _errs48 === errors4;
                                                      } else {
                                                        var valid0 = true;
                                                      }
                                                      if (valid0) {
                                                        if (data3.required !== undefined) {
                                                          let data24 = data3.required;
                                                          const _errs49 = errors4;
                                                          const _errs50 = errors4;
                                                          if (errors4 === _errs50) {
                                                            if (Array.isArray(data24)) {
                                                              var valid6 = true;
                                                              const len0 = data24.length;
                                                              for (let i0 = 0;i0 < len0; i0++) {
                                                                const _errs52 = errors4;
                                                                if (typeof data24[i0] !== "string") {
                                                                  validate10.errors = [{ instancePath: instancePath + "/required/" + i0, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                  return false;
                                                                }
                                                                var valid6 = _errs52 === errors4;
                                                                if (!valid6) {
                                                                  break;
                                                                }
                                                              }
                                                              if (valid6) {
                                                                let i1 = data24.length;
                                                                let j0;
                                                                if (i1 > 1) {
                                                                  const indices0 = {};
                                                                  for (;i1--; ) {
                                                                    let item0 = data24[i1];
                                                                    if (typeof item0 !== "string") {
                                                                      continue;
                                                                    }
                                                                    if (typeof indices0[item0] == "number") {
                                                                      j0 = indices0[item0];
                                                                      validate10.errors = [{ instancePath: instancePath + "/required", schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: i1, j: j0 }, message: "must NOT have duplicate items (items ## " + j0 + " and " + i1 + " are identical)" }];
                                                                      return false;
                                                                      break;
                                                                    }
                                                                    indices0[item0] = i1;
                                                                  }
                                                                }
                                                              }
                                                            } else {
                                                              validate10.errors = [{ instancePath: instancePath + "/required", schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                                              return false;
                                                            }
                                                          }
                                                          var valid0 = _errs49 === errors4;
                                                        } else {
                                                          var valid0 = true;
                                                        }
                                                        if (valid0) {
                                                          if (data3.additionalProperties !== undefined) {
                                                            const _errs54 = errors4;
                                                            if (!validate10(data3.additionalProperties, { instancePath: instancePath + "/additionalProperties", parentData: data3, parentDataProperty: "additionalProperties", rootData })) {
                                                              vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                              errors4 = vErrors.length;
                                                            }
                                                            var valid0 = _errs54 === errors4;
                                                          } else {
                                                            var valid0 = true;
                                                          }
                                                          if (valid0) {
                                                            if (data3.definitions !== undefined) {
                                                              let data27 = data3.definitions;
                                                              const _errs55 = errors4;
                                                              if (errors4 === _errs55) {
                                                                if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                                                                  for (const key0 in data27) {
                                                                    const _errs58 = errors4;
                                                                    if (!validate10(data27[key0], { instancePath: instancePath + "/definitions/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data27, parentDataProperty: key0, rootData })) {
                                                                      vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                      errors4 = vErrors.length;
                                                                    }
                                                                    var valid8 = _errs58 === errors4;
                                                                    if (!valid8) {
                                                                      break;
                                                                    }
                                                                  }
                                                                } else {
                                                                  validate10.errors = [{ instancePath: instancePath + "/definitions", schemaPath: "#/properties/definitions/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                  return false;
                                                                }
                                                              }
                                                              var valid0 = _errs55 === errors4;
                                                            } else {
                                                              var valid0 = true;
                                                            }
                                                            if (valid0) {
                                                              if (data3.properties !== undefined) {
                                                                let data29 = data3.properties;
                                                                const _errs59 = errors4;
                                                                if (errors4 === _errs59) {
                                                                  if (data29 && typeof data29 == "object" && !Array.isArray(data29)) {
                                                                    for (const key1 in data29) {
                                                                      const _errs62 = errors4;
                                                                      if (!validate10(data29[key1], { instancePath: instancePath + "/properties/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data29, parentDataProperty: key1, rootData })) {
                                                                        vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                        errors4 = vErrors.length;
                                                                      }
                                                                      var valid9 = _errs62 === errors4;
                                                                      if (!valid9) {
                                                                        break;
                                                                      }
                                                                    }
                                                                  } else {
                                                                    validate10.errors = [{ instancePath: instancePath + "/properties", schemaPath: "#/properties/properties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                    return false;
                                                                  }
                                                                }
                                                                var valid0 = _errs59 === errors4;
                                                              } else {
                                                                var valid0 = true;
                                                              }
                                                              if (valid0) {
                                                                if (data3.patternProperties !== undefined) {
                                                                  let data31 = data3.patternProperties;
                                                                  const _errs63 = errors4;
                                                                  if (errors4 === _errs63) {
                                                                    if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                                                                      for (const key2 in data31) {
                                                                        const _errs65 = errors4;
                                                                        if (errors4 === _errs65) {
                                                                          if (typeof key2 === "string") {
                                                                            if (!formats6(key2)) {
                                                                              const err1 = { instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames/format", keyword: "format", params: { format: "regex" }, message: "must match format \"regex\"", propertyName: key2 };
                                                                              if (vErrors === null) {
                                                                                vErrors = [err1];
                                                                              } else {
                                                                                vErrors.push(err1);
                                                                              }
                                                                              errors4++;
                                                                            }
                                                                          }
                                                                        }
                                                                        var valid10 = _errs65 === errors4;
                                                                        if (!valid10) {
                                                                          const err2 = { instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames", keyword: "propertyNames", params: { propertyName: key2 }, message: "property name must be valid" };
                                                                          if (vErrors === null) {
                                                                            vErrors = [err2];
                                                                          } else {
                                                                            vErrors.push(err2);
                                                                          }
                                                                          errors4++;
                                                                          validate10.errors = vErrors;
                                                                          return false;
                                                                          break;
                                                                        }
                                                                      }
                                                                      if (valid10) {
                                                                        for (const key3 in data31) {
                                                                          const _errs67 = errors4;
                                                                          if (!validate10(data31[key3], { instancePath: instancePath + "/patternProperties/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data31, parentDataProperty: key3, rootData })) {
                                                                            vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                            errors4 = vErrors.length;
                                                                          }
                                                                          var valid11 = _errs67 === errors4;
                                                                          if (!valid11) {
                                                                            break;
                                                                          }
                                                                        }
                                                                      }
                                                                    } else {
                                                                      validate10.errors = [{ instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                      return false;
                                                                    }
                                                                  }
                                                                  var valid0 = _errs63 === errors4;
                                                                } else {
                                                                  var valid0 = true;
                                                                }
                                                                if (valid0) {
                                                                  if (data3.dependencies !== undefined) {
                                                                    let data33 = data3.dependencies;
                                                                    const _errs68 = errors4;
                                                                    if (errors4 === _errs68) {
                                                                      if (data33 && typeof data33 == "object" && !Array.isArray(data33)) {
                                                                        for (const key4 in data33) {
                                                                          let data34 = data33[key4];
                                                                          const _errs71 = errors4;
                                                                          const _errs72 = errors4;
                                                                          let valid13 = false;
                                                                          const _errs73 = errors4;
                                                                          if (!validate10(data34, { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data33, parentDataProperty: key4, rootData })) {
                                                                            vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                            errors4 = vErrors.length;
                                                                          }
                                                                          var _valid1 = _errs73 === errors4;
                                                                          valid13 = valid13 || _valid1;
                                                                          if (!valid13) {
                                                                            const _errs74 = errors4;
                                                                            const _errs75 = errors4;
                                                                            if (errors4 === _errs75) {
                                                                              if (Array.isArray(data34)) {
                                                                                var valid15 = true;
                                                                                const len1 = data34.length;
                                                                                for (let i2 = 0;i2 < len1; i2++) {
                                                                                  const _errs77 = errors4;
                                                                                  if (typeof data34[i2] !== "string") {
                                                                                    const err3 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1") + "/" + i2, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                                                    if (vErrors === null) {
                                                                                      vErrors = [err3];
                                                                                    } else {
                                                                                      vErrors.push(err3);
                                                                                    }
                                                                                    errors4++;
                                                                                  }
                                                                                  var valid15 = _errs77 === errors4;
                                                                                  if (!valid15) {
                                                                                    break;
                                                                                  }
                                                                                }
                                                                                if (valid15) {
                                                                                  let i3 = data34.length;
                                                                                  let j1;
                                                                                  if (i3 > 1) {
                                                                                    const indices1 = {};
                                                                                    for (;i3--; ) {
                                                                                      let item1 = data34[i3];
                                                                                      if (typeof item1 !== "string") {
                                                                                        continue;
                                                                                      }
                                                                                      if (typeof indices1[item1] == "number") {
                                                                                        j1 = indices1[item1];
                                                                                        const err4 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: i3, j: j1 }, message: "must NOT have duplicate items (items ## " + j1 + " and " + i3 + " are identical)" };
                                                                                        if (vErrors === null) {
                                                                                          vErrors = [err4];
                                                                                        } else {
                                                                                          vErrors.push(err4);
                                                                                        }
                                                                                        errors4++;
                                                                                        break;
                                                                                      }
                                                                                      indices1[item1] = i3;
                                                                                    }
                                                                                  }
                                                                                }
                                                                              } else {
                                                                                const err5 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                                if (vErrors === null) {
                                                                                  vErrors = [err5];
                                                                                } else {
                                                                                  vErrors.push(err5);
                                                                                }
                                                                                errors4++;
                                                                              }
                                                                            }
                                                                            var _valid1 = _errs74 === errors4;
                                                                            valid13 = valid13 || _valid1;
                                                                          }
                                                                          if (!valid13) {
                                                                            const err6 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/dependencies/additionalProperties/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                            if (vErrors === null) {
                                                                              vErrors = [err6];
                                                                            } else {
                                                                              vErrors.push(err6);
                                                                            }
                                                                            errors4++;
                                                                            validate10.errors = vErrors;
                                                                            return false;
                                                                          } else {
                                                                            errors4 = _errs72;
                                                                            if (vErrors !== null) {
                                                                              if (_errs72) {
                                                                                vErrors.length = _errs72;
                                                                              } else {
                                                                                vErrors = null;
                                                                              }
                                                                            }
                                                                          }
                                                                          var valid12 = _errs71 === errors4;
                                                                          if (!valid12) {
                                                                            break;
                                                                          }
                                                                        }
                                                                      } else {
                                                                        validate10.errors = [{ instancePath: instancePath + "/dependencies", schemaPath: "#/properties/dependencies/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                        return false;
                                                                      }
                                                                    }
                                                                    var valid0 = _errs68 === errors4;
                                                                  } else {
                                                                    var valid0 = true;
                                                                  }
                                                                  if (valid0) {
                                                                    if (data3.propertyNames !== undefined) {
                                                                      const _errs79 = errors4;
                                                                      if (!validate10(data3.propertyNames, { instancePath: instancePath + "/propertyNames", parentData: data3, parentDataProperty: "propertyNames", rootData })) {
                                                                        vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                        errors4 = vErrors.length;
                                                                      }
                                                                      var valid0 = _errs79 === errors4;
                                                                    } else {
                                                                      var valid0 = true;
                                                                    }
                                                                    if (valid0) {
                                                                      if (data3.enum !== undefined) {
                                                                        let data37 = data3.enum;
                                                                        const _errs80 = errors4;
                                                                        if (errors4 === _errs80) {
                                                                          if (Array.isArray(data37)) {
                                                                            if (data37.length < 1) {
                                                                              validate10.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
                                                                              return false;
                                                                            } else {
                                                                              let i4 = data37.length;
                                                                              let j2;
                                                                              if (i4 > 1) {
                                                                                outer0:
                                                                                  for (;i4--; ) {
                                                                                    for (j2 = i4;j2--; ) {
                                                                                      if (func0(data37[i4], data37[j2])) {
                                                                                        validate10.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/uniqueItems", keyword: "uniqueItems", params: { i: i4, j: j2 }, message: "must NOT have duplicate items (items ## " + j2 + " and " + i4 + " are identical)" }];
                                                                                        return false;
                                                                                        break outer0;
                                                                                      }
                                                                                    }
                                                                                  }
                                                                              }
                                                                            }
                                                                          } else {
                                                                            validate10.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                                                            return false;
                                                                          }
                                                                        }
                                                                        var valid0 = _errs80 === errors4;
                                                                      } else {
                                                                        var valid0 = true;
                                                                      }
                                                                      if (valid0) {
                                                                        if (data3.type !== undefined) {
                                                                          let data38 = data3.type;
                                                                          const _errs82 = errors4;
                                                                          const _errs83 = errors4;
                                                                          let valid18 = false;
                                                                          const _errs84 = errors4;
                                                                          if (!(data38 === "array" || data38 === "boolean" || data38 === "integer" || data38 === "null" || data38 === "number" || data38 === "object" || data38 === "string")) {
                                                                            const err7 = { instancePath: instancePath + "/type", schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: schema20.enum }, message: "must be equal to one of the allowed values" };
                                                                            if (vErrors === null) {
                                                                              vErrors = [err7];
                                                                            } else {
                                                                              vErrors.push(err7);
                                                                            }
                                                                            errors4++;
                                                                          }
                                                                          var _valid2 = _errs84 === errors4;
                                                                          valid18 = valid18 || _valid2;
                                                                          if (!valid18) {
                                                                            const _errs86 = errors4;
                                                                            if (errors4 === _errs86) {
                                                                              if (Array.isArray(data38)) {
                                                                                if (data38.length < 1) {
                                                                                  const err8 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                                                                                  if (vErrors === null) {
                                                                                    vErrors = [err8];
                                                                                  } else {
                                                                                    vErrors.push(err8);
                                                                                  }
                                                                                  errors4++;
                                                                                } else {
                                                                                  var valid20 = true;
                                                                                  const len2 = data38.length;
                                                                                  for (let i5 = 0;i5 < len2; i5++) {
                                                                                    let data39 = data38[i5];
                                                                                    const _errs88 = errors4;
                                                                                    if (!(data39 === "array" || data39 === "boolean" || data39 === "integer" || data39 === "null" || data39 === "number" || data39 === "object" || data39 === "string")) {
                                                                                      const err9 = { instancePath: instancePath + "/type/" + i5, schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: schema20.enum }, message: "must be equal to one of the allowed values" };
                                                                                      if (vErrors === null) {
                                                                                        vErrors = [err9];
                                                                                      } else {
                                                                                        vErrors.push(err9);
                                                                                      }
                                                                                      errors4++;
                                                                                    }
                                                                                    var valid20 = _errs88 === errors4;
                                                                                    if (!valid20) {
                                                                                      break;
                                                                                    }
                                                                                  }
                                                                                  if (valid20) {
                                                                                    let i6 = data38.length;
                                                                                    let j3;
                                                                                    if (i6 > 1) {
                                                                                      outer1:
                                                                                        for (;i6--; ) {
                                                                                          for (j3 = i6;j3--; ) {
                                                                                            if (func0(data38[i6], data38[j3])) {
                                                                                              const err10 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/uniqueItems", keyword: "uniqueItems", params: { i: i6, j: j3 }, message: "must NOT have duplicate items (items ## " + j3 + " and " + i6 + " are identical)" };
                                                                                              if (vErrors === null) {
                                                                                                vErrors = [err10];
                                                                                              } else {
                                                                                                vErrors.push(err10);
                                                                                              }
                                                                                              errors4++;
                                                                                              break outer1;
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              } else {
                                                                                const err11 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                                if (vErrors === null) {
                                                                                  vErrors = [err11];
                                                                                } else {
                                                                                  vErrors.push(err11);
                                                                                }
                                                                                errors4++;
                                                                              }
                                                                            }
                                                                            var _valid2 = _errs86 === errors4;
                                                                            valid18 = valid18 || _valid2;
                                                                          }
                                                                          if (!valid18) {
                                                                            const err12 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                            if (vErrors === null) {
                                                                              vErrors = [err12];
                                                                            } else {
                                                                              vErrors.push(err12);
                                                                            }
                                                                            errors4++;
                                                                            validate10.errors = vErrors;
                                                                            return false;
                                                                          } else {
                                                                            errors4 = _errs83;
                                                                            if (vErrors !== null) {
                                                                              if (_errs83) {
                                                                                vErrors.length = _errs83;
                                                                              } else {
                                                                                vErrors = null;
                                                                              }
                                                                            }
                                                                          }
                                                                          var valid0 = _errs82 === errors4;
                                                                        } else {
                                                                          var valid0 = true;
                                                                        }
                                                                        if (valid0) {
                                                                          if (data3.format !== undefined) {
                                                                            const _errs90 = errors4;
                                                                            if (typeof data3.format !== "string") {
                                                                              validate10.errors = [{ instancePath: instancePath + "/format", schemaPath: "#/properties/format/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                              return false;
                                                                            }
                                                                            var valid0 = _errs90 === errors4;
                                                                          } else {
                                                                            var valid0 = true;
                                                                          }
                                                                          if (valid0) {
                                                                            if (data3.contentMediaType !== undefined) {
                                                                              const _errs92 = errors4;
                                                                              if (typeof data3.contentMediaType !== "string") {
                                                                                validate10.errors = [{ instancePath: instancePath + "/contentMediaType", schemaPath: "#/properties/contentMediaType/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                                return false;
                                                                              }
                                                                              var valid0 = _errs92 === errors4;
                                                                            } else {
                                                                              var valid0 = true;
                                                                            }
                                                                            if (valid0) {
                                                                              if (data3.contentEncoding !== undefined) {
                                                                                const _errs94 = errors4;
                                                                                if (typeof data3.contentEncoding !== "string") {
                                                                                  validate10.errors = [{ instancePath: instancePath + "/contentEncoding", schemaPath: "#/properties/contentEncoding/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                                  return false;
                                                                                }
                                                                                var valid0 = _errs94 === errors4;
                                                                              } else {
                                                                                var valid0 = true;
                                                                              }
                                                                              if (valid0) {
                                                                                if (data3.if !== undefined) {
                                                                                  const _errs96 = errors4;
                                                                                  if (!validate10(data3.if, { instancePath: instancePath + "/if", parentData: data3, parentDataProperty: "if", rootData })) {
                                                                                    vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                    errors4 = vErrors.length;
                                                                                  }
                                                                                  var valid0 = _errs96 === errors4;
                                                                                } else {
                                                                                  var valid0 = true;
                                                                                }
                                                                                if (valid0) {
                                                                                  if (data3.then !== undefined) {
                                                                                    const _errs97 = errors4;
                                                                                    if (!validate10(data3.then, { instancePath: instancePath + "/then", parentData: data3, parentDataProperty: "then", rootData })) {
                                                                                      vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                      errors4 = vErrors.length;
                                                                                    }
                                                                                    var valid0 = _errs97 === errors4;
                                                                                  } else {
                                                                                    var valid0 = true;
                                                                                  }
                                                                                  if (valid0) {
                                                                                    if (data3.else !== undefined) {
                                                                                      const _errs98 = errors4;
                                                                                      if (!validate10(data3.else, { instancePath: instancePath + "/else", parentData: data3, parentDataProperty: "else", rootData })) {
                                                                                        vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                        errors4 = vErrors.length;
                                                                                      }
                                                                                      var valid0 = _errs98 === errors4;
                                                                                    } else {
                                                                                      var valid0 = true;
                                                                                    }
                                                                                    if (valid0) {
                                                                                      if (data3.allOf !== undefined) {
                                                                                        const _errs99 = errors4;
                                                                                        if (!validate13(data3.allOf, { instancePath: instancePath + "/allOf", parentData: data3, parentDataProperty: "allOf", rootData })) {
                                                                                          vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                                                          errors4 = vErrors.length;
                                                                                        }
                                                                                        var valid0 = _errs99 === errors4;
                                                                                      } else {
                                                                                        var valid0 = true;
                                                                                      }
                                                                                      if (valid0) {
                                                                                        if (data3.anyOf !== undefined) {
                                                                                          const _errs100 = errors4;
                                                                                          if (!validate13(data3.anyOf, { instancePath: instancePath + "/anyOf", parentData: data3, parentDataProperty: "anyOf", rootData })) {
                                                                                            vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                                                            errors4 = vErrors.length;
                                                                                          }
                                                                                          var valid0 = _errs100 === errors4;
                                                                                        } else {
                                                                                          var valid0 = true;
                                                                                        }
                                                                                        if (valid0) {
                                                                                          if (data3.oneOf !== undefined) {
                                                                                            const _errs101 = errors4;
                                                                                            if (!validate13(data3.oneOf, { instancePath: instancePath + "/oneOf", parentData: data3, parentDataProperty: "oneOf", rootData })) {
                                                                                              vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                                                              errors4 = vErrors.length;
                                                                                            }
                                                                                            var valid0 = _errs101 === errors4;
                                                                                          } else {
                                                                                            var valid0 = true;
                                                                                          }
                                                                                          if (valid0) {
                                                                                            if (data3.not !== undefined) {
                                                                                              const _errs102 = errors4;
                                                                                              if (!validate10(data3.not, { instancePath: instancePath + "/not", parentData: data3, parentDataProperty: "not", rootData })) {
                                                                                                vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                                errors4 = vErrors.length;
                                                                                              }
                                                                                              var valid0 = _errs102 === errors4;
                                                                                            } else {
                                                                                              var valid0 = true;
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    validate10.errors = vErrors;
    return errors4 === 0;
  };
  module.exports = validate10;
  module.exports.default = validate10;
  var schema11 = { $schema: "http://json-schema.org/draft-07/schema#", $id: "http://json-schema.org/draft-07/schema#", title: "Core schema meta-schema", definitions: { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: true, default: [] } }, type: ["object", "boolean"], properties: { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: true, readOnly: { type: "boolean", default: false }, examples: { type: "array", items: true }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: true }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: false }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: true, enum: { type: "array", items: true, minItems: 1, uniqueItems: true }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: true }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, default: true };
  var schema20 = { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] };
  var formats0 = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  var formats2 = require_formats().fullFormats.uri;
  var formats6 = require_formats().fullFormats.regex;
  var root1 = { validate: validate10 };
  var func0 = require_equal().default;
});

// ../node_modules/.pnpm/@fastify+merge-json-schemas@0.1.1/node_modules/@fastify/merge-json-schemas/lib/errors.js
var require_errors6 = __commonJS((exports, module) => {
  class MergeError extends Error {
    constructor(keyword, schemas5) {
      super();
      this.name = "JsonSchemaMergeError";
      this.code = "JSON_SCHEMA_MERGE_ERROR";
      this.message = `Failed to merge "${keyword}" keyword schemas.`;
      this.schemas = schemas5;
    }
  }

  class ResolverNotFoundError extends Error {
    constructor(keyword, schemas5) {
      super();
      this.name = "JsonSchemaMergeError";
      this.code = "JSON_SCHEMA_MERGE_ERROR";
      this.message = `Resolver for "${keyword}" keyword not found.`;
      this.schemas = schemas5;
    }
  }

  class InvalidOnConflictOptionError extends Error {
    constructor(onConflict) {
      super();
      this.name = "JsonSchemaMergeError";
      this.code = "JSON_SCHEMA_MERGE_ERROR";
      this.message = `Invalid "onConflict" option: "${onConflict}".`;
    }
  }
  module.exports = {
    MergeError,
    ResolverNotFoundError,
    InvalidOnConflictOptionError
  };
});

// ../node_modules/.pnpm/@fastify+merge-json-schemas@0.1.1/node_modules/@fastify/merge-json-schemas/lib/resolvers.js
var require_resolvers = __commonJS((exports, module) => {
  var _arraysIntersection = function(arrays) {
    let intersection = arrays[0];
    for (let i = 1;i < arrays.length; i++) {
      intersection = intersection.filter((value) => arrays[i].includes(value));
    }
    return intersection;
  };
  var arraysIntersection = function(keyword, values, mergedSchema) {
    const intersection = _arraysIntersection(values);
    if (intersection.length === 0) {
      throw new MergeError(keyword, values);
    }
    mergedSchema[keyword] = intersection;
  };
  var hybridArraysIntersection = function(keyword, values, mergedSchema) {
    for (let i = 0;i < values.length; i++) {
      if (!Array.isArray(values[i])) {
        values[i] = [values[i]];
      }
    }
    const intersection = _arraysIntersection(values);
    if (intersection.length === 0) {
      throw new MergeError(keyword, values);
    }
    if (intersection.length === 1) {
      mergedSchema[keyword] = intersection[0];
    } else {
      mergedSchema[keyword] = intersection;
    }
  };
  var arraysUnion = function(keyword, values, mergedSchema) {
    const union = [];
    for (const array of values) {
      for (const value of array) {
        if (!union.includes(value)) {
          union.push(value);
        }
      }
    }
    mergedSchema[keyword] = union;
  };
  var minNumber = function(keyword, values, mergedSchema) {
    mergedSchema[keyword] = Math.min(...values);
  };
  var maxNumber = function(keyword, values, mergedSchema) {
    mergedSchema[keyword] = Math.max(...values);
  };
  var commonMultiple = function(keyword, values, mergedSchema) {
    const gcd = (a, b) => !b ? a : gcd(b, a % b);
    const lcm = (a, b) => a * b / gcd(a, b);
    let scale = 1;
    for (const value of values) {
      while (value * scale % 1 !== 0) {
        scale *= 10;
      }
    }
    let multiple = values[0] * scale;
    for (const value of values) {
      multiple = lcm(multiple, value * scale);
    }
    mergedSchema[keyword] = multiple / scale;
  };
  var allEqual = function(keyword, values, mergedSchema) {
    const firstValue = values[0];
    for (let i = 1;i < values.length; i++) {
      if (!deepEqual(values[i], firstValue)) {
        throw new MergeError(keyword, values);
      }
    }
    mergedSchema[keyword] = firstValue;
  };
  var skip = function() {
  };
  var booleanAnd = function(keyword, values, mergedSchema) {
    for (const value of values) {
      if (value === false) {
        mergedSchema[keyword] = false;
        return;
      }
    }
    mergedSchema[keyword] = true;
  };
  var booleanOr = function(keyword, values, mergedSchema) {
    for (const value of values) {
      if (value === true) {
        mergedSchema[keyword] = true;
        return;
      }
    }
    mergedSchema[keyword] = false;
  };
  var deepEqual = require_fast_deep_equal();
  var { MergeError } = require_errors6();
  module.exports = {
    arraysIntersection,
    hybridArraysIntersection,
    arraysUnion,
    minNumber,
    maxNumber,
    commonMultiple,
    allEqual,
    booleanAnd,
    booleanOr,
    skip
  };
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fast-json-stringify@5.12.0/node_modules/@fastify/merge-json-schemas/index.js
var require_merge_json_schemas = __commonJS((exports, module) => {
  var mergeSchemasResolver = function(keyword, values, mergedSchema, schemas5, options) {
    mergedSchema[keyword] = _mergeSchemas(values, options);
  };
  var cartesianProduct = function(arrays) {
    let result = [[]];
    for (const array of arrays) {
      const temp = [];
      for (const x of result) {
        for (const y of array) {
          temp.push([...x, y]);
        }
      }
      result = temp;
    }
    return result;
  };
  var mergeOneOf = function(keyword, values, mergedSchema, schemas5, options) {
    if (values.length === 1) {
      mergedSchema[keyword] = values[0];
      return;
    }
    const product = cartesianProduct(values);
    const mergedOneOf = [];
    for (const combination of product) {
      try {
        const mergedSchema2 = _mergeSchemas(combination, options);
        if (mergedSchema2 !== undefined) {
          mergedOneOf.push(mergedSchema2);
        }
      } catch (error) {
        if (error instanceof errors4.MergeError)
          continue;
        throw error;
      }
    }
    mergedSchema[keyword] = mergedOneOf;
  };
  var getSchemaForItem = function(schema, index2) {
    const { items, additionalItems } = schema;
    if (Array.isArray(items)) {
      if (index2 < items.length) {
        return items[index2];
      }
      return additionalItems;
    }
    if (items !== undefined) {
      return items;
    }
    return additionalItems;
  };
  var mergeItems = function(keyword, values, mergedSchema, schemas5, options) {
    let maxArrayItemsLength = 0;
    for (const itemsSchema of values) {
      if (Array.isArray(itemsSchema)) {
        maxArrayItemsLength = Math.max(maxArrayItemsLength, itemsSchema.length);
      }
    }
    if (maxArrayItemsLength === 0) {
      mergedSchema[keyword] = _mergeSchemas(values, options);
      return;
    }
    const mergedItemsSchemas = [];
    for (let i = 0;i < maxArrayItemsLength; i++) {
      const indexItemSchemas = [];
      for (const schema of schemas5) {
        const itemSchema = getSchemaForItem(schema, i);
        if (itemSchema !== undefined) {
          indexItemSchemas.push(itemSchema);
        }
      }
      mergedItemsSchemas[i] = _mergeSchemas(indexItemSchemas, options);
    }
    mergedSchema[keyword] = mergedItemsSchemas;
  };
  var mergeAdditionalItems = function(keyword, values, mergedSchema, schemas5, options) {
    let hasArrayItems = false;
    for (const schema of schemas5) {
      if (Array.isArray(schema.items)) {
        hasArrayItems = true;
        break;
      }
    }
    if (!hasArrayItems) {
      mergedSchema[keyword] = _mergeSchemas(values, options);
      return;
    }
    const mergedAdditionalItemsSchemas = [];
    for (const schema of schemas5) {
      let additionalItemsSchema = schema.additionalItems;
      if (additionalItemsSchema === undefined && !Array.isArray(schema.items)) {
        additionalItemsSchema = schema.items;
      }
      if (additionalItemsSchema !== undefined) {
        mergedAdditionalItemsSchemas.push(additionalItemsSchema);
      }
    }
    mergedSchema[keyword] = _mergeSchemas(mergedAdditionalItemsSchemas, options);
  };
  var getSchemaForProperty = function(schema, propertyName) {
    const { properties, patternProperties, additionalProperties } = schema;
    if (properties?.[propertyName] !== undefined) {
      return properties[propertyName];
    }
    for (const pattern of Object.keys(patternProperties ?? {})) {
      const regexp = new RegExp(pattern);
      if (regexp.test(propertyName)) {
        return patternProperties[pattern];
      }
    }
    return additionalProperties;
  };
  var mergeProperties = function(keyword, values, mergedSchema, schemas5, options) {
    const foundProperties = {};
    for (const currentSchema of schemas5) {
      const properties = currentSchema.properties ?? {};
      for (const propertyName of Object.keys(properties)) {
        if (foundProperties[propertyName] !== undefined)
          continue;
        const propertySchema = properties[propertyName];
        foundProperties[propertyName] = [propertySchema];
        for (const anotherSchema of schemas5) {
          if (currentSchema === anotherSchema)
            continue;
          const propertySchema2 = getSchemaForProperty(anotherSchema, propertyName);
          if (propertySchema2 !== undefined) {
            foundProperties[propertyName].push(propertySchema2);
          }
        }
      }
    }
    const mergedProperties = {};
    for (const property of Object.keys(foundProperties)) {
      const propertySchemas = foundProperties[property];
      mergedProperties[property] = _mergeSchemas(propertySchemas, options);
    }
    mergedSchema[keyword] = mergedProperties;
  };
  var mergeObjects = function(keyword, values, mergedSchema, schemas5, options) {
    const objectsProperties = {};
    for (const properties of values) {
      for (const propertyName of Object.keys(properties)) {
        if (objectsProperties[propertyName] === undefined) {
          objectsProperties[propertyName] = [];
        }
        objectsProperties[propertyName].push(properties[propertyName]);
      }
    }
    const mergedProperties = {};
    for (const propertyName of Object.keys(objectsProperties)) {
      const propertySchemas = objectsProperties[propertyName];
      const mergedPropertySchema = _mergeSchemas(propertySchemas, options);
      mergedProperties[propertyName] = mergedPropertySchema;
    }
    mergedSchema[keyword] = mergedProperties;
  };
  var mergeIfThenElseSchemas = function(keyword, values, mergedSchema, schemas5, options) {
    for (let i = 0;i < schemas5.length; i++) {
      const subSchema = {
        if: schemas5[i].if,
        then: schemas5[i].then,
        else: schemas5[i].else
      };
      if (subSchema.if === undefined)
        continue;
      if (mergedSchema.if === undefined) {
        mergedSchema.if = subSchema.if;
        if (subSchema.then !== undefined) {
          mergedSchema.then = subSchema.then;
        }
        if (subSchema.else !== undefined) {
          mergedSchema.else = subSchema.else;
        }
        continue;
      }
      if (mergedSchema.then !== undefined) {
        mergedSchema.then = _mergeSchemas([mergedSchema.then, subSchema], options);
      }
      if (mergedSchema.else !== undefined) {
        mergedSchema.else = _mergeSchemas([mergedSchema.else, subSchema], options);
      }
    }
  };
  var mergeDependencies = function(keyword, values, mergedSchema) {
    const mergedDependencies = {};
    for (const dependencies of values) {
      for (const propertyName of Object.keys(dependencies)) {
        if (mergedDependencies[propertyName] === undefined) {
          mergedDependencies[propertyName] = [];
        }
        const mergedPropertyDependencies = mergedDependencies[propertyName];
        for (const propertyDependency of dependencies[propertyName]) {
          if (!mergedPropertyDependencies.includes(propertyDependency)) {
            mergedPropertyDependencies.push(propertyDependency);
          }
        }
      }
    }
    mergedSchema[keyword] = mergedDependencies;
  };
  var _mergeSchemas = function(schemas5, options) {
    if (schemas5.length === 0)
      return {};
    if (schemas5.length === 1)
      return schemas5[0];
    const mergedSchema = {};
    const keywords = {};
    let allSchemasAreTrue = true;
    for (const schema of schemas5) {
      if (schema === false)
        return false;
      if (schema === true)
        continue;
      allSchemasAreTrue = false;
      for (const keyword of Object.keys(schema)) {
        if (keywords[keyword] === undefined) {
          keywords[keyword] = [];
        }
        keywords[keyword].push(schema[keyword]);
      }
    }
    if (allSchemasAreTrue)
      return true;
    for (const keyword of Object.keys(keywords)) {
      const keywordValues = keywords[keyword];
      const resolver = options.resolvers[keyword] ?? options.defaultResolver;
      resolver(keyword, keywordValues, mergedSchema, schemas5, options);
    }
    return mergedSchema;
  };
  var defaultResolver = function(keyword, values, mergedSchema, schemas5, options) {
    const onConflict = options.onConflict ?? "throw";
    if (values.length === 1 || onConflict === "first") {
      mergedSchema[keyword] = values[0];
      return;
    }
    let allValuesEqual = true;
    for (let i = 1;i < values.length; i++) {
      if (!deepEqual(values[i], values[0])) {
        allValuesEqual = false;
        break;
      }
    }
    if (allValuesEqual) {
      mergedSchema[keyword] = values[0];
      return;
    }
    if (onConflict === "throw") {
      throw new errors4.ResolverNotFoundError(keyword, values);
    }
    if (onConflict === "skip") {
      return;
    }
    throw new errors4.InvalidOnConflictOptionError(onConflict);
  };
  var mergeSchemas = function(schemas5, options = {}) {
    if (options.defaultResolver === undefined) {
      options.defaultResolver = defaultResolver;
    }
    options.resolvers = { ...keywordsResolvers, ...options.resolvers };
    const mergedSchema = _mergeSchemas(schemas5, options);
    return mergedSchema;
  };
  var deepEqual = require_fast_deep_equal();
  var resolvers = require_resolvers();
  var errors4 = require_errors6();
  var keywordsResolvers = {
    $id: resolvers.skip,
    type: resolvers.hybridArraysIntersection,
    enum: resolvers.arraysIntersection,
    minLength: resolvers.maxNumber,
    maxLength: resolvers.minNumber,
    minimum: resolvers.maxNumber,
    maximum: resolvers.minNumber,
    multipleOf: resolvers.commonMultiple,
    exclusiveMinimum: resolvers.maxNumber,
    exclusiveMaximum: resolvers.minNumber,
    minItems: resolvers.maxNumber,
    maxItems: resolvers.minNumber,
    maxProperties: resolvers.minNumber,
    minProperties: resolvers.maxNumber,
    const: resolvers.allEqual,
    default: resolvers.allEqual,
    format: resolvers.allEqual,
    required: resolvers.arraysUnion,
    properties: mergeProperties,
    patternProperties: mergeObjects,
    additionalProperties: mergeSchemasResolver,
    items: mergeItems,
    additionalItems: mergeAdditionalItems,
    definitions: mergeObjects,
    $defs: mergeObjects,
    nullable: resolvers.booleanAnd,
    oneOf: mergeOneOf,
    anyOf: mergeOneOf,
    allOf: resolvers.arraysUnion,
    not: mergeSchemasResolver,
    if: mergeIfThenElseSchemas,
    then: resolvers.skip,
    else: resolvers.skip,
    dependencies: mergeDependencies,
    dependentRequired: mergeDependencies,
    dependentSchemas: mergeObjects,
    propertyNames: mergeSchemasResolver,
    uniqueItems: resolvers.booleanOr,
    contains: mergeSchemasResolver
  };
  module.exports = { mergeSchemas, keywordsResolvers, defaultResolver, ...errors4 };
});

// ../node_modules/.pnpm/fast-json-stringify@5.12.0/node_modules/fast-json-stringify/lib/merge-schemas.js
var require_merge_schemas = __commonJS((exports, module) => {
  var mergeSchemas = function(schemas5) {
    return _mergeSchemas(schemas5, { onConflict: "skip" });
  };
  var { mergeSchemas: _mergeSchemas } = require_merge_json_schemas();
  module.exports = mergeSchemas;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/@fastify+fast-json-stringify-compiler@4.3.0/node_modules/fast-json-stringify/index.js
var require_fast_json_stringify = __commonJS((exports, module) => {
  var isValidSchema = function(schema, name) {
    if (!validate(schema)) {
      if (name) {
        name = `"${name}" `;
      } else {
        name = "";
      }
      const first = validate.errors[0];
      const err = new Error(`${name}schema is invalid: data${first.instancePath} ${first.message}`);
      err.errors = isValidSchema.errors;
      throw err;
    }
  };
  var resolveRef = function(context, location) {
    const ref = location.schema.$ref;
    let hashIndex = ref.indexOf("#");
    if (hashIndex === -1) {
      hashIndex = ref.length;
    }
    const schemaId = ref.slice(0, hashIndex) || location.schemaId;
    const jsonPointer = ref.slice(hashIndex) || "#";
    const schema = context.refResolver.getSchema(schemaId, jsonPointer);
    if (schema === null) {
      throw new Error(`Cannot find reference "${ref}"`);
    }
    const newLocation = new Location(schema, schemaId, jsonPointer);
    if (schema.$ref !== undefined) {
      return resolveRef(context, newLocation);
    }
    return newLocation;
  };
  var getMergedLocation = function(context, mergedSchemaId) {
    const mergedSchema = context.refResolver.getSchema(mergedSchemaId, "#");
    return new Location(mergedSchema, mergedSchemaId, "#");
  };
  var getSchemaId = function(schema, rootSchemaId) {
    if (schema.$id && schema.$id.charAt(0) !== "#") {
      return schema.$id;
    }
    return rootSchemaId;
  };
  var build = function(schema, options) {
    isValidSchema(schema);
    options = options || {};
    const context = {
      functions: [],
      functionsCounter: 0,
      functionsNamesBySchema: new Map,
      options,
      refResolver: new RefResolver,
      rootSchemaId: schema.$id || `__fjs_root_${schemaIdCounter++}`,
      validatorSchemasIds: new Set,
      mergedSchemasIds: new Map
    };
    const schemaId = getSchemaId(schema, context.rootSchemaId);
    if (!context.refResolver.hasSchema(schemaId)) {
      context.refResolver.addSchema(schema, context.rootSchemaId);
    }
    if (options.schema) {
      for (const key in options.schema) {
        const schema2 = options.schema[key];
        const schemaId2 = getSchemaId(schema2, key);
        if (!context.refResolver.hasSchema(schemaId2)) {
          isValidSchema(schema2, key);
          context.refResolver.addSchema(schema2, key);
        }
      }
    }
    if (options.rounding) {
      if (!validRoundingMethods.includes(options.rounding)) {
        throw new Error(`Unsupported integer rounding method ${options.rounding}`);
      }
    }
    if (options.largeArrayMechanism) {
      if (validLargeArrayMechanisms.includes(options.largeArrayMechanism)) {
        largeArrayMechanism = options.largeArrayMechanism;
      } else {
        throw new Error(`Unsupported large array mechanism ${options.largeArrayMechanism}`);
      }
    }
    if (options.largeArraySize) {
      if (typeof options.largeArraySize === "string" && Number.isFinite(Number.parseInt(options.largeArraySize, 10))) {
        largeArraySize = Number.parseInt(options.largeArraySize, 10);
      } else if (typeof options.largeArraySize === "number" && Number.isInteger(options.largeArraySize)) {
        largeArraySize = options.largeArraySize;
      } else if (typeof options.largeArraySize === "bigint") {
        largeArraySize = Number(options.largeArraySize);
      } else {
        throw new Error(`Unsupported large array size. Expected integer-like, got ${typeof options.largeArraySize} with value ${options.largeArraySize}`);
      }
    }
    const location = new Location(schema, context.rootSchemaId);
    const code = buildValue(context, location, "input");
    let contextFunctionCode;
    if (code === "json += anonymous0(input)") {
      contextFunctionCode = `
    ${context.functions.join("\n")}
    const main = anonymous0
    return main
    `;
    } else {
      contextFunctionCode = `
    function main (input) {
      let json = ''
      ${code}
      return json
    }
    ${context.functions.join("\n")}
    return main
    `;
    }
    const serializer = new Serializer(options);
    const validator = new Validator(options.ajv);
    for (const schemaId2 of context.validatorSchemasIds) {
      const schema2 = context.refResolver.getSchema(schemaId2);
      validator.addSchema(schema2, schemaId2);
      const dependencies = context.refResolver.getSchemaDependencies(schemaId2);
      for (const [schemaId3, schema3] of Object.entries(dependencies)) {
        validator.addSchema(schema3, schemaId3);
      }
    }
    if (options.debugMode) {
      options.mode = "debug";
    }
    if (options.mode === "debug") {
      return {
        validator,
        serializer,
        code: `validator\nserializer\n${contextFunctionCode}`,
        ajv: validator.ajv
      };
    }
    const contextFunc = new Function("validator", "serializer", contextFunctionCode);
    if (options.mode === "standalone") {
      const buildStandaloneCode = require_standalone();
      return buildStandaloneCode(contextFunc, context, serializer, validator);
    }
    return contextFunc(validator, serializer);
  };
  var inferTypeByKeyword = function(schema) {
    for (var keyword of objectKeywords) {
      if (keyword in schema)
        return "object";
    }
    for (var keyword of arrayKeywords) {
      if (keyword in schema)
        return "array";
    }
    for (var keyword of stringKeywords) {
      if (keyword in schema)
        return "string";
    }
    for (var keyword of numberKeywords) {
      if (keyword in schema)
        return "number";
    }
    return schema.type;
  };
  var buildExtraObjectPropertiesSerializer = function(context, location, addComma) {
    const schema = location.schema;
    const propertiesKeys = Object.keys(schema.properties || {});
    let code = `
    const propertiesKeys = ${JSON.stringify(propertiesKeys)}
    for (const [key, value] of Object.entries(obj)) {
      if (
        propertiesKeys.includes(key) ||
        value === undefined ||
        typeof value === 'function' ||
        typeof value === 'symbol'
      ) continue
  `;
    const patternPropertiesLocation = location.getPropertyLocation("patternProperties");
    const patternPropertiesSchema = patternPropertiesLocation.schema;
    if (patternPropertiesSchema !== undefined) {
      for (const propertyKey in patternPropertiesSchema) {
        const propertyLocation = patternPropertiesLocation.getPropertyLocation(propertyKey);
        code += `
        if (/${propertyKey.replace(/\\*\//g, "\\/")}/.test(key)) {
          ${addComma}
          json += serializer.asString(key) + ':'
          ${buildValue(context, propertyLocation, "value")}
          continue
        }
      `;
      }
    }
    const additionalPropertiesLocation = location.getPropertyLocation("additionalProperties");
    const additionalPropertiesSchema = additionalPropertiesLocation.schema;
    if (additionalPropertiesSchema !== undefined) {
      if (additionalPropertiesSchema === true) {
        code += `
        ${addComma}
        json += serializer.asString(key) + ':' + JSON.stringify(value)
      `;
      } else {
        const propertyLocation = location.getPropertyLocation("additionalProperties");
        code += `
        ${addComma}
        json += serializer.asString(key) + ':'
        ${buildValue(context, propertyLocation, "value")}
      `;
      }
    }
    code += `
    }
  `;
    return code;
  };
  var buildInnerObject = function(context, location) {
    const schema = location.schema;
    const propertiesLocation = location.getPropertyLocation("properties");
    const requiredProperties = schema.required || [];
    const propertiesKeys = Object.keys(schema.properties || {}).sort((key1, key2) => {
      const required1 = requiredProperties.includes(key1);
      const required2 = requiredProperties.includes(key2);
      return required1 === required2 ? 0 : required1 ? -1 : 1;
    });
    const hasRequiredProperties = requiredProperties.includes(propertiesKeys[0]);
    let code = "";
    for (const key of requiredProperties) {
      if (!propertiesKeys.includes(key)) {
        code += `if (obj['${key}'] === undefined) throw new Error('"${key}" is required!')\n`;
      }
    }
    code += "let json = \'{\'\n";
    let addComma = "";
    if (!hasRequiredProperties) {
      code += "let addComma = false\n";
      addComma = "!addComma && (addComma = true) || (json += \',\')";
    }
    for (const key of propertiesKeys) {
      let propertyLocation = propertiesLocation.getPropertyLocation(key);
      if (propertyLocation.schema.$ref) {
        propertyLocation = resolveRef(context, propertyLocation);
      }
      const sanitizedKey = JSON.stringify(key);
      const defaultValue = propertyLocation.schema.default;
      const isRequired = requiredProperties.includes(key);
      code += `
      if (obj[${sanitizedKey}] !== undefined) {
        ${addComma}
        json += ${JSON.stringify(sanitizedKey + ":")}
        ${buildValue(context, propertyLocation, `obj[${sanitizedKey}]`)}
      }`;
      if (defaultValue !== undefined) {
        code += ` else {
        ${addComma}
        json += ${JSON.stringify(sanitizedKey + ":" + JSON.stringify(defaultValue))}
      }
      `;
      } else if (isRequired) {
        code += ` else {
        throw new Error('${sanitizedKey} is required!')
      }
      `;
      } else {
        code += "\n";
      }
      if (hasRequiredProperties) {
        addComma = "json += \',\'";
      }
    }
    if (schema.patternProperties || schema.additionalProperties) {
      code += buildExtraObjectPropertiesSerializer(context, location, addComma);
    }
    code += `
    return json + '}'
  `;
    return code;
  };
  var mergeLocations = function(context, mergedSchemaId, mergedLocations) {
    for (let i = 0;i < mergedLocations.length; i++) {
      const location = mergedLocations[i];
      const schema = location.schema;
      if (schema.$ref) {
        mergedLocations[i] = resolveRef(context, location);
      }
    }
    const mergedSchemas = [];
    for (const location of mergedLocations) {
      const schema = cloneOriginSchema(context, location.schema, location.schemaId);
      delete schema.$id;
      mergedSchemas.push(schema);
    }
    const mergedSchema = mergeSchemas(mergedSchemas);
    const mergedLocation = new Location(mergedSchema, mergedSchemaId);
    context.refResolver.addSchema(mergedSchema, mergedSchemaId);
    return mergedLocation;
  };
  var cloneOriginSchema = function(context, schema, schemaId) {
    const clonedSchema = Array.isArray(schema) ? [] : {};
    if (schema.$id !== undefined && schema.$id.charAt(0) !== "#") {
      schemaId = schema.$id;
    }
    const mergedSchemaRef = context.mergedSchemasIds.get(schema);
    if (mergedSchemaRef) {
      context.mergedSchemasIds.set(clonedSchema, mergedSchemaRef);
    }
    for (const key in schema) {
      let value = schema[key];
      if (key === "$ref" && value.charAt(0) === "#") {
        value = schemaId + value;
      }
      if (typeof value === "object" && value !== null) {
        value = cloneOriginSchema(context, value, schemaId);
      }
      clonedSchema[key] = value;
    }
    return clonedSchema;
  };
  var toJSON = function(variableName) {
    return `(${variableName} && typeof ${variableName}.toJSON === 'function')
    ? ${variableName}.toJSON()
    : ${variableName}
  `;
  };
  var buildObject = function(context, location) {
    const schema = location.schema;
    if (context.functionsNamesBySchema.has(schema)) {
      return context.functionsNamesBySchema.get(schema);
    }
    const functionName = generateFuncName(context);
    context.functionsNamesBySchema.set(schema, functionName);
    let schemaRef = location.getSchemaRef();
    if (schemaRef.startsWith(context.rootSchemaId)) {
      schemaRef = schemaRef.replace(context.rootSchemaId, "");
    }
    let functionCode = `
  `;
    const nullable = schema.nullable === true;
    functionCode += `
    // ${schemaRef}
    function ${functionName} (input) {
      const obj = ${toJSON("input")}
      ${!nullable ? "if (obj === null) return \'{}\'" : ""}

      ${buildInnerObject(context, location)}
    }
  `;
    context.functions.push(functionCode);
    return functionName;
  };
  var buildArray = function(context, location) {
    const schema = location.schema;
    let itemsLocation = location.getPropertyLocation("items");
    itemsLocation.schema = itemsLocation.schema || {};
    if (itemsLocation.schema.$ref) {
      itemsLocation = resolveRef(context, itemsLocation);
    }
    const itemsSchema = itemsLocation.schema;
    if (context.functionsNamesBySchema.has(schema)) {
      return context.functionsNamesBySchema.get(schema);
    }
    const functionName = generateFuncName(context);
    context.functionsNamesBySchema.set(schema, functionName);
    let schemaRef = location.getSchemaRef();
    if (schemaRef.startsWith(context.rootSchemaId)) {
      schemaRef = schemaRef.replace(context.rootSchemaId, "");
    }
    let functionCode = `
    function ${functionName} (obj) {
      // ${schemaRef}
  `;
    const nullable = schema.nullable === true;
    functionCode += `
    ${!nullable ? "if (obj === null) return \'[]\'" : ""}
    if (!Array.isArray(obj)) {
      throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
    }
    const arrayLength = obj.length
  `;
    if (!schema.additionalItems && Array.isArray(itemsSchema)) {
      functionCode += `
      if (arrayLength > ${itemsSchema.length}) {
        throw new Error(\`Item at ${itemsSchema.length} does not match schema definition.\`)
      }
    `;
    }
    if (largeArrayMechanism === "json-stringify") {
      functionCode += `if (arrayLength && arrayLength >= ${largeArraySize}) return JSON.stringify(obj)\n`;
    }
    functionCode += `
    let jsonOutput = ''
  `;
    if (Array.isArray(itemsSchema)) {
      for (let i = 0;i < itemsSchema.length; i++) {
        const item = itemsSchema[i];
        const tmpRes = buildValue(context, itemsLocation.getPropertyLocation(i), `obj[${i}]`);
        functionCode += `
        if (${i} < arrayLength) {
          if (${buildArrayTypeCondition(item.type, `[${i}]`)}) {
            let json = ''
            ${tmpRes}
            jsonOutput += json
            if (${i} < arrayLength - 1) {
              jsonOutput += ','
            }
          } else {
            throw new Error(\`Item at ${i} does not match schema definition.\`)
          }
        }
        `;
      }
      if (schema.additionalItems) {
        functionCode += `
        for (let i = ${itemsSchema.length}; i < arrayLength; i++) {
          jsonOutput += JSON.stringify(obj[i])
          if (i < arrayLength - 1) {
            jsonOutput += ','
          }
        }`;
      }
    } else {
      const code = buildValue(context, itemsLocation, "obj[i]");
      functionCode += `
      for (let i = 0; i < arrayLength; i++) {
        let json = ''
        ${code}
        jsonOutput += json
        if (i < arrayLength - 1) {
          jsonOutput += ','
        }
      }`;
    }
    functionCode += `
    return \`[\${jsonOutput}]\`
  }`;
    context.functions.push(functionCode);
    return functionName;
  };
  var buildArrayTypeCondition = function(type, accessor) {
    let condition;
    switch (type) {
      case "null":
        condition = `obj${accessor} === null`;
        break;
      case "string":
        condition = `typeof obj${accessor} === 'string' ||
      obj${accessor} === null ||
      obj${accessor} instanceof Date ||
      obj${accessor} instanceof RegExp ||
      (
        typeof obj${accessor} === "object" &&
        typeof obj${accessor}.toString === "function" &&
        obj${accessor}.toString !== Object.prototype.toString
      )`;
        break;
      case "integer":
        condition = `Number.isInteger(obj${accessor})`;
        break;
      case "number":
        condition = `Number.isFinite(obj${accessor})`;
        break;
      case "boolean":
        condition = `typeof obj${accessor} === 'boolean'`;
        break;
      case "object":
        condition = `obj${accessor} && typeof obj${accessor} === 'object' && obj${accessor}.constructor === Object`;
        break;
      case "array":
        condition = `Array.isArray(obj${accessor})`;
        break;
      default:
        if (Array.isArray(type)) {
          const conditions = type.map((subType) => {
            return buildArrayTypeCondition(subType, accessor);
          });
          condition = `(${conditions.join(" || ")})`;
        }
    }
    return condition;
  };
  var generateFuncName = function(context) {
    return "anonymous" + context.functionsCounter++;
  };
  var buildMultiTypeSerializer = function(context, location, input) {
    const schema = location.schema;
    const types12 = schema.type.sort((t1) => t1 === "null" ? -1 : 1);
    let code = "";
    types12.forEach((type, index2) => {
      location.schema = { ...location.schema, type };
      const nestedResult = buildSingleTypeSerializer(context, location, input);
      const statement = index2 === 0 ? "if" : "else if";
      switch (type) {
        case "null":
          code += `
          ${statement} (${input} === null)
            ${nestedResult}
          `;
          break;
        case "string": {
          code += `
          ${statement}(
            typeof ${input} === "string" ||
            ${input} === null ||
            ${input} instanceof Date ||
            ${input} instanceof RegExp ||
            (
              typeof ${input} === "object" &&
              typeof ${input}.toString === "function" &&
              ${input}.toString !== Object.prototype.toString
            )
          )
            ${nestedResult}
        `;
          break;
        }
        case "array": {
          code += `
          ${statement}(Array.isArray(${input}))
            ${nestedResult}
        `;
          break;
        }
        case "integer": {
          code += `
          ${statement}(Number.isInteger(${input}) || ${input} === null)
            ${nestedResult}
        `;
          break;
        }
        default: {
          code += `
          ${statement}(typeof ${input} === "${type}" || ${input} === null)
            ${nestedResult}
        `;
          break;
        }
      }
    });
    let schemaRef = location.getSchemaRef();
    if (schemaRef.startsWith(context.rootSchemaId)) {
      schemaRef = schemaRef.replace(context.rootSchemaId, "");
    }
    code += `
    else throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
  `;
    return code;
  };
  var buildSingleTypeSerializer = function(context, location, input) {
    const schema = location.schema;
    switch (schema.type) {
      case "null":
        return "json += \'null\'";
      case "string": {
        if (schema.format === "date-time") {
          return `json += serializer.asDateTime(${input})`;
        } else if (schema.format === "date") {
          return `json += serializer.asDate(${input})`;
        } else if (schema.format === "time") {
          return `json += serializer.asTime(${input})`;
        } else {
          return `json += serializer.asString(${input})`;
        }
      }
      case "integer":
        return `json += serializer.asInteger(${input})`;
      case "number":
        return `json += serializer.asNumber(${input})`;
      case "boolean":
        return `json += serializer.asBoolean(${input})`;
      case "object": {
        const funcName = buildObject(context, location);
        return `json += ${funcName}(${input})`;
      }
      case "array": {
        const funcName = buildArray(context, location);
        return `json += ${funcName}(${input})`;
      }
      case undefined:
        return `json += JSON.stringify(${input})`;
      default:
        throw new Error(`${schema.type} unsupported`);
    }
  };
  var buildConstSerializer = function(location, input) {
    const schema = location.schema;
    const type = schema.type;
    const hasNullType = Array.isArray(type) && type.includes("null");
    let code = "";
    if (hasNullType) {
      code += `
      if (${input} === null) {
        json += 'null'
      } else {
    `;
    }
    code += `json += '${JSON.stringify(schema.const).replace(SINGLE_TICK, "\\'")}'`;
    if (hasNullType) {
      code += `
      }
    `;
    }
    return code;
  };
  var buildAllOf = function(context, location, input) {
    const schema = location.schema;
    let mergedSchemaId = context.mergedSchemasIds.get(schema);
    if (mergedSchemaId) {
      const mergedLocation2 = getMergedLocation(context, mergedSchemaId);
      return buildValue(context, mergedLocation2, input);
    }
    mergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
    context.mergedSchemasIds.set(schema, mergedSchemaId);
    const { allOf, ...schemaWithoutAllOf } = location.schema;
    const locations = [
      new Location(schemaWithoutAllOf, location.schemaId, location.jsonPointer)
    ];
    const allOfsLocation = location.getPropertyLocation("allOf");
    for (let i = 0;i < allOf.length; i++) {
      locations.push(allOfsLocation.getPropertyLocation(i));
    }
    const mergedLocation = mergeLocations(context, mergedSchemaId, locations);
    return buildValue(context, mergedLocation, input);
  };
  var buildOneOf = function(context, location, input) {
    context.validatorSchemasIds.add(location.schemaId);
    const schema = location.schema;
    const type = schema.anyOf ? "anyOf" : "oneOf";
    const { [type]: oneOfs, ...schemaWithoutAnyOf } = location.schema;
    const locationWithoutOneOf = new Location(schemaWithoutAnyOf, location.schemaId, location.jsonPointer);
    const oneOfsLocation = location.getPropertyLocation(type);
    let code = "";
    for (let index2 = 0;index2 < oneOfs.length; index2++) {
      const optionLocation = oneOfsLocation.getPropertyLocation(index2);
      const optionSchema = optionLocation.schema;
      let mergedSchemaId = context.mergedSchemasIds.get(optionSchema);
      let mergedLocation = null;
      if (mergedSchemaId) {
        mergedLocation = getMergedLocation(context, mergedSchemaId);
      } else {
        mergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
        context.mergedSchemasIds.set(optionSchema, mergedSchemaId);
        mergedLocation = mergeLocations(context, mergedSchemaId, [
          locationWithoutOneOf,
          optionLocation
        ]);
      }
      const nestedResult = buildValue(context, mergedLocation, input);
      const schemaRef2 = optionLocation.getSchemaRef();
      code += `
      ${index2 === 0 ? "if" : "else if"}(validator.validate("${schemaRef2}", ${input}))
        ${nestedResult}
    `;
    }
    let schemaRef = location.getSchemaRef();
    if (schemaRef.startsWith(context.rootSchemaId)) {
      schemaRef = schemaRef.replace(context.rootSchemaId, "");
    }
    code += `
    else throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
  `;
    return code;
  };
  var buildIfThenElse = function(context, location, input) {
    context.validatorSchemasIds.add(location.schemaId);
    const {
      if: ifSchema,
      then: thenSchema,
      else: elseSchema,
      ...schemaWithoutIfThenElse
    } = location.schema;
    const rootLocation = new Location(schemaWithoutIfThenElse, location.schemaId, location.jsonPointer);
    const ifLocation = location.getPropertyLocation("if");
    const ifSchemaRef = ifLocation.getSchemaRef();
    const thenLocation = location.getPropertyLocation("then");
    let thenMergedSchemaId = context.mergedSchemasIds.get(thenSchema);
    let thenMergedLocation = null;
    if (thenMergedSchemaId) {
      thenMergedLocation = getMergedLocation(context, thenMergedSchemaId);
    } else {
      thenMergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
      context.mergedSchemasIds.set(thenSchema, thenMergedSchemaId);
      thenMergedLocation = mergeLocations(context, thenMergedSchemaId, [
        rootLocation,
        thenLocation
      ]);
    }
    if (!elseSchema) {
      return `
      if (validator.validate("${ifSchemaRef}", ${input})) {
        ${buildValue(context, thenMergedLocation, input)}
      } else {
        ${buildValue(context, rootLocation, input)}
      }
    `;
    }
    const elseLocation = location.getPropertyLocation("else");
    let elseMergedSchemaId = context.mergedSchemasIds.get(elseSchema);
    let elseMergedLocation = null;
    if (elseMergedSchemaId) {
      elseMergedLocation = getMergedLocation(context, elseMergedSchemaId);
    } else {
      elseMergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
      context.mergedSchemasIds.set(elseSchema, elseMergedSchemaId);
      elseMergedLocation = mergeLocations(context, elseMergedSchemaId, [
        rootLocation,
        elseLocation
      ]);
    }
    return `
    if (validator.validate("${ifSchemaRef}", ${input})) {
      ${buildValue(context, thenMergedLocation, input)}
    } else {
      ${buildValue(context, elseMergedLocation, input)}
    }
  `;
  };
  var buildValue = function(context, location, input) {
    let schema = location.schema;
    if (typeof schema === "boolean") {
      return `json += JSON.stringify(${input})`;
    }
    if (schema.$ref) {
      location = resolveRef(context, location);
      schema = location.schema;
    }
    if (schema.allOf) {
      return buildAllOf(context, location, input);
    }
    if (schema.anyOf || schema.oneOf) {
      return buildOneOf(context, location, input);
    }
    if (schema.if && schema.then) {
      return buildIfThenElse(context, location, input);
    }
    if (schema.type === undefined) {
      const inferredType = inferTypeByKeyword(schema);
      if (inferredType) {
        schema.type = inferredType;
      }
    }
    let code = "";
    const type = schema.type;
    const nullable = schema.nullable === true;
    if (nullable) {
      code += `
      if (${input} === null) {
        json += 'null'
      } else {
    `;
    }
    if (schema.const !== undefined) {
      code += buildConstSerializer(location, input);
    } else if (Array.isArray(type)) {
      code += buildMultiTypeSerializer(context, location, input);
    } else {
      code += buildSingleTypeSerializer(context, location, input);
    }
    if (nullable) {
      code += `
      }
    `;
    }
    return code;
  };
  var { RefResolver } = require_json_schema_ref_resolver();
  var Serializer = require_serializer();
  var Validator = require_validator2();
  var Location = require_location();
  var validate = require_schema_validator();
  var mergeSchemas = require_merge_schemas();
  var SINGLE_TICK = /'/g;
  var largeArraySize = 20000;
  var largeArrayMechanism = "default";
  var validRoundingMethods = [
    "floor",
    "ceil",
    "round",
    "trunc"
  ];
  var validLargeArrayMechanisms = [
    "default",
    "json-stringify"
  ];
  var schemaIdCounter = 0;
  var objectKeywords = [
    "properties",
    "required",
    "additionalProperties",
    "patternProperties",
    "maxProperties",
    "minProperties",
    "dependencies"
  ];
  var arrayKeywords = [
    "items",
    "additionalItems",
    "maxItems",
    "minItems",
    "uniqueItems",
    "contains"
  ];
  var stringKeywords = [
    "maxLength",
    "minLength",
    "pattern"
  ];
  var numberKeywords = [
    "multipleOf",
    "maximum",
    "exclusiveMaximum",
    "minimum",
    "exclusiveMinimum"
  ];
  module.exports = build;
  module.exports.default = build;
  module.exports.build = build;
  module.exports.validLargeArrayMechanisms = validLargeArrayMechanisms;
  module.exports.restore = function({ code, validator, serializer }) {
    return Function.apply(null, ["validator", "serializer", code]).apply(null, [validator, serializer]);
  };
});

// ../node_modules/.pnpm/@fastify+fast-json-stringify-compiler@4.3.0/node_modules/@fastify/fast-json-stringify-compiler/standalone.js
var require_standalone2 = __commonJS((exports, module) => {
  var StandaloneSerializer = function(options = { readMode: true }) {
    if (options.readMode === true && typeof options.restoreFunction !== "function") {
      throw new Error("You must provide a function for the restoreFunction-option when readMode ON");
    }
    if (options.readMode !== true && typeof options.storeFunction !== "function") {
      throw new Error("You must provide a function for the storeFunction-option when readMode OFF");
    }
    if (options.readMode === true) {
      return function wrapper() {
        return function(opts) {
          return options.restoreFunction(opts);
        };
      };
    }
    const factory = SerializerSelector();
    return function wrapper(externalSchemas, serializerOpts = {}) {
      serializerOpts.mode = "standalone";
      const compiler = factory(externalSchemas, serializerOpts);
      return function(opts) {
        const serializeFuncCode = compiler(opts);
        options.storeFunction(opts, serializeFuncCode);
        return new Function(serializeFuncCode);
      };
    };
  };
  var SerializerSelector = require_fast_json_stringify_compiler();
  module.exports = StandaloneSerializer;
  module.exports.default = StandaloneSerializer;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fastify@4.26.0/node_modules/@fastify/fast-json-stringify-compiler/index.js
var require_fast_json_stringify_compiler = __commonJS((exports, module) => {
  var SerializerSelector = function() {
    return function buildSerializerFactory(externalSchemas, serializerOpts) {
      const fjsOpts = Object.assign({}, serializerOpts, { schema: externalSchemas });
      return responseSchemaCompiler.bind(null, fjsOpts);
    };
  };
  var responseSchemaCompiler = function(fjsOpts, { schema }) {
    if (fjsOpts.schema && schema.$id && fjsOpts.schema[schema.$id]) {
      fjsOpts.schema = { ...fjsOpts.schema };
      delete fjsOpts.schema[schema.$id];
    }
    return fastJsonStringify(schema, fjsOpts);
  };
  var fastJsonStringify = require_fast_json_stringify();
  module.exports = SerializerSelector;
  module.exports.default = SerializerSelector;
  module.exports.SerializerSelector = SerializerSelector;
  module.exports.StandaloneSerializer = require_standalone2();
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/jtd/metadata.js
var require_metadata4 = __commonJS((exports) => {
  var checkMetadata = function({ it, keyword }, metadata) {
    if (it.jtdMetadata !== metadata) {
      throw new Error(`JTD: "${keyword}" cannot be used in this schema location`);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkMetadata = undefined;
  var util_1 = require_util3();
  var def = {
    keyword: "metadata",
    schemaType: "object",
    code(cxt) {
      checkMetadata(cxt);
      const { gen: gen2, schema, it } = cxt;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      const valid = gen2.name("valid");
      cxt.subschema({ keyword: "metadata", jtdMetadata: true }, valid);
      cxt.ok(valid);
    }
  };
  exports.checkMetadata = checkMetadata;
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/jtd/ref.js
var require_ref2 = __commonJS((exports) => {
  var hasRef = function(schema) {
    for (const key in schema) {
      let sch;
      if (key === "ref" || typeof (sch = schema[key]) == "object" && hasRef(sch))
        return true;
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasRef = undefined;
  var compile_1 = require_compile();
  var codegen_1 = require_codegen();
  var ref_error_1 = require_ref_error();
  var names_1 = require_names();
  var ref_1 = require_ref();
  var metadata_1 = require_metadata4();
  var def = {
    keyword: "ref",
    schemaType: "string",
    code(cxt) {
      (0, metadata_1.checkMetadata)(cxt);
      const { gen: gen2, data: data3, schema: ref, parentSchema, it } = cxt;
      const { schemaEnv: { root } } = it;
      const valid = gen2.name("valid");
      if (parentSchema.nullable) {
        gen2.var(valid, (0, codegen_1._)`${data3} === null`);
        gen2.if((0, codegen_1.not)(valid), validateJtdRef);
      } else {
        gen2.var(valid, false);
        validateJtdRef();
      }
      cxt.ok(valid);
      function validateJtdRef() {
        var _a2;
        const refSchema = (_a2 = root.schema.definitions) === null || _a2 === undefined ? undefined : _a2[ref];
        if (!refSchema) {
          throw new ref_error_1.default(it.opts.uriResolver, "", ref, `No definition ${ref}`);
        }
        if (hasRef(refSchema) || !it.opts.inlineRefs)
          callValidate(refSchema);
        else
          inlineRefSchema(refSchema);
      }
      function callValidate(schema) {
        const sch = compile_1.compileSchema.call(it.self, new compile_1.SchemaEnv({ schema, root, schemaPath: `/definitions/${ref}` }));
        const v = (0, ref_1.getValidate)(cxt, sch);
        const errsCount = gen2.const("_errs", names_1.default.errors);
        (0, ref_1.callRef)(cxt, v, sch, sch.$async);
        gen2.assign(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
      }
      function inlineRefSchema(schema) {
        const schName = gen2.scopeValue("schema", it.opts.code.source === true ? { ref: schema, code: (0, codegen_1.stringify)(schema) } : { ref: schema });
        cxt.subschema({
          schema,
          dataTypes: [],
          schemaPath: codegen_1.nil,
          topSchemaRef: schName,
          errSchemaPath: `/definitions/${ref}`
        }, valid);
      }
    }
  };
  exports.hasRef = hasRef;
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/runtime/timestamp.js
var require_timestamp = __commonJS((exports) => {
  var validTimestamp = function(str, allowDate) {
    const dt = str.split(DT_SEPARATOR);
    return dt.length === 2 && validDate(dt[0]) && validTime(dt[1]) || allowDate && dt.length === 1 && validDate(dt[0]);
  };
  var validDate = function(str) {
    const matches = DATE.exec(str);
    if (!matches)
      return false;
    const y = +matches[1];
    const m = +matches[2];
    const d = +matches[3];
    return m >= 1 && m <= 12 && d >= 1 && (d <= DAYS[m] || m === 2 && d === 29 && (y % 100 === 0 ? y % 400 === 0 : y % 4 === 0));
  };
  var validTime = function(str) {
    const matches = TIME.exec(str);
    if (!matches)
      return false;
    const hr = +matches[1];
    const min = +matches[2];
    const sec = +matches[3];
    const tzH = +(matches[4] || 0);
    const tzM = +(matches[5] || 0);
    return hr <= 23 && min <= 59 && sec <= 59 || hr - tzH === 23 && min - tzM === 59 && sec === 60;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var DT_SEPARATOR = /t|\s/i;
  var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  var TIME = /^(\d\d):(\d\d):(\d\d)(?:\.\d+)?(?:z|([+-]\d\d)(?::?(\d\d))?)$/i;
  var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  exports.default = validTimestamp;
  validTimestamp.code = 'require("ajv/dist/runtime/timestamp").default';
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/jtd/error.js
var require_error3 = __commonJS((exports) => {
  var typeError = function(t) {
    return {
      message: (cxt) => typeErrorMessage(cxt, t),
      params: (cxt) => typeErrorParams(cxt, t)
    };
  };
  var typeErrorMessage = function({ parentSchema }, t) {
    return (parentSchema === null || parentSchema === undefined ? undefined : parentSchema.nullable) ? `must be ${t} or null` : `must be ${t}`;
  };
  var typeErrorParams = function({ parentSchema }, t) {
    return (0, codegen_1._)`{type: ${t}, nullable: ${!!(parentSchema === null || parentSchema === undefined ? undefined : parentSchema.nullable)}}`;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.typeErrorParams = exports.typeErrorMessage = exports.typeError = undefined;
  var codegen_1 = require_codegen();
  exports.typeError = typeError;
  exports.typeErrorMessage = typeErrorMessage;
  exports.typeErrorParams = typeErrorParams;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/jtd/type.js
var require_type = __commonJS((exports) => {
  var timestampCode = function(cxt) {
    const { gen: gen2, data: data3, it } = cxt;
    const { timestamp, allowDate } = it.opts;
    if (timestamp === "date")
      return (0, codegen_1._)`${data3} instanceof Date `;
    const vts = (0, util_1.useFunc)(gen2, timestamp_1.default);
    const allowDateArg = allowDate ? (0, codegen_1._)`, true` : codegen_1.nil;
    const validString = (0, codegen_1._)`typeof ${data3} == "string" && ${vts}(${data3}${allowDateArg})`;
    return timestamp === "string" ? validString : (0, codegen_1.or)((0, codegen_1._)`${data3} instanceof Date`, validString);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.intRange = undefined;
  var codegen_1 = require_codegen();
  var timestamp_1 = require_timestamp();
  var util_1 = require_util3();
  var metadata_1 = require_metadata4();
  var error_1 = require_error3();
  exports.intRange = {
    int8: [-128, 127, 3],
    uint8: [0, 255, 3],
    int16: [-32768, 32767, 5],
    uint16: [0, 65535, 5],
    int32: [-2147483648, 2147483647, 10],
    uint32: [0, 4294967295, 10]
  };
  var error = {
    message: (cxt) => (0, error_1.typeErrorMessage)(cxt, cxt.schema),
    params: (cxt) => (0, error_1.typeErrorParams)(cxt, cxt.schema)
  };
  var def = {
    keyword: "type",
    schemaType: "string",
    error,
    code(cxt) {
      (0, metadata_1.checkMetadata)(cxt);
      const { data: data3, schema, parentSchema, it } = cxt;
      let cond;
      switch (schema) {
        case "boolean":
        case "string":
          cond = (0, codegen_1._)`typeof ${data3} == ${schema}`;
          break;
        case "timestamp": {
          cond = timestampCode(cxt);
          break;
        }
        case "float32":
        case "float64":
          cond = (0, codegen_1._)`typeof ${data3} == "number"`;
          break;
        default: {
          const sch = schema;
          cond = (0, codegen_1._)`typeof ${data3} == "number" && isFinite(${data3}) && !(${data3} % 1)`;
          if (!it.opts.int32range && (sch === "int32" || sch === "uint32")) {
            if (sch === "uint32")
              cond = (0, codegen_1._)`${cond} && ${data3} >= 0`;
          } else {
            const [min, max] = exports.intRange[sch];
            cond = (0, codegen_1._)`${cond} && ${data3} >= ${min} && ${data3} <= ${max}`;
          }
        }
      }
      cxt.pass(parentSchema.nullable ? (0, codegen_1.or)((0, codegen_1._)`${data3} === null`, cond) : cond);
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/jtd/nullable.js
var require_nullable = __commonJS((exports) => {
  var checkNullable = function({ gen: gen2, data: data3, parentSchema }, cond = codegen_1.nil) {
    const valid = gen2.name("valid");
    if (parentSchema.nullable) {
      gen2.let(valid, (0, codegen_1._)`${data3} === null`);
      cond = (0, codegen_1.not)(valid);
    } else {
      gen2.let(valid, false);
    }
    return [valid, cond];
  };
  var checkNullableObject = function(cxt, cond) {
    const [valid, cond_] = checkNullable(cxt, cond);
    return [valid, (0, codegen_1._)`${cond_} && typeof ${cxt.data} == "object" && !Array.isArray(${cxt.data})`];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkNullableObject = exports.checkNullable = undefined;
  var codegen_1 = require_codegen();
  exports.checkNullable = checkNullable;
  exports.checkNullableObject = checkNullableObject;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/jtd/enum.js
var require_enum2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var metadata_1 = require_metadata4();
  var nullable_1 = require_nullable();
  var error = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
  };
  var def = {
    keyword: "enum",
    schemaType: "array",
    error,
    code(cxt) {
      (0, metadata_1.checkMetadata)(cxt);
      const { gen: gen2, data: data3, schema, schemaValue, parentSchema, it } = cxt;
      if (schema.length === 0)
        throw new Error("enum must have non-empty array");
      if (schema.length !== new Set(schema).size)
        throw new Error("enum items must be unique");
      let valid;
      const isString = (0, codegen_1._)`typeof ${data3} == "string"`;
      if (schema.length >= it.opts.loopEnum) {
        let cond;
        [valid, cond] = (0, nullable_1.checkNullable)(cxt, isString);
        gen2.if(cond, loopEnum);
      } else {
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        valid = (0, codegen_1.and)(isString, (0, codegen_1.or)(...schema.map((value) => (0, codegen_1._)`${data3} === ${value}`)));
        if (parentSchema.nullable)
          valid = (0, codegen_1.or)((0, codegen_1._)`${data3} === null`, valid);
      }
      cxt.pass(valid);
      function loopEnum() {
        gen2.forOf("v", schemaValue, (v) => gen2.if((0, codegen_1._)`${valid} = ${data3} === ${v}`, () => gen2.break()));
      }
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/jtd/elements.js
var require_elements = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util3();
  var code_1 = require_code2();
  var codegen_1 = require_codegen();
  var metadata_1 = require_metadata4();
  var nullable_1 = require_nullable();
  var error_1 = require_error3();
  var def = {
    keyword: "elements",
    schemaType: "object",
    error: (0, error_1.typeError)("array"),
    code(cxt) {
      (0, metadata_1.checkMetadata)(cxt);
      const { gen: gen2, data: data3, schema, it } = cxt;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      const [valid] = (0, nullable_1.checkNullable)(cxt);
      gen2.if((0, codegen_1.not)(valid), () => gen2.if((0, codegen_1._)`Array.isArray(${data3})`, () => gen2.assign(valid, (0, code_1.validateArray)(cxt)), () => cxt.error()));
      cxt.ok(valid);
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/jtd/properties.js
var require_properties2 = __commonJS((exports) => {
  var validateProperties = function(cxt) {
    (0, metadata_1.checkMetadata)(cxt);
    const { gen: gen2, data: data3, parentSchema, it } = cxt;
    const { additionalProperties, nullable } = parentSchema;
    if (it.jtdDiscriminator && nullable)
      throw new Error("JTD: nullable inside discriminator mapping");
    if (commonProperties()) {
      throw new Error("JTD: properties and optionalProperties have common members");
    }
    const [allProps, properties] = schemaProperties("properties");
    const [allOptProps, optProperties] = schemaProperties("optionalProperties");
    if (properties.length === 0 && optProperties.length === 0 && additionalProperties) {
      return;
    }
    const [valid, cond] = it.jtdDiscriminator === undefined ? (0, nullable_1.checkNullableObject)(cxt, data3) : [gen2.let("valid", false), true];
    gen2.if(cond, () => gen2.assign(valid, true).block(() => {
      validateProps(properties, "properties", true);
      validateProps(optProperties, "optionalProperties");
      if (!additionalProperties)
        validateAdditional();
    }));
    cxt.pass(valid);
    function commonProperties() {
      const props = parentSchema.properties;
      const optProps = parentSchema.optionalProperties;
      if (!(props && optProps))
        return false;
      for (const p in props) {
        if (Object.prototype.hasOwnProperty.call(optProps, p))
          return true;
      }
      return false;
    }
    function schemaProperties(keyword) {
      const schema = parentSchema[keyword];
      const allPs = schema ? (0, code_1.allSchemaProperties)(schema) : [];
      if (it.jtdDiscriminator && allPs.some((p) => p === it.jtdDiscriminator)) {
        throw new Error(`JTD: discriminator tag used in ${keyword}`);
      }
      const ps = allPs.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
      return [allPs, ps];
    }
    function validateProps(props, keyword, required) {
      const _valid = gen2.var("valid");
      for (const prop of props) {
        gen2.if((0, code_1.propertyInData)(gen2, data3, prop, it.opts.ownProperties), () => applyPropertySchema(prop, keyword, _valid), () => missingProperty(prop));
        cxt.ok(_valid);
      }
      function missingProperty(prop) {
        if (required) {
          gen2.assign(_valid, false);
          cxt.error(false, { propError: PropError.Missing, missingProperty: prop }, { schemaPath: prop });
        } else {
          gen2.assign(_valid, true);
        }
      }
    }
    function applyPropertySchema(prop, keyword, _valid) {
      cxt.subschema({
        keyword,
        schemaProp: prop,
        dataProp: prop
      }, _valid);
    }
    function validateAdditional() {
      gen2.forIn("key", data3, (key) => {
        const addProp = isAdditional(key, allProps, "properties", it.jtdDiscriminator);
        const addOptProp = isAdditional(key, allOptProps, "optionalProperties");
        const extra = addProp === true ? addOptProp : addOptProp === true ? addProp : (0, codegen_1.and)(addProp, addOptProp);
        gen2.if(extra, () => {
          if (it.opts.removeAdditional) {
            gen2.code((0, codegen_1._)`delete ${data3}[${key}]`);
          } else {
            cxt.error(false, { propError: PropError.Additional, additionalProperty: key }, { instancePath: key, parentSchema: true });
            if (!it.opts.allErrors)
              gen2.break();
          }
        });
      });
    }
    function isAdditional(key, props, keyword, jtdDiscriminator) {
      let additional;
      if (props.length > 8) {
        const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema[keyword], keyword);
        additional = (0, codegen_1.not)((0, code_1.isOwnProperty)(gen2, propsSchema, key));
        if (jtdDiscriminator !== undefined) {
          additional = (0, codegen_1.and)(additional, (0, codegen_1._)`${key} !== ${jtdDiscriminator}`);
        }
      } else if (props.length || jtdDiscriminator !== undefined) {
        const ps = jtdDiscriminator === undefined ? props : [jtdDiscriminator].concat(props);
        additional = (0, codegen_1.and)(...ps.map((p) => (0, codegen_1._)`${key} !== ${p}`));
      } else {
        additional = true;
      }
      return additional;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateProperties = exports.error = undefined;
  var code_1 = require_code2();
  var util_1 = require_util3();
  var codegen_1 = require_codegen();
  var metadata_1 = require_metadata4();
  var nullable_1 = require_nullable();
  var error_1 = require_error3();
  var PropError;
  (function(PropError2) {
    PropError2["Additional"] = "additional";
    PropError2["Missing"] = "missing";
  })(PropError || (PropError = {}));
  exports.error = {
    message: (cxt) => {
      const { params } = cxt;
      return params.propError ? params.propError === PropError.Additional ? "must NOT have additional properties" : `must have property '${params.missingProperty}'` : (0, error_1.typeErrorMessage)(cxt, "object");
    },
    params: (cxt) => {
      const { params } = cxt;
      return params.propError ? params.propError === PropError.Additional ? (0, codegen_1._)`{error: ${params.propError}, additionalProperty: ${params.additionalProperty}}` : (0, codegen_1._)`{error: ${params.propError}, missingProperty: ${params.missingProperty}}` : (0, error_1.typeErrorParams)(cxt, "object");
    }
  };
  var def = {
    keyword: "properties",
    schemaType: "object",
    error: exports.error,
    code: validateProperties
  };
  exports.validateProperties = validateProperties;
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/jtd/optionalProperties.js
var require_optionalProperties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var properties_1 = require_properties2();
  var def = {
    keyword: "optionalProperties",
    schemaType: "object",
    error: properties_1.error,
    code(cxt) {
      if (cxt.parentSchema.properties)
        return;
      (0, properties_1.validateProperties)(cxt);
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/jtd/discriminator.js
var require_discriminator2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var metadata_1 = require_metadata4();
  var nullable_1 = require_nullable();
  var error_1 = require_error3();
  var types_1 = require_types3();
  var error = {
    message: (cxt) => {
      const { schema, params } = cxt;
      return params.discrError ? params.discrError === types_1.DiscrError.Tag ? `tag "${schema}" must be string` : `value of tag "${schema}" must be in mapping` : (0, error_1.typeErrorMessage)(cxt, "object");
    },
    params: (cxt) => {
      const { schema, params } = cxt;
      return params.discrError ? (0, codegen_1._)`{error: ${params.discrError}, tag: ${schema}, tagValue: ${params.tag}}` : (0, error_1.typeErrorParams)(cxt, "object");
    }
  };
  var def = {
    keyword: "discriminator",
    schemaType: "string",
    implements: ["mapping"],
    error,
    code(cxt) {
      (0, metadata_1.checkMetadata)(cxt);
      const { gen: gen2, data: data3, schema, parentSchema } = cxt;
      const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data3);
      gen2.if(cond);
      validateDiscriminator();
      gen2.elseIf((0, codegen_1.not)(valid));
      cxt.error();
      gen2.endIf();
      cxt.ok(valid);
      function validateDiscriminator() {
        const tag = gen2.const("tag", (0, codegen_1._)`${data3}${(0, codegen_1.getProperty)(schema)}`);
        gen2.if((0, codegen_1._)`${tag} === undefined`);
        cxt.error(false, { discrError: types_1.DiscrError.Tag, tag });
        gen2.elseIf((0, codegen_1._)`typeof ${tag} == "string"`);
        validateMapping(tag);
        gen2.else();
        cxt.error(false, { discrError: types_1.DiscrError.Tag, tag }, { instancePath: schema });
        gen2.endIf();
      }
      function validateMapping(tag) {
        gen2.if(false);
        for (const tagValue in parentSchema.mapping) {
          gen2.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
          gen2.assign(valid, applyTagSchema(tagValue));
        }
        gen2.else();
        cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag }, { instancePath: schema, schemaPath: "mapping", parentSchema: true });
        gen2.endIf();
      }
      function applyTagSchema(schemaProp) {
        const _valid = gen2.name("valid");
        cxt.subschema({
          keyword: "mapping",
          schemaProp,
          jtdDiscriminator: schema
        }, _valid);
        return _valid;
      }
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/jtd/values.js
var require_values = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util3();
  var codegen_1 = require_codegen();
  var metadata_1 = require_metadata4();
  var nullable_1 = require_nullable();
  var error_1 = require_error3();
  var def = {
    keyword: "values",
    schemaType: "object",
    error: (0, error_1.typeError)("object"),
    code(cxt) {
      (0, metadata_1.checkMetadata)(cxt);
      const { gen: gen2, data: data3, schema, it } = cxt;
      const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data3);
      if ((0, util_1.alwaysValidSchema)(it, schema)) {
        gen2.if((0, codegen_1.not)((0, codegen_1.or)(cond, valid)), () => cxt.error());
      } else {
        gen2.if(cond);
        gen2.assign(valid, validateMap());
        gen2.elseIf((0, codegen_1.not)(valid));
        cxt.error();
        gen2.endIf();
      }
      cxt.ok(valid);
      function validateMap() {
        const _valid = gen2.name("valid");
        if (it.allErrors) {
          const validMap = gen2.let("valid", true);
          validateValues(() => gen2.assign(validMap, false));
          return validMap;
        }
        gen2.var(_valid, true);
        validateValues(() => gen2.break());
        return _valid;
        function validateValues(notValid) {
          gen2.forIn("key", data3, (key) => {
            cxt.subschema({
              keyword: "values",
              dataProp: key,
              dataPropType: util_1.Type.Str
            }, _valid);
            gen2.if((0, codegen_1.not)(_valid), notValid);
          });
        }
      }
    }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/jtd/union.js
var require_union = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code2();
  var def = {
    keyword: "union",
    schemaType: "array",
    trackErrors: true,
    code: code_1.validateUnion,
    error: { message: "must match a schema in union" }
  };
  exports.default = def;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/jtd/index.js
var require_jtd = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var ref_1 = require_ref2();
  var type_1 = require_type();
  var enum_1 = require_enum2();
  var elements_1 = require_elements();
  var properties_1 = require_properties2();
  var optionalProperties_1 = require_optionalProperties();
  var discriminator_1 = require_discriminator2();
  var values_1 = require_values();
  var union_1 = require_union();
  var metadata_1 = require_metadata4();
  var jtdVocabulary = [
    "definitions",
    ref_1.default,
    type_1.default,
    enum_1.default,
    elements_1.default,
    properties_1.default,
    optionalProperties_1.default,
    discriminator_1.default,
    values_1.default,
    union_1.default,
    metadata_1.default,
    { keyword: "additionalProperties", schemaType: "boolean" },
    { keyword: "nullable", schemaType: "boolean" }
  ];
  exports.default = jtdVocabulary;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/refs/jtd-schema.js
var require_jtd_schema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var shared = (root) => {
    const sch = {
      nullable: { type: "boolean" },
      metadata: {
        optionalProperties: {
          union: { elements: { ref: "schema" } }
        },
        additionalProperties: true
      }
    };
    if (root)
      sch.definitions = { values: { ref: "schema" } };
    return sch;
  };
  var emptyForm = (root) => ({
    optionalProperties: shared(root)
  });
  var refForm = (root) => ({
    properties: {
      ref: { type: "string" }
    },
    optionalProperties: shared(root)
  });
  var typeForm = (root) => ({
    properties: {
      type: {
        enum: [
          "boolean",
          "timestamp",
          "string",
          "float32",
          "float64",
          "int8",
          "uint8",
          "int16",
          "uint16",
          "int32",
          "uint32"
        ]
      }
    },
    optionalProperties: shared(root)
  });
  var enumForm = (root) => ({
    properties: {
      enum: { elements: { type: "string" } }
    },
    optionalProperties: shared(root)
  });
  var elementsForm = (root) => ({
    properties: {
      elements: { ref: "schema" }
    },
    optionalProperties: shared(root)
  });
  var propertiesForm = (root) => ({
    properties: {
      properties: { values: { ref: "schema" } }
    },
    optionalProperties: {
      optionalProperties: { values: { ref: "schema" } },
      additionalProperties: { type: "boolean" },
      ...shared(root)
    }
  });
  var optionalPropertiesForm = (root) => ({
    properties: {
      optionalProperties: { values: { ref: "schema" } }
    },
    optionalProperties: {
      additionalProperties: { type: "boolean" },
      ...shared(root)
    }
  });
  var discriminatorForm = (root) => ({
    properties: {
      discriminator: { type: "string" },
      mapping: {
        values: {
          metadata: {
            union: [propertiesForm(false), optionalPropertiesForm(false)]
          }
        }
      }
    },
    optionalProperties: shared(root)
  });
  var valuesForm = (root) => ({
    properties: {
      values: { ref: "schema" }
    },
    optionalProperties: shared(root)
  });
  var schema = (root) => ({
    metadata: {
      union: [
        emptyForm,
        refForm,
        typeForm,
        enumForm,
        elementsForm,
        propertiesForm,
        optionalPropertiesForm,
        discriminatorForm,
        valuesForm
      ].map((s) => s(root))
    }
  });
  var jtdMetaSchema = {
    definitions: {
      schema: schema(false)
    },
    ...schema(true)
  };
  exports.default = jtdMetaSchema;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/jtd/types.js
var require_types4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.jtdForms = undefined;
  exports.jtdForms = [
    "elements",
    "values",
    "discriminator",
    "properties",
    "optionalProperties",
    "enum",
    "type",
    "ref"
  ];
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/runtime/quote.js
var require_quote = __commonJS((exports) => {
  var quote = function(s) {
    rxEscapable.lastIndex = 0;
    return '"' + (rxEscapable.test(s) ? s.replace(rxEscapable, (a) => {
      const c = escaped[a];
      return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
    }) : s) + '"';
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var rxEscapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
  var escaped = {
    "\b": "\\b",
    "\t": "\\t",
    "\n": "\\n",
    "\f": "\\f",
    "\r": "\\r",
    '"': '\\"',
    "\\": "\\\\"
  };
  exports.default = quote;
  quote.code = 'require("ajv/dist/runtime/quote").default';
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/jtd/serialize.js
var require_serialize = __commonJS((exports) => {
  var compileSerializer = function(sch, definitions) {
    const _sch = __1.getCompilingSchema.call(this, sch);
    if (_sch)
      return _sch;
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen2 = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    const serializeName = gen2.scopeName("serialize");
    const cxt = {
      self: this,
      gen: gen2,
      schema: sch.schema,
      schemaEnv: sch,
      definitions,
      data: names_1.default.data
    };
    let sourceCode;
    try {
      this._compilations.add(sch);
      sch.serializeName = serializeName;
      gen2.func(serializeName, names_1.default.data, false, () => {
        gen2.let(names_1.default.json, (0, codegen_1.str)``);
        serializeCode(cxt);
        gen2.return(names_1.default.json);
      });
      gen2.optimize(this.opts.code.optimize);
      const serializeFuncCode = gen2.toString();
      sourceCode = `${gen2.scopeRefs(names_1.default.scope)}return ${serializeFuncCode}`;
      const makeSerialize = new Function(`${names_1.default.scope}`, sourceCode);
      const serialize = makeSerialize(this.scope.get());
      this.scope.value(serializeName, { ref: serialize });
      sch.serialize = serialize;
    } catch (e) {
      if (sourceCode)
        this.logger.error("Error compiling serializer, function code:", sourceCode);
      delete sch.serialize;
      delete sch.serializeName;
      throw e;
    } finally {
      this._compilations.delete(sch);
    }
    return sch;
  };
  var serializeCode = function(cxt) {
    let form;
    for (const key of types_1.jtdForms) {
      if (key in cxt.schema) {
        form = key;
        break;
      }
    }
    serializeNullable(cxt, form ? genSerialize[form] : serializeEmpty);
  };
  var serializeNullable = function(cxt, serializeForm) {
    const { gen: gen2, schema, data: data3 } = cxt;
    if (!schema.nullable)
      return serializeForm(cxt);
    gen2.if((0, codegen_1._)`${data3} === undefined || ${data3} === null`, () => gen2.add(names_1.default.json, (0, codegen_1._)`"null"`), () => serializeForm(cxt));
  };
  var serializeElements = function(cxt) {
    const { gen: gen2, schema, data: data3 } = cxt;
    gen2.add(names_1.default.json, (0, codegen_1.str)`[`);
    const first = gen2.let("first", true);
    gen2.forOf("el", data3, (el) => {
      addComma(cxt, first);
      serializeCode({ ...cxt, schema: schema.elements, data: el });
    });
    gen2.add(names_1.default.json, (0, codegen_1.str)`]`);
  };
  var serializeValues = function(cxt) {
    const { gen: gen2, schema, data: data3 } = cxt;
    gen2.add(names_1.default.json, (0, codegen_1.str)`{`);
    const first = gen2.let("first", true);
    gen2.forIn("key", data3, (key) => serializeKeyValue(cxt, key, schema.values, first));
    gen2.add(names_1.default.json, (0, codegen_1.str)`}`);
  };
  var serializeKeyValue = function(cxt, key, schema, first) {
    const { gen: gen2, data: data3 } = cxt;
    addComma(cxt, first);
    serializeString({ ...cxt, data: key });
    gen2.add(names_1.default.json, (0, codegen_1.str)`:`);
    const value = gen2.const("value", (0, codegen_1._)`${data3}${(0, codegen_1.getProperty)(key)}`);
    serializeCode({ ...cxt, schema, data: value });
  };
  var serializeDiscriminator = function(cxt) {
    const { gen: gen2, schema, data: data3 } = cxt;
    const { discriminator } = schema;
    gen2.add(names_1.default.json, (0, codegen_1.str)`{${JSON.stringify(discriminator)}:`);
    const tag = gen2.const("tag", (0, codegen_1._)`${data3}${(0, codegen_1.getProperty)(discriminator)}`);
    serializeString({ ...cxt, data: tag });
    gen2.if(false);
    for (const tagValue in schema.mapping) {
      gen2.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
      const sch = schema.mapping[tagValue];
      serializeSchemaProperties({ ...cxt, schema: sch }, discriminator);
    }
    gen2.endIf();
    gen2.add(names_1.default.json, (0, codegen_1.str)`}`);
  };
  var serializeProperties = function(cxt) {
    const { gen: gen2 } = cxt;
    gen2.add(names_1.default.json, (0, codegen_1.str)`{`);
    serializeSchemaProperties(cxt);
    gen2.add(names_1.default.json, (0, codegen_1.str)`}`);
  };
  var serializeSchemaProperties = function(cxt, discriminator) {
    const { gen: gen2, schema, data: data3 } = cxt;
    const { properties, optionalProperties } = schema;
    const props = keys(properties);
    const optProps = keys(optionalProperties);
    const allProps = allProperties(props.concat(optProps));
    let first = !discriminator;
    let firstProp;
    for (const key of props) {
      if (first)
        first = false;
      else
        gen2.add(names_1.default.json, (0, codegen_1.str)`,`);
      serializeProperty(key, properties[key], keyValue(key));
    }
    if (first)
      firstProp = gen2.let("first", true);
    for (const key of optProps) {
      const value = keyValue(key);
      gen2.if((0, codegen_1.and)((0, codegen_1._)`${value} !== undefined`, (0, code_1.isOwnProperty)(gen2, data3, key)), () => {
        addComma(cxt, firstProp);
        serializeProperty(key, optionalProperties[key], value);
      });
    }
    if (schema.additionalProperties) {
      gen2.forIn("key", data3, (key) => gen2.if(isAdditional(key, allProps), () => serializeKeyValue(cxt, key, {}, firstProp)));
    }
    function keys(ps) {
      return ps ? Object.keys(ps) : [];
    }
    function allProperties(ps) {
      if (discriminator)
        ps.push(discriminator);
      if (new Set(ps).size !== ps.length) {
        throw new Error("JTD: properties/optionalProperties/disciminator overlap");
      }
      return ps;
    }
    function keyValue(key) {
      return gen2.const("value", (0, codegen_1._)`${data3}${(0, codegen_1.getProperty)(key)}`);
    }
    function serializeProperty(key, propSchema, value) {
      gen2.add(names_1.default.json, (0, codegen_1.str)`${JSON.stringify(key)}:`);
      serializeCode({ ...cxt, schema: propSchema, data: value });
    }
    function isAdditional(key, ps) {
      return ps.length ? (0, codegen_1.and)(...ps.map((p) => (0, codegen_1._)`${key} !== ${p}`)) : true;
    }
  };
  var serializeType = function(cxt) {
    const { gen: gen2, schema, data: data3 } = cxt;
    switch (schema.type) {
      case "boolean":
        gen2.add(names_1.default.json, (0, codegen_1._)`${data3} ? "true" : "false"`);
        break;
      case "string":
        serializeString(cxt);
        break;
      case "timestamp":
        gen2.if((0, codegen_1._)`${data3} instanceof Date`, () => gen2.add(names_1.default.json, (0, codegen_1._)`'"' + ${data3}.toISOString() + '"'`), () => serializeString(cxt));
        break;
      default:
        serializeNumber(cxt);
    }
  };
  var serializeString = function({ gen: gen2, data: data3 }) {
    gen2.add(names_1.default.json, (0, codegen_1._)`${(0, util_1.useFunc)(gen2, quote_1.default)}(${data3})`);
  };
  var serializeNumber = function({ gen: gen2, data: data3 }) {
    gen2.add(names_1.default.json, (0, codegen_1._)`"" + ${data3}`);
  };
  var serializeRef = function(cxt) {
    const { gen: gen2, self: self2, data: data3, definitions, schema, schemaEnv } = cxt;
    const { ref } = schema;
    const refSchema = definitions[ref];
    if (!refSchema)
      throw new ref_error_1.default(self2.opts.uriResolver, "", ref, `No definition ${ref}`);
    if (!(0, ref_1.hasRef)(refSchema))
      return serializeCode({ ...cxt, schema: refSchema });
    const { root } = schemaEnv;
    const sch = compileSerializer.call(self2, new __1.SchemaEnv({ schema: refSchema, root }), definitions);
    gen2.add(names_1.default.json, (0, codegen_1._)`${getSerialize(gen2, sch)}(${data3})`);
  };
  var getSerialize = function(gen2, sch) {
    return sch.serialize ? gen2.scopeValue("serialize", { ref: sch.serialize }) : (0, codegen_1._)`${gen2.scopeValue("wrapper", { ref: sch })}.serialize`;
  };
  var serializeEmpty = function({ gen: gen2, data: data3 }) {
    gen2.add(names_1.default.json, (0, codegen_1._)`JSON.stringify(${data3})`);
  };
  var addComma = function({ gen: gen2 }, first) {
    if (first) {
      gen2.if(first, () => gen2.assign(first, false), () => gen2.add(names_1.default.json, (0, codegen_1.str)`,`));
    } else {
      gen2.add(names_1.default.json, (0, codegen_1.str)`,`);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var types_1 = require_types4();
  var __1 = require_compile();
  var codegen_1 = require_codegen();
  var ref_error_1 = require_ref_error();
  var names_1 = require_names();
  var code_1 = require_code2();
  var ref_1 = require_ref2();
  var util_1 = require_util3();
  var quote_1 = require_quote();
  var genSerialize = {
    elements: serializeElements,
    values: serializeValues,
    discriminator: serializeDiscriminator,
    properties: serializeProperties,
    optionalProperties: serializeProperties,
    enum: serializeString,
    type: serializeType,
    ref: serializeRef
  };
  exports.default = compileSerializer;
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/runtime/parseJson.js
var require_parseJson = __commonJS((exports) => {
  var parseJson = function(s, pos) {
    let endPos;
    parseJson.message = undefined;
    let matches;
    if (pos)
      s = s.slice(pos);
    try {
      parseJson.position = pos + s.length;
      return JSON.parse(s);
    } catch (e) {
      matches = rxParseJson.exec(e.message);
      if (!matches) {
        parseJson.message = "unexpected end";
        return;
      }
      endPos = +matches[1];
      const c = s[endPos];
      s = s.slice(0, endPos);
      parseJson.position = pos + endPos;
      try {
        return JSON.parse(s);
      } catch (e1) {
        parseJson.message = `unexpected token ${c}`;
        return;
      }
    }
  };
  var parseJsonNumber = function(s, pos, maxDigits) {
    let numStr = "";
    let c;
    parseJsonNumber.message = undefined;
    if (s[pos] === "-") {
      numStr += "-";
      pos++;
    }
    if (s[pos] === "0") {
      numStr += "0";
      pos++;
    } else {
      if (!parseDigits(maxDigits)) {
        errorMessage();
        return;
      }
    }
    if (maxDigits) {
      parseJsonNumber.position = pos;
      return +numStr;
    }
    if (s[pos] === ".") {
      numStr += ".";
      pos++;
      if (!parseDigits()) {
        errorMessage();
        return;
      }
    }
    if (c = s[pos], c === "e" || c === "E") {
      numStr += "e";
      pos++;
      if (c = s[pos], c === "+" || c === "-") {
        numStr += c;
        pos++;
      }
      if (!parseDigits()) {
        errorMessage();
        return;
      }
    }
    parseJsonNumber.position = pos;
    return +numStr;
    function parseDigits(maxLen) {
      let digit = false;
      while (c = s[pos], c >= "0" && c <= "9" && (maxLen === undefined || maxLen-- > 0)) {
        digit = true;
        numStr += c;
        pos++;
      }
      return digit;
    }
    function errorMessage() {
      parseJsonNumber.position = pos;
      parseJsonNumber.message = pos < s.length ? `unexpected token ${s[pos]}` : "unexpected end";
    }
  };
  var parseJsonString = function(s, pos) {
    let str = "";
    let c;
    parseJsonString.message = undefined;
    while (true) {
      c = s[pos++];
      if (c === '"')
        break;
      if (c === "\\") {
        c = s[pos];
        if (c in escapedChars) {
          str += escapedChars[c];
          pos++;
        } else if (c === "u") {
          pos++;
          let count = 4;
          let code = 0;
          while (count--) {
            code <<= 4;
            c = s[pos];
            if (c === undefined) {
              errorMessage("unexpected end");
              return;
            }
            c = c.toLowerCase();
            if (c >= "a" && c <= "f") {
              code += c.charCodeAt(0) - CODE_A + 10;
            } else if (c >= "0" && c <= "9") {
              code += c.charCodeAt(0) - CODE_0;
            } else {
              errorMessage(`unexpected token ${c}`);
              return;
            }
            pos++;
          }
          str += String.fromCharCode(code);
        } else {
          errorMessage(`unexpected token ${c}`);
          return;
        }
      } else if (c === undefined) {
        errorMessage("unexpected end");
        return;
      } else {
        if (c.charCodeAt(0) >= 32) {
          str += c;
        } else {
          errorMessage(`unexpected token ${c}`);
          return;
        }
      }
    }
    parseJsonString.position = pos;
    return str;
    function errorMessage(msg) {
      parseJsonString.position = pos;
      parseJsonString.message = msg;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseJsonString = exports.parseJsonNumber = exports.parseJson = undefined;
  var rxParseJson = /position\s(\d+)$/;
  exports.parseJson = parseJson;
  parseJson.message = undefined;
  parseJson.position = 0;
  parseJson.code = 'require("ajv/dist/runtime/parseJson").parseJson';
  exports.parseJsonNumber = parseJsonNumber;
  parseJsonNumber.message = undefined;
  parseJsonNumber.position = 0;
  parseJsonNumber.code = 'require("ajv/dist/runtime/parseJson").parseJsonNumber';
  var escapedChars = {
    b: "\b",
    f: "\f",
    n: "\n",
    r: "\r",
    t: "\t",
    '"': '"',
    "/": "/",
    "\\": "\\"
  };
  var CODE_A = "a".charCodeAt(0);
  var CODE_0 = "0".charCodeAt(0);
  exports.parseJsonString = parseJsonString;
  parseJsonString.message = undefined;
  parseJsonString.position = 0;
  parseJsonString.code = 'require("ajv/dist/runtime/parseJson").parseJsonString';
});

// ../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/jtd/parse.js
var require_parse3 = __commonJS((exports) => {
  var compileParser = function(sch, definitions) {
    const _sch = __1.getCompilingSchema.call(this, sch);
    if (_sch)
      return _sch;
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen2 = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    const parseName = gen2.scopeName("parse");
    const cxt = {
      self: this,
      gen: gen2,
      schema: sch.schema,
      schemaEnv: sch,
      definitions,
      data: names_1.default.data,
      parseName,
      char: gen2.name("c")
    };
    let sourceCode;
    try {
      this._compilations.add(sch);
      sch.parseName = parseName;
      parserFunction(cxt);
      gen2.optimize(this.opts.code.optimize);
      const parseFuncCode = gen2.toString();
      sourceCode = `${gen2.scopeRefs(names_1.default.scope)}return ${parseFuncCode}`;
      const makeParse = new Function(`${names_1.default.scope}`, sourceCode);
      const parse = makeParse(this.scope.get());
      this.scope.value(parseName, { ref: parse });
      sch.parse = parse;
    } catch (e) {
      if (sourceCode)
        this.logger.error("Error compiling parser, function code:", sourceCode);
      delete sch.parse;
      delete sch.parseName;
      throw e;
    } finally {
      this._compilations.delete(sch);
    }
    return sch;
  };
  var parserFunction = function(cxt) {
    const { gen: gen2, parseName, char } = cxt;
    gen2.func(parseName, (0, codegen_1._)`${names_1.default.json}, ${names_1.default.jsonPos}, ${names_1.default.jsonPart}`, false, () => {
      gen2.let(names_1.default.data);
      gen2.let(char);
      gen2.assign((0, codegen_1._)`${parseName}.message`, undef);
      gen2.assign((0, codegen_1._)`${parseName}.position`, undef);
      gen2.assign(names_1.default.jsonPos, (0, codegen_1._)`${names_1.default.jsonPos} || 0`);
      gen2.const(names_1.default.jsonLen, (0, codegen_1._)`${names_1.default.json}.length`);
      parseCode(cxt);
      skipWhitespace(cxt);
      gen2.if(names_1.default.jsonPart, () => {
        gen2.assign((0, codegen_1._)`${parseName}.position`, names_1.default.jsonPos);
        gen2.return(names_1.default.data);
      });
      gen2.if((0, codegen_1._)`${names_1.default.jsonPos} === ${names_1.default.jsonLen}`, () => gen2.return(names_1.default.data));
      jsonSyntaxError(cxt);
    });
  };
  var parseCode = function(cxt) {
    let form;
    for (const key of types_1.jtdForms) {
      if (key in cxt.schema) {
        form = key;
        break;
      }
    }
    if (form)
      parseNullable(cxt, genParse[form]);
    else
      parseEmpty(cxt);
  };
  var parseNullable = function(cxt, parseForm) {
    const { gen: gen2, schema, data: data3 } = cxt;
    if (!schema.nullable)
      return parseForm(cxt);
    tryParseToken(cxt, "null", parseForm, () => gen2.assign(data3, null));
  };
  var parseElements = function(cxt) {
    const { gen: gen2, schema, data: data3 } = cxt;
    parseToken(cxt, "[");
    const ix = gen2.let("i", 0);
    gen2.assign(data3, (0, codegen_1._)`[]`);
    parseItems(cxt, "]", () => {
      const el = gen2.let("el");
      parseCode({ ...cxt, schema: schema.elements, data: el });
      gen2.assign((0, codegen_1._)`${data3}[${ix}++]`, el);
    });
  };
  var parseValues = function(cxt) {
    const { gen: gen2, schema, data: data3 } = cxt;
    parseToken(cxt, "{");
    gen2.assign(data3, (0, codegen_1._)`{}`);
    parseItems(cxt, "}", () => parseKeyValue(cxt, schema.values));
  };
  var parseItems = function(cxt, endToken, block7) {
    tryParseItems(cxt, endToken, block7);
    parseToken(cxt, endToken);
  };
  var tryParseItems = function(cxt, endToken, block7) {
    const { gen: gen2 } = cxt;
    gen2.for((0, codegen_1._)`;${names_1.default.jsonPos}<${names_1.default.jsonLen} && ${jsonSlice(1)}!==${endToken};`, () => {
      block7();
      tryParseToken(cxt, ",", () => gen2.break(), hasItem);
    });
    function hasItem() {
      tryParseToken(cxt, endToken, () => {
      }, jsonSyntaxError);
    }
  };
  var parseKeyValue = function(cxt, schema) {
    const { gen: gen2 } = cxt;
    const key = gen2.let("key");
    parseString({ ...cxt, data: key });
    parseToken(cxt, ":");
    parsePropertyValue(cxt, key, schema);
  };
  var parseDiscriminator = function(cxt) {
    const { gen: gen2, data: data3, schema } = cxt;
    const { discriminator, mapping } = schema;
    parseToken(cxt, "{");
    gen2.assign(data3, (0, codegen_1._)`{}`);
    const startPos = gen2.const("pos", names_1.default.jsonPos);
    const value = gen2.let("value");
    const tag = gen2.let("tag");
    tryParseItems(cxt, "}", () => {
      const key = gen2.let("key");
      parseString({ ...cxt, data: key });
      parseToken(cxt, ":");
      gen2.if((0, codegen_1._)`${key} === ${discriminator}`, () => {
        parseString({ ...cxt, data: tag });
        gen2.assign((0, codegen_1._)`${data3}[${key}]`, tag);
        gen2.break();
      }, () => parseEmpty({ ...cxt, data: value }));
    });
    gen2.assign(names_1.default.jsonPos, startPos);
    gen2.if((0, codegen_1._)`${tag} === undefined`);
    parsingError(cxt, (0, codegen_1.str)`discriminator tag not found`);
    for (const tagValue in mapping) {
      gen2.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
      parseSchemaProperties({ ...cxt, schema: mapping[tagValue] }, discriminator);
    }
    gen2.else();
    parsingError(cxt, (0, codegen_1.str)`discriminator value not in schema`);
    gen2.endIf();
  };
  var parseProperties = function(cxt) {
    const { gen: gen2, data: data3 } = cxt;
    parseToken(cxt, "{");
    gen2.assign(data3, (0, codegen_1._)`{}`);
    parseSchemaProperties(cxt);
  };
  var parseSchemaProperties = function(cxt, discriminator) {
    const { gen: gen2, schema, data: data3 } = cxt;
    const { properties, optionalProperties, additionalProperties } = schema;
    parseItems(cxt, "}", () => {
      const key = gen2.let("key");
      parseString({ ...cxt, data: key });
      parseToken(cxt, ":");
      gen2.if(false);
      parseDefinedProperty(cxt, key, properties);
      parseDefinedProperty(cxt, key, optionalProperties);
      if (discriminator) {
        gen2.elseIf((0, codegen_1._)`${key} === ${discriminator}`);
        const tag = gen2.let("tag");
        parseString({ ...cxt, data: tag });
      }
      gen2.else();
      if (additionalProperties) {
        parseEmpty({ ...cxt, data: (0, codegen_1._)`${data3}[${key}]` });
      } else {
        parsingError(cxt, (0, codegen_1.str)`property ${key} not allowed`);
      }
      gen2.endIf();
    });
    if (properties) {
      const hasProp = (0, code_1.hasPropFunc)(gen2);
      const allProps = (0, codegen_1.and)(...Object.keys(properties).map((p) => (0, codegen_1._)`${hasProp}.call(${data3}, ${p})`));
      gen2.if((0, codegen_1.not)(allProps), () => parsingError(cxt, (0, codegen_1.str)`missing required properties`));
    }
  };
  var parseDefinedProperty = function(cxt, key, schemas5 = {}) {
    const { gen: gen2 } = cxt;
    for (const prop in schemas5) {
      gen2.elseIf((0, codegen_1._)`${key} === ${prop}`);
      parsePropertyValue(cxt, key, schemas5[prop]);
    }
  };
  var parsePropertyValue = function(cxt, key, schema) {
    parseCode({ ...cxt, schema, data: (0, codegen_1._)`${cxt.data}[${key}]` });
  };
  var parseType = function(cxt) {
    const { gen: gen2, schema, data: data3, self: self2 } = cxt;
    switch (schema.type) {
      case "boolean":
        parseBoolean(cxt);
        break;
      case "string":
        parseString(cxt);
        break;
      case "timestamp": {
        parseString(cxt);
        const vts = (0, util_1.useFunc)(gen2, timestamp_1.default);
        const { allowDate, parseDate } = self2.opts;
        const notValid = allowDate ? (0, codegen_1._)`!${vts}(${data3}, true)` : (0, codegen_1._)`!${vts}(${data3})`;
        const fail = parseDate ? (0, codegen_1.or)(notValid, (0, codegen_1._)`(${data3} = new Date(${data3}), false)`, (0, codegen_1._)`isNaN(${data3}.valueOf())`) : notValid;
        gen2.if(fail, () => parsingError(cxt, (0, codegen_1.str)`invalid timestamp`));
        break;
      }
      case "float32":
      case "float64":
        parseNumber(cxt);
        break;
      default: {
        const t = schema.type;
        if (!self2.opts.int32range && (t === "int32" || t === "uint32")) {
          parseNumber(cxt, 16);
          if (t === "uint32") {
            gen2.if((0, codegen_1._)`${data3} < 0`, () => parsingError(cxt, (0, codegen_1.str)`integer out of range`));
          }
        } else {
          const [min, max, maxDigits] = type_1.intRange[t];
          parseNumber(cxt, maxDigits);
          gen2.if((0, codegen_1._)`${data3} < ${min} || ${data3} > ${max}`, () => parsingError(cxt, (0, codegen_1.str)`integer out of range`));
        }
      }
    }
  };
  var parseString = function(cxt) {
    parseToken(cxt, '"');
    parseWith(cxt, parseJson_1.parseJsonString);
  };
  var parseEnum = function(cxt) {
    const { gen: gen2, data: data3, schema } = cxt;
    const enumSch = schema.enum;
    parseToken(cxt, '"');
    gen2.if(false);
    for (const value of enumSch) {
      const valueStr = JSON.stringify(value).slice(1);
      gen2.elseIf((0, codegen_1._)`${jsonSlice(valueStr.length)} === ${valueStr}`);
      gen2.assign(data3, (0, codegen_1.str)`${value}`);
      gen2.add(names_1.default.jsonPos, valueStr.length);
    }
    gen2.else();
    jsonSyntaxError(cxt);
    gen2.endIf();
  };
  var parseNumber = function(cxt, maxDigits) {
    const { gen: gen2 } = cxt;
    skipWhitespace(cxt);
    gen2.if((0, codegen_1._)`"-0123456789".indexOf(${jsonSlice(1)}) < 0`, () => jsonSyntaxError(cxt), () => parseWith(cxt, parseJson_1.parseJsonNumber, maxDigits));
  };
  var parseBooleanToken = function(bool, fail) {
    return (cxt) => {
      const { gen: gen2, data: data3 } = cxt;
      tryParseToken(cxt, `${bool}`, () => fail(cxt), () => gen2.assign(data3, bool));
    };
  };
  var parseRef = function(cxt) {
    const { gen: gen2, self: self2, definitions, schema, schemaEnv } = cxt;
    const { ref } = schema;
    const refSchema = definitions[ref];
    if (!refSchema)
      throw new ref_error_1.default(self2.opts.uriResolver, "", ref, `No definition ${ref}`);
    if (!(0, ref_1.hasRef)(refSchema))
      return parseCode({ ...cxt, schema: refSchema });
    const { root } = schemaEnv;
    const sch = compileParser.call(self2, new __1.SchemaEnv({ schema: refSchema, root }), definitions);
    partialParse(cxt, getParser(gen2, sch), true);
  };
  var getParser = function(gen2, sch) {
    return sch.parse ? gen2.scopeValue("parse", { ref: sch.parse }) : (0, codegen_1._)`${gen2.scopeValue("wrapper", { ref: sch })}.parse`;
  };
  var parseEmpty = function(cxt) {
    parseWith(cxt, parseJson_1.parseJson);
  };
  var parseWith = function(cxt, parseFunc, args) {
    partialParse(cxt, (0, util_1.useFunc)(cxt.gen, parseFunc), args);
  };
  var partialParse = function(cxt, parseFunc, args) {
    const { gen: gen2, data: data3 } = cxt;
    gen2.assign(data3, (0, codegen_1._)`${parseFunc}(${names_1.default.json}, ${names_1.default.jsonPos}${args ? (0, codegen_1._)`, ${args}` : codegen_1.nil})`);
    gen2.assign(names_1.default.jsonPos, (0, codegen_1._)`${parseFunc}.position`);
    gen2.if((0, codegen_1._)`${data3} === undefined`, () => parsingError(cxt, (0, codegen_1._)`${parseFunc}.message`));
  };
  var parseToken = function(cxt, tok) {
    tryParseToken(cxt, tok, jsonSyntaxError);
  };
  var tryParseToken = function(cxt, tok, fail, success) {
    const { gen: gen2 } = cxt;
    const n = tok.length;
    skipWhitespace(cxt);
    gen2.if((0, codegen_1._)`${jsonSlice(n)} === ${tok}`, () => {
      gen2.add(names_1.default.jsonPos, n);
      success === null || success === undefined || success(cxt);
    }, () => fail(cxt));
  };
  var skipWhitespace = function({ gen: gen2, char: c }) {
    gen2.code((0, codegen_1._)`while((${c}=${names_1.default.json}[${names_1.default.jsonPos}],${c}===" "||${c}==="\\n"||${c}==="\\r"||${c}==="\\t"))${names_1.default.jsonPos}++;`);
  };
  var jsonSlice = function(len) {
    return len === 1 ? (0, codegen_1._)`${names_1.default.json}[${names_1.default.jsonPos}]` : (0, codegen_1._)`${names_1.default.json}.slice(${names_1.default.jsonPos}, ${names_1.default.jsonPos}+${len})`;
  };
  var jsonSyntaxError = function(cxt) {
    parsingError(cxt, (0, codegen_1._)`"unexpected token " + ${names_1.default.json}[${names_1.default.jsonPos}]`);
  };
  var parsingError = function({ gen: gen2, parseName }, msg) {
    gen2.assign((0, codegen_1._)`${parseName}.message`, msg);
    gen2.assign((0, codegen_1._)`${parseName}.position`, names_1.default.jsonPos);
    gen2.return(undef);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var types_1 = require_types4();
  var __1 = require_compile();
  var codegen_1 = require_codegen();
  var ref_error_1 = require_ref_error();
  var names_1 = require_names();
  var code_1 = require_code2();
  var ref_1 = require_ref2();
  var type_1 = require_type();
  var parseJson_1 = require_parseJson();
  var util_1 = require_util3();
  var timestamp_1 = require_timestamp();
  var genParse = {
    elements: parseElements,
    values: parseValues,
    discriminator: parseDiscriminator,
    properties: parseProperties,
    optionalProperties: parseProperties,
    enum: parseEnum,
    type: parseType,
    ref: parseRef
  };
  exports.default = compileParser;
  var undef = (0, codegen_1._)`undefined`;
  var parseBoolean = parseBooleanToken(true, parseBooleanToken(false, jsonSyntaxError));
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/@fastify+ajv-compiler@3.5.0/node_modules/ajv/dist/jtd.js
var require_jtd2 = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = undefined;
  var core_1 = require_core();
  var jtd_1 = require_jtd();
  var jtd_schema_1 = require_jtd_schema();
  var serialize_1 = require_serialize();
  var parse_1 = require_parse3();
  var META_SCHEMA_ID = "JTD-meta-schema";

  class Ajv extends core_1.default {
    constructor(opts = {}) {
      super({
        ...opts,
        jtd: true
      });
    }
    _addVocabularies() {
      super._addVocabularies();
      this.addVocabulary(jtd_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      this.addMetaSchema(jtd_schema_1.default, META_SCHEMA_ID, false);
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined);
    }
    compileSerializer(schema) {
      const sch = this._addSchema(schema);
      return sch.serialize || this._compileSerializer(sch);
    }
    compileParser(schema) {
      const sch = this._addSchema(schema);
      return sch.parse || this._compileParser(sch);
    }
    _compileSerializer(sch) {
      serialize_1.default.call(this, sch, sch.schema.definitions || {});
      if (!sch.serialize)
        throw new Error("ajv implementation error");
      return sch.serialize;
    }
    _compileParser(sch) {
      parse_1.default.call(this, sch, sch.schema.definitions || {});
      if (!sch.parse)
        throw new Error("ajv implementation error");
      return sch.parse;
    }
  }
  module.exports = exports = Ajv;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = Ajv;
  var validate_1 = require_validate();
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_1.KeywordCxt;
  } });
  var codegen_1 = require_codegen();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_1._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_1.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_1.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_1.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_1.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_1.CodeGen;
  } });
  var validation_error_1 = require_validation_error();
  Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
    return validation_error_1.default;
  } });
  var ref_error_1 = require_ref_error();
  Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
    return ref_error_1.default;
  } });
});

// ../node_modules/.pnpm/@fastify+ajv-compiler@3.5.0/node_modules/@fastify/ajv-compiler/lib/default-ajv-options.js
var require_default_ajv_options = __commonJS((exports, module) => {
  var fastUri = require_fast_uri();
  module.exports = Object.freeze({
    coerceTypes: "array",
    useDefaults: true,
    removeAdditional: true,
    uriResolver: fastUri,
    addUsedSchema: false,
    allErrors: false
  });
});

// ../node_modules/.pnpm/@fastify+ajv-compiler@3.5.0/node_modules/@fastify/ajv-compiler/lib/validator-compiler.js
var require_validator_compiler = __commonJS((exports, module) => {
  var Ajv = require_ajv().default;
  var AjvJTD = require_jtd2();
  var defaultAjvOptions = require_default_ajv_options();

  class ValidatorCompiler {
    constructor(externalSchemas, options) {
      if (options.mode === "JTD") {
        this.ajv = new AjvJTD(Object.assign({}, defaultAjvOptions, options.customOptions));
      } else {
        this.ajv = new Ajv(Object.assign({}, defaultAjvOptions, options.customOptions));
      }
      let addFormatPlugin = true;
      if (options.plugins && options.plugins.length > 0) {
        for (const plugin of options.plugins) {
          if (Array.isArray(plugin)) {
            addFormatPlugin = addFormatPlugin && plugin[0].name !== "formatsPlugin";
            plugin[0](this.ajv, plugin[1]);
          } else {
            addFormatPlugin = addFormatPlugin && plugin.name !== "formatsPlugin";
            plugin(this.ajv);
          }
        }
      }
      if (addFormatPlugin) {
        require_dist()(this.ajv);
      }
      const sourceSchemas = Object.values(externalSchemas);
      for (const extSchema of sourceSchemas) {
        this.ajv.addSchema(extSchema);
      }
    }
    buildValidatorFunction({ schema }) {
      if (schema.$id) {
        const stored = this.ajv.getSchema(schema.$id);
        if (stored) {
          return stored;
        }
      }
      return this.ajv.compile(schema);
    }
  }
  module.exports = ValidatorCompiler;
});

// ../node_modules/.pnpm/@fastify+ajv-compiler@3.5.0/node_modules/@fastify/ajv-compiler/lib/serializer-compiler.js
var require_serializer_compiler = __commonJS((exports, module) => {
  var AjvJTD = require_jtd2();
  var defaultAjvOptions = require_default_ajv_options();

  class SerializerCompiler {
    constructor(externalSchemas, options) {
      this.ajv = new AjvJTD(Object.assign({}, defaultAjvOptions, options));
    }
    buildSerializerFunction({ schema }) {
      return this.ajv.compileSerializer(schema);
    }
  }
  module.exports = SerializerCompiler;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/@fastify+ajv-compiler@3.5.0/node_modules/ajv/dist/standalone/index.js
var require_standalone3 = __commonJS((exports, module) => {
  var standaloneCode = function(ajv, refsOrFunc) {
    if (!ajv.opts.code.source) {
      throw new Error("moduleCode: ajv instance must have code.source option");
    }
    const { _n } = ajv.scope.opts;
    return typeof refsOrFunc == "function" ? funcExportCode(refsOrFunc.source) : refsOrFunc !== undefined ? multiExportsCode(refsOrFunc, getValidate) : multiExportsCode(ajv.schemas, (sch) => sch.meta ? undefined : ajv.compile(sch.schema));
    function getValidate(id2) {
      const v = ajv.getSchema(id2);
      if (!v)
        throw new Error(`moduleCode: no schema with id ${id2}`);
      return v;
    }
    function funcExportCode(source) {
      const usedValues = {};
      const n = source === null || source === undefined ? undefined : source.validateName;
      const vCode = validateCode(usedValues, source);
      if (ajv.opts.code.esm) {
        return `"use strict";${_n}export const validate = ${n};${_n}export default ${n};${_n}${vCode}`;
      }
      return `"use strict";${_n}module.exports = ${n};${_n}module.exports.default = ${n};${_n}${vCode}`;
    }
    function multiExportsCode(schemas5, getValidateFunc) {
      var _a2;
      const usedValues = {};
      let code = (0, code_1._)`"use strict";`;
      for (const name in schemas5) {
        const v = getValidateFunc(schemas5[name]);
        if (v) {
          const vCode = validateCode(usedValues, v.source);
          const exportSyntax = ajv.opts.code.esm ? (0, code_1._)`export const ${(0, code_1.getEsmExportName)(name)}` : (0, code_1._)`exports${(0, code_1.getProperty)(name)}`;
          code = (0, code_1._)`${code}${_n}${exportSyntax} = ${(_a2 = v.source) === null || _a2 === undefined ? undefined : _a2.validateName};${_n}${vCode}`;
        }
      }
      return `${code}`;
    }
    function validateCode(usedValues, s) {
      if (!s)
        throw new Error('moduleCode: function does not have "source" property');
      if (usedState(s.validateName) === scope_1.UsedValueState.Completed)
        return code_1.nil;
      setUsedState(s.validateName, scope_1.UsedValueState.Started);
      const scopeCode = ajv.scope.scopeCode(s.scopeValues, usedValues, refValidateCode);
      const code = new code_1._Code(`${scopeCode}${_n}${s.validateCode}`);
      return s.evaluated ? (0, code_1._)`${code}${s.validateName}.evaluated = ${s.evaluated};${_n}` : code;
      function refValidateCode(n) {
        var _a2;
        const vRef = (_a2 = n.value) === null || _a2 === undefined ? undefined : _a2.ref;
        if (n.prefix === "validate" && typeof vRef == "function") {
          const v = vRef;
          return validateCode(usedValues, v.source);
        } else if ((n.prefix === "root" || n.prefix === "wrapper") && typeof vRef == "object") {
          const { validate, validateName } = vRef;
          if (!validateName)
            throw new Error("ajv internal error");
          const def = ajv.opts.code.es5 ? scope_1.varKinds.var : scope_1.varKinds.const;
          const wrapper = (0, code_1._)`${def} ${n} = {validate: ${validateName}};`;
          if (usedState(validateName) === scope_1.UsedValueState.Started)
            return wrapper;
          const vCode = validateCode(usedValues, validate === null || validate === undefined ? undefined : validate.source);
          return (0, code_1._)`${wrapper}${_n}${vCode}`;
        }
        return;
      }
      function usedState(name) {
        var _a2;
        return (_a2 = usedValues[name.prefix]) === null || _a2 === undefined ? undefined : _a2.get(name);
      }
      function setUsedState(name, state) {
        const { prefix } = name;
        const names = usedValues[prefix] = usedValues[prefix] || new Map;
        names.set(name, state);
      }
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var scope_1 = require_scope2();
  var code_1 = require_code();
  module.exports = exports = standaloneCode;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = standaloneCode;
});

// ../node_modules/.pnpm/@fastify+ajv-compiler@3.5.0/node_modules/@fastify/ajv-compiler/standalone.js
var require_standalone4 = __commonJS((exports, module) => {
  var StandaloneValidator = function(options = { readMode: true }) {
    if (options.readMode === true && !options.restoreFunction) {
      throw new Error("You must provide a restoreFunction options when readMode ON");
    }
    if (options.readMode !== true && !options.storeFunction) {
      throw new Error("You must provide a storeFunction options when readMode OFF");
    }
    if (options.readMode === true) {
      return function wrapper() {
        return function(opts) {
          return options.restoreFunction(opts);
        };
      };
    }
    const factory = ValidatorSelector();
    return function wrapper(externalSchemas, ajvOptions = {}) {
      if (!ajvOptions.customOptions || !ajvOptions.customOptions.code) {
        ajvOptions.customOptions = Object.assign({}, ajvOptions.customOptions, { code: { source: true } });
      }
      const compiler = factory(externalSchemas, ajvOptions);
      return function(opts) {
        const validationFunc = compiler(opts);
        const schemaValidationCode = standaloneCode(compiler[ValidatorSelector.AjvReference].ajv, validationFunc);
        options.storeFunction(opts, schemaValidationCode);
        return validationFunc;
      };
    };
  };
  var ValidatorSelector = require_ajv_compiler();
  var standaloneCode = require_standalone3().default;
  module.exports = StandaloneValidator;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fastify@4.26.0/node_modules/@fastify/ajv-compiler/index.js
var require_ajv_compiler = __commonJS((exports, module) => {
  var AjvCompiler = function(opts) {
    const validatorPool = new Map;
    const serializerPool = new Map;
    if (opts && opts.jtdSerializer === true) {
      return function buildSerializerFromPool(externalSchemas, serializerOpts) {
        const uniqueAjvKey = getPoolKey({}, serializerOpts);
        if (serializerPool.has(uniqueAjvKey)) {
          return serializerPool.get(uniqueAjvKey);
        }
        const compiler = new SerializerCompiler(externalSchemas, serializerOpts);
        const ret2 = compiler.buildSerializerFunction.bind(compiler);
        serializerPool.set(uniqueAjvKey, ret2);
        return ret2;
      };
    }
    return function buildCompilerFromPool(externalSchemas, options) {
      const uniqueAjvKey = getPoolKey(externalSchemas, options.customOptions);
      if (validatorPool.has(uniqueAjvKey)) {
        return validatorPool.get(uniqueAjvKey);
      }
      const compiler = new ValidatorCompiler(externalSchemas, options);
      const ret2 = compiler.buildValidatorFunction.bind(compiler);
      validatorPool.set(uniqueAjvKey, ret2);
      if (options.customOptions.code !== undefined) {
        ret2[AjvReference] = compiler;
      }
      return ret2;
    };
  };
  var getPoolKey = function(externalSchemas, options) {
    const externals = JSON.stringify(externalSchemas);
    const ajvConfig = JSON.stringify(options);
    return `${externals}${ajvConfig}`;
  };
  var AjvReference = Symbol.for("fastify.ajv-compiler.reference");
  var ValidatorCompiler = require_validator_compiler();
  var SerializerCompiler = require_serializer_compiler();
  module.exports = AjvCompiler;
  module.exports.default = AjvCompiler;
  module.exports.AjvCompiler = AjvCompiler;
  module.exports.AjvReference = AjvReference;
  module.exports.StandaloneValidator = require_standalone4();
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/schema-controller.js
var require_schema_controller = __commonJS((exports, module) => {
  var buildSchemaController = function(parentSchemaCtrl, opts) {
    if (parentSchemaCtrl) {
      return new SchemaController(parentSchemaCtrl, opts);
    }
    const compilersFactory = Object.assign({
      buildValidator: null,
      buildSerializer: null
    }, opts?.compilersFactory);
    if (!compilersFactory.buildValidator) {
      compilersFactory.buildValidator = ValidatorSelector();
    }
    if (!compilersFactory.buildSerializer) {
      compilersFactory.buildSerializer = SerializerSelector();
    }
    const option = {
      bucket: opts && opts.bucket || buildSchemas,
      compilersFactory,
      isCustomValidatorCompiler: typeof opts?.compilersFactory?.buildValidator === "function",
      isCustomSerializerCompiler: typeof opts?.compilersFactory?.buildValidator === "function"
    };
    return new SchemaController(undefined, option);
  };
  var { buildSchemas } = require_schemas();
  var SerializerSelector = require_fast_json_stringify_compiler();
  var ValidatorSelector = require_ajv_compiler();

  class SchemaController {
    constructor(parent, options) {
      this.opts = options || parent?.opts;
      this.addedSchemas = false;
      this.compilersFactory = this.opts.compilersFactory;
      if (parent) {
        this.schemaBucket = this.opts.bucket(parent.getSchemas());
        this.validatorCompiler = parent.getValidatorCompiler();
        this.serializerCompiler = parent.getSerializerCompiler();
        this.isCustomValidatorCompiler = parent.isCustomValidatorCompiler;
        this.isCustomSerializerCompiler = parent.isCustomSerializerCompiler;
        this.parent = parent;
      } else {
        this.schemaBucket = this.opts.bucket();
        this.isCustomValidatorCompiler = this.opts.isCustomValidatorCompiler || false;
        this.isCustomSerializerCompiler = this.opts.isCustomSerializerCompiler || false;
      }
    }
    add(schema) {
      this.addedSchemas = true;
      return this.schemaBucket.add(schema);
    }
    getSchema(schemaId) {
      return this.schemaBucket.getSchema(schemaId);
    }
    getSchemas() {
      return this.schemaBucket.getSchemas();
    }
    setValidatorCompiler(validatorCompiler) {
      this.compilersFactory = Object.assign({}, this.compilersFactory, { buildValidator: () => validatorCompiler });
      this.validatorCompiler = validatorCompiler;
      this.isCustomValidatorCompiler = true;
    }
    setSerializerCompiler(serializerCompiler) {
      this.compilersFactory = Object.assign({}, this.compilersFactory, { buildSerializer: () => serializerCompiler });
      this.serializerCompiler = serializerCompiler;
      this.isCustomSerializerCompiler = true;
    }
    getValidatorCompiler() {
      return this.validatorCompiler || this.parent && this.parent.getValidatorCompiler();
    }
    getSerializerCompiler() {
      return this.serializerCompiler || this.parent && this.parent.getSerializerCompiler();
    }
    getSerializerBuilder() {
      return this.compilersFactory.buildSerializer || this.parent && this.parent.getSerializerBuilder();
    }
    getValidatorBuilder() {
      return this.compilersFactory.buildValidator || this.parent && this.parent.getValidatorBuilder();
    }
    setupValidator(serverOptions) {
      const isReady = this.validatorCompiler !== undefined && !this.addedSchemas;
      if (isReady) {
        return;
      }
      this.validatorCompiler = this.getValidatorBuilder()(this.schemaBucket.getSchemas(), serverOptions.ajv);
    }
    setupSerializer(serverOptions) {
      const isReady = this.serializerCompiler !== undefined && !this.addedSchemas;
      if (isReady) {
        return;
      }
      this.serializerCompiler = this.getSerializerBuilder()(this.schemaBucket.getSchemas(), serverOptions.serializerOpts);
    }
  }
  SchemaController.buildSchemaController = buildSchemaController;
  module.exports = SchemaController;
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/pluginUtils.js
var require_pluginUtils = __commonJS((exports, module) => {
  var getMeta = function(fn) {
    return fn[Symbol.for("plugin-meta")];
  };
  var getPluginName = function(func) {
    const display = getDisplayName(func);
    if (display) {
      return display;
    }
    const cache = __require.cache;
    if (cache) {
      const keys = Object.keys(cache);
      for (let i = 0;i < keys.length; i++) {
        const key = keys[i];
        if (cache[key].exports === func) {
          return key;
        }
      }
    }
    if (func.name) {
      return func.name;
    }
    return null;
  };
  var getFuncPreview = function(func) {
    return func.toString().split("\n").slice(0, 2).map((s) => s.trim()).join(" -- ");
  };
  var getDisplayName = function(fn) {
    return fn[Symbol.for("fastify.display-name")];
  };
  var shouldSkipOverride = function(fn) {
    return !!fn[Symbol.for("skip-override")];
  };
  var checkDependencies = function(fn) {
    const meta = getMeta(fn);
    if (!meta)
      return;
    const dependencies = meta.dependencies;
    if (!dependencies)
      return;
    assert(Array.isArray(dependencies), "The dependencies should be an array of strings");
    dependencies.forEach((dependency) => {
      assert(this[kRegisteredPlugins].indexOf(dependency) > -1, `The dependency '${dependency}' of plugin '${meta.name}' is not registered`);
    });
  };
  var checkDecorators = function(fn) {
    const meta = getMeta(fn);
    if (!meta)
      return;
    const { decorators, name } = meta;
    if (!decorators)
      return;
    if (decorators.fastify)
      _checkDecorators(this, "Fastify", decorators.fastify, name);
    if (decorators.reply)
      _checkDecorators(this, "Reply", decorators.reply, name);
    if (decorators.request)
      _checkDecorators(this, "Request", decorators.request, name);
  };
  var _checkDecorators = function(that, instance, decorators, name) {
    assert(Array.isArray(decorators), "The decorators should be an array of strings");
    decorators.forEach((decorator) => {
      const withPluginName = typeof name === "string" ? ` required by '${name}'` : "";
      if (!checks[instance].call(that, decorator)) {
        throw new FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE(decorator, withPluginName, instance);
      }
    });
  };
  var checkVersion = function(fn) {
    const meta = getMeta(fn);
    if (!meta)
      return;
    const requiredVersion = meta.fastify;
    const fastifyRc = /-rc.+$/.test(this.version);
    if (fastifyRc === true && semver.gt(this.version, semver.coerce(requiredVersion)) === true) {
      return;
    }
    if (requiredVersion && semver.satisfies(this.version, requiredVersion, { includePrerelease: fastifyRc }) === false) {
      throw new FST_ERR_PLUGIN_VERSION_MISMATCH(meta.name, requiredVersion, this.version);
    }
  };
  var registerPluginName = function(fn) {
    const meta = getMeta(fn);
    if (!meta)
      return;
    const name = meta.name;
    if (!name)
      return;
    this[kRegisteredPlugins].push(name);
    return name;
  };
  var checkPluginHealthiness = function(fn, pluginName) {
    if (fn.constructor.name === "AsyncFunction" && fn.length === 3) {
      FSTWRN002(pluginName || "anonymous");
    }
  };
  var registerPlugin = function(fn) {
    const pluginName = registerPluginName.call(this, fn) || getPluginName(fn);
    checkPluginHealthiness.call(this, fn, pluginName);
    checkVersion.call(this, fn);
    checkDecorators.call(this, fn);
    checkDependencies.call(this, fn);
    return shouldSkipOverride(fn);
  };
  var semver = require_semver2();
  var assert = __require("node:assert");
  var kRegisteredPlugins = Symbol.for("registered-plugin");
  var {
    kTestInternals
  } = require_symbols3();
  var { exist, existReply, existRequest } = require_decorate();
  var {
    FST_ERR_PLUGIN_VERSION_MISMATCH,
    FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE
  } = require_errors4();
  var { FSTWRN002 } = require_warnings();
  var checks = {
    Fastify: exist,
    Request: existRequest,
    Reply: existReply
  };
  module.exports = {
    getPluginName,
    getFuncPreview,
    kRegisteredPlugins,
    getDisplayName,
    registerPlugin
  };
  module.exports[kTestInternals] = {
    shouldSkipOverride,
    getMeta,
    checkDecorators,
    checkDependencies
  };
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/reqIdGenFactory.js
var require_reqIdGenFactory = __commonJS((exports, module) => {
  var reqIdGenFactory = function(requestIdHeader, optGenReqId) {
    const genReqId = optGenReqId || buildDefaultGenReqId();
    if (requestIdHeader) {
      return buildOptionalHeaderReqId(requestIdHeader, genReqId);
    }
    return genReqId;
  };
  var getGenReqId = function(contextServer, req) {
    return contextServer.genReqId(req);
  };
  var buildDefaultGenReqId = function() {
    const maxInt = 2147483647;
    let nextReqId = 0;
    return function defaultGenReqId() {
      nextReqId = nextReqId + 1 & maxInt;
      return `req-${nextReqId.toString(36)}`;
    };
  };
  var buildOptionalHeaderReqId = function(requestIdHeader, genReqId) {
    return function(req) {
      return req.headers[requestIdHeader] || genReqId(req);
    };
  };
  module.exports = {
    getGenReqId,
    reqIdGenFactory
  };
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fast-querystring@1.1.2/node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component = __commonJS((exports, module) => {
  var decodeURIComponent2 = function(uri) {
    var percentPosition = uri.indexOf("%");
    if (percentPosition === -1)
      return uri;
    var length = uri.length;
    var decoded = "";
    var last = 0;
    var codepoint = 0;
    var startOfOctets = percentPosition;
    var state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length) {
      var high = hexCodeToInt(uri[percentPosition + 1], 4);
      var low = hexCodeToInt(uri[percentPosition + 2], 0);
      var byte = high | low;
      var type = UTF8_DATA[byte];
      state = UTF8_DATA[256 + state + type];
      codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type];
      if (state === UTF8_ACCEPT) {
        decoded += uri.slice(last, startOfOctets);
        decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
        codepoint = 0;
        last = percentPosition + 3;
        percentPosition = startOfOctets = uri.indexOf("%", last);
      } else if (state === UTF8_REJECT) {
        return null;
      } else {
        percentPosition += 3;
        if (percentPosition < length && uri.charCodeAt(percentPosition) === 37)
          continue;
        return null;
      }
    }
    return decoded + uri.slice(last);
  };
  var hexCodeToInt = function(c, shift) {
    var i = HEX[c];
    return i === undefined ? 255 : i << shift;
  };
  var UTF8_ACCEPT = 12;
  var UTF8_REJECT = 0;
  var UTF8_DATA = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  var HEX = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  module.exports = decodeURIComponent2;
});

// ../node_modules/.pnpm/fast-querystring@1.1.2/node_modules/fast-querystring/lib/parse.js
var require_parse4 = __commonJS((exports, module) => {
  var parse = function(input) {
    const result = new Empty;
    if (typeof input !== "string") {
      return result;
    }
    let inputLength = input.length;
    let key = "";
    let value = "";
    let startingIndex = -1;
    let equalityIndex = -1;
    let shouldDecodeKey = false;
    let shouldDecodeValue = false;
    let keyHasPlus = false;
    let valueHasPlus = false;
    let hasBothKeyValuePair = false;
    let c = 0;
    for (let i = 0;i < inputLength + 1; i++) {
      c = i !== inputLength ? input.charCodeAt(i) : 38;
      if (c === 38) {
        hasBothKeyValuePair = equalityIndex > startingIndex;
        if (!hasBothKeyValuePair) {
          equalityIndex = i;
        }
        key = input.slice(startingIndex + 1, equalityIndex);
        if (hasBothKeyValuePair || key.length > 0) {
          if (keyHasPlus) {
            key = key.replace(plusRegex, " ");
          }
          if (shouldDecodeKey) {
            key = fastDecode(key) || key;
          }
          if (hasBothKeyValuePair) {
            value = input.slice(equalityIndex + 1, i);
            if (valueHasPlus) {
              value = value.replace(plusRegex, " ");
            }
            if (shouldDecodeValue) {
              value = fastDecode(value) || value;
            }
          }
          const currentValue = result[key];
          if (currentValue === undefined) {
            result[key] = value;
          } else {
            if (currentValue.pop) {
              currentValue.push(value);
            } else {
              result[key] = [currentValue, value];
            }
          }
        }
        value = "";
        startingIndex = i;
        equalityIndex = i;
        shouldDecodeKey = false;
        shouldDecodeValue = false;
        keyHasPlus = false;
        valueHasPlus = false;
      } else if (c === 61) {
        if (equalityIndex <= startingIndex) {
          equalityIndex = i;
        } else {
          shouldDecodeValue = true;
        }
      } else if (c === 43) {
        if (equalityIndex > startingIndex) {
          valueHasPlus = true;
        } else {
          keyHasPlus = true;
        }
      } else if (c === 37) {
        if (equalityIndex > startingIndex) {
          shouldDecodeValue = true;
        } else {
          shouldDecodeKey = true;
        }
      }
    }
    return result;
  };
  var fastDecode = require_fast_decode_uri_component();
  var plusRegex = /\+/g;
  var Empty = function() {
  };
  Empty.prototype = Object.create(null);
  module.exports = parse;
});

// ../node_modules/.pnpm/fast-querystring@1.1.2/node_modules/fast-querystring/lib/internals/querystring.js
var require_querystring = __commonJS((exports, module) => {
  var encodeString2 = function(str) {
    const len = str.length;
    if (len === 0)
      return "";
    let out = "";
    let lastPos = 0;
    let i = 0;
    outer:
      for (;i < len; i++) {
        let c = str.charCodeAt(i);
        while (c < 128) {
          if (noEscape[c] !== 1) {
            if (lastPos < i)
              out += str.slice(lastPos, i);
            lastPos = i + 1;
            out += hexTable[c];
          }
          if (++i === len)
            break outer;
          c = str.charCodeAt(i);
        }
        if (lastPos < i)
          out += str.slice(lastPos, i);
        if (c < 2048) {
          lastPos = i + 1;
          out += hexTable[192 | c >> 6] + hexTable[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          lastPos = i + 1;
          out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          continue;
        }
        ++i;
        if (i >= len) {
          throw new Error("URI malformed");
        }
        const c2 = str.charCodeAt(i) & 1023;
        lastPos = i + 1;
        c = 65536 + ((c & 1023) << 10 | c2);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
    if (lastPos === 0)
      return str;
    if (lastPos < len)
      return out + str.slice(lastPos);
    return out;
  };
  var hexTable = Array.from({ length: 256 }, (_, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  var noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
  ]);
  module.exports = { encodeString: encodeString2 };
});

// ../node_modules/.pnpm/fast-querystring@1.1.2/node_modules/fast-querystring/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  var getAsPrimitive = function(value) {
    const type = typeof value;
    if (type === "string") {
      return encodeString2(value);
    } else if (type === "bigint") {
      return value.toString();
    } else if (type === "boolean") {
      return value ? "true" : "false";
    } else if (type === "number" && Number.isFinite(value)) {
      return value < 1000000000000000000000 ? "" + value : encodeString2("" + value);
    }
    return "";
  };
  var stringify14 = function(input) {
    let result = "";
    if (input === null || typeof input !== "object") {
      return result;
    }
    const separator = "&";
    const keys = Object.keys(input);
    const keyLength = keys.length;
    let valueLength = 0;
    for (let i = 0;i < keyLength; i++) {
      const key = keys[i];
      const value = input[key];
      const encodedKey = encodeString2(key) + "=";
      if (i) {
        result += separator;
      }
      if (Array.isArray(value)) {
        valueLength = value.length;
        for (let j = 0;j < valueLength; j++) {
          if (j) {
            result += separator;
          }
          result += encodedKey;
          result += getAsPrimitive(value[j]);
        }
      } else {
        result += encodedKey;
        result += getAsPrimitive(value);
      }
    }
    return result;
  };
  var { encodeString: encodeString2 } = require_querystring();
  module.exports = stringify14;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/find-my-way@8.1.0/node_modules/fast-querystring/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var parse = require_parse4();
  var stringify14 = require_stringify();
  var fastQuerystring = {
    parse,
    stringify: stringify14
  };
  module.exports = fastQuerystring;
  module.exports.default = fastQuerystring;
  module.exports.parse = parse;
  module.exports.stringify = stringify14;
});

// ../node_modules/.pnpm/ret@0.2.2/node_modules/ret/lib/types.js
var require_types5 = __commonJS((exports, module) => {
  module.exports = {
    ROOT: 0,
    GROUP: 1,
    POSITION: 2,
    SET: 3,
    RANGE: 4,
    REPETITION: 5,
    REFERENCE: 6,
    CHAR: 7
  };
});

// ../node_modules/.pnpm/ret@0.2.2/node_modules/ret/lib/sets.js
var require_sets = __commonJS((exports) => {
  var types12 = require_types5();
  var INTS = () => [{ type: types12.RANGE, from: 48, to: 57 }];
  var WORDS = () => {
    return [
      { type: types12.CHAR, value: 95 },
      { type: types12.RANGE, from: 97, to: 122 },
      { type: types12.RANGE, from: 65, to: 90 }
    ].concat(INTS());
  };
  var WHITESPACE = () => {
    return [
      { type: types12.CHAR, value: 9 },
      { type: types12.CHAR, value: 10 },
      { type: types12.CHAR, value: 11 },
      { type: types12.CHAR, value: 12 },
      { type: types12.CHAR, value: 13 },
      { type: types12.CHAR, value: 32 },
      { type: types12.CHAR, value: 160 },
      { type: types12.CHAR, value: 5760 },
      { type: types12.RANGE, from: 8192, to: 8202 },
      { type: types12.CHAR, value: 8232 },
      { type: types12.CHAR, value: 8233 },
      { type: types12.CHAR, value: 8239 },
      { type: types12.CHAR, value: 8287 },
      { type: types12.CHAR, value: 12288 },
      { type: types12.CHAR, value: 65279 }
    ];
  };
  var NOTANYCHAR = () => {
    return [
      { type: types12.CHAR, value: 10 },
      { type: types12.CHAR, value: 13 },
      { type: types12.CHAR, value: 8232 },
      { type: types12.CHAR, value: 8233 }
    ];
  };
  exports.words = () => ({ type: types12.SET, set: WORDS(), not: false });
  exports.notWords = () => ({ type: types12.SET, set: WORDS(), not: true });
  exports.ints = () => ({ type: types12.SET, set: INTS(), not: false });
  exports.notInts = () => ({ type: types12.SET, set: INTS(), not: true });
  exports.whitespace = () => ({ type: types12.SET, set: WHITESPACE(), not: false });
  exports.notWhitespace = () => ({ type: types12.SET, set: WHITESPACE(), not: true });
  exports.anyChar = () => ({ type: types12.SET, set: NOTANYCHAR(), not: true });
});

// ../node_modules/.pnpm/ret@0.2.2/node_modules/ret/lib/util.js
var require_util4 = __commonJS((exports) => {
  var types12 = require_types5();
  var sets = require_sets();
  var CTRL = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
  var SLSH = { "0": 0, t: 9, n: 10, v: 11, f: 12, r: 13 };
  exports.strToChars = function(str) {
    var chars_regex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
    str = str.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {
      if (lbs) {
        return s;
      }
      var code = b ? 8 : a16 ? parseInt(a16, 16) : b16 ? parseInt(b16, 16) : c8 ? parseInt(c8, 8) : dctrl ? CTRL.indexOf(dctrl) : SLSH[eslsh];
      var c = String.fromCharCode(code);
      if (/[[\]{}^$.|?*+()]/.test(c)) {
        c = "\\" + c;
      }
      return c;
    });
    return str;
  };
  exports.tokenizeClass = (str, regexpStr) => {
    var tokens = [];
    var regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?([^])/g;
    var rs, c;
    while ((rs = regexp.exec(str)) != null) {
      if (rs[1]) {
        tokens.push(sets.words());
      } else if (rs[2]) {
        tokens.push(sets.ints());
      } else if (rs[3]) {
        tokens.push(sets.whitespace());
      } else if (rs[4]) {
        tokens.push(sets.notWords());
      } else if (rs[5]) {
        tokens.push(sets.notInts());
      } else if (rs[6]) {
        tokens.push(sets.notWhitespace());
      } else if (rs[7]) {
        tokens.push({
          type: types12.RANGE,
          from: (rs[8] || rs[9]).charCodeAt(0),
          to: rs[10].charCodeAt(0)
        });
      } else if (c = rs[12]) {
        tokens.push({
          type: types12.CHAR,
          value: c.charCodeAt(0)
        });
      } else {
        return [tokens, regexp.lastIndex];
      }
    }
    exports.error(regexpStr, "Unterminated character class");
  };
  exports.error = (regexp, msg) => {
    throw new SyntaxError("Invalid regular expression: /" + regexp + "/: " + msg);
  };
});

// ../node_modules/.pnpm/ret@0.2.2/node_modules/ret/lib/positions.js
var require_positions = __commonJS((exports) => {
  var types12 = require_types5();
  exports.wordBoundary = () => ({ type: types12.POSITION, value: "b" });
  exports.nonWordBoundary = () => ({ type: types12.POSITION, value: "B" });
  exports.begin = () => ({ type: types12.POSITION, value: "^" });
  exports.end = () => ({ type: types12.POSITION, value: "$" });
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/safe-regex2@2.0.0/node_modules/ret/lib/index.js
var require_lib3 = __commonJS((exports, module) => {
  var util2 = require_util4();
  var types12 = require_types5();
  var sets = require_sets();
  var positions = require_positions();
  module.exports = (regexpStr) => {
    var i = 0, l, c, start = { type: types12.ROOT, stack: [] }, lastGroup = start, last = start.stack, groupStack = [];
    var repeatErr = (i2) => {
      util2.error(regexpStr, `Nothing to repeat at column ${i2 - 1}`);
    };
    var str = util2.strToChars(regexpStr);
    l = str.length;
    while (i < l) {
      c = str[i++];
      switch (c) {
        case "\\":
          c = str[i++];
          switch (c) {
            case "b":
              last.push(positions.wordBoundary());
              break;
            case "B":
              last.push(positions.nonWordBoundary());
              break;
            case "w":
              last.push(sets.words());
              break;
            case "W":
              last.push(sets.notWords());
              break;
            case "d":
              last.push(sets.ints());
              break;
            case "D":
              last.push(sets.notInts());
              break;
            case "s":
              last.push(sets.whitespace());
              break;
            case "S":
              last.push(sets.notWhitespace());
              break;
            default:
              if (/\d/.test(c)) {
                last.push({ type: types12.REFERENCE, value: parseInt(c, 10) });
              } else {
                last.push({ type: types12.CHAR, value: c.charCodeAt(0) });
              }
          }
          break;
        case "^":
          last.push(positions.begin());
          break;
        case "$":
          last.push(positions.end());
          break;
        case "[":
          var not;
          if (str[i] === "^") {
            not = true;
            i++;
          } else {
            not = false;
          }
          var classTokens = util2.tokenizeClass(str.slice(i), regexpStr);
          i += classTokens[1];
          last.push({
            type: types12.SET,
            set: classTokens[0],
            not
          });
          break;
        case ".":
          last.push(sets.anyChar());
          break;
        case "(":
          var group = {
            type: types12.GROUP,
            stack: [],
            remember: true
          };
          c = str[i];
          if (c === "?") {
            c = str[i + 1];
            i += 2;
            if (c === "=") {
              group.followedBy = true;
            } else if (c === "!") {
              group.notFollowedBy = true;
            } else if (c !== ":") {
              util2.error(regexpStr, `Invalid group, character '${c}'` + ` after '?' at column ${i - 1}`);
            }
            group.remember = false;
          }
          last.push(group);
          groupStack.push(lastGroup);
          lastGroup = group;
          last = group.stack;
          break;
        case ")":
          if (groupStack.length === 0) {
            util2.error(regexpStr, `Unmatched ) at column ${i - 1}`);
          }
          lastGroup = groupStack.pop();
          last = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
          break;
        case "|":
          if (!lastGroup.options) {
            lastGroup.options = [lastGroup.stack];
            delete lastGroup.stack;
          }
          var stack = [];
          lastGroup.options.push(stack);
          last = stack;
          break;
        case "{":
          var rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)), min, max;
          if (rs !== null) {
            if (last.length === 0) {
              repeatErr(i);
            }
            min = parseInt(rs[1], 10);
            max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;
            i += rs[0].length;
            last.push({
              type: types12.REPETITION,
              min,
              max,
              value: last.pop()
            });
          } else {
            last.push({
              type: types12.CHAR,
              value: 123
            });
          }
          break;
        case "?":
          if (last.length === 0) {
            repeatErr(i);
          }
          last.push({
            type: types12.REPETITION,
            min: 0,
            max: 1,
            value: last.pop()
          });
          break;
        case "+":
          if (last.length === 0) {
            repeatErr(i);
          }
          last.push({
            type: types12.REPETITION,
            min: 1,
            max: Infinity,
            value: last.pop()
          });
          break;
        case "*":
          if (last.length === 0) {
            repeatErr(i);
          }
          last.push({
            type: types12.REPETITION,
            min: 0,
            max: Infinity,
            value: last.pop()
          });
          break;
        default:
          last.push({
            type: types12.CHAR,
            value: c.charCodeAt(0)
          });
      }
    }
    if (groupStack.length !== 0) {
      util2.error(regexpStr, "Unterminated group");
    }
    return start;
  };
  module.exports.types = types12;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/find-my-way@8.1.0/node_modules/safe-regex2/index.js
var require_safe_regex2 = __commonJS((exports, module) => {
  var isRegExp = function(x) {
    return {}.toString.call(x) === "[object RegExp]";
  };
  var parse = require_lib3();
  var types12 = parse.types;
  module.exports = function(re, opts) {
    if (!opts)
      opts = {};
    var replimit = opts.limit === undefined ? 25 : opts.limit;
    if (isRegExp(re))
      re = re.source;
    else if (typeof re !== "string")
      re = String(re);
    try {
      re = parse(re);
    } catch (err) {
      return false;
    }
    var reps = 0;
    return function walk(node9, starHeight) {
      var i;
      var ok;
      var len;
      if (node9.type === types12.REPETITION) {
        starHeight++;
        reps++;
        if (starHeight > 1)
          return false;
        if (reps > replimit)
          return false;
      }
      if (node9.options) {
        for (i = 0, len = node9.options.length;i < len; i++) {
          ok = walk({ stack: node9.options[i] }, starHeight);
          if (!ok)
            return false;
        }
      }
      var stack = node9.stack || node9.value && node9.value.stack;
      if (!stack)
        return true;
      for (i = 0;i < stack.length; i++) {
        ok = walk(stack[i], starHeight);
        if (!ok)
          return false;
      }
      return true;
    }(re, 0);
  };
});

// ../node_modules/.pnpm/find-my-way@8.1.0/node_modules/find-my-way/lib/strategies/http-method.js
var require_http_method = __commonJS((exports, module) => {
  module.exports = {
    name: "__fmw_internal_strategy_merged_tree_http_method__",
    storage: function() {
      const handlers = {};
      return {
        get: (type) => {
          return handlers[type] || null;
        },
        set: (type, store2) => {
          handlers[type] = store2;
        }
      };
    },
    deriveConstraint: (req) => {
      return req.method;
    },
    mustMatchWhenDerived: true
  };
});

// ../node_modules/.pnpm/find-my-way@8.1.0/node_modules/find-my-way/lib/pretty-print.js
var require_pretty_print = __commonJS((exports, module) => {
  var printObjectTree = function(obj, parentPrefix = "") {
    let tree = "";
    const keys = Object.keys(obj);
    for (let i = 0;i < keys.length; i++) {
      const key = keys[i];
      const value = obj[key];
      const isLast = i === keys.length - 1;
      const nodePrefix = isLast ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ";
      const childPrefix = isLast ? "    " : "\u2502   ";
      const nodeData = value[treeDataSymbol] || "";
      const prefixedNodeData = nodeData.split("\n").join("\n" + parentPrefix + childPrefix);
      tree += parentPrefix + nodePrefix + key + prefixedNodeData + "\n";
      tree += printObjectTree(value, parentPrefix + childPrefix);
    }
    return tree;
  };
  var parseFunctionName = function(fn) {
    let fName = fn.name || "";
    fName = fName.replace("bound", "").trim();
    fName = (fName || "anonymous") + "()";
    return fName;
  };
  var parseMeta = function(meta) {
    if (Array.isArray(meta))
      return meta.map((m) => parseMeta(m));
    if (typeof meta === "symbol")
      return meta.toString();
    if (typeof meta === "function")
      return parseFunctionName(meta);
    return meta;
  };
  var getRouteMetaData = function(route, options) {
    if (!options.includeMeta)
      return {};
    const metaDataObject = options.buildPrettyMeta(route);
    const filteredMetaData = {};
    let includeMetaKeys = options.includeMeta;
    if (!Array.isArray(includeMetaKeys)) {
      includeMetaKeys = Reflect.ownKeys(metaDataObject);
    }
    for (const metaKey of includeMetaKeys) {
      if (!Object.prototype.hasOwnProperty.call(metaDataObject, metaKey))
        continue;
      const serializedKey = metaKey.toString();
      const metaValue = metaDataObject[metaKey];
      if (metaValue !== undefined && metaValue !== null) {
        const serializedValue = JSON.stringify(parseMeta(metaValue));
        filteredMetaData[serializedKey] = serializedValue;
      }
    }
    return filteredMetaData;
  };
  var serializeMetaData = function(metaData) {
    let serializedMetaData = "";
    for (const [key, value] of Object.entries(metaData)) {
      serializedMetaData += `
\u2022 (${key}) ${value}`;
    }
    return serializedMetaData;
  };
  var normalizeRoute = function(route) {
    const constraints = { ...route.opts.constraints };
    const method = constraints[httpMethodStrategy.name];
    delete constraints[httpMethodStrategy.name];
    return { ...route, method, opts: { constraints } };
  };
  var serializeRoute = function(route) {
    let serializedRoute = ` (${route.method})`;
    const constraints = route.opts.constraints || {};
    if (Object.keys(constraints).length !== 0) {
      serializedRoute += " " + JSON.stringify(constraints);
    }
    serializedRoute += serializeMetaData(route.metaData);
    return serializedRoute;
  };
  var mergeSimilarRoutes = function(routes) {
    return routes.reduce((mergedRoutes, route) => {
      for (const nodeRoute of mergedRoutes) {
        if (deepEqual(route.opts.constraints, nodeRoute.opts.constraints) && deepEqual(route.metaData, nodeRoute.metaData)) {
          nodeRoute.method += ", " + route.method;
          return mergedRoutes;
        }
      }
      mergedRoutes.push(route);
      return mergedRoutes;
    }, []);
  };
  var serializeNode = function(node9, prefix, options) {
    let routes = node9.routes;
    if (options.method === undefined) {
      routes = routes.map(normalizeRoute);
    }
    routes = routes.map((route) => {
      route.metaData = getRouteMetaData(route, options);
      return route;
    });
    if (options.method === undefined) {
      routes = mergeSimilarRoutes(routes);
    }
    return routes.map(serializeRoute).join(`\n${prefix}`);
  };
  var buildObjectTree = function(node9, tree, prefix, options) {
    if (node9.isLeafNode || options.commonPrefix !== false) {
      prefix = prefix || "(empty root node)";
      tree = tree[prefix] = {};
      if (node9.isLeafNode) {
        tree[treeDataSymbol] = serializeNode(node9, prefix, options);
      }
      prefix = "";
    }
    if (node9.staticChildren) {
      for (const child of Object.values(node9.staticChildren)) {
        buildObjectTree(child, tree, prefix + child.prefix, options);
      }
    }
    if (node9.parametricChildren) {
      for (const child of Object.values(node9.parametricChildren)) {
        const childPrefix = Array.from(child.nodePaths).join("|");
        buildObjectTree(child, tree, prefix + childPrefix, options);
      }
    }
    if (node9.wildcardChild) {
      buildObjectTree(node9.wildcardChild, tree, "*", options);
    }
  };
  var prettyPrintTree = function(root, options) {
    const objectTree = {};
    buildObjectTree(root, objectTree, root.prefix, options);
    return printObjectTree(objectTree);
  };
  var deepEqual = require_fast_deep_equal();
  var httpMethodStrategy = require_http_method();
  var treeDataSymbol = Symbol("treeData");
  module.exports = { prettyPrintTree };
});

// ../node_modules/.pnpm/find-my-way@8.1.0/node_modules/find-my-way/lib/handler-storage.js
var require_handler_storage = __commonJS((exports, module) => {
  var httpMethodStrategy = require_http_method();

  class HandlerStorage {
    constructor() {
      this.unconstrainedHandler = null;
      this.constraints = [];
      this.handlers = [];
      this.constrainedHandlerStores = null;
    }
    getMatchingHandler(derivedConstraints) {
      if (derivedConstraints === undefined) {
        return this.unconstrainedHandler;
      }
      return this._getHandlerMatchingConstraints(derivedConstraints);
    }
    addHandler(constrainer, route) {
      const params = route.params;
      const constraints = route.opts.constraints || {};
      const handlerObject = {
        params,
        constraints,
        handler: route.handler,
        store: route.store || null,
        _createParamsObject: this._compileCreateParamsObject(params)
      };
      const constraintsNames = Object.keys(constraints);
      if (constraintsNames.length === 0) {
        this.unconstrainedHandler = handlerObject;
      }
      for (const constraint of constraintsNames) {
        if (!this.constraints.includes(constraint)) {
          if (constraint === "version") {
            this.constraints.unshift(constraint);
          } else {
            this.constraints.push(constraint);
          }
        }
      }
      const isMergedTree = constraintsNames.includes(httpMethodStrategy.name);
      if (!isMergedTree && this.handlers.length >= 32) {
        throw new Error("find-my-way supports a maximum of 32 route handlers per node when there are constraints, limit reached");
      }
      this.handlers.push(handlerObject);
      this.handlers.sort((a, b) => Object.keys(a.constraints).length - Object.keys(b.constraints).length);
      if (!isMergedTree) {
        this._compileGetHandlerMatchingConstraints(constrainer, constraints);
      }
    }
    _compileCreateParamsObject(params) {
      const lines = [];
      for (let i = 0;i < params.length; i++) {
        lines.push(`'${params[i]}': paramsArray[${i}]`);
      }
      return new Function("paramsArray", `return {${lines.join(",")}}`);
    }
    _getHandlerMatchingConstraints() {
      return null;
    }
    _buildConstraintStore(store2, constraint) {
      for (let i = 0;i < this.handlers.length; i++) {
        const handler = this.handlers[i];
        const constraintValue = handler.constraints[constraint];
        if (constraintValue !== undefined) {
          let indexes = store2.get(constraintValue) || 0;
          indexes |= 1 << i;
          store2.set(constraintValue, indexes);
        }
      }
    }
    _constrainedIndexBitmask(constraint) {
      let mask = 0;
      for (let i = 0;i < this.handlers.length; i++) {
        const handler = this.handlers[i];
        const constraintValue = handler.constraints[constraint];
        if (constraintValue !== undefined) {
          mask |= 1 << i;
        }
      }
      return ~mask;
    }
    _compileGetHandlerMatchingConstraints(constrainer) {
      this.constrainedHandlerStores = {};
      for (const constraint of this.constraints) {
        const store2 = constrainer.newStoreForConstraint(constraint);
        this.constrainedHandlerStores[constraint] = store2;
        this._buildConstraintStore(store2, constraint);
      }
      const lines = [];
      lines.push(`
    let candidates = ${(1 << this.handlers.length) - 1}
    let mask, matches
    `);
      for (const constraint of this.constraints) {
        lines.push(`
      mask = ${this._constrainedIndexBitmask(constraint)}
      value = derivedConstraints.${constraint}
      `);
        const strategy = constrainer.strategies[constraint];
        const matchMask = strategy.mustMatchWhenDerived ? "matches" : "(matches | mask)";
        lines.push(`
      if (value === undefined) {
        candidates &= mask
      } else {
        matches = this.constrainedHandlerStores.${constraint}.get(value) || 0
        candidates &= ${matchMask}
      }
      if (candidates === 0) return null;
      `);
      }
      for (const constraint in constrainer.strategies) {
        const strategy = constrainer.strategies[constraint];
        if (strategy.mustMatchWhenDerived && !this.constraints.includes(constraint)) {
          lines.push(`if (derivedConstraints.${constraint} !== undefined) return null`);
        }
      }
      lines.push("return this.handlers[Math.floor(Math.log2(candidates))]");
      this._getHandlerMatchingConstraints = new Function("derivedConstraints", lines.join("\n"));
    }
  }
  module.exports = HandlerStorage;
});

// ../node_modules/.pnpm/find-my-way@8.1.0/node_modules/find-my-way/lib/node.js
var require_node2 = __commonJS((exports, module) => {
  var HandlerStorage = require_handler_storage();
  var NODE_TYPES = {
    STATIC: 0,
    PARAMETRIC: 1,
    WILDCARD: 2
  };

  class Node {
    constructor() {
      this.isLeafNode = false;
      this.routes = null;
      this.handlerStorage = null;
    }
    addRoute(route, constrainer) {
      if (this.routes === null) {
        this.routes = [];
      }
      if (this.handlerStorage === null) {
        this.handlerStorage = new HandlerStorage;
      }
      this.isLeafNode = true;
      this.routes.push(route);
      this.handlerStorage.addHandler(constrainer, route);
    }
  }

  class ParentNode extends Node {
    constructor() {
      super();
      this.staticChildren = {};
    }
    findStaticMatchingChild(path, pathIndex) {
      const staticChild = this.staticChildren[path.charAt(pathIndex)];
      if (staticChild === undefined || !staticChild.matchPrefix(path, pathIndex)) {
        return null;
      }
      return staticChild;
    }
    getStaticChild(path, pathIndex = 0) {
      if (path.length === pathIndex) {
        return this;
      }
      const staticChild = this.findStaticMatchingChild(path, pathIndex);
      if (staticChild) {
        return staticChild.getStaticChild(path, pathIndex + staticChild.prefix.length);
      }
      return null;
    }
    createStaticChild(path) {
      if (path.length === 0) {
        return this;
      }
      let staticChild = this.staticChildren[path.charAt(0)];
      if (staticChild) {
        let i = 1;
        for (;i < staticChild.prefix.length; i++) {
          if (path.charCodeAt(i) !== staticChild.prefix.charCodeAt(i)) {
            staticChild = staticChild.split(this, i);
            break;
          }
        }
        return staticChild.createStaticChild(path.slice(i));
      }
      const label = path.charAt(0);
      this.staticChildren[label] = new StaticNode(path);
      return this.staticChildren[label];
    }
  }

  class StaticNode extends ParentNode {
    constructor(prefix) {
      super();
      this.prefix = prefix;
      this.wildcardChild = null;
      this.parametricChildren = [];
      this.kind = NODE_TYPES.STATIC;
      this._compilePrefixMatch();
    }
    getParametricChild(regex3) {
      const regexpSource = regex3 && regex3.source;
      const parametricChild = this.parametricChildren.find((child) => {
        const childRegexSource = child.regex && child.regex.source;
        return childRegexSource === regexpSource;
      });
      if (parametricChild) {
        return parametricChild;
      }
      return null;
    }
    createParametricChild(regex3, staticSuffix, nodePath) {
      let parametricChild = this.getParametricChild(regex3);
      if (parametricChild) {
        parametricChild.nodePaths.add(nodePath);
        return parametricChild;
      }
      parametricChild = new ParametricNode(regex3, staticSuffix, nodePath);
      this.parametricChildren.push(parametricChild);
      this.parametricChildren.sort((child1, child2) => {
        if (!child1.isRegex)
          return 1;
        if (!child2.isRegex)
          return -1;
        if (child1.staticSuffix === null)
          return 1;
        if (child2.staticSuffix === null)
          return -1;
        if (child2.staticSuffix.endsWith(child1.staticSuffix))
          return 1;
        if (child1.staticSuffix.endsWith(child2.staticSuffix))
          return -1;
        return 0;
      });
      return parametricChild;
    }
    getWildcardChild() {
      if (this.wildcardChild) {
        return this.wildcardChild;
      }
      return null;
    }
    createWildcardChild() {
      this.wildcardChild = this.getWildcardChild() || new WildcardNode;
      return this.wildcardChild;
    }
    split(parentNode, length) {
      const parentPrefix = this.prefix.slice(0, length);
      const childPrefix = this.prefix.slice(length);
      this.prefix = childPrefix;
      this._compilePrefixMatch();
      const staticNode = new StaticNode(parentPrefix);
      staticNode.staticChildren[childPrefix.charAt(0)] = this;
      parentNode.staticChildren[parentPrefix.charAt(0)] = staticNode;
      return staticNode;
    }
    getNextNode(path, pathIndex, nodeStack, paramsCount) {
      let node9 = this.findStaticMatchingChild(path, pathIndex);
      let parametricBrotherNodeIndex = 0;
      if (node9 === null) {
        if (this.parametricChildren.length === 0) {
          return this.wildcardChild;
        }
        node9 = this.parametricChildren[0];
        parametricBrotherNodeIndex = 1;
      }
      if (this.wildcardChild !== null) {
        nodeStack.push({
          paramsCount,
          brotherPathIndex: pathIndex,
          brotherNode: this.wildcardChild
        });
      }
      for (let i = this.parametricChildren.length - 1;i >= parametricBrotherNodeIndex; i--) {
        nodeStack.push({
          paramsCount,
          brotherPathIndex: pathIndex,
          brotherNode: this.parametricChildren[i]
        });
      }
      return node9;
    }
    _compilePrefixMatch() {
      if (this.prefix.length === 1) {
        this.matchPrefix = () => true;
        return;
      }
      const lines = [];
      for (let i = 1;i < this.prefix.length; i++) {
        const charCode = this.prefix.charCodeAt(i);
        lines.push(`path.charCodeAt(i + ${i}) === ${charCode}`);
      }
      this.matchPrefix = new Function("path", "i", `return ${lines.join(" && ")}`);
    }
  }

  class ParametricNode extends ParentNode {
    constructor(regex3, staticSuffix, nodePath) {
      super();
      this.isRegex = !!regex3;
      this.regex = regex3 || null;
      this.staticSuffix = staticSuffix || null;
      this.kind = NODE_TYPES.PARAMETRIC;
      this.nodePaths = new Set([nodePath]);
    }
    getNextNode(path, pathIndex) {
      return this.findStaticMatchingChild(path, pathIndex);
    }
  }

  class WildcardNode extends Node {
    constructor() {
      super();
      this.kind = NODE_TYPES.WILDCARD;
    }
    getNextNode() {
      return null;
    }
  }
  module.exports = { StaticNode, ParametricNode, WildcardNode, NODE_TYPES };
});

// ../node_modules/.pnpm/find-my-way@8.1.0/node_modules/find-my-way/lib/strategies/accept-version.js
var require_accept_version = __commonJS((exports, module) => {
  var SemVerStore = function() {
    if (!(this instanceof SemVerStore)) {
      return new SemVerStore;
    }
    this.store = {};
    this.maxMajor = 0;
    this.maxMinors = {};
    this.maxPatches = {};
  };
  var assert = __require("assert");
  SemVerStore.prototype.set = function(version3, store2) {
    if (typeof version3 !== "string") {
      throw new TypeError("Version should be a string");
    }
    let [major, minor, patch] = version3.split(".");
    major = Number(major) || 0;
    minor = Number(minor) || 0;
    patch = Number(patch) || 0;
    if (major >= this.maxMajor) {
      this.maxMajor = major;
      this.store.x = store2;
      this.store["*"] = store2;
      this.store["x.x"] = store2;
      this.store["x.x.x"] = store2;
    }
    if (minor >= (this.maxMinors[major] || 0)) {
      this.maxMinors[major] = minor;
      this.store[`${major}.x`] = store2;
      this.store[`${major}.x.x`] = store2;
    }
    if (patch >= (this.store[`${major}.${minor}`] || 0)) {
      this.maxPatches[`${major}.${minor}`] = patch;
      this.store[`${major}.${minor}.x`] = store2;
    }
    this.store[`${major}.${minor}.${patch}`] = store2;
    return this;
  };
  SemVerStore.prototype.get = function(version3) {
    return this.store[version3];
  };
  module.exports = {
    name: "version",
    mustMatchWhenDerived: true,
    storage: SemVerStore,
    validate(value) {
      assert(typeof value === "string", "Version should be a string");
    }
  };
});

// ../node_modules/.pnpm/find-my-way@8.1.0/node_modules/find-my-way/lib/strategies/accept-host.js
var require_accept_host = __commonJS((exports, module) => {
  var HostStorage = function() {
    const hosts = {};
    const regexHosts = [];
    return {
      get: (host) => {
        const exact = hosts[host];
        if (exact) {
          return exact;
        }
        for (const regex3 of regexHosts) {
          if (regex3.host.test(host)) {
            return regex3.value;
          }
        }
      },
      set: (host, value) => {
        if (host instanceof RegExp) {
          regexHosts.push({ host, value });
        } else {
          hosts[host] = value;
        }
      }
    };
  };
  var assert = __require("assert");
  module.exports = {
    name: "host",
    mustMatchWhenDerived: false,
    storage: HostStorage,
    validate(value) {
      assert(typeof value === "string" || Object.prototype.toString.call(value) === "[object RegExp]", "Host should be a string or a RegExp");
    }
  };
});

// ../node_modules/.pnpm/find-my-way@8.1.0/node_modules/find-my-way/lib/constrainer.js
var require_constrainer = __commonJS((exports, module) => {
  var acceptVersionStrategy = require_accept_version();
  var acceptHostStrategy = require_accept_host();
  var assert = __require("assert");

  class Constrainer {
    constructor(customStrategies) {
      this.strategies = {
        version: acceptVersionStrategy,
        host: acceptHostStrategy
      };
      this.strategiesInUse = new Set;
      this.asyncStrategiesInUse = new Set;
      if (customStrategies) {
        for (const strategy of Object.values(customStrategies)) {
          this.addConstraintStrategy(strategy);
        }
      }
    }
    isStrategyUsed(strategyName) {
      return this.strategiesInUse.has(strategyName) || this.asyncStrategiesInUse.has(strategyName);
    }
    hasConstraintStrategy(strategyName) {
      const customConstraintStrategy = this.strategies[strategyName];
      if (customConstraintStrategy !== undefined) {
        return customConstraintStrategy.isCustom || this.isStrategyUsed(strategyName);
      }
      return false;
    }
    addConstraintStrategy(strategy) {
      assert(typeof strategy.name === "string" && strategy.name !== "", "strategy.name is required.");
      assert(strategy.storage && typeof strategy.storage === "function", "strategy.storage function is required.");
      assert(strategy.deriveConstraint && typeof strategy.deriveConstraint === "function", "strategy.deriveConstraint function is required.");
      if (this.strategies[strategy.name] && this.strategies[strategy.name].isCustom) {
        throw new Error(`There already exists a custom constraint with the name ${strategy.name}.`);
      }
      if (this.isStrategyUsed(strategy.name)) {
        throw new Error(`There already exists a route with ${strategy.name} constraint.`);
      }
      strategy.isCustom = true;
      strategy.isAsync = strategy.deriveConstraint.length === 3;
      this.strategies[strategy.name] = strategy;
      if (strategy.mustMatchWhenDerived) {
        this.noteUsage({ [strategy.name]: strategy });
      }
    }
    deriveConstraints(req, ctx, done) {
      const constraints = this.deriveSyncConstraints(req, ctx);
      if (done === undefined) {
        return constraints;
      }
      this.deriveAsyncConstraints(constraints, req, ctx, done);
    }
    deriveSyncConstraints(req, ctx) {
      return;
    }
    noteUsage(constraints) {
      if (constraints) {
        const beforeSize = this.strategiesInUse.size;
        for (const key in constraints) {
          const strategy = this.strategies[key];
          if (strategy.isAsync) {
            this.asyncStrategiesInUse.add(key);
          } else {
            this.strategiesInUse.add(key);
          }
        }
        if (beforeSize !== this.strategiesInUse.size) {
          this._buildDeriveConstraints();
        }
      }
    }
    newStoreForConstraint(constraint) {
      if (!this.strategies[constraint]) {
        throw new Error(`No strategy registered for constraint key ${constraint}`);
      }
      return this.strategies[constraint].storage();
    }
    validateConstraints(constraints) {
      for (const key in constraints) {
        const value = constraints[key];
        if (typeof value === "undefined") {
          throw new Error("Can\'t pass an undefined constraint value, must pass null or no key at all");
        }
        const strategy = this.strategies[key];
        if (!strategy) {
          throw new Error(`No strategy registered for constraint key ${key}`);
        }
        if (strategy.validate) {
          strategy.validate(value);
        }
      }
    }
    deriveAsyncConstraints(constraints, req, ctx, done) {
      let asyncConstraintsCount = this.asyncStrategiesInUse.size;
      if (asyncConstraintsCount === 0) {
        done(null, constraints);
        return;
      }
      constraints = constraints || {};
      for (const key of this.asyncStrategiesInUse) {
        const strategy = this.strategies[key];
        strategy.deriveConstraint(req, ctx, (err, constraintValue) => {
          if (err !== null) {
            done(err);
            return;
          }
          constraints[key] = constraintValue;
          if (--asyncConstraintsCount === 0) {
            done(null, constraints);
          }
        });
      }
    }
    _buildDeriveConstraints() {
      if (this.strategiesInUse.size === 0)
        return;
      const lines = ["return {"];
      for (const key of this.strategiesInUse) {
        const strategy = this.strategies[key];
        if (!strategy.isCustom) {
          if (key === "version") {
            lines.push("   version: req.headers[\'accept-version\'],");
          } else if (key === "host") {
            lines.push("   host: req.headers.host || req.headers[\':authority\'],");
          } else {
            throw new Error("unknown non-custom strategy for compiling constraint derivation function");
          }
        } else {
          lines.push(`  ${strategy.name}: this.strategies.${key}.deriveConstraint(req, ctx),`);
        }
      }
      lines.push("}");
      this.deriveSyncConstraints = new Function("req", "ctx", lines.join("\n")).bind(this);
    }
  }
  module.exports = Constrainer;
});

// ../node_modules/.pnpm/find-my-way@8.1.0/node_modules/find-my-way/lib/http-methods.js
var require_http_methods = __commonJS((exports, module) => {
  var httpMethods = [
    "ACL",
    "BIND",
    "CHECKOUT",
    "CONNECT",
    "COPY",
    "DELETE",
    "GET",
    "HEAD",
    "LINK",
    "LOCK",
    "M-SEARCH",
    "MERGE",
    "MKACTIVITY",
    "MKCALENDAR",
    "MKCOL",
    "MOVE",
    "NOTIFY",
    "OPTIONS",
    "PATCH",
    "POST",
    "PROPFIND",
    "PROPPATCH",
    "PURGE",
    "PUT",
    "REBIND",
    "REPORT",
    "SEARCH",
    "SOURCE",
    "SUBSCRIBE",
    "TRACE",
    "UNBIND",
    "UNLINK",
    "UNLOCK",
    "UNSUBSCRIBE"
  ];
  module.exports = httpMethods;
});

// ../node_modules/.pnpm/find-my-way@8.1.0/node_modules/find-my-way/lib/url-sanitizer.js
var require_url_sanitizer = __commonJS((exports, module) => {
  var decodeComponentChar = function(highCharCode, lowCharCode) {
    if (highCharCode === 50) {
      if (lowCharCode === 53)
        return "%";
      if (lowCharCode === 51)
        return "#";
      if (lowCharCode === 52)
        return "$";
      if (lowCharCode === 54)
        return "&";
      if (lowCharCode === 66)
        return "+";
      if (lowCharCode === 98)
        return "+";
      if (lowCharCode === 67)
        return ",";
      if (lowCharCode === 99)
        return ",";
      if (lowCharCode === 70)
        return "/";
      if (lowCharCode === 102)
        return "/";
      return null;
    }
    if (highCharCode === 51) {
      if (lowCharCode === 65)
        return ":";
      if (lowCharCode === 97)
        return ":";
      if (lowCharCode === 66)
        return ";";
      if (lowCharCode === 98)
        return ";";
      if (lowCharCode === 68)
        return "=";
      if (lowCharCode === 100)
        return "=";
      if (lowCharCode === 70)
        return "?";
      if (lowCharCode === 102)
        return "?";
      return null;
    }
    if (highCharCode === 52 && lowCharCode === 48) {
      return "@";
    }
    return null;
  };
  var safeDecodeURI = function(path, useSemicolonDelimiter) {
    let shouldDecode = false;
    let shouldDecodeParam = false;
    let querystring = "";
    for (let i = 1;i < path.length; i++) {
      const charCode = path.charCodeAt(i);
      if (charCode === 37) {
        const highCharCode = path.charCodeAt(i + 1);
        const lowCharCode = path.charCodeAt(i + 2);
        if (decodeComponentChar(highCharCode, lowCharCode) === null) {
          shouldDecode = true;
        } else {
          shouldDecodeParam = true;
          if (highCharCode === 50 && lowCharCode === 53) {
            shouldDecode = true;
            path = path.slice(0, i + 1) + "25" + path.slice(i + 1);
            i += 2;
          }
          i += 2;
        }
      } else if (charCode === 63 || charCode === 35 || charCode === 59 && useSemicolonDelimiter) {
        querystring = path.slice(i + 1);
        path = path.slice(0, i);
        break;
      }
    }
    const decodedPath = shouldDecode ? decodeURI(path) : path;
    return { path: decodedPath, querystring, shouldDecodeParam };
  };
  var safeDecodeURIComponent = function(uriComponent) {
    const startIndex = uriComponent.indexOf("%");
    if (startIndex === -1)
      return uriComponent;
    let decoded = "";
    let lastIndex = startIndex;
    for (let i = startIndex;i < uriComponent.length; i++) {
      if (uriComponent.charCodeAt(i) === 37) {
        const highCharCode = uriComponent.charCodeAt(i + 1);
        const lowCharCode = uriComponent.charCodeAt(i + 2);
        const decodedChar = decodeComponentChar(highCharCode, lowCharCode);
        decoded += uriComponent.slice(lastIndex, i) + decodedChar;
        lastIndex = i + 3;
      }
    }
    return uriComponent.slice(0, startIndex) + decoded + uriComponent.slice(lastIndex);
  };
  module.exports = { safeDecodeURI, safeDecodeURIComponent };
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fastify@4.26.0/node_modules/find-my-way/index.js
var require_find_my_way = __commonJS((exports, module) => {
  var Router = function(opts) {
    if (!(this instanceof Router)) {
      return new Router(opts);
    }
    opts = opts || {};
    this._opts = opts;
    if (opts.defaultRoute) {
      assert(typeof opts.defaultRoute === "function", "The default route must be a function");
      this.defaultRoute = opts.defaultRoute;
    } else {
      this.defaultRoute = null;
    }
    if (opts.onBadUrl) {
      assert(typeof opts.onBadUrl === "function", "The bad url handler must be a function");
      this.onBadUrl = opts.onBadUrl;
    } else {
      this.onBadUrl = null;
    }
    if (opts.buildPrettyMeta) {
      assert(typeof opts.buildPrettyMeta === "function", "buildPrettyMeta must be a function");
      this.buildPrettyMeta = opts.buildPrettyMeta;
    } else {
      this.buildPrettyMeta = defaultBuildPrettyMeta;
    }
    if (opts.querystringParser) {
      assert(typeof opts.querystringParser === "function", "querystringParser must be a function");
      this.querystringParser = opts.querystringParser;
    } else {
      this.querystringParser = (query) => query === "" ? {} : querystring.parse(query);
    }
    this.caseSensitive = opts.caseSensitive === undefined ? true : opts.caseSensitive;
    this.ignoreTrailingSlash = opts.ignoreTrailingSlash || false;
    this.ignoreDuplicateSlashes = opts.ignoreDuplicateSlashes || false;
    this.maxParamLength = opts.maxParamLength || 100;
    this.allowUnsafeRegex = opts.allowUnsafeRegex || false;
    this.constrainer = new Constrainer(opts.constraints);
    this.useSemicolonDelimiter = opts.useSemicolonDelimiter || false;
    this.routes = [];
    this.trees = {};
  };
  var escapeRegExp = function(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  };
  var removeDuplicateSlashes = function(path) {
    return path.replace(/\/\/+/g, "/");
  };
  var trimLastSlash = function(path) {
    if (path.length > 1 && path.charCodeAt(path.length - 1) === 47) {
      return path.slice(0, -1);
    }
    return path;
  };
  var trimRegExpStartAndEnd = function(regexString) {
    if (regexString.charCodeAt(1) === 94) {
      regexString = regexString.slice(0, 1) + regexString.slice(2);
    }
    if (regexString.charCodeAt(regexString.length - 2) === 36) {
      regexString = regexString.slice(0, regexString.length - 2) + regexString.slice(regexString.length - 1);
    }
    return regexString;
  };
  var getClosingParenthensePosition = function(path, idx) {
    let parentheses = 1;
    while (idx < path.length) {
      idx++;
      if (path[idx] === "\\") {
        idx++;
        continue;
      }
      if (path[idx] === ")") {
        parentheses--;
      } else if (path[idx] === "(") {
        parentheses++;
      }
      if (!parentheses)
        return idx;
    }
    throw new TypeError('Invalid regexp expression in "' + path + '"');
  };
  var defaultBuildPrettyMeta = function(route) {
    if (!route)
      return {};
    if (!route.store)
      return {};
    return Object.assign({}, route.store);
  };
  var assert = __require("assert");
  var querystring = require_lib2();
  var isRegexSafe = require_safe_regex2();
  var deepEqual = require_fast_deep_equal();
  var { prettyPrintTree } = require_pretty_print();
  var { StaticNode, NODE_TYPES } = require_node2();
  var Constrainer = require_constrainer();
  var httpMethods = require_http_methods();
  var httpMethodStrategy = require_http_method();
  var { safeDecodeURI, safeDecodeURIComponent } = require_url_sanitizer();
  var FULL_PATH_REGEXP = /^https?:\/\/.*?\//;
  var OPTIONAL_PARAM_REGEXP = /(\/:[^/()]*?)\?(\/?)/;
  if (!isRegexSafe(FULL_PATH_REGEXP)) {
    throw new Error("the FULL_PATH_REGEXP is not safe, update this module");
  }
  if (!isRegexSafe(OPTIONAL_PARAM_REGEXP)) {
    throw new Error("the OPTIONAL_PARAM_REGEXP is not safe, update this module");
  }
  Router.prototype.on = function on(method, path, opts, handler, store2) {
    if (typeof opts === "function") {
      if (handler !== undefined) {
        store2 = handler;
      }
      handler = opts;
      opts = {};
    }
    assert(typeof path === "string", "Path should be a string");
    assert(path.length > 0, "The path could not be empty");
    assert(path[0] === "/" || path[0] === "*", "The first character of a path should be `/` or `*`");
    assert(typeof handler === "function", "Handler should be a function");
    const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP);
    if (optionalParamMatch) {
      assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, "Optional Parameter needs to be the last parameter of the path");
      const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, "$1$2");
      const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, "$2");
      this.on(method, pathFull, opts, handler, store2);
      this.on(method, pathOptional, opts, handler, store2);
      return;
    }
    const route = path;
    if (this.ignoreDuplicateSlashes) {
      path = removeDuplicateSlashes(path);
    }
    if (this.ignoreTrailingSlash) {
      path = trimLastSlash(path);
    }
    const methods = Array.isArray(method) ? method : [method];
    for (const method2 of methods) {
      assert(typeof method2 === "string", "Method should be a string");
      assert(httpMethods.includes(method2), `Method '${method2}' is not an http method.`);
      this._on(method2, path, opts, handler, store2, route);
    }
  };
  Router.prototype._on = function _on(method, path, opts, handler, store2) {
    let constraints = {};
    if (opts.constraints !== undefined) {
      assert(typeof opts.constraints === "object" && opts.constraints !== null, "Constraints should be an object");
      if (Object.keys(opts.constraints).length !== 0) {
        constraints = opts.constraints;
      }
    }
    this.constrainer.validateConstraints(constraints);
    this.constrainer.noteUsage(constraints);
    if (this.trees[method] === undefined) {
      this.trees[method] = new StaticNode("/");
    }
    let pattern = path;
    if (pattern === "*" && this.trees[method].prefix.length !== 0) {
      const currentRoot = this.trees[method];
      this.trees[method] = new StaticNode("");
      this.trees[method].staticChildren["/"] = currentRoot;
    }
    let currentNode = this.trees[method];
    let parentNodePathIndex = currentNode.prefix.length;
    const params = [];
    for (let i = 0;i <= pattern.length; i++) {
      if (pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) === 58) {
        i++;
        continue;
      }
      const isParametricNode = pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) !== 58;
      const isWildcardNode = pattern.charCodeAt(i) === 42;
      if (isParametricNode || isWildcardNode || i === pattern.length && i !== parentNodePathIndex) {
        let staticNodePath = pattern.slice(parentNodePathIndex, i);
        if (!this.caseSensitive) {
          staticNodePath = staticNodePath.toLowerCase();
        }
        staticNodePath = staticNodePath.split("::").join(":");
        staticNodePath = staticNodePath.split("%").join("%25");
        currentNode = currentNode.createStaticChild(staticNodePath);
      }
      if (isParametricNode) {
        let isRegexNode = false;
        const regexps = [];
        let lastParamStartIndex = i + 1;
        for (let j = lastParamStartIndex;; j++) {
          const charCode = pattern.charCodeAt(j);
          const isRegexParam = charCode === 40;
          const isStaticPart = charCode === 45 || charCode === 46;
          const isEndOfNode = charCode === 47 || j === pattern.length;
          if (isRegexParam || isStaticPart || isEndOfNode) {
            const paramName = pattern.slice(lastParamStartIndex, j);
            params.push(paramName);
            isRegexNode = isRegexNode || isRegexParam || isStaticPart;
            if (isRegexParam) {
              const endOfRegexIndex = getClosingParenthensePosition(pattern, j);
              const regexString = pattern.slice(j, endOfRegexIndex + 1);
              if (!this.allowUnsafeRegex) {
                assert(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`);
              }
              regexps.push(trimRegExpStartAndEnd(regexString));
              j = endOfRegexIndex + 1;
            } else {
              regexps.push("(.*?)");
            }
            const staticPartStartIndex = j;
            for (;j < pattern.length; j++) {
              const charCode2 = pattern.charCodeAt(j);
              if (charCode2 === 47)
                break;
              if (charCode2 === 58) {
                const nextCharCode = pattern.charCodeAt(j + 1);
                if (nextCharCode === 58)
                  j++;
                else
                  break;
              }
            }
            let staticPart = pattern.slice(staticPartStartIndex, j);
            if (staticPart) {
              staticPart = staticPart.split("::").join(":");
              staticPart = staticPart.split("%").join("%25");
              regexps.push(escapeRegExp(staticPart));
            }
            lastParamStartIndex = j + 1;
            if (isEndOfNode || pattern.charCodeAt(j) === 47 || j === pattern.length) {
              const nodePattern = isRegexNode ? "()" + staticPart : staticPart;
              const nodePath = pattern.slice(i, j);
              pattern = pattern.slice(0, i + 1) + nodePattern + pattern.slice(j);
              i += nodePattern.length;
              const regex3 = isRegexNode ? new RegExp("^" + regexps.join("") + "$") : null;
              currentNode = currentNode.createParametricChild(regex3, staticPart || null, nodePath);
              parentNodePathIndex = i + 1;
              break;
            }
          }
        }
      } else if (isWildcardNode) {
        params.push("*");
        currentNode = currentNode.createWildcardChild();
        parentNodePathIndex = i + 1;
        if (i !== pattern.length - 1) {
          throw new Error("Wildcard must be the last character in the route");
        }
      }
    }
    if (!this.caseSensitive) {
      pattern = pattern.toLowerCase();
    }
    if (pattern === "*") {
      pattern = "/*";
    }
    for (const existRoute of this.routes) {
      const routeConstraints = existRoute.opts.constraints || {};
      if (existRoute.method === method && existRoute.pattern === pattern && deepEqual(routeConstraints, constraints)) {
        throw new Error(`Method '${method}' already declared for route '${pattern}' with constraints '${JSON.stringify(constraints)}'`);
      }
    }
    const route = { method, path, pattern, params, opts, handler, store: store2 };
    this.routes.push(route);
    currentNode.addRoute(route, this.constrainer);
  };
  Router.prototype.hasRoute = function hasRoute(method, path, constraints) {
    const route = this.findRoute(method, path, constraints);
    return route !== null;
  };
  Router.prototype.findRoute = function findNode(method, path, constraints = {}) {
    if (this.trees[method] === undefined) {
      return null;
    }
    let pattern = path;
    let currentNode = this.trees[method];
    let parentNodePathIndex = currentNode.prefix.length;
    const params = [];
    for (let i = 0;i <= pattern.length; i++) {
      if (pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) === 58) {
        i++;
        continue;
      }
      const isParametricNode = pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) !== 58;
      const isWildcardNode = pattern.charCodeAt(i) === 42;
      if (isParametricNode || isWildcardNode || i === pattern.length && i !== parentNodePathIndex) {
        let staticNodePath = pattern.slice(parentNodePathIndex, i);
        if (!this.caseSensitive) {
          staticNodePath = staticNodePath.toLowerCase();
        }
        staticNodePath = staticNodePath.split("::").join(":");
        staticNodePath = staticNodePath.split("%").join("%25");
        currentNode = currentNode.getStaticChild(staticNodePath);
        if (currentNode === null) {
          return null;
        }
      }
      if (isParametricNode) {
        let isRegexNode = false;
        const regexps = [];
        let lastParamStartIndex = i + 1;
        for (let j = lastParamStartIndex;; j++) {
          const charCode = pattern.charCodeAt(j);
          const isRegexParam = charCode === 40;
          const isStaticPart = charCode === 45 || charCode === 46;
          const isEndOfNode = charCode === 47 || j === pattern.length;
          if (isRegexParam || isStaticPart || isEndOfNode) {
            const paramName = pattern.slice(lastParamStartIndex, j);
            params.push(paramName);
            isRegexNode = isRegexNode || isRegexParam || isStaticPart;
            if (isRegexParam) {
              const endOfRegexIndex = getClosingParenthensePosition(pattern, j);
              const regexString = pattern.slice(j, endOfRegexIndex + 1);
              if (!this.allowUnsafeRegex) {
                assert(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`);
              }
              regexps.push(trimRegExpStartAndEnd(regexString));
              j = endOfRegexIndex + 1;
            } else {
              regexps.push("(.*?)");
            }
            const staticPartStartIndex = j;
            for (;j < pattern.length; j++) {
              const charCode2 = pattern.charCodeAt(j);
              if (charCode2 === 47)
                break;
              if (charCode2 === 58) {
                const nextCharCode = pattern.charCodeAt(j + 1);
                if (nextCharCode === 58)
                  j++;
                else
                  break;
              }
            }
            let staticPart = pattern.slice(staticPartStartIndex, j);
            if (staticPart) {
              staticPart = staticPart.split("::").join(":");
              staticPart = staticPart.split("%").join("%25");
              regexps.push(escapeRegExp(staticPart));
            }
            lastParamStartIndex = j + 1;
            if (isEndOfNode || pattern.charCodeAt(j) === 47 || j === pattern.length) {
              const nodePattern = isRegexNode ? "()" + staticPart : staticPart;
              const nodePath = pattern.slice(i, j);
              pattern = pattern.slice(0, i + 1) + nodePattern + pattern.slice(j);
              i += nodePattern.length;
              const regex3 = isRegexNode ? new RegExp("^" + regexps.join("") + "$") : null;
              currentNode = currentNode.getParametricChild(regex3, staticPart || null, nodePath);
              if (currentNode === null) {
                return null;
              }
              parentNodePathIndex = i + 1;
              break;
            }
          }
        }
      } else if (isWildcardNode) {
        params.push("*");
        currentNode = currentNode.getWildcardChild();
        if (currentNode === null) {
          return null;
        }
        parentNodePathIndex = i + 1;
        if (i !== pattern.length - 1) {
          throw new Error("Wildcard must be the last character in the route");
        }
      }
    }
    if (!this.caseSensitive) {
      pattern = pattern.toLowerCase();
    }
    if (pattern === "*") {
      pattern = "/*";
    }
    for (const existRoute of this.routes) {
      const routeConstraints = existRoute.opts.constraints || {};
      if (existRoute.method === method && existRoute.pattern === pattern && deepEqual(routeConstraints, constraints)) {
        return {
          handler: existRoute.handler,
          store: existRoute.store,
          params: existRoute.params || []
        };
      }
    }
    return null;
  };
  Router.prototype.hasConstraintStrategy = function(strategyName) {
    return this.constrainer.hasConstraintStrategy(strategyName);
  };
  Router.prototype.addConstraintStrategy = function(constraints) {
    this.constrainer.addConstraintStrategy(constraints);
    this._rebuild(this.routes);
  };
  Router.prototype.reset = function reset() {
    this.trees = {};
    this.routes = [];
  };
  Router.prototype.off = function off(method, path, constraints) {
    assert(typeof path === "string", "Path should be a string");
    assert(path.length > 0, "The path could not be empty");
    assert(path[0] === "/" || path[0] === "*", "The first character of a path should be `/` or `*`");
    assert(typeof constraints === "undefined" || typeof constraints === "object" && !Array.isArray(constraints) && constraints !== null, "Constraints should be an object or undefined.");
    const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP);
    if (optionalParamMatch) {
      assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, "Optional Parameter needs to be the last parameter of the path");
      const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, "$1$2");
      const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, "$2");
      this.off(method, pathFull, constraints);
      this.off(method, pathOptional, constraints);
      return;
    }
    if (this.ignoreDuplicateSlashes) {
      path = removeDuplicateSlashes(path);
    }
    if (this.ignoreTrailingSlash) {
      path = trimLastSlash(path);
    }
    const methods = Array.isArray(method) ? method : [method];
    for (const method2 of methods) {
      this._off(method2, path, constraints);
    }
  };
  Router.prototype._off = function _off(method, path, constraints) {
    assert(typeof method === "string", "Method should be a string");
    assert(httpMethods.includes(method), `Method '${method}' is not an http method.`);
    function matcherWithoutConstraints(route) {
      return method !== route.method || path !== route.path;
    }
    function matcherWithConstraints(route) {
      return matcherWithoutConstraints(route) || !deepEqual(constraints, route.opts.constraints || {});
    }
    const predicate = constraints ? matcherWithConstraints : matcherWithoutConstraints;
    const newRoutes = this.routes.filter(predicate);
    this._rebuild(newRoutes);
  };
  Router.prototype.lookup = function lookup(req, res, ctx, done) {
    if (typeof ctx === "function") {
      done = ctx;
      ctx = undefined;
    }
    if (done === undefined) {
      const constraints = this.constrainer.deriveConstraints(req, ctx);
      const handle = this.find(req.method, req.url, constraints);
      return this.callHandler(handle, req, res, ctx);
    }
    this.constrainer.deriveConstraints(req, ctx, (err, constraints) => {
      if (err !== null) {
        done(err);
        return;
      }
      try {
        const handle = this.find(req.method, req.url, constraints);
        const result = this.callHandler(handle, req, res, ctx);
        done(null, result);
      } catch (err2) {
        done(err2);
      }
    });
  };
  Router.prototype.callHandler = function callHandler(handle, req, res, ctx) {
    if (handle === null)
      return this._defaultRoute(req, res, ctx);
    return ctx === undefined ? handle.handler(req, res, handle.params, handle.store, handle.searchParams) : handle.handler.call(ctx, req, res, handle.params, handle.store, handle.searchParams);
  };
  Router.prototype.find = function find(method, path, derivedConstraints) {
    let currentNode = this.trees[method];
    if (currentNode === undefined)
      return null;
    if (path.charCodeAt(0) !== 47) {
      path = path.replace(FULL_PATH_REGEXP, "/");
    }
    if (this.ignoreDuplicateSlashes) {
      path = removeDuplicateSlashes(path);
    }
    let sanitizedUrl;
    let querystring2;
    let shouldDecodeParam;
    try {
      sanitizedUrl = safeDecodeURI(path, this.useSemicolonDelimiter);
      path = sanitizedUrl.path;
      querystring2 = sanitizedUrl.querystring;
      shouldDecodeParam = sanitizedUrl.shouldDecodeParam;
    } catch (error) {
      return this._onBadUrl(path);
    }
    if (this.ignoreTrailingSlash) {
      path = trimLastSlash(path);
    }
    const originPath = path;
    if (this.caseSensitive === false) {
      path = path.toLowerCase();
    }
    const maxParamLength = this.maxParamLength;
    let pathIndex = currentNode.prefix.length;
    const params = [];
    const pathLen = path.length;
    const brothersNodesStack = [];
    while (true) {
      if (pathIndex === pathLen && currentNode.isLeafNode) {
        const handle = currentNode.handlerStorage.getMatchingHandler(derivedConstraints);
        if (handle !== null) {
          return {
            handler: handle.handler,
            store: handle.store,
            params: handle._createParamsObject(params),
            searchParams: this.querystringParser(querystring2)
          };
        }
      }
      let node9 = currentNode.getNextNode(path, pathIndex, brothersNodesStack, params.length);
      if (node9 === null) {
        if (brothersNodesStack.length === 0) {
          return null;
        }
        const brotherNodeState = brothersNodesStack.pop();
        pathIndex = brotherNodeState.brotherPathIndex;
        params.splice(brotherNodeState.paramsCount);
        node9 = brotherNodeState.brotherNode;
      }
      currentNode = node9;
      if (currentNode.kind === NODE_TYPES.STATIC) {
        pathIndex += currentNode.prefix.length;
        continue;
      }
      if (currentNode.kind === NODE_TYPES.WILDCARD) {
        let param = originPath.slice(pathIndex);
        if (shouldDecodeParam) {
          param = safeDecodeURIComponent(param);
        }
        params.push(param);
        pathIndex = pathLen;
        continue;
      }
      if (currentNode.kind === NODE_TYPES.PARAMETRIC) {
        let paramEndIndex = originPath.indexOf("/", pathIndex);
        if (paramEndIndex === -1) {
          paramEndIndex = pathLen;
        }
        let param = originPath.slice(pathIndex, paramEndIndex);
        if (shouldDecodeParam) {
          param = safeDecodeURIComponent(param);
        }
        if (currentNode.isRegex) {
          const matchedParameters = currentNode.regex.exec(param);
          if (matchedParameters === null)
            continue;
          for (let i = 1;i < matchedParameters.length; i++) {
            const matchedParam = matchedParameters[i];
            if (matchedParam.length > maxParamLength) {
              return null;
            }
            params.push(matchedParam);
          }
        } else {
          if (param.length > maxParamLength) {
            return null;
          }
          params.push(param);
        }
        pathIndex = paramEndIndex;
      }
    }
  };
  Router.prototype._rebuild = function(routes) {
    this.reset();
    for (const route of routes) {
      const { method, path, opts, handler, store: store2 } = route;
      this._on(method, path, opts, handler, store2);
    }
  };
  Router.prototype._defaultRoute = function(req, res, ctx) {
    if (this.defaultRoute !== null) {
      return ctx === undefined ? this.defaultRoute(req, res) : this.defaultRoute.call(ctx, req, res);
    } else {
      res.statusCode = 404;
      res.end();
    }
  };
  Router.prototype._onBadUrl = function(path) {
    if (this.onBadUrl === null) {
      return null;
    }
    const onBadUrl = this.onBadUrl;
    return {
      handler: (req, res, ctx) => onBadUrl(path, req, res),
      params: {},
      store: null
    };
  };
  Router.prototype.prettyPrint = function(options = {}) {
    const method = options.method;
    options.buildPrettyMeta = this.buildPrettyMeta.bind(this);
    let tree = null;
    if (method === undefined) {
      const { version: version3, host, ...constraints } = this.constrainer.strategies;
      constraints[httpMethodStrategy.name] = httpMethodStrategy;
      const mergedRouter = new Router({ ...this._opts, constraints });
      const mergedRoutes = this.routes.map((route) => {
        const constraints2 = {
          ...route.opts.constraints,
          [httpMethodStrategy.name]: route.method
        };
        return { ...route, method: "MERGED", opts: { constraints: constraints2 } };
      });
      mergedRouter._rebuild(mergedRoutes);
      tree = mergedRouter.trees.MERGED;
    } else {
      tree = this.trees[method];
    }
    if (tree == null)
      return "(empty tree)";
    return prettyPrintTree(tree, options);
  };
  for (const i in httpMethods) {
    if (!httpMethods.hasOwnProperty(i))
      continue;
    const m = httpMethods[i];
    const methodName = m.toLowerCase();
    if (Router.prototype[methodName])
      throw new Error("Method already exists: " + methodName);
    Router.prototype[methodName] = function(path, handler, store2) {
      return this.on(m, path, handler, store2);
    };
  }
  Router.prototype.all = function(path, handler, store2) {
    this.on(httpMethods, path, handler, store2);
  };
  module.exports = Router;
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/headRoute.js
var require_headRoute = __commonJS((exports, module) => {
  var headRouteOnSendHandler = function(req, reply, payload, done) {
    if (payload === undefined) {
      reply.header("content-length", "0");
      return done(null, null);
    }
    if (typeof payload.resume === "function") {
      payload.on("error", (err) => {
        reply.log.error({ err }, "Error on Stream found for HEAD route");
      });
      payload.resume();
      return done(null, null);
    }
    const size9 = "" + Buffer.byteLength(payload);
    reply.header("content-length", size9);
    done(null, null);
  };
  var parseHeadOnSendHandlers = function(onSendHandlers) {
    if (onSendHandlers == null)
      return headRouteOnSendHandler;
    return Array.isArray(onSendHandlers) ? [...onSendHandlers, headRouteOnSendHandler] : [onSendHandlers, headRouteOnSendHandler];
  };
  module.exports = {
    parseHeadOnSendHandlers
  };
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/route.js
var require_route = __commonJS((exports, module) => {
  var buildRouting = function(options) {
    const router = FindMyWay(options.config);
    let avvio;
    let fourOhFour;
    let logger3;
    let hasLogger;
    let setupResponseListeners;
    let throwIfAlreadyStarted;
    let disableRequestLogging;
    let ignoreTrailingSlash;
    let ignoreDuplicateSlashes;
    let return503OnClosing;
    let globalExposeHeadRoutes;
    let validateHTTPVersion;
    let keepAliveConnections;
    let closing = false;
    return {
      setup(options2, fastifyArgs) {
        avvio = fastifyArgs.avvio;
        fourOhFour = fastifyArgs.fourOhFour;
        logger3 = fastifyArgs.logger;
        hasLogger = fastifyArgs.hasLogger;
        setupResponseListeners = fastifyArgs.setupResponseListeners;
        throwIfAlreadyStarted = fastifyArgs.throwIfAlreadyStarted;
        validateHTTPVersion = fastifyArgs.validateHTTPVersion;
        globalExposeHeadRoutes = options2.exposeHeadRoutes;
        disableRequestLogging = options2.disableRequestLogging;
        ignoreTrailingSlash = options2.ignoreTrailingSlash;
        ignoreDuplicateSlashes = options2.ignoreDuplicateSlashes;
        return503OnClosing = Object.prototype.hasOwnProperty.call(options2, "return503OnClosing") ? options2.return503OnClosing : true;
        keepAliveConnections = fastifyArgs.keepAliveConnections;
      },
      routing: router.lookup.bind(router),
      route,
      hasRoute,
      prepareRoute,
      getDefaultRoute: function() {
        FSTDEP014();
        return router.defaultRoute;
      },
      setDefaultRoute: function(defaultRoute) {
        FSTDEP014();
        if (typeof defaultRoute !== "function") {
          throw new FST_ERR_DEFAULT_ROUTE_INVALID_TYPE;
        }
        router.defaultRoute = defaultRoute;
      },
      routeHandler,
      closeRoutes: () => {
        closing = true;
      },
      printRoutes: router.prettyPrint.bind(router),
      addConstraintStrategy,
      hasConstraintStrategy,
      isAsyncConstraint,
      findRoute
    };
    function addConstraintStrategy(strategy) {
      throwIfAlreadyStarted("Cannot add constraint strategy!");
      return router.addConstraintStrategy(strategy);
    }
    function hasConstraintStrategy(strategyName) {
      return router.hasConstraintStrategy(strategyName);
    }
    function isAsyncConstraint() {
      return router.constrainer.asyncStrategiesInUse.size > 0;
    }
    function prepareRoute({ method, url, options: options2, handler, isFastify }) {
      if (typeof url !== "string") {
        throw new FST_ERR_INVALID_URL(typeof url);
      }
      if (!handler && typeof options2 === "function") {
        handler = options2;
        options2 = {};
      } else if (handler && typeof handler === "function") {
        if (Object.prototype.toString.call(options2) !== "[object Object]") {
          throw new FST_ERR_ROUTE_OPTIONS_NOT_OBJ(method, url);
        } else if (options2.handler) {
          if (typeof options2.handler === "function") {
            throw new FST_ERR_ROUTE_DUPLICATED_HANDLER(method, url);
          } else {
            throw new FST_ERR_ROUTE_HANDLER_NOT_FN(method, url);
          }
        }
      }
      options2 = Object.assign({}, options2, {
        method,
        url,
        path: url,
        handler: handler || options2 && options2.handler
      });
      return route.call(this, { options: options2, isFastify });
    }
    function hasRoute({ options: options2 }) {
      return findRoute(options2) !== null;
    }
    function findRoute(options2) {
      const route2 = router.find(options2.method, options2.url || "", options2.constraints);
      if (route2) {
        return {
          handler: route2.handler,
          params: route2.params,
          searchParams: route2.searchParams
        };
      } else {
        return null;
      }
    }
    function route({ options: options2, isFastify }) {
      const opts = { ...options2 };
      const { exposeHeadRoute } = opts;
      const hasRouteExposeHeadRouteFlag = exposeHeadRoute != null;
      const shouldExposeHead = hasRouteExposeHeadRouteFlag ? exposeHeadRoute : globalExposeHeadRoutes;
      const isGetRoute = opts.method === "GET" || Array.isArray(opts.method) && opts.method.includes("GET");
      const isHeadRoute = opts.method === "HEAD" || Array.isArray(opts.method) && opts.method.includes("HEAD");
      const headOpts = shouldExposeHead && isGetRoute ? { ...options2 } : null;
      throwIfAlreadyStarted("Cannot add route!");
      const path = opts.url || opts.path || "";
      if (Array.isArray(opts.method)) {
        for (var i = 0;i < opts.method.length; ++i) {
          opts.method[i] = normalizeAndValidateMethod(opts.method[i]);
          validateSchemaBodyOption(opts.method[i], path, opts.schema);
        }
      } else {
        opts.method = normalizeAndValidateMethod(opts.method);
        validateSchemaBodyOption(opts.method, path, opts.schema);
      }
      if (!opts.handler) {
        throw new FST_ERR_ROUTE_MISSING_HANDLER(opts.method, path);
      }
      if (opts.errorHandler !== undefined && typeof opts.errorHandler !== "function") {
        throw new FST_ERR_ROUTE_HANDLER_NOT_FN(opts.method, path);
      }
      validateBodyLimitOption(opts.bodyLimit);
      const prefix = this[kRoutePrefix];
      if (path === "/" && prefix.length > 0 && opts.method !== "HEAD") {
        switch (opts.prefixTrailingSlash) {
          case "slash":
            addNewRoute.call(this, { path, isFastify });
            break;
          case "no-slash":
            addNewRoute.call(this, { path: "", isFastify });
            break;
          case "both":
          default:
            addNewRoute.call(this, { path: "", isFastify });
            if (ignoreTrailingSlash !== true && (ignoreDuplicateSlashes !== true || !prefix.endsWith("/"))) {
              addNewRoute.call(this, { path, prefixing: true, isFastify });
            }
        }
      } else if (path[0] === "/" && prefix.endsWith("/")) {
        addNewRoute.call(this, { path: path.slice(1), isFastify });
      } else {
        addNewRoute.call(this, { path, isFastify });
      }
      return this;
      function addNewRoute({ path: path2, prefixing = false, isFastify: isFastify2 = false }) {
        const url = prefix + path2;
        opts.url = url;
        opts.path = url;
        opts.routePath = path2;
        opts.prefix = prefix;
        opts.logLevel = opts.logLevel || this[kLogLevel];
        if (this[kLogSerializers] || opts.logSerializers) {
          opts.logSerializers = Object.assign(Object.create(this[kLogSerializers]), opts.logSerializers);
        }
        if (opts.attachValidation == null) {
          opts.attachValidation = false;
        }
        if (prefixing === false) {
          for (const hook of this[kHooks].onRoute) {
            hook.call(this, opts);
          }
        }
        for (const hook of lifecycleHooks) {
          if (opts && hook in opts) {
            if (Array.isArray(opts[hook])) {
              for (const func of opts[hook]) {
                if (typeof func !== "function") {
                  throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(func));
                }
                if (hook === "onSend" || hook === "preSerialization" || hook === "onError" || hook === "preParsing") {
                  if (func.constructor.name === "AsyncFunction" && func.length === 4) {
                    throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER;
                  }
                } else if (hook === "onRequestAbort") {
                  if (func.constructor.name === "AsyncFunction" && func.length !== 1) {
                    throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER;
                  }
                } else {
                  if (func.constructor.name === "AsyncFunction" && func.length === 3) {
                    throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER;
                  }
                }
              }
            } else if (opts[hook] !== undefined && typeof opts[hook] !== "function") {
              throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(opts[hook]));
            }
          }
        }
        const constraints = opts.constraints || {};
        const config = {
          ...opts.config,
          url,
          method: opts.method
        };
        const context = new Context({
          schema: opts.schema,
          handler: opts.handler.bind(this),
          config,
          errorHandler: opts.errorHandler,
          childLoggerFactory: opts.childLoggerFactory,
          bodyLimit: opts.bodyLimit,
          logLevel: opts.logLevel,
          logSerializers: opts.logSerializers,
          attachValidation: opts.attachValidation,
          schemaErrorFormatter: opts.schemaErrorFormatter,
          replySerializer: this[kReplySerializerDefault],
          validatorCompiler: opts.validatorCompiler,
          serializerCompiler: opts.serializerCompiler,
          exposeHeadRoute: shouldExposeHead,
          prefixTrailingSlash: opts.prefixTrailingSlash || "both",
          server: this,
          isFastify: isFastify2
        });
        if (opts.version) {
          FSTDEP008();
          constraints.version = opts.version;
        }
        const headHandler = router.findRoute("HEAD", opts.url, constraints);
        const hasHEADHandler = headHandler !== null;
        if (isHeadRoute && hasHEADHandler && !context[kRouteByFastify] && headHandler.store[kRouteByFastify]) {
          router.off("HEAD", opts.url, constraints);
        }
        try {
          router.on(opts.method, opts.url, { constraints }, routeHandler, context);
        } catch (error) {
          if (!context[kRouteByFastify]) {
            const isDuplicatedRoute = error.message.includes(`Method '${opts.method}' already declared for route '${opts.url}'`);
            if (isDuplicatedRoute) {
              throw new FST_ERR_DUPLICATED_ROUTE(opts.method, opts.url);
            }
            throw error;
          }
        }
        this.after((notHandledErr, done) => {
          context.errorHandler = opts.errorHandler ? buildErrorHandler(this[kErrorHandler], opts.errorHandler) : this[kErrorHandler];
          context._parserOptions.limit = opts.bodyLimit || null;
          context.logLevel = opts.logLevel;
          context.logSerializers = opts.logSerializers;
          context.attachValidation = opts.attachValidation;
          context[kReplySerializerDefault] = this[kReplySerializerDefault];
          context.schemaErrorFormatter = opts.schemaErrorFormatter || this[kSchemaErrorFormatter] || context.schemaErrorFormatter;
          avvio.once("preReady", () => {
            for (const hook of lifecycleHooks) {
              const toSet = this[kHooks][hook].concat(opts[hook] || []).map((h) => h.bind(this));
              context[hook] = toSet.length ? toSet : null;
            }
            while (!context.Request[kHasBeenDecorated] && context.Request.parent) {
              context.Request = context.Request.parent;
            }
            while (!context.Reply[kHasBeenDecorated] && context.Reply.parent) {
              context.Reply = context.Reply.parent;
            }
            fourOhFour.setContext(this, context);
            if (opts.schema) {
              context.schema = normalizeSchema(context.schema, this.initialConfig);
              const schemaController = this[kSchemaController];
              if (!opts.validatorCompiler && (opts.schema.body || opts.schema.headers || opts.schema.querystring || opts.schema.params)) {
                schemaController.setupValidator(this[kOptions]);
              }
              try {
                const isCustom = typeof opts?.validatorCompiler === "function" || schemaController.isCustomValidatorCompiler;
                compileSchemasForValidation(context, opts.validatorCompiler || schemaController.validatorCompiler, isCustom);
              } catch (error) {
                throw new FST_ERR_SCH_VALIDATION_BUILD(opts.method, url, error.message);
              }
              if (opts.schema.response && !opts.serializerCompiler) {
                schemaController.setupSerializer(this[kOptions]);
              }
              try {
                compileSchemasForSerialization(context, opts.serializerCompiler || schemaController.serializerCompiler);
              } catch (error) {
                throw new FST_ERR_SCH_SERIALIZATION_BUILD(opts.method, url, error.message);
              }
            }
          });
          done(notHandledErr);
        });
        if (shouldExposeHead && isGetRoute && !isHeadRoute && !hasHEADHandler) {
          const onSendHandlers = parseHeadOnSendHandlers(headOpts.onSend);
          prepareRoute.call(this, { method: "HEAD", url: path2, options: { ...headOpts, onSend: onSendHandlers }, isFastify: true });
        } else if (hasHEADHandler && exposeHeadRoute) {
          FSTDEP007();
        }
      }
    }
    function routeHandler(req, res, params, context, query) {
      const id2 = getGenReqId(context.server, req);
      const loggerOpts = {
        level: context.logLevel
      };
      if (context.logSerializers) {
        loggerOpts.serializers = context.logSerializers;
      }
      const childLogger = createChildLogger(context, logger3, req, id2, loggerOpts);
      childLogger[kDisableRequestLogging] = disableRequestLogging;
      if (!validateHTTPVersion(req.httpVersion)) {
        childLogger.info({ res: { statusCode: 505 } }, "request aborted - invalid HTTP version");
        const message = '{"error":"HTTP Version Not Supported","message":"HTTP Version Not Supported","statusCode":505}';
        const headers = {
          "Content-Type": "application/json",
          "Content-Length": message.length
        };
        res.writeHead(505, headers);
        res.end(message);
        return;
      }
      if (closing === true) {
        if (req.httpVersionMajor !== 2) {
          res.setHeader("Connection", "close");
        }
        if (return503OnClosing) {
          const headers = {
            "Content-Type": "application/json",
            "Content-Length": "80"
          };
          res.writeHead(503, headers);
          res.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}');
          childLogger.info({ res: { statusCode: 503 } }, "request aborted - refusing to accept new requests as server is closing");
          return;
        }
      }
      const connHeader = String.prototype.toLowerCase.call(req.headers.connection || "");
      if (connHeader === "keep-alive") {
        if (keepAliveConnections.has(req.socket) === false) {
          keepAliveConnections.add(req.socket);
          req.socket.on("close", removeTrackedSocket.bind({ keepAliveConnections, socket: req.socket }));
        }
      }
      if (req.headers[kRequestAcceptVersion] !== undefined) {
        req.headers["accept-version"] = req.headers[kRequestAcceptVersion];
        req.headers[kRequestAcceptVersion] = undefined;
      }
      const request5 = new context.Request(id2, params, req, query, childLogger, context);
      const reply = new context.Reply(res, request5, childLogger);
      if (disableRequestLogging === false) {
        childLogger.info({ req: request5 }, "incoming request");
      }
      if (hasLogger === true || context.onResponse !== null) {
        setupResponseListeners(reply);
      }
      if (context.onRequest !== null) {
        onRequestHookRunner(context.onRequest, request5, reply, runPreParsing);
      } else {
        runPreParsing(null, request5, reply);
      }
      if (context.onRequestAbort !== null) {
        req.on("close", () => {
          if (req.aborted) {
            onRequestAbortHookRunner(context.onRequestAbort, request5, handleOnRequestAbortHooksErrors.bind(null, reply));
          }
        });
      }
      if (context.onTimeout !== null) {
        if (!request5.raw.socket._meta) {
          request5.raw.socket.on("timeout", handleTimeout);
        }
        request5.raw.socket._meta = { context, request: request5, reply };
      }
    }
  };
  var handleOnRequestAbortHooksErrors = function(reply, err) {
    if (err) {
      reply.log.error({ err }, "onRequestAborted hook failed");
    }
  };
  var handleTimeout = function() {
    const { context, request: request5, reply } = this._meta;
    onTimeoutHookRunner(context.onTimeout, request5, reply, noop);
  };
  var normalizeAndValidateMethod = function(method) {
    if (typeof method !== "string") {
      throw new FST_ERR_ROUTE_METHOD_INVALID;
    }
    method = method.toUpperCase();
    if (supportedMethods.indexOf(method) === -1) {
      throw new FST_ERR_ROUTE_METHOD_NOT_SUPPORTED(method);
    }
    return method;
  };
  var validateSchemaBodyOption = function(method, path, schema) {
    if ((method === "GET" || method === "HEAD") && schema && schema.body) {
      throw new FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED(method, path);
    }
  };
  var validateBodyLimitOption = function(bodyLimit) {
    if (bodyLimit === undefined)
      return;
    if (!Number.isInteger(bodyLimit) || bodyLimit <= 0) {
      throw new FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT(bodyLimit);
    }
  };
  var runPreParsing = function(err, request5, reply) {
    if (reply.sent === true)
      return;
    if (err != null) {
      reply[kReplyIsError] = true;
      reply.send(err);
      return;
    }
    request5[kRequestPayloadStream] = request5.raw;
    if (request5[kRouteContext].preParsing !== null) {
      preParsingHookRunner(request5[kRouteContext].preParsing, request5, reply, handleRequest);
    } else {
      handleRequest(null, request5, reply);
    }
  };
  var removeTrackedSocket = function() {
    this.keepAliveConnections.delete(this.socket);
  };
  var noop = function() {
  };
  var FindMyWay = require_find_my_way();
  var Context = require_context2();
  var handleRequest = require_handleRequest();
  var { onRequestAbortHookRunner, lifecycleHooks, preParsingHookRunner, onTimeoutHookRunner, onRequestHookRunner } = require_hooks2();
  var { supportedMethods } = require_httpMethods();
  var { normalizeSchema } = require_schemas();
  var { parseHeadOnSendHandlers } = require_headRoute();
  var {
    FSTDEP007,
    FSTDEP008,
    FSTDEP014
  } = require_warnings();
  var {
    compileSchemasForValidation,
    compileSchemasForSerialization
  } = require_validation2();
  var {
    FST_ERR_SCH_VALIDATION_BUILD,
    FST_ERR_SCH_SERIALIZATION_BUILD,
    FST_ERR_DEFAULT_ROUTE_INVALID_TYPE,
    FST_ERR_DUPLICATED_ROUTE,
    FST_ERR_INVALID_URL,
    FST_ERR_HOOK_INVALID_HANDLER,
    FST_ERR_ROUTE_OPTIONS_NOT_OBJ,
    FST_ERR_ROUTE_DUPLICATED_HANDLER,
    FST_ERR_ROUTE_HANDLER_NOT_FN,
    FST_ERR_ROUTE_MISSING_HANDLER,
    FST_ERR_ROUTE_METHOD_NOT_SUPPORTED,
    FST_ERR_ROUTE_METHOD_INVALID,
    FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED,
    FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT,
    FST_ERR_HOOK_INVALID_ASYNC_HANDLER
  } = require_errors4();
  var {
    kRoutePrefix,
    kLogLevel,
    kLogSerializers,
    kHooks,
    kSchemaController,
    kOptions,
    kReplySerializerDefault,
    kReplyIsError,
    kRequestPayloadStream,
    kDisableRequestLogging,
    kSchemaErrorFormatter,
    kErrorHandler,
    kHasBeenDecorated,
    kRequestAcceptVersion,
    kRouteByFastify,
    kRouteContext
  } = require_symbols3();
  var { buildErrorHandler } = require_error_handler();
  var { createChildLogger } = require_logger2();
  var { getGenReqId } = require_reqIdGenFactory();
  module.exports = { buildRouting, validateBodyLimitOption };
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/fourOhFour.js
var require_fourOhFour = __commonJS((exports, module) => {
  var fourOhFour = function(options) {
    const { logger: logger3 } = options;
    const router = FindMyWay({ onBadUrl: createOnBadUrl(), defaultRoute: fourOhFourFallBack });
    let _onBadUrlHandler = null;
    return { router, setNotFoundHandler, setContext, arrange404 };
    function arrange404(instance) {
      instance[kFourOhFourLevelInstance] = instance;
      instance[kCanSetNotFoundHandler] = true;
      router.onBadUrl = router.onBadUrl.bind(instance);
      router.defaultRoute = router.defaultRoute.bind(instance);
    }
    function basic404(request5, reply) {
      const { url, method } = request5.raw;
      const message = `Route ${method}:${url} not found`;
      request5.log.info(message);
      reply.code(404).send({
        message,
        error: "Not Found",
        statusCode: 404
      });
    }
    function createOnBadUrl() {
      return function onBadUrl(path, req, res) {
        const fourOhFourContext = this[kFourOhFourLevelInstance][kFourOhFourContext];
        const id2 = getGenReqId(fourOhFourContext.server, req);
        const childLogger = createChildLogger(fourOhFourContext, logger3, req, id2);
        const request5 = new Request2(id2, null, req, null, childLogger, fourOhFourContext);
        const reply = new Reply(res, request5, childLogger);
        _onBadUrlHandler(request5, reply);
      };
    }
    function setContext(instance, context) {
      const _404Context = Object.assign({}, instance[kFourOhFourContext]);
      _404Context.onSend = context.onSend;
      context[kFourOhFourContext] = _404Context;
    }
    function setNotFoundHandler(opts, handler, avvio, routeHandler) {
      if (this[kCanSetNotFoundHandler] === undefined) {
        this[kCanSetNotFoundHandler] = true;
      }
      if (this[kFourOhFourContext] === undefined) {
        this[kFourOhFourContext] = null;
      }
      const _fastify = this;
      const prefix = this[kRoutePrefix] || "/";
      if (this[kCanSetNotFoundHandler] === false) {
        throw new Error(`Not found handler already set for Fastify instance with prefix: '${prefix}'`);
      }
      if (typeof opts === "object") {
        if (opts.preHandler) {
          if (Array.isArray(opts.preHandler)) {
            opts.preHandler = opts.preHandler.map((hook) => hook.bind(_fastify));
          } else {
            opts.preHandler = opts.preHandler.bind(_fastify);
          }
        }
        if (opts.preValidation) {
          if (Array.isArray(opts.preValidation)) {
            opts.preValidation = opts.preValidation.map((hook) => hook.bind(_fastify));
          } else {
            opts.preValidation = opts.preValidation.bind(_fastify);
          }
        }
      }
      if (typeof opts === "function") {
        handler = opts;
        opts = undefined;
      }
      opts = opts || {};
      if (handler) {
        this[kFourOhFourLevelInstance][kCanSetNotFoundHandler] = false;
        handler = handler.bind(this);
        _onBadUrlHandler = handler;
      } else {
        handler = basic404;
        _onBadUrlHandler = basic404;
      }
      this.after((notHandledErr, done) => {
        _setNotFoundHandler.call(this, prefix, opts, handler, avvio, routeHandler);
        done(notHandledErr);
      });
    }
    function _setNotFoundHandler(prefix, opts, handler, avvio, routeHandler) {
      const context = new Context({
        schema: opts.schema,
        handler,
        config: opts.config || {},
        server: this
      });
      avvio.once("preReady", () => {
        const context2 = this[kFourOhFourContext];
        for (const hook of lifecycleHooks) {
          const toSet = this[kHooks][hook].concat(opts[hook] || []).map((h) => h.bind(this));
          context2[hook] = toSet.length ? toSet : null;
        }
        context2.errorHandler = opts.errorHandler ? buildErrorHandler(this[kErrorHandler], opts.errorHandler) : this[kErrorHandler];
      });
      if (this[kFourOhFourContext] !== null && prefix === "/") {
        Object.assign(this[kFourOhFourContext], context);
        return;
      }
      this[kFourOhFourLevelInstance][kFourOhFourContext] = context;
      router.all(prefix + (prefix.endsWith("/") ? "*" : "/*"), routeHandler, context);
      router.all(prefix, routeHandler, context);
    }
    function fourOhFourFallBack(req, res) {
      const fourOhFourContext = this[kFourOhFourLevelInstance][kFourOhFourContext];
      const id2 = getGenReqId(fourOhFourContext.server, req);
      const childLogger = createChildLogger(fourOhFourContext, logger3, req, id2);
      childLogger.info({ req }, "incoming request");
      const request5 = new Request2(id2, null, req, null, childLogger, fourOhFourContext);
      const reply = new Reply(res, request5, childLogger);
      request5.log.warn("the default handler for 404 did not catch this, this is likely a fastify bug, please report it");
      request5.log.warn(router.prettyPrint());
      reply.code(404).send(new FST_ERR_NOT_FOUND);
    }
  };
  var FindMyWay = require_find_my_way();
  var Reply = require_reply();
  var Request2 = require_request3();
  var Context = require_context2();
  var {
    kRoutePrefix,
    kCanSetNotFoundHandler,
    kFourOhFourLevelInstance,
    kFourOhFourContext,
    kHooks,
    kErrorHandler
  } = require_symbols3();
  var { lifecycleHooks } = require_hooks2();
  var { buildErrorHandler } = require_error_handler();
  var {
    FST_ERR_NOT_FOUND
  } = require_errors4();
  var { createChildLogger } = require_logger2();
  var { getGenReqId } = require_reqIdGenFactory();
  module.exports = fourOhFour;
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/configValidator.js
var require_configValidator = __commonJS((exports, module) => {
  var validate10 = function(data3, { instancePath = "", parentData, parentDataProperty, rootData = data3 } = {}) {
    let vErrors = null;
    let errors4 = 0;
    if (errors4 === 0) {
      if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
        if (data3.connectionTimeout === undefined) {
          data3.connectionTimeout = 0;
        }
        if (data3.keepAliveTimeout === undefined) {
          data3.keepAliveTimeout = 72000;
        }
        if (data3.maxRequestsPerSocket === undefined) {
          data3.maxRequestsPerSocket = 0;
        }
        if (data3.requestTimeout === undefined) {
          data3.requestTimeout = 0;
        }
        if (data3.bodyLimit === undefined) {
          data3.bodyLimit = 1048576;
        }
        if (data3.caseSensitive === undefined) {
          data3.caseSensitive = true;
        }
        if (data3.allowUnsafeRegex === undefined) {
          data3.allowUnsafeRegex = false;
        }
        if (data3.ignoreTrailingSlash === undefined) {
          data3.ignoreTrailingSlash = false;
        }
        if (data3.ignoreDuplicateSlashes === undefined) {
          data3.ignoreDuplicateSlashes = false;
        }
        if (data3.disableRequestLogging === undefined) {
          data3.disableRequestLogging = false;
        }
        if (data3.jsonShorthand === undefined) {
          data3.jsonShorthand = true;
        }
        if (data3.maxParamLength === undefined) {
          data3.maxParamLength = 100;
        }
        if (data3.onProtoPoisoning === undefined) {
          data3.onProtoPoisoning = "error";
        }
        if (data3.onConstructorPoisoning === undefined) {
          data3.onConstructorPoisoning = "error";
        }
        if (data3.pluginTimeout === undefined) {
          data3.pluginTimeout = 1e4;
        }
        if (data3.requestIdHeader === undefined) {
          data3.requestIdHeader = "request-id";
        }
        if (data3.requestIdLogLabel === undefined) {
          data3.requestIdLogLabel = "reqId";
        }
        if (data3.http2SessionTimeout === undefined) {
          data3.http2SessionTimeout = 72000;
        }
        if (data3.exposeHeadRoutes === undefined) {
          data3.exposeHeadRoutes = true;
        }
        if (data3.useSemicolonDelimiter === undefined) {
          data3.useSemicolonDelimiter = true;
        }
        const _errs1 = errors4;
        for (const key0 in data3) {
          if (!func2.call(schema11.properties, key0)) {
            delete data3[key0];
          }
        }
        if (_errs1 === errors4) {
          let data0 = data3.connectionTimeout;
          const _errs2 = errors4;
          if (!(typeof data0 == "number" && (!(data0 % 1) && !isNaN(data0)) && isFinite(data0))) {
            let dataType0 = typeof data0;
            let coerced0 = undefined;
            if (!(coerced0 !== undefined)) {
              if (dataType0 === "boolean" || data0 === null || dataType0 === "string" && data0 && data0 == +data0 && !(data0 % 1)) {
                coerced0 = +data0;
              } else {
                validate10.errors = [{ instancePath: instancePath + "/connectionTimeout", schemaPath: "#/properties/connectionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                return false;
              }
            }
            if (coerced0 !== undefined) {
              data0 = coerced0;
              if (data3 !== undefined) {
                data3["connectionTimeout"] = coerced0;
              }
            }
          }
          var valid0 = _errs2 === errors4;
          if (valid0) {
            let data1 = data3.keepAliveTimeout;
            const _errs4 = errors4;
            if (!(typeof data1 == "number" && (!(data1 % 1) && !isNaN(data1)) && isFinite(data1))) {
              let dataType1 = typeof data1;
              let coerced1 = undefined;
              if (!(coerced1 !== undefined)) {
                if (dataType1 === "boolean" || data1 === null || dataType1 === "string" && data1 && data1 == +data1 && !(data1 % 1)) {
                  coerced1 = +data1;
                } else {
                  validate10.errors = [{ instancePath: instancePath + "/keepAliveTimeout", schemaPath: "#/properties/keepAliveTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                  return false;
                }
              }
              if (coerced1 !== undefined) {
                data1 = coerced1;
                if (data3 !== undefined) {
                  data3["keepAliveTimeout"] = coerced1;
                }
              }
            }
            var valid0 = _errs4 === errors4;
            if (valid0) {
              if (data3.forceCloseConnections !== undefined) {
                let data22 = data3.forceCloseConnections;
                const _errs6 = errors4;
                const _errs7 = errors4;
                let valid1 = false;
                let passing0 = null;
                const _errs8 = errors4;
                if (typeof data22 !== "string") {
                  let dataType2 = typeof data22;
                  let coerced2 = undefined;
                  if (!(coerced2 !== undefined)) {
                    if (dataType2 == "number" || dataType2 == "boolean") {
                      coerced2 = "" + data22;
                    } else if (data22 === null) {
                      coerced2 = "";
                    } else {
                      const err0 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err0];
                      } else {
                        vErrors.push(err0);
                      }
                      errors4++;
                    }
                  }
                  if (coerced2 !== undefined) {
                    data22 = coerced2;
                    if (data3 !== undefined) {
                      data3["forceCloseConnections"] = coerced2;
                    }
                  }
                }
                if (errors4 === _errs8) {
                  if (typeof data22 === "string") {
                    if (!pattern0.test(data22)) {
                      const err1 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/pattern", keyword: "pattern", params: { pattern: "idle" }, message: "must match pattern \"idle\"" };
                      if (vErrors === null) {
                        vErrors = [err1];
                      } else {
                        vErrors.push(err1);
                      }
                      errors4++;
                    }
                  }
                }
                var _valid0 = _errs8 === errors4;
                if (_valid0) {
                  valid1 = true;
                  passing0 = 0;
                }
                const _errs10 = errors4;
                if (typeof data22 !== "boolean") {
                  let coerced3 = undefined;
                  if (!(coerced3 !== undefined)) {
                    if (data22 === "false" || data22 === 0 || data22 === null) {
                      coerced3 = false;
                    } else if (data22 === "true" || data22 === 1) {
                      coerced3 = true;
                    } else {
                      const err2 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/1/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                      if (vErrors === null) {
                        vErrors = [err2];
                      } else {
                        vErrors.push(err2);
                      }
                      errors4++;
                    }
                  }
                  if (coerced3 !== undefined) {
                    data22 = coerced3;
                    if (data3 !== undefined) {
                      data3["forceCloseConnections"] = coerced3;
                    }
                  }
                }
                var _valid0 = _errs10 === errors4;
                if (_valid0 && valid1) {
                  valid1 = false;
                  passing0 = [passing0, 1];
                } else {
                  if (_valid0) {
                    valid1 = true;
                    passing0 = 1;
                  }
                }
                if (!valid1) {
                  const err3 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
                  if (vErrors === null) {
                    vErrors = [err3];
                  } else {
                    vErrors.push(err3);
                  }
                  errors4++;
                  validate10.errors = vErrors;
                  return false;
                } else {
                  errors4 = _errs7;
                  if (vErrors !== null) {
                    if (_errs7) {
                      vErrors.length = _errs7;
                    } else {
                      vErrors = null;
                    }
                  }
                }
                var valid0 = _errs6 === errors4;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                let data32 = data3.maxRequestsPerSocket;
                const _errs12 = errors4;
                if (!(typeof data32 == "number" && (!(data32 % 1) && !isNaN(data32)) && isFinite(data32)) && data32 !== null) {
                  let dataType4 = typeof data32;
                  let coerced4 = undefined;
                  if (!(coerced4 !== undefined)) {
                    if (dataType4 === "boolean" || data32 === null || dataType4 === "string" && data32 && data32 == +data32 && !(data32 % 1)) {
                      coerced4 = +data32;
                    } else if (data32 === "" || data32 === 0 || data32 === false) {
                      coerced4 = null;
                    } else {
                      validate10.errors = [{ instancePath: instancePath + "/maxRequestsPerSocket", schemaPath: "#/properties/maxRequestsPerSocket/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                      return false;
                    }
                  }
                  if (coerced4 !== undefined) {
                    data32 = coerced4;
                    if (data3 !== undefined) {
                      data3["maxRequestsPerSocket"] = coerced4;
                    }
                  }
                }
                var valid0 = _errs12 === errors4;
                if (valid0) {
                  let data4 = data3.requestTimeout;
                  const _errs15 = errors4;
                  if (!(typeof data4 == "number" && (!(data4 % 1) && !isNaN(data4)) && isFinite(data4))) {
                    let dataType5 = typeof data4;
                    let coerced5 = undefined;
                    if (!(coerced5 !== undefined)) {
                      if (dataType5 === "boolean" || data4 === null || dataType5 === "string" && data4 && data4 == +data4 && !(data4 % 1)) {
                        coerced5 = +data4;
                      } else {
                        validate10.errors = [{ instancePath: instancePath + "/requestTimeout", schemaPath: "#/properties/requestTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                        return false;
                      }
                    }
                    if (coerced5 !== undefined) {
                      data4 = coerced5;
                      if (data3 !== undefined) {
                        data3["requestTimeout"] = coerced5;
                      }
                    }
                  }
                  var valid0 = _errs15 === errors4;
                  if (valid0) {
                    let data5 = data3.bodyLimit;
                    const _errs17 = errors4;
                    if (!(typeof data5 == "number" && (!(data5 % 1) && !isNaN(data5)) && isFinite(data5))) {
                      let dataType6 = typeof data5;
                      let coerced6 = undefined;
                      if (!(coerced6 !== undefined)) {
                        if (dataType6 === "boolean" || data5 === null || dataType6 === "string" && data5 && data5 == +data5 && !(data5 % 1)) {
                          coerced6 = +data5;
                        } else {
                          validate10.errors = [{ instancePath: instancePath + "/bodyLimit", schemaPath: "#/properties/bodyLimit/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                          return false;
                        }
                      }
                      if (coerced6 !== undefined) {
                        data5 = coerced6;
                        if (data3 !== undefined) {
                          data3["bodyLimit"] = coerced6;
                        }
                      }
                    }
                    var valid0 = _errs17 === errors4;
                    if (valid0) {
                      let data6 = data3.caseSensitive;
                      const _errs19 = errors4;
                      if (typeof data6 !== "boolean") {
                        let coerced7 = undefined;
                        if (!(coerced7 !== undefined)) {
                          if (data6 === "false" || data6 === 0 || data6 === null) {
                            coerced7 = false;
                          } else if (data6 === "true" || data6 === 1) {
                            coerced7 = true;
                          } else {
                            validate10.errors = [{ instancePath: instancePath + "/caseSensitive", schemaPath: "#/properties/caseSensitive/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                            return false;
                          }
                        }
                        if (coerced7 !== undefined) {
                          data6 = coerced7;
                          if (data3 !== undefined) {
                            data3["caseSensitive"] = coerced7;
                          }
                        }
                      }
                      var valid0 = _errs19 === errors4;
                      if (valid0) {
                        let data7 = data3.allowUnsafeRegex;
                        const _errs21 = errors4;
                        if (typeof data7 !== "boolean") {
                          let coerced8 = undefined;
                          if (!(coerced8 !== undefined)) {
                            if (data7 === "false" || data7 === 0 || data7 === null) {
                              coerced8 = false;
                            } else if (data7 === "true" || data7 === 1) {
                              coerced8 = true;
                            } else {
                              validate10.errors = [{ instancePath: instancePath + "/allowUnsafeRegex", schemaPath: "#/properties/allowUnsafeRegex/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                              return false;
                            }
                          }
                          if (coerced8 !== undefined) {
                            data7 = coerced8;
                            if (data3 !== undefined) {
                              data3["allowUnsafeRegex"] = coerced8;
                            }
                          }
                        }
                        var valid0 = _errs21 === errors4;
                        if (valid0) {
                          if (data3.http2 !== undefined) {
                            let data8 = data3.http2;
                            const _errs23 = errors4;
                            if (typeof data8 !== "boolean") {
                              let coerced9 = undefined;
                              if (!(coerced9 !== undefined)) {
                                if (data8 === "false" || data8 === 0 || data8 === null) {
                                  coerced9 = false;
                                } else if (data8 === "true" || data8 === 1) {
                                  coerced9 = true;
                                } else {
                                  validate10.errors = [{ instancePath: instancePath + "/http2", schemaPath: "#/properties/http2/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                  return false;
                                }
                              }
                              if (coerced9 !== undefined) {
                                data8 = coerced9;
                                if (data3 !== undefined) {
                                  data3["http2"] = coerced9;
                                }
                              }
                            }
                            var valid0 = _errs23 === errors4;
                          } else {
                            var valid0 = true;
                          }
                          if (valid0) {
                            if (data3.https !== undefined) {
                              let data9 = data3.https;
                              const _errs25 = errors4;
                              const _errs26 = errors4;
                              let valid2 = true;
                              const _errs27 = errors4;
                              const _errs28 = errors4;
                              const _errs29 = errors4;
                              const _errs30 = errors4;
                              let valid4 = false;
                              let passing1 = null;
                              const _errs31 = errors4;
                              if (typeof data9 !== "boolean") {
                                let coerced10 = undefined;
                                if (!(coerced10 !== undefined)) {
                                  if (data9 === "false" || data9 === 0 || data9 === null) {
                                    coerced10 = false;
                                  } else if (data9 === "true" || data9 === 1) {
                                    coerced10 = true;
                                  } else {
                                    const err4 = {};
                                    if (vErrors === null) {
                                      vErrors = [err4];
                                    } else {
                                      vErrors.push(err4);
                                    }
                                    errors4++;
                                  }
                                }
                                if (coerced10 !== undefined) {
                                  data9 = coerced10;
                                  if (data3 !== undefined) {
                                    data3["https"] = coerced10;
                                  }
                                }
                              }
                              var _valid2 = _errs31 === errors4;
                              if (_valid2) {
                                valid4 = true;
                                passing1 = 0;
                              }
                              const _errs33 = errors4;
                              if (data9 !== null) {
                                let coerced11 = undefined;
                                if (!(coerced11 !== undefined)) {
                                  if (data9 === "" || data9 === 0 || data9 === false) {
                                    coerced11 = null;
                                  } else {
                                    const err5 = {};
                                    if (vErrors === null) {
                                      vErrors = [err5];
                                    } else {
                                      vErrors.push(err5);
                                    }
                                    errors4++;
                                  }
                                }
                                if (coerced11 !== undefined) {
                                  data9 = coerced11;
                                  if (data3 !== undefined) {
                                    data3["https"] = coerced11;
                                  }
                                }
                              }
                              var _valid2 = _errs33 === errors4;
                              if (_valid2 && valid4) {
                                valid4 = false;
                                passing1 = [passing1, 1];
                              } else {
                                if (_valid2) {
                                  valid4 = true;
                                  passing1 = 1;
                                }
                                const _errs35 = errors4;
                                if (errors4 === _errs35) {
                                  if (data9 && typeof data9 == "object" && !Array.isArray(data9)) {
                                    let missing0;
                                    if (data9.allowHTTP1 === undefined && (missing0 = "allowHTTP1")) {
                                      const err6 = {};
                                      if (vErrors === null) {
                                        vErrors = [err6];
                                      } else {
                                        vErrors.push(err6);
                                      }
                                      errors4++;
                                    } else {
                                      const _errs37 = errors4;
                                      for (const key1 in data9) {
                                        if (!(key1 === "allowHTTP1")) {
                                          delete data9[key1];
                                        }
                                      }
                                      if (_errs37 === errors4) {
                                        if (data9.allowHTTP1 !== undefined) {
                                          let data10 = data9.allowHTTP1;
                                          if (typeof data10 !== "boolean") {
                                            let coerced12 = undefined;
                                            if (!(coerced12 !== undefined)) {
                                              if (data10 === "false" || data10 === 0 || data10 === null) {
                                                coerced12 = false;
                                              } else if (data10 === "true" || data10 === 1) {
                                                coerced12 = true;
                                              } else {
                                                const err7 = {};
                                                if (vErrors === null) {
                                                  vErrors = [err7];
                                                } else {
                                                  vErrors.push(err7);
                                                }
                                                errors4++;
                                              }
                                            }
                                            if (coerced12 !== undefined) {
                                              data10 = coerced12;
                                              if (data9 !== undefined) {
                                                data9["allowHTTP1"] = coerced12;
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  } else {
                                    const err8 = {};
                                    if (vErrors === null) {
                                      vErrors = [err8];
                                    } else {
                                      vErrors.push(err8);
                                    }
                                    errors4++;
                                  }
                                }
                                var _valid2 = _errs35 === errors4;
                                if (_valid2 && valid4) {
                                  valid4 = false;
                                  passing1 = [passing1, 2];
                                } else {
                                  if (_valid2) {
                                    valid4 = true;
                                    passing1 = 2;
                                  }
                                }
                              }
                              if (!valid4) {
                                const err9 = {};
                                if (vErrors === null) {
                                  vErrors = [err9];
                                } else {
                                  vErrors.push(err9);
                                }
                                errors4++;
                              } else {
                                errors4 = _errs30;
                                if (vErrors !== null) {
                                  if (_errs30) {
                                    vErrors.length = _errs30;
                                  } else {
                                    vErrors = null;
                                  }
                                }
                              }
                              var valid3 = _errs29 === errors4;
                              if (valid3) {
                                const err10 = {};
                                if (vErrors === null) {
                                  vErrors = [err10];
                                } else {
                                  vErrors.push(err10);
                                }
                                errors4++;
                              } else {
                                errors4 = _errs28;
                                if (vErrors !== null) {
                                  if (_errs28) {
                                    vErrors.length = _errs28;
                                  } else {
                                    vErrors = null;
                                  }
                                }
                              }
                              var _valid1 = _errs27 === errors4;
                              errors4 = _errs26;
                              if (vErrors !== null) {
                                if (_errs26) {
                                  vErrors.length = _errs26;
                                } else {
                                  vErrors = null;
                                }
                              }
                              if (_valid1) {
                                const _errs40 = errors4;
                                data3["https"] = true;
                                var _valid1 = _errs40 === errors4;
                                valid2 = _valid1;
                              }
                              if (!valid2) {
                                const err11 = { instancePath: instancePath + "/https", schemaPath: "#/properties/https/if", keyword: "if", params: { failingKeyword: "then" }, message: "must match \"then\" schema" };
                                if (vErrors === null) {
                                  vErrors = [err11];
                                } else {
                                  vErrors.push(err11);
                                }
                                errors4++;
                                validate10.errors = vErrors;
                                return false;
                              }
                              var valid0 = _errs25 === errors4;
                            } else {
                              var valid0 = true;
                            }
                            if (valid0) {
                              let data11 = data3.ignoreTrailingSlash;
                              const _errs41 = errors4;
                              if (typeof data11 !== "boolean") {
                                let coerced13 = undefined;
                                if (!(coerced13 !== undefined)) {
                                  if (data11 === "false" || data11 === 0 || data11 === null) {
                                    coerced13 = false;
                                  } else if (data11 === "true" || data11 === 1) {
                                    coerced13 = true;
                                  } else {
                                    validate10.errors = [{ instancePath: instancePath + "/ignoreTrailingSlash", schemaPath: "#/properties/ignoreTrailingSlash/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                    return false;
                                  }
                                }
                                if (coerced13 !== undefined) {
                                  data11 = coerced13;
                                  if (data3 !== undefined) {
                                    data3["ignoreTrailingSlash"] = coerced13;
                                  }
                                }
                              }
                              var valid0 = _errs41 === errors4;
                              if (valid0) {
                                let data12 = data3.ignoreDuplicateSlashes;
                                const _errs43 = errors4;
                                if (typeof data12 !== "boolean") {
                                  let coerced14 = undefined;
                                  if (!(coerced14 !== undefined)) {
                                    if (data12 === "false" || data12 === 0 || data12 === null) {
                                      coerced14 = false;
                                    } else if (data12 === "true" || data12 === 1) {
                                      coerced14 = true;
                                    } else {
                                      validate10.errors = [{ instancePath: instancePath + "/ignoreDuplicateSlashes", schemaPath: "#/properties/ignoreDuplicateSlashes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                      return false;
                                    }
                                  }
                                  if (coerced14 !== undefined) {
                                    data12 = coerced14;
                                    if (data3 !== undefined) {
                                      data3["ignoreDuplicateSlashes"] = coerced14;
                                    }
                                  }
                                }
                                var valid0 = _errs43 === errors4;
                                if (valid0) {
                                  let data13 = data3.disableRequestLogging;
                                  const _errs45 = errors4;
                                  if (typeof data13 !== "boolean") {
                                    let coerced15 = undefined;
                                    if (!(coerced15 !== undefined)) {
                                      if (data13 === "false" || data13 === 0 || data13 === null) {
                                        coerced15 = false;
                                      } else if (data13 === "true" || data13 === 1) {
                                        coerced15 = true;
                                      } else {
                                        validate10.errors = [{ instancePath: instancePath + "/disableRequestLogging", schemaPath: "#/properties/disableRequestLogging/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                        return false;
                                      }
                                    }
                                    if (coerced15 !== undefined) {
                                      data13 = coerced15;
                                      if (data3 !== undefined) {
                                        data3["disableRequestLogging"] = coerced15;
                                      }
                                    }
                                  }
                                  var valid0 = _errs45 === errors4;
                                  if (valid0) {
                                    let data14 = data3.jsonShorthand;
                                    const _errs47 = errors4;
                                    if (typeof data14 !== "boolean") {
                                      let coerced16 = undefined;
                                      if (!(coerced16 !== undefined)) {
                                        if (data14 === "false" || data14 === 0 || data14 === null) {
                                          coerced16 = false;
                                        } else if (data14 === "true" || data14 === 1) {
                                          coerced16 = true;
                                        } else {
                                          validate10.errors = [{ instancePath: instancePath + "/jsonShorthand", schemaPath: "#/properties/jsonShorthand/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                          return false;
                                        }
                                      }
                                      if (coerced16 !== undefined) {
                                        data14 = coerced16;
                                        if (data3 !== undefined) {
                                          data3["jsonShorthand"] = coerced16;
                                        }
                                      }
                                    }
                                    var valid0 = _errs47 === errors4;
                                    if (valid0) {
                                      let data15 = data3.maxParamLength;
                                      const _errs49 = errors4;
                                      if (!(typeof data15 == "number" && (!(data15 % 1) && !isNaN(data15)) && isFinite(data15))) {
                                        let dataType17 = typeof data15;
                                        let coerced17 = undefined;
                                        if (!(coerced17 !== undefined)) {
                                          if (dataType17 === "boolean" || data15 === null || dataType17 === "string" && data15 && data15 == +data15 && !(data15 % 1)) {
                                            coerced17 = +data15;
                                          } else {
                                            validate10.errors = [{ instancePath: instancePath + "/maxParamLength", schemaPath: "#/properties/maxParamLength/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                            return false;
                                          }
                                        }
                                        if (coerced17 !== undefined) {
                                          data15 = coerced17;
                                          if (data3 !== undefined) {
                                            data3["maxParamLength"] = coerced17;
                                          }
                                        }
                                      }
                                      var valid0 = _errs49 === errors4;
                                      if (valid0) {
                                        let data16 = data3.onProtoPoisoning;
                                        const _errs51 = errors4;
                                        if (typeof data16 !== "string") {
                                          let dataType18 = typeof data16;
                                          let coerced18 = undefined;
                                          if (!(coerced18 !== undefined)) {
                                            if (dataType18 == "number" || dataType18 == "boolean") {
                                              coerced18 = "" + data16;
                                            } else if (data16 === null) {
                                              coerced18 = "";
                                            } else {
                                              validate10.errors = [{ instancePath: instancePath + "/onProtoPoisoning", schemaPath: "#/properties/onProtoPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                              return false;
                                            }
                                          }
                                          if (coerced18 !== undefined) {
                                            data16 = coerced18;
                                            if (data3 !== undefined) {
                                              data3["onProtoPoisoning"] = coerced18;
                                            }
                                          }
                                        }
                                        var valid0 = _errs51 === errors4;
                                        if (valid0) {
                                          let data17 = data3.onConstructorPoisoning;
                                          const _errs53 = errors4;
                                          if (typeof data17 !== "string") {
                                            let dataType19 = typeof data17;
                                            let coerced19 = undefined;
                                            if (!(coerced19 !== undefined)) {
                                              if (dataType19 == "number" || dataType19 == "boolean") {
                                                coerced19 = "" + data17;
                                              } else if (data17 === null) {
                                                coerced19 = "";
                                              } else {
                                                validate10.errors = [{ instancePath: instancePath + "/onConstructorPoisoning", schemaPath: "#/properties/onConstructorPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                return false;
                                              }
                                            }
                                            if (coerced19 !== undefined) {
                                              data17 = coerced19;
                                              if (data3 !== undefined) {
                                                data3["onConstructorPoisoning"] = coerced19;
                                              }
                                            }
                                          }
                                          var valid0 = _errs53 === errors4;
                                          if (valid0) {
                                            let data18 = data3.pluginTimeout;
                                            const _errs55 = errors4;
                                            if (!(typeof data18 == "number" && (!(data18 % 1) && !isNaN(data18)) && isFinite(data18))) {
                                              let dataType20 = typeof data18;
                                              let coerced20 = undefined;
                                              if (!(coerced20 !== undefined)) {
                                                if (dataType20 === "boolean" || data18 === null || dataType20 === "string" && data18 && data18 == +data18 && !(data18 % 1)) {
                                                  coerced20 = +data18;
                                                } else {
                                                  validate10.errors = [{ instancePath: instancePath + "/pluginTimeout", schemaPath: "#/properties/pluginTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                  return false;
                                                }
                                              }
                                              if (coerced20 !== undefined) {
                                                data18 = coerced20;
                                                if (data3 !== undefined) {
                                                  data3["pluginTimeout"] = coerced20;
                                                }
                                              }
                                            }
                                            var valid0 = _errs55 === errors4;
                                            if (valid0) {
                                              let data19 = data3.requestIdHeader;
                                              const _errs57 = errors4;
                                              const _errs58 = errors4;
                                              let valid6 = false;
                                              const _errs59 = errors4;
                                              if (!(data19 === false)) {
                                                const err12 = { instancePath: instancePath + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/0/enum", keyword: "enum", params: { allowedValues: schema11.properties.requestIdHeader.anyOf[0].enum }, message: "must be equal to one of the allowed values" };
                                                if (vErrors === null) {
                                                  vErrors = [err12];
                                                } else {
                                                  vErrors.push(err12);
                                                }
                                                errors4++;
                                              }
                                              var _valid3 = _errs59 === errors4;
                                              valid6 = valid6 || _valid3;
                                              if (!valid6) {
                                                const _errs60 = errors4;
                                                if (typeof data19 !== "string") {
                                                  let dataType21 = typeof data19;
                                                  let coerced21 = undefined;
                                                  if (!(coerced21 !== undefined)) {
                                                    if (dataType21 == "number" || dataType21 == "boolean") {
                                                      coerced21 = "" + data19;
                                                    } else if (data19 === null) {
                                                      coerced21 = "";
                                                    } else {
                                                      const err13 = { instancePath: instancePath + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                      if (vErrors === null) {
                                                        vErrors = [err13];
                                                      } else {
                                                        vErrors.push(err13);
                                                      }
                                                      errors4++;
                                                    }
                                                  }
                                                  if (coerced21 !== undefined) {
                                                    data19 = coerced21;
                                                    if (data3 !== undefined) {
                                                      data3["requestIdHeader"] = coerced21;
                                                    }
                                                  }
                                                }
                                                var _valid3 = _errs60 === errors4;
                                                valid6 = valid6 || _valid3;
                                              }
                                              if (!valid6) {
                                                const err14 = { instancePath: instancePath + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                if (vErrors === null) {
                                                  vErrors = [err14];
                                                } else {
                                                  vErrors.push(err14);
                                                }
                                                errors4++;
                                                validate10.errors = vErrors;
                                                return false;
                                              } else {
                                                errors4 = _errs58;
                                                if (vErrors !== null) {
                                                  if (_errs58) {
                                                    vErrors.length = _errs58;
                                                  } else {
                                                    vErrors = null;
                                                  }
                                                }
                                              }
                                              var valid0 = _errs57 === errors4;
                                              if (valid0) {
                                                let data20 = data3.requestIdLogLabel;
                                                const _errs62 = errors4;
                                                if (typeof data20 !== "string") {
                                                  let dataType22 = typeof data20;
                                                  let coerced22 = undefined;
                                                  if (!(coerced22 !== undefined)) {
                                                    if (dataType22 == "number" || dataType22 == "boolean") {
                                                      coerced22 = "" + data20;
                                                    } else if (data20 === null) {
                                                      coerced22 = "";
                                                    } else {
                                                      validate10.errors = [{ instancePath: instancePath + "/requestIdLogLabel", schemaPath: "#/properties/requestIdLogLabel/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                      return false;
                                                    }
                                                  }
                                                  if (coerced22 !== undefined) {
                                                    data20 = coerced22;
                                                    if (data3 !== undefined) {
                                                      data3["requestIdLogLabel"] = coerced22;
                                                    }
                                                  }
                                                }
                                                var valid0 = _errs62 === errors4;
                                                if (valid0) {
                                                  let data21 = data3.http2SessionTimeout;
                                                  const _errs64 = errors4;
                                                  if (!(typeof data21 == "number" && (!(data21 % 1) && !isNaN(data21)) && isFinite(data21))) {
                                                    let dataType23 = typeof data21;
                                                    let coerced23 = undefined;
                                                    if (!(coerced23 !== undefined)) {
                                                      if (dataType23 === "boolean" || data21 === null || dataType23 === "string" && data21 && data21 == +data21 && !(data21 % 1)) {
                                                        coerced23 = +data21;
                                                      } else {
                                                        validate10.errors = [{ instancePath: instancePath + "/http2SessionTimeout", schemaPath: "#/properties/http2SessionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                        return false;
                                                      }
                                                    }
                                                    if (coerced23 !== undefined) {
                                                      data21 = coerced23;
                                                      if (data3 !== undefined) {
                                                        data3["http2SessionTimeout"] = coerced23;
                                                      }
                                                    }
                                                  }
                                                  var valid0 = _errs64 === errors4;
                                                  if (valid0) {
                                                    let data22 = data3.exposeHeadRoutes;
                                                    const _errs66 = errors4;
                                                    if (typeof data22 !== "boolean") {
                                                      let coerced24 = undefined;
                                                      if (!(coerced24 !== undefined)) {
                                                        if (data22 === "false" || data22 === 0 || data22 === null) {
                                                          coerced24 = false;
                                                        } else if (data22 === "true" || data22 === 1) {
                                                          coerced24 = true;
                                                        } else {
                                                          validate10.errors = [{ instancePath: instancePath + "/exposeHeadRoutes", schemaPath: "#/properties/exposeHeadRoutes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                          return false;
                                                        }
                                                      }
                                                      if (coerced24 !== undefined) {
                                                        data22 = coerced24;
                                                        if (data3 !== undefined) {
                                                          data3["exposeHeadRoutes"] = coerced24;
                                                        }
                                                      }
                                                    }
                                                    var valid0 = _errs66 === errors4;
                                                    if (valid0) {
                                                      let data23 = data3.useSemicolonDelimiter;
                                                      const _errs68 = errors4;
                                                      if (typeof data23 !== "boolean") {
                                                        let coerced25 = undefined;
                                                        if (!(coerced25 !== undefined)) {
                                                          if (data23 === "false" || data23 === 0 || data23 === null) {
                                                            coerced25 = false;
                                                          } else if (data23 === "true" || data23 === 1) {
                                                            coerced25 = true;
                                                          } else {
                                                            validate10.errors = [{ instancePath: instancePath + "/useSemicolonDelimiter", schemaPath: "#/properties/useSemicolonDelimiter/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                            return false;
                                                          }
                                                        }
                                                        if (coerced25 !== undefined) {
                                                          data23 = coerced25;
                                                          if (data3 !== undefined) {
                                                            data3["useSemicolonDelimiter"] = coerced25;
                                                          }
                                                        }
                                                      }
                                                      var valid0 = _errs68 === errors4;
                                                      if (valid0) {
                                                        if (data3.versioning !== undefined) {
                                                          let data24 = data3.versioning;
                                                          const _errs70 = errors4;
                                                          if (errors4 === _errs70) {
                                                            if (data24 && typeof data24 == "object" && !Array.isArray(data24)) {
                                                              let missing1;
                                                              if (data24.storage === undefined && (missing1 = "storage") || data24.deriveVersion === undefined && (missing1 = "deriveVersion")) {
                                                                validate10.errors = [{ instancePath: instancePath + "/versioning", schemaPath: "#/properties/versioning/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" }];
                                                                return false;
                                                              }
                                                            } else {
                                                              validate10.errors = [{ instancePath: instancePath + "/versioning", schemaPath: "#/properties/versioning/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                              return false;
                                                            }
                                                          }
                                                          var valid0 = _errs70 === errors4;
                                                        } else {
                                                          var valid0 = true;
                                                        }
                                                        if (valid0) {
                                                          if (data3.constraints !== undefined) {
                                                            let data25 = data3.constraints;
                                                            const _errs73 = errors4;
                                                            if (errors4 === _errs73) {
                                                              if (data25 && typeof data25 == "object" && !Array.isArray(data25)) {
                                                                for (const key2 in data25) {
                                                                  let data26 = data25[key2];
                                                                  const _errs76 = errors4;
                                                                  if (errors4 === _errs76) {
                                                                    if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                                                                      let missing2;
                                                                      if (data26.name === undefined && (missing2 = "name") || data26.storage === undefined && (missing2 = "storage") || data26.validate === undefined && (missing2 = "validate") || data26.deriveConstraint === undefined && (missing2 = "deriveConstraint")) {
                                                                        validate10.errors = [{ instancePath: instancePath + "/constraints/" + key2.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/required", keyword: "required", params: { missingProperty: missing2 }, message: "must have required property '" + missing2 + "'" }];
                                                                        return false;
                                                                      } else {
                                                                        if (data26.name !== undefined) {
                                                                          let data27 = data26.name;
                                                                          if (typeof data27 !== "string") {
                                                                            let dataType26 = typeof data27;
                                                                            let coerced26 = undefined;
                                                                            if (!(coerced26 !== undefined)) {
                                                                              if (dataType26 == "number" || dataType26 == "boolean") {
                                                                                coerced26 = "" + data27;
                                                                              } else if (data27 === null) {
                                                                                coerced26 = "";
                                                                              } else {
                                                                                validate10.errors = [{ instancePath: instancePath + "/constraints/" + key2.replace(/~/g, "~0").replace(/\//g, "~1") + "/name", schemaPath: "#/properties/constraints/additionalProperties/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                                return false;
                                                                              }
                                                                            }
                                                                            if (coerced26 !== undefined) {
                                                                              data27 = coerced26;
                                                                              if (data26 !== undefined) {
                                                                                data26["name"] = coerced26;
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    } else {
                                                                      validate10.errors = [{ instancePath: instancePath + "/constraints/" + key2.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                      return false;
                                                                    }
                                                                  }
                                                                  var valid7 = _errs76 === errors4;
                                                                  if (!valid7) {
                                                                    break;
                                                                  }
                                                                }
                                                              } else {
                                                                validate10.errors = [{ instancePath: instancePath + "/constraints", schemaPath: "#/properties/constraints/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                return false;
                                                              }
                                                            }
                                                            var valid0 = _errs73 === errors4;
                                                          } else {
                                                            var valid0 = true;
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        validate10.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
        return false;
      }
    }
    validate10.errors = vErrors;
    return errors4 === 0;
  };
  module.exports = validate10;
  module.exports.default = validate10;
  var schema11 = { type: "object", additionalProperties: false, properties: { connectionTimeout: { type: "integer", default: 0 }, keepAliveTimeout: { type: "integer", default: 72000 }, forceCloseConnections: { oneOf: [{ type: "string", pattern: "idle" }, { type: "boolean" }] }, maxRequestsPerSocket: { type: "integer", default: 0, nullable: true }, requestTimeout: { type: "integer", default: 0 }, bodyLimit: { type: "integer", default: 1048576 }, caseSensitive: { type: "boolean", default: true }, allowUnsafeRegex: { type: "boolean", default: false }, http2: { type: "boolean" }, https: { if: { not: { oneOf: [{ type: "boolean" }, { type: "null" }, { type: "object", additionalProperties: false, required: ["allowHTTP1"], properties: { allowHTTP1: { type: "boolean" } } }] } }, then: { setDefaultValue: true } }, ignoreTrailingSlash: { type: "boolean", default: false }, ignoreDuplicateSlashes: { type: "boolean", default: false }, disableRequestLogging: { type: "boolean", default: false }, jsonShorthand: { type: "boolean", default: true }, maxParamLength: { type: "integer", default: 100 }, onProtoPoisoning: { type: "string", default: "error" }, onConstructorPoisoning: { type: "string", default: "error" }, pluginTimeout: { type: "integer", default: 1e4 }, requestIdHeader: { anyOf: [{ enum: [false] }, { type: "string" }], default: "request-id" }, requestIdLogLabel: { type: "string", default: "reqId" }, http2SessionTimeout: { type: "integer", default: 72000 }, exposeHeadRoutes: { type: "boolean", default: true }, useSemicolonDelimiter: { type: "boolean", default: true }, versioning: { type: "object", additionalProperties: true, required: ["storage", "deriveVersion"], properties: { storage: {}, deriveVersion: {} } }, constraints: { type: "object", additionalProperties: { type: "object", required: ["name", "storage", "validate", "deriveConstraint"], additionalProperties: true, properties: { name: { type: "string" }, storage: {}, validate: {}, deriveConstraint: {} } } } } };
  var func2 = Object.prototype.hasOwnProperty;
  var pattern0 = new RegExp("idle", "u");
  module.exports.defaultInitOptions = { connectionTimeout: 0, keepAliveTimeout: 72000, maxRequestsPerSocket: 0, requestTimeout: 0, bodyLimit: 1048576, caseSensitive: true, allowUnsafeRegex: false, disableRequestLogging: false, jsonShorthand: true, ignoreTrailingSlash: false, ignoreDuplicateSlashes: false, maxParamLength: 100, onProtoPoisoning: "error", onConstructorPoisoning: "error", pluginTimeout: 1e4, requestIdHeader: "request-id", requestIdLogLabel: "reqId", http2SessionTimeout: 72000, exposeHeadRoutes: true, useSemicolonDelimiter: true };
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/initialConfigValidation.js
var require_initialConfigValidation = __commonJS((exports, module) => {
  var validateInitialConfig = function(options) {
    const opts = deepClone(options);
    if (!validate(opts)) {
      const error = new FST_ERR_INIT_OPTS_INVALID(JSON.stringify(validate.errors.map((e) => e.message)));
      error.errors = validate.errors;
      throw error;
    }
    return deepFreezeObject(opts);
  };
  var deepFreezeObject = function(object) {
    const properties = Object.getOwnPropertyNames(object);
    for (const name of properties) {
      const value = object[name];
      if (ArrayBuffer.isView(value) && !(value instanceof DataView)) {
        continue;
      }
      object[name] = value && typeof value === "object" ? deepFreezeObject(value) : value;
    }
    return Object.freeze(object);
  };
  var validate = require_configValidator();
  var deepClone = require_rfdc()({ circles: true, proto: false });
  var { FST_ERR_INIT_OPTS_INVALID } = require_errors4();
  module.exports = validateInitialConfig;
  module.exports.defaultInitOptions = validate.defaultInitOptions;
  module.exports.utils = { deepFreezeObject };
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/pluginOverride.js
var require_pluginOverride = __commonJS((exports, module) => {
  var buildRoutePrefix = function(instancePrefix, pluginPrefix) {
    if (!pluginPrefix) {
      return instancePrefix;
    }
    if (instancePrefix.endsWith("/") && pluginPrefix[0] === "/") {
      pluginPrefix = pluginPrefix.slice(1);
    } else if (pluginPrefix[0] !== "/") {
      pluginPrefix = "/" + pluginPrefix;
    }
    return instancePrefix + pluginPrefix;
  };
  var {
    kAvvioBoot,
    kChildren,
    kRoutePrefix,
    kLogLevel,
    kLogSerializers,
    kHooks,
    kSchemaController,
    kContentTypeParser,
    kReply,
    kRequest,
    kFourOhFour,
    kPluginNameChain
  } = require_symbols3();
  var Reply = require_reply();
  var Request2 = require_request3();
  var SchemaController = require_schema_controller();
  var ContentTypeParser = require_contentTypeParser();
  var { buildHooks } = require_hooks2();
  var pluginUtils = require_pluginUtils();
  module.exports = function override(old, fn, opts) {
    const shouldSkipOverride = pluginUtils.registerPlugin.call(old, fn);
    const fnName = pluginUtils.getPluginName(fn) || pluginUtils.getFuncPreview(fn);
    if (shouldSkipOverride) {
      old[kPluginNameChain].push(fnName);
      return old;
    }
    const instance = Object.create(old);
    old[kChildren].push(instance);
    instance.ready = old[kAvvioBoot].bind(instance);
    instance[kChildren] = [];
    instance[kReply] = Reply.buildReply(instance[kReply]);
    instance[kRequest] = Request2.buildRequest(instance[kRequest]);
    instance[kContentTypeParser] = ContentTypeParser.helpers.buildContentTypeParser(instance[kContentTypeParser]);
    instance[kHooks] = buildHooks(instance[kHooks]);
    instance[kRoutePrefix] = buildRoutePrefix(instance[kRoutePrefix], opts.prefix);
    instance[kLogLevel] = opts.logLevel || instance[kLogLevel];
    instance[kSchemaController] = SchemaController.buildSchemaController(old[kSchemaController]);
    instance.getSchema = instance[kSchemaController].getSchema.bind(instance[kSchemaController]);
    instance.getSchemas = instance[kSchemaController].getSchemas.bind(instance[kSchemaController]);
    instance[pluginUtils.kRegisteredPlugins] = Object.create(instance[pluginUtils.kRegisteredPlugins]);
    instance[kPluginNameChain] = [fnName];
    if (instance[kLogSerializers] || opts.logSerializers) {
      instance[kLogSerializers] = Object.assign(Object.create(instance[kLogSerializers]), opts.logSerializers);
    }
    if (opts.prefix) {
      instance[kFourOhFour].arrange404(instance);
    }
    for (const hook of instance[kHooks].onRegister)
      hook.call(this, instance, opts);
    return instance;
  };
});

// ../node_modules/.pnpm/fastify@4.26.0/node_modules/fastify/lib/noop-set.js
var require_noop_set = __commonJS((exports, module) => {
  module.exports = function noopSet() {
    return {
      [Symbol.iterator]: function* () {
      },
      add() {
      },
      delete() {
      },
      has() {
        return true;
      }
    };
  };
});

// /home/mous/work/pimlico/alto/src/node_modules/fastify/fastify.js
var require_fastify = __commonJS((exports, module) => {
  var defaultBuildPrettyMeta = function(route) {
    const cleanKeys = {};
    const allowedProps = ["errorHandler", "logLevel", "logSerializers"];
    allowedProps.concat(supportedHooks).forEach((k) => {
      cleanKeys[k] = route.store[k];
    });
    return Object.assign({}, cleanKeys);
  };
  var fastify = function(options) {
    options = options || {};
    if (typeof options !== "object") {
      throw new FST_ERR_OPTIONS_NOT_OBJ;
    }
    if (options.querystringParser && typeof options.querystringParser !== "function") {
      throw new FST_ERR_QSP_NOT_FN(typeof options.querystringParser);
    }
    if (options.schemaController && options.schemaController.bucket && typeof options.schemaController.bucket !== "function") {
      throw new FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN(typeof options.schemaController.bucket);
    }
    validateBodyLimitOption(options.bodyLimit);
    const requestIdHeader = options.requestIdHeader === false ? false : (options.requestIdHeader || defaultInitOptions.requestIdHeader).toLowerCase();
    const genReqId = reqIdGenFactory(requestIdHeader, options.genReqId);
    const requestIdLogLabel = options.requestIdLogLabel || "reqId";
    const bodyLimit = options.bodyLimit || defaultInitOptions.bodyLimit;
    const disableRequestLogging = options.disableRequestLogging || false;
    const ajvOptions = Object.assign({
      customOptions: {},
      plugins: []
    }, options.ajv);
    const frameworkErrors = options.frameworkErrors;
    if (!ajvOptions.customOptions || Object.prototype.toString.call(ajvOptions.customOptions) !== "[object Object]") {
      throw new FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ(typeof ajvOptions.customOptions);
    }
    if (!ajvOptions.plugins || !Array.isArray(ajvOptions.plugins)) {
      throw new FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR(typeof ajvOptions.plugins);
    }
    const { logger: logger3, hasLogger } = createLogger(options);
    options.connectionTimeout = options.connectionTimeout || defaultInitOptions.connectionTimeout;
    options.keepAliveTimeout = options.keepAliveTimeout || defaultInitOptions.keepAliveTimeout;
    options.maxRequestsPerSocket = options.maxRequestsPerSocket || defaultInitOptions.maxRequestsPerSocket;
    options.requestTimeout = options.requestTimeout || defaultInitOptions.requestTimeout;
    options.logger = logger3;
    options.requestIdHeader = requestIdHeader;
    options.requestIdLogLabel = requestIdLogLabel;
    options.disableRequestLogging = disableRequestLogging;
    options.ajv = ajvOptions;
    options.clientErrorHandler = options.clientErrorHandler || defaultClientErrorHandler;
    const initialConfig = getSecuredInitialConfig(options);
    options.exposeHeadRoutes = initialConfig.exposeHeadRoutes;
    let constraints = options.constraints;
    if (options.versioning) {
      FSTDEP009();
      constraints = {
        ...constraints,
        version: {
          name: "version",
          mustMatchWhenDerived: true,
          storage: options.versioning.storage,
          deriveConstraint: options.versioning.deriveVersion,
          validate(value) {
            if (typeof value !== "string") {
              throw new FST_ERR_VERSION_CONSTRAINT_NOT_STR;
            }
          }
        }
      };
    }
    const router = buildRouting({
      config: {
        defaultRoute,
        onBadUrl,
        constraints,
        ignoreTrailingSlash: options.ignoreTrailingSlash || defaultInitOptions.ignoreTrailingSlash,
        ignoreDuplicateSlashes: options.ignoreDuplicateSlashes || defaultInitOptions.ignoreDuplicateSlashes,
        maxParamLength: options.maxParamLength || defaultInitOptions.maxParamLength,
        caseSensitive: options.caseSensitive,
        allowUnsafeRegex: options.allowUnsafeRegex || defaultInitOptions.allowUnsafeRegex,
        buildPrettyMeta: defaultBuildPrettyMeta,
        querystringParser: options.querystringParser,
        useSemicolonDelimiter: options.useSemicolonDelimiter ?? defaultInitOptions.useSemicolonDelimiter
      }
    });
    const fourOhFour = build404(options);
    const httpHandler = wrapRouting(router, options);
    options.http2SessionTimeout = initialConfig.http2SessionTimeout;
    const { server, listen } = createServer(options, httpHandler);
    const serverHasCloseAllConnections = typeof server.closeAllConnections === "function";
    const serverHasCloseIdleConnections = typeof server.closeIdleConnections === "function";
    let forceCloseConnections = options.forceCloseConnections;
    if (forceCloseConnections === "idle" && !serverHasCloseIdleConnections) {
      throw new FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE;
    } else if (typeof forceCloseConnections !== "boolean") {
      forceCloseConnections = serverHasCloseIdleConnections ? "idle" : false;
    }
    const keepAliveConnections = !serverHasCloseAllConnections && forceCloseConnections === true ? new Set : noopSet();
    const setupResponseListeners = Reply.setupResponseListeners;
    const schemaController = SchemaController.buildSchemaController(null, options.schemaController);
    const fastify2 = {
      [kState]: {
        listening: false,
        closing: false,
        started: false,
        ready: false,
        booting: false,
        readyPromise: null
      },
      [kKeepAliveConnections]: keepAliveConnections,
      [kOptions]: options,
      [kChildren]: [],
      [kServerBindings]: [],
      [kBodyLimit]: bodyLimit,
      [kRoutePrefix]: "",
      [kLogLevel]: "",
      [kLogSerializers]: null,
      [kHooks]: new Hooks,
      [kSchemaController]: schemaController,
      [kSchemaErrorFormatter]: null,
      [kErrorHandler]: buildErrorHandler(),
      [kChildLoggerFactory]: defaultChildLoggerFactory,
      [kReplySerializerDefault]: null,
      [kContentTypeParser]: new ContentTypeParser(bodyLimit, options.onProtoPoisoning || defaultInitOptions.onProtoPoisoning, options.onConstructorPoisoning || defaultInitOptions.onConstructorPoisoning),
      [kReply]: Reply.buildReply(Reply),
      [kRequest]: Request2.buildRequest(Request2, options.trustProxy),
      [kFourOhFour]: fourOhFour,
      [pluginUtils.kRegisteredPlugins]: [],
      [kPluginNameChain]: ["fastify"],
      [kAvvioBoot]: null,
      [kGenReqId]: genReqId,
      routing: httpHandler,
      getDefaultRoute: router.getDefaultRoute.bind(router),
      setDefaultRoute: router.setDefaultRoute.bind(router),
      delete: function _delete(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "DELETE", url, options: options2, handler });
      },
      get: function _get(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "GET", url, options: options2, handler });
      },
      head: function _head(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "HEAD", url, options: options2, handler });
      },
      patch: function _patch(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "PATCH", url, options: options2, handler });
      },
      post: function _post(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "POST", url, options: options2, handler });
      },
      put: function _put(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "PUT", url, options: options2, handler });
      },
      options: function _options(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "OPTIONS", url, options: options2, handler });
      },
      all: function _all(url, options2, handler) {
        return router.prepareRoute.call(this, { method: supportedMethods, url, options: options2, handler });
      },
      route: function _route(options2) {
        return router.route.call(this, { options: options2 });
      },
      hasRoute: function _route(options2) {
        return router.hasRoute.call(this, { options: options2 });
      },
      findRoute: function _findRoute(options2) {
        return router.findRoute(options2);
      },
      log: logger3,
      withTypeProvider,
      addHook,
      addSchema,
      getSchema: schemaController.getSchema.bind(schemaController),
      getSchemas: schemaController.getSchemas.bind(schemaController),
      setValidatorCompiler,
      setSerializerCompiler,
      setSchemaController,
      setReplySerializer,
      setSchemaErrorFormatter,
      setGenReqId,
      addContentTypeParser: ContentTypeParser.helpers.addContentTypeParser,
      hasContentTypeParser: ContentTypeParser.helpers.hasContentTypeParser,
      getDefaultJsonParser: ContentTypeParser.defaultParsers.getDefaultJsonParser,
      defaultTextParser: ContentTypeParser.defaultParsers.defaultTextParser,
      removeContentTypeParser: ContentTypeParser.helpers.removeContentTypeParser,
      removeAllContentTypeParsers: ContentTypeParser.helpers.removeAllContentTypeParsers,
      register: null,
      after: null,
      ready: null,
      onClose: null,
      close: null,
      printPlugins: null,
      hasPlugin: function(name) {
        return this[pluginUtils.kRegisteredPlugins].includes(name) || this[kPluginNameChain].includes(name);
      },
      listen,
      server,
      addresses: function() {
        const binded = this[kServerBindings].map((b) => b.address());
        binded.push(this.server.address());
        return binded.filter((adr) => adr);
      },
      decorate: decorator.add,
      hasDecorator: decorator.exist,
      decorateReply: decorator.decorateReply,
      decorateRequest: decorator.decorateRequest,
      hasRequestDecorator: decorator.existRequest,
      hasReplyDecorator: decorator.existReply,
      inject,
      printRoutes,
      setNotFoundHandler,
      setErrorHandler,
      setChildLoggerFactory,
      initialConfig,
      addConstraintStrategy: router.addConstraintStrategy.bind(router),
      hasConstraintStrategy: router.hasConstraintStrategy.bind(router)
    };
    Object.defineProperties(fastify2, {
      listeningOrigin: {
        get() {
          const address10 = this.addresses().slice(-1).pop();
          if (typeof address10 === "string") {
            return address10;
          }
          const host = address10.family === "IPv6" ? `[${address10.address}]` : address10.address;
          return `${this[kOptions].https ? "https" : "http"}://${host}:${address10.port}`;
        }
      },
      pluginName: {
        configurable: true,
        get() {
          if (this[kPluginNameChain].length > 1) {
            return this[kPluginNameChain].join(" -> ");
          }
          return this[kPluginNameChain][0];
        }
      },
      prefix: {
        configurable: true,
        get() {
          return this[kRoutePrefix];
        }
      },
      validatorCompiler: {
        configurable: true,
        get() {
          return this[kSchemaController].getValidatorCompiler();
        }
      },
      serializerCompiler: {
        configurable: true,
        get() {
          return this[kSchemaController].getSerializerCompiler();
        }
      },
      childLoggerFactory: {
        configurable: true,
        get() {
          return this[kChildLoggerFactory];
        }
      },
      version: {
        configurable: true,
        get() {
          return VERSION;
        }
      },
      errorHandler: {
        configurable: true,
        get() {
          return this[kErrorHandler].func;
        }
      },
      genReqId: {
        configurable: true,
        get() {
          return this[kGenReqId];
        }
      }
    });
    if (options.schemaErrorFormatter) {
      validateSchemaErrorFormatter(options.schemaErrorFormatter);
      fastify2[kSchemaErrorFormatter] = options.schemaErrorFormatter.bind(fastify2);
    }
    const avvioPluginTimeout = Number(options.pluginTimeout);
    const avvio = Avvio(fastify2, {
      autostart: false,
      timeout: isNaN(avvioPluginTimeout) === false ? avvioPluginTimeout : defaultInitOptions.pluginTimeout,
      expose: {
        use: "register"
      }
    });
    avvio.override = override;
    avvio.on("start", () => fastify2[kState].started = true);
    fastify2[kAvvioBoot] = fastify2.ready;
    fastify2.ready = ready;
    fastify2.printPlugins = avvio.prettyPrint.bind(avvio);
    avvio.once("preReady", () => {
      fastify2.onClose((instance, done) => {
        fastify2[kState].closing = true;
        router.closeRoutes();
        hookRunnerApplication("preClose", fastify2[kAvvioBoot], fastify2, function() {
          if (fastify2[kState].listening) {
            if (forceCloseConnections === "idle") {
              instance.server.closeIdleConnections();
            } else if (serverHasCloseAllConnections && forceCloseConnections) {
              instance.server.closeAllConnections();
            } else if (forceCloseConnections === true) {
              for (const conn of fastify2[kKeepAliveConnections]) {
                conn.destroy();
                fastify2[kKeepAliveConnections].delete(conn);
              }
            }
          }
          if (!options.serverFactory || fastify2[kState].listening) {
            instance.server.close(function(err) {
              if (err && err.code !== "ERR_SERVER_NOT_RUNNING") {
                done(null);
              } else {
                done();
              }
            });
          } else {
            process.nextTick(done, null);
          }
        });
      });
    });
    const onBadUrlContext = new Context({
      server: fastify2,
      config: {}
    });
    fastify2.setNotFoundHandler();
    fourOhFour.arrange404(fastify2);
    router.setup(options, {
      avvio,
      fourOhFour,
      logger: logger3,
      hasLogger,
      setupResponseListeners,
      throwIfAlreadyStarted,
      validateHTTPVersion: compileValidateHTTPVersion(options),
      keepAliveConnections
    });
    server.on("clientError", options.clientErrorHandler.bind(fastify2));
    try {
      const dc = __require("node:diagnostics_channel");
      const initChannel = dc.channel("fastify.initialization");
      if (initChannel.hasSubscribers) {
        initChannel.publish({ fastify: fastify2 });
      }
    } catch (e) {
    }
    if ("asyncDispose" in Symbol) {
      fastify2[Symbol.asyncDispose] = function dispose() {
        return fastify2.close();
      };
    }
    return fastify2;
    function throwIfAlreadyStarted(msg) {
      if (fastify2[kState].started)
        throw new FST_ERR_INSTANCE_ALREADY_LISTENING(msg);
    }
    function inject(opts, cb) {
      if (lightMyRequest === undefined) {
        lightMyRequest = require_light_my_request();
      }
      if (fastify2[kState].started) {
        if (fastify2[kState].closing) {
          const error = new FST_ERR_REOPENED_CLOSE_SERVER;
          if (cb) {
            cb(error);
            return;
          } else {
            return Promise.reject(error);
          }
        }
        return lightMyRequest(httpHandler, opts, cb);
      }
      if (cb) {
        this.ready((err) => {
          if (err)
            cb(err, null);
          else
            lightMyRequest(httpHandler, opts, cb);
        });
      } else {
        return lightMyRequest((req, res) => {
          this.ready(function(err) {
            if (err) {
              res.emit("error", err);
              return;
            }
            httpHandler(req, res);
          });
        }, opts);
      }
    }
    function ready(cb) {
      if (this[kState].readyPromise !== null) {
        if (cb != null) {
          this[kState].readyPromise.then(() => cb(null, fastify2), cb);
          return;
        }
        return this[kState].readyPromise;
      }
      let resolveReady;
      let rejectReady;
      process.nextTick(runHooks);
      this[kState].readyPromise = new Promise(function(resolve5, reject) {
        resolveReady = resolve5;
        rejectReady = reject;
      });
      if (!cb) {
        return this[kState].readyPromise;
      } else {
        this[kState].readyPromise.then(() => cb(null, fastify2), cb);
      }
      function runHooks() {
        fastify2[kAvvioBoot]((err, done) => {
          if (err || fastify2[kState].started || fastify2[kState].ready || fastify2[kState].booting) {
            manageErr(err);
          } else {
            fastify2[kState].booting = true;
            hookRunnerApplication("onReady", fastify2[kAvvioBoot], fastify2, manageErr);
          }
          done();
        });
      }
      function manageErr(err) {
        err = err != null && AVVIO_ERRORS_MAP[err.code] != null ? appendStackTrace(err, new AVVIO_ERRORS_MAP[err.code](err.message)) : err;
        if (err) {
          return rejectReady(err);
        }
        resolveReady(fastify2);
        fastify2[kState].booting = false;
        fastify2[kState].ready = true;
        fastify2[kState].promise = null;
      }
    }
    function withTypeProvider() {
      return this;
    }
    function addHook(name, fn) {
      throwIfAlreadyStarted('Cannot call "addHook"!');
      if (fn == null) {
        throw new errorCodes.FST_ERR_HOOK_INVALID_HANDLER(name, fn);
      }
      if (name === "onSend" || name === "preSerialization" || name === "onError" || name === "preParsing") {
        if (fn.constructor.name === "AsyncFunction" && fn.length === 4) {
          throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER;
        }
      } else if (name === "onReady" || name === "onListen") {
        if (fn.constructor.name === "AsyncFunction" && fn.length !== 0) {
          throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER;
        }
      } else if (name === "onRequestAbort") {
        if (fn.constructor.name === "AsyncFunction" && fn.length !== 1) {
          throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER;
        }
      } else {
        if (fn.constructor.name === "AsyncFunction" && fn.length === 3) {
          throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER;
        }
      }
      if (name === "onClose") {
        this.onClose(fn);
      } else if (name === "onReady" || name === "onListen" || name === "onRoute") {
        this[kHooks].add(name, fn);
      } else {
        this.after((err, done) => {
          _addHook.call(this, name, fn);
          done(err);
        });
      }
      return this;
      function _addHook(name2, fn2) {
        this[kHooks].add(name2, fn2);
        this[kChildren].forEach((child) => _addHook.call(child, name2, fn2));
      }
    }
    function addSchema(schema) {
      throwIfAlreadyStarted('Cannot call "addSchema"!');
      this[kSchemaController].add(schema);
      this[kChildren].forEach((child) => child.addSchema(schema));
      return this;
    }
    function defaultClientErrorHandler(err, socket) {
      if (err.code === "ECONNRESET" || socket.destroyed) {
        return;
      }
      let body, errorCode, errorStatus, errorLabel;
      if (err.code === "ERR_HTTP_REQUEST_TIMEOUT") {
        errorCode = "408";
        errorStatus = http2.STATUS_CODES[errorCode];
        body = `{"error":"${errorStatus}","message":"Client Timeout","statusCode":408}`;
        errorLabel = "timeout";
      } else if (err.code === "HPE_HEADER_OVERFLOW") {
        errorCode = "431";
        errorStatus = http2.STATUS_CODES[errorCode];
        body = `{"error":"${errorStatus}","message":"Exceeded maximum allowed HTTP header size","statusCode":431}`;
        errorLabel = "header_overflow";
      } else {
        errorCode = "400";
        errorStatus = http2.STATUS_CODES[errorCode];
        body = `{"error":"${errorStatus}","message":"Client Error","statusCode":400}`;
        errorLabel = "error";
      }
      this.log.trace({ err }, `client ${errorLabel}`);
      if (socket.writable) {
        socket.write(`HTTP/1.1 ${errorCode} ${errorStatus}\r\nContent-Length: ${body.length}\r\nContent-Type: application/json\r\n\r\n${body}`);
      }
      socket.destroy(err);
    }
    function defaultRoute(req, res) {
      if (req.headers["accept-version"] !== undefined) {
        req.headers[kRequestAcceptVersion] = req.headers["accept-version"];
        req.headers["accept-version"] = undefined;
      }
      fourOhFour.router.lookup(req, res);
    }
    function onBadUrl(path, req, res) {
      if (frameworkErrors) {
        const id2 = getGenReqId(onBadUrlContext.server, req);
        const childLogger = createChildLogger(onBadUrlContext, logger3, req, id2);
        const request5 = new Request2(id2, null, req, null, childLogger, onBadUrlContext);
        const reply = new Reply(res, request5, childLogger);
        if (disableRequestLogging === false) {
          childLogger.info({ req: request5 }, "incoming request");
        }
        return frameworkErrors(new FST_ERR_BAD_URL(path), request5, reply);
      }
      const body = `{"error":"Bad Request","code":"FST_ERR_BAD_URL","message":"'${path}' is not a valid url component","statusCode":400}`;
      res.writeHead(400, {
        "Content-Type": "application/json",
        "Content-Length": body.length
      });
      res.end(body);
    }
    function buildAsyncConstraintCallback(isAsync2, req, res) {
      if (isAsync2 === false)
        return;
      return function onAsyncConstraintError(err) {
        if (err) {
          if (frameworkErrors) {
            const id2 = getGenReqId(onBadUrlContext.server, req);
            const childLogger = createChildLogger(onBadUrlContext, logger3, req, id2);
            const request5 = new Request2(id2, null, req, null, childLogger, onBadUrlContext);
            const reply = new Reply(res, request5, childLogger);
            if (disableRequestLogging === false) {
              childLogger.info({ req: request5 }, "incoming request");
            }
            return frameworkErrors(new FST_ERR_ASYNC_CONSTRAINT, request5, reply);
          }
          const body = '{"error":"Internal Server Error","message":"Unexpected error from async constraint","statusCode":500}';
          res.writeHead(500, {
            "Content-Type": "application/json",
            "Content-Length": body.length
          });
          res.end(body);
        }
      };
    }
    function setNotFoundHandler(opts, handler) {
      throwIfAlreadyStarted('Cannot call "setNotFoundHandler"!');
      fourOhFour.setNotFoundHandler.call(this, opts, handler, avvio, router.routeHandler);
      return this;
    }
    function setValidatorCompiler(validatorCompiler) {
      throwIfAlreadyStarted('Cannot call "setValidatorCompiler"!');
      this[kSchemaController].setValidatorCompiler(validatorCompiler);
      return this;
    }
    function setSchemaErrorFormatter(errorFormatter) {
      throwIfAlreadyStarted('Cannot call "setSchemaErrorFormatter"!');
      validateSchemaErrorFormatter(errorFormatter);
      this[kSchemaErrorFormatter] = errorFormatter.bind(this);
      return this;
    }
    function setSerializerCompiler(serializerCompiler) {
      throwIfAlreadyStarted('Cannot call "setSerializerCompiler"!');
      this[kSchemaController].setSerializerCompiler(serializerCompiler);
      return this;
    }
    function setSchemaController(schemaControllerOpts) {
      throwIfAlreadyStarted('Cannot call "setSchemaController"!');
      const old = this[kSchemaController];
      const schemaController2 = SchemaController.buildSchemaController(old, Object.assign({}, old.opts, schemaControllerOpts));
      this[kSchemaController] = schemaController2;
      this.getSchema = schemaController2.getSchema.bind(schemaController2);
      this.getSchemas = schemaController2.getSchemas.bind(schemaController2);
      return this;
    }
    function setReplySerializer(replySerializer) {
      throwIfAlreadyStarted('Cannot call "setReplySerializer"!');
      this[kReplySerializerDefault] = replySerializer;
      return this;
    }
    function setErrorHandler(func) {
      throwIfAlreadyStarted('Cannot call "setErrorHandler"!');
      this[kErrorHandler] = buildErrorHandler(this[kErrorHandler], func.bind(this));
      return this;
    }
    function setChildLoggerFactory(factory) {
      throwIfAlreadyStarted('Cannot call "setChildLoggerFactory"!');
      this[kChildLoggerFactory] = factory;
      return this;
    }
    function printRoutes(opts = {}) {
      opts.includeMeta = opts.includeHooks ? opts.includeMeta ? supportedHooks.concat(opts.includeMeta) : supportedHooks : opts.includeMeta;
      return router.printRoutes(opts);
    }
    function wrapRouting(router2, { rewriteUrl, logger: logger4 }) {
      let isAsync2;
      return function preRouting(req, res) {
        if (isAsync2 === undefined)
          isAsync2 = router2.isAsyncConstraint();
        if (rewriteUrl) {
          req.originalUrl = req.url;
          const url = rewriteUrl.call(fastify2, req);
          if (typeof url === "string") {
            req.url = url;
          } else {
            const err = new FST_ERR_ROUTE_REWRITE_NOT_STR(req.url, typeof url);
            req.destroy(err);
          }
        }
        router2.routing(req, res, buildAsyncConstraintCallback(isAsync2, req, res));
      };
    }
    function setGenReqId(func) {
      throwIfAlreadyStarted('Cannot call "setGenReqId"!');
      this[kGenReqId] = reqIdGenFactory(this[kOptions].requestIdHeader, func);
      return this;
    }
  };
  var validateSchemaErrorFormatter = function(schemaErrorFormatter) {
    if (typeof schemaErrorFormatter !== "function") {
      throw new FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN(typeof schemaErrorFormatter);
    } else if (schemaErrorFormatter.constructor.name === "AsyncFunction") {
      throw new FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN("AsyncFunction");
    }
  };
  var VERSION = "4.26.0";
  var Avvio = require_boot();
  var http2 = __require("node:http");
  var lightMyRequest;
  var {
    kAvvioBoot,
    kChildren,
    kServerBindings,
    kBodyLimit,
    kRoutePrefix,
    kLogLevel,
    kLogSerializers,
    kHooks,
    kSchemaController,
    kRequestAcceptVersion,
    kReplySerializerDefault,
    kContentTypeParser,
    kReply,
    kRequest,
    kFourOhFour,
    kState,
    kOptions,
    kPluginNameChain,
    kSchemaErrorFormatter,
    kErrorHandler,
    kKeepAliveConnections,
    kChildLoggerFactory,
    kGenReqId
  } = require_symbols3();
  var { createServer, compileValidateHTTPVersion } = require_server();
  var Reply = require_reply();
  var Request2 = require_request3();
  var Context = require_context2();
  var { supportedMethods } = require_httpMethods();
  var decorator = require_decorate();
  var ContentTypeParser = require_contentTypeParser();
  var SchemaController = require_schema_controller();
  var { Hooks, hookRunnerApplication, supportedHooks } = require_hooks2();
  var { createLogger, createChildLogger, defaultChildLoggerFactory } = require_logger2();
  var pluginUtils = require_pluginUtils();
  var { getGenReqId, reqIdGenFactory } = require_reqIdGenFactory();
  var { buildRouting, validateBodyLimitOption } = require_route();
  var build404 = require_fourOhFour();
  var getSecuredInitialConfig = require_initialConfigValidation();
  var override = require_pluginOverride();
  var { FSTDEP009 } = require_warnings();
  var noopSet = require_noop_set();
  var {
    appendStackTrace,
    AVVIO_ERRORS_MAP,
    ...errorCodes
  } = require_errors4();
  var { defaultInitOptions } = getSecuredInitialConfig;
  var {
    FST_ERR_ASYNC_CONSTRAINT,
    FST_ERR_BAD_URL,
    FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE,
    FST_ERR_OPTIONS_NOT_OBJ,
    FST_ERR_QSP_NOT_FN,
    FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN,
    FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ,
    FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR,
    FST_ERR_VERSION_CONSTRAINT_NOT_STR,
    FST_ERR_INSTANCE_ALREADY_LISTENING,
    FST_ERR_REOPENED_CLOSE_SERVER,
    FST_ERR_ROUTE_REWRITE_NOT_STR,
    FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN
  } = errorCodes;
  var { buildErrorHandler } = require_error_handler();
  fastify.errorCodes = errorCodes;
  module.exports = fastify;
  module.exports.fastify = fastify;
  module.exports.default = fastify;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/node_modules/fastify/package.json
var require_package3 = __commonJS((exports, module) => {
  module.exports = {
    name: "fastify",
    version: "4.26.0",
    description: "Fast and low overhead web framework, for Node.js",
    main: "fastify.js",
    type: "commonjs",
    types: "fastify.d.ts",
    scripts: {
      bench: "branchcmp -r 2 -g -s \"npm run benchmark\"",
      benchmark: "concurrently -k -s first \"node ./examples/benchmark/simple.js\" \"autocannon -c 100 -d 30 -p 10 localhost:3000/\"",
      "benchmark:parser": "concurrently -k -s first \"node ./examples/benchmark/parser.js\" \"autocannon -c 100 -d 30 -p 10 -i ./examples/benchmark/body.json -H \"content-type:application/jsoff\" -m POST localhost:3000/\"",
      "build:validation": "node build/build-error-serializer.js && node build/build-validation.js",
      coverage: "npm run unit -- --coverage-report=html",
      "coverage:ci": "c8 --reporter=lcov tap --coverage-report=html --no-browser --no-check-coverage",
      "coverage:ci-check-coverage": "c8 check-coverage --branches 100 --functions 100 --lines 100 --statements 100",
      lint: "npm run lint:standard && npm run lint:typescript && npm run lint:markdown",
      "lint:fix": "standard --fix && npm run lint:typescript:fix",
      "lint:markdown": "markdownlint-cli2",
      "lint:standard": "standard | snazzy",
      "lint:typescript": "eslint -c types/.eslintrc.json types/**/*.d.ts test/types/**/*.test-d.ts",
      "lint:typescript:fix": "npm run lint:typescript -- --fix",
      prepublishOnly: "cross-env PREPUBLISH=true tap --no-check-coverage test/build/**.test.js && npm run test:validator:integrity",
      test: "npm run lint && npm run unit && npm run test:typescript",
      "test:ci": "npm run unit -- --cov --coverage-report=lcovonly && npm run test:typescript",
      "test:report": "npm run lint && npm run unit:report && npm run test:typescript",
      "test:validator:integrity": "npm run build:validation && git diff --quiet --ignore-all-space --ignore-blank-lines --ignore-cr-at-eol lib/error-serializer.js && git diff --quiet --ignore-all-space --ignore-blank-lines --ignore-cr-at-eol lib/configValidator.js",
      "test:typescript": "tsc test/types/import.ts && tsd",
      "test:watch": "npm run unit -- --watch --cov --no-coverage-report --reporter=terse",
      unit: "c8 tap",
      "unit:junit": "tap-mocha-reporter xunit < out.tap > test/junit-testresults.xml",
      "unit:report": "tap --cov --coverage-report=html --coverage-report=cobertura | tee out.tap",
      citgm: "tap --jobs=1 --timeout=120"
    },
    repository: {
      type: "git",
      url: "git+https://github.com/fastify/fastify.git"
    },
    keywords: [
      "web",
      "framework",
      "json",
      "schema",
      "open",
      "api"
    ],
    author: "Matteo Collina <hello@matteocollina.com>",
    contributors: [
      {
        name: "Tomas Della Vedova",
        url: "http://delved.org",
        author: true
      },
      {
        name: "Tommaso Allevi",
        email: "tomallevi@gmail.com"
      },
      {
        name: "Ethan Arrowood",
        url: "https://github.com/Ethan-Arrowood",
        email: "ethan.arrowood@gmail.com"
      },
      {
        name: "Dustin Deus",
        url: "http://starptech.de",
        email: "deusdustin@gmail.com"
      },
      {
        name: "Ayoub El Khattabi",
        url: "https://github.com/AyoubElk",
        email: "elkhattabi.ayoub@gmail.com"
      },
      {
        name: "Rafael Gonzaga",
        email: "rafael.nunu@hotmail.com",
        url: "https://github.com/rafaelgss"
      },
      {
        name: "Trivikram Kamat",
        url: "http://trivikr.github.io",
        email: "trivikr.dev@gmail.com"
      },
      {
        name: "Luciano Mammino",
        url: "https://loige.co"
      },
      {
        name: "Cemre Mengu",
        email: "cemremengu@gmail.com"
      },
      {
        name: "Evan Shortiss",
        email: "evanshortiss@gmail.com"
      },
      {
        name: "Maksim Sinik",
        url: "https://maksim.dev"
      },
      {
        name: "Manuel Spigolon",
        email: "behemoth89@gmail.com"
      },
      {
        name: "James Sumners",
        url: "https://james.sumners.info"
      },
      {
        name: "Denis F\xE4cke",
        url: "https://github.com/SerayaEryn"
      },
      {
        name: "Igor Savin",
        email: "kibertoad@gmail.com",
        url: "https://github.com/kibertoad"
      },
      {
        name: "Vincent Le Goff",
        email: "vince.legoff@gmail.com",
        url: "https://github.com/zekth"
      },
      {
        name: "Luis Orbaiceta",
        email: "luisorbaiceta@gmail.com",
        url: "https://luisorbaiceta.com"
      },
      {
        name: "Carlos Fuentes",
        email: "me@metcoder.dev",
        url: "https://metcoder.dev"
      },
      {
        name: "G\xFCrg\xFCn Day\u0131o\u011Flu",
        email: "gurgun.dayioglu@icloud.com",
        url: "https://heyhey.to/G"
      },
      {
        name: "Aras Abbasi",
        email: "aras.abbasi@gmail.com"
      }
    ],
    license: "MIT",
    bugs: {
      url: "https://github.com/fastify/fastify/issues"
    },
    homepage: "https://fastify.dev/",
    funding: [
      {
        type: "github",
        url: "https://github.com/sponsors/fastify"
      },
      {
        type: "opencollective",
        url: "https://opencollective.com/fastify"
      }
    ],
    devDependencies: {
      "@fastify/pre-commit": "^2.0.2",
      "@sinclair/typebox": "^0.31.17",
      "@sinonjs/fake-timers": "^11.1.0",
      "@types/node": "^20.8.4",
      "@typescript-eslint/eslint-plugin": "^6.7.5",
      "@typescript-eslint/parser": "^6.7.5",
      ajv: "^8.12.0",
      "ajv-errors": "^3.0.0",
      "ajv-formats": "^2.1.1",
      "ajv-i18n": "^4.2.0",
      "ajv-merge-patch": "^5.0.1",
      autocannon: "^7.14.0",
      "branch-comparer": "^1.1.0",
      c8: "^8.0.1",
      concurrently: "^8.2.2",
      "cross-env": "^7.0.3",
      eslint: "^8.51.0",
      "eslint-config-standard": "^17.1.0",
      "eslint-import-resolver-node": "^0.3.9",
      "eslint-plugin-import": "^2.28.1",
      "eslint-plugin-n": "^16.2.0",
      "eslint-plugin-promise": "^6.1.1",
      "fast-json-body": "^1.1.0",
      "fastify-plugin": "^4.5.1",
      "fluent-json-schema": "^4.1.2",
      "form-data": "^4.0.0",
      h2url: "^0.2.0",
      "http-errors": "^2.0.0",
      joi: "^17.11.0",
      "json-schema-to-ts": "^2.9.2",
      JSONStream: "^1.3.5",
      "markdownlint-cli2": "^0.10.0",
      "node-forge": "^1.3.1",
      proxyquire: "^2.1.3",
      send: "^0.18.0",
      "simple-get": "^4.0.1",
      snazzy: "^9.0.0",
      split2: "^4.2.0",
      standard: "^17.1.0",
      tap: "^16.3.9",
      tsd: "^0.29.0",
      typescript: "^5.2.2",
      undici: "^5.26.0",
      vary: "^1.1.2",
      yup: "^1.3.2"
    },
    dependencies: {
      "@fastify/ajv-compiler": "^3.5.0",
      "@fastify/error": "^3.4.0",
      "@fastify/fast-json-stringify-compiler": "^4.3.0",
      "abstract-logging": "^2.0.1",
      avvio: "^8.2.1",
      "fast-content-type-parse": "^1.1.0",
      "fast-json-stringify": "^5.8.0",
      "find-my-way": "^8.0.0",
      "light-my-request": "^5.11.0",
      pino: "^8.17.0",
      "process-warning": "^3.0.0",
      "proxy-addr": "^2.0.7",
      rfdc: "^1.3.0",
      "secure-json-parse": "^2.7.0",
      semver: "^7.5.4",
      "toad-cache": "^3.3.0"
    },
    standard: {
      ignore: [
        "lib/configValidator.js",
        "lib/error-serializer.js",
        "fastify.d.ts",
        "types/*",
        "test/types/*",
        "test/same-shape.test.js"
      ]
    },
    tsd: {
      directory: "test/types"
    }
  };
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fastify-plugin@1.6.1/node_modules/semver/semver.js
var require_semver3 = __commonJS((exports, module) => {
  var tok = function(n) {
    t[n] = R++;
  };
  var parse = function(version3, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version3 instanceof SemVer) {
      return version3;
    }
    if (typeof version3 !== "string") {
      return null;
    }
    if (version3.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? re[t.LOOSE] : re[t.FULL];
    if (!r.test(version3)) {
      return null;
    }
    try {
      return new SemVer(version3, options);
    } catch (er) {
      return null;
    }
  };
  var valid = function(version3, options) {
    var v = parse(version3, options);
    return v ? v.version : null;
  };
  var clean = function(version3, options) {
    var s = parse(version3.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  var SemVer = function(version3, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version3 instanceof SemVer) {
      if (version3.loose === options.loose) {
        return version3;
      } else {
        version3 = version3.version;
      }
    } else if (typeof version3 !== "string") {
      throw new TypeError("Invalid Version: " + version3);
    }
    if (version3.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version3, options);
    }
    debug("SemVer", version3, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version3.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: " + version3);
    }
    this.raw = version3;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map(function(id2) {
        if (/^[0-9]+$/.test(id2)) {
          var num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  };
  var inc = function(version3, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = undefined;
    }
    try {
      return new SemVer(version3, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  };
  var diff = function(version1, version22) {
    if (eq(version1, version22)) {
      return null;
    } else {
      var v1 = parse(version1);
      var v2 = parse(version22);
      var prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  };
  var compareIdentifiers = function(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  var rcompareIdentifiers = function(a, b) {
    return compareIdentifiers(b, a);
  };
  var major = function(a, loose) {
    return new SemVer(a, loose).major;
  };
  var minor = function(a, loose) {
    return new SemVer(a, loose).minor;
  };
  var patch = function(a, loose) {
    return new SemVer(a, loose).patch;
  };
  var compare = function(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  };
  var compareLoose = function(a, b) {
    return compare(a, b, true);
  };
  var compareBuild = function(a, b, loose) {
    var versionA = new SemVer(a, loose);
    var versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  var rcompare = function(a, b, loose) {
    return compare(b, a, loose);
  };
  var sort = function(list, loose) {
    return list.sort(function(a, b) {
      return exports.compareBuild(a, b, loose);
    });
  };
  var rsort = function(list, loose) {
    return list.sort(function(a, b) {
      return exports.compareBuild(b, a, loose);
    });
  };
  var gt = function(a, b, loose) {
    return compare(a, b, loose) > 0;
  };
  var lt = function(a, b, loose) {
    return compare(a, b, loose) < 0;
  };
  var eq = function(a, b, loose) {
    return compare(a, b, loose) === 0;
  };
  var neq = function(a, b, loose) {
    return compare(a, b, loose) !== 0;
  };
  var gte = function(a, b, loose) {
    return compare(a, b, loose) >= 0;
  };
  var lte = function(a, b, loose) {
    return compare(a, b, loose) <= 0;
  };
  var cmp = function(a, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  };
  var Comparator = function(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    debug("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  };
  var Range = function(range, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range;
    this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + range);
    }
    this.format();
  };
  var isSatisfiable = function(comparators, options) {
    var result = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every(function(otherComparator) {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var toComparators = function(range, options) {
    return new Range(range, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  };
  var parseComparator = function(comp, options) {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  var isX = function(id2) {
    return !id2 || id2.toLowerCase() === "x" || id2 === "*";
  };
  var replaceTildes = function(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  };
  var replaceTilde = function(comp, options) {
    var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("tilde", comp, _, M, m, p, pr);
      var ret2;
      if (isX(M)) {
        ret2 = "";
      } else if (isX(m)) {
        ret2 = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret2 = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret2 = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
      } else {
        ret2 = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
      }
      debug("tilde return", ret2);
      return ret2;
    });
  };
  var replaceCarets = function(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  };
  var replaceCaret = function(comp, options) {
    debug("caret", comp, options);
    var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("caret", comp, _, M, m, p, pr);
      var ret2;
      if (isX(M)) {
        ret2 = "";
      } else if (isX(m)) {
        ret2 = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret2 = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else {
          ret2 = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret2 = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret2 = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret2 = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret2 = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret2 = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret2 = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug("caret return", ret2);
      return ret2;
    });
  };
  var replaceXRanges = function(comp, options) {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  };
  var replaceXRange = function(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, function(ret2, gtlt, M, m, p, pr) {
      debug("xRange", comp, ret2, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret2 = "<0.0.0-0";
        } else {
          ret2 = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        ret2 = gtlt + M + "." + m + "." + p + pr;
      } else if (xm) {
        ret2 = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
      } else if (xp) {
        ret2 = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
      }
      debug("xRange return", ret2);
      return ret2;
    });
  };
  var replaceStars = function(comp, options) {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[t.STAR], "");
  };
  var hyphenReplace = function($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  };
  var testSet = function(set, version3, options) {
    for (var i2 = 0;i2 < set.length; i2++) {
      if (!set[i2].test(version3)) {
        return false;
      }
    }
    if (version3.prerelease.length && !options.includePrerelease) {
      for (i2 = 0;i2 < set.length; i2++) {
        debug(set[i2].semver);
        if (set[i2].semver === ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          var allowed = set[i2].semver;
          if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  var satisfies = function(version3, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version3);
  };
  var maxSatisfying = function(versions, range, options) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  var minSatisfying = function(versions, range, options) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  var minVersion = function(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0;i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  var validRange = function(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  var ltr = function(version3, range, options) {
    return outside(version3, range, "<", options);
  };
  var gtr = function(version3, range, options) {
    return outside(version3, range, ">", options);
  };
  var outside = function(version3, range, hilo, options) {
    version3 = new SemVer(version3, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version3, range, options)) {
      return false;
    }
    for (var i2 = 0;i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version3, low.semver)) {
        return false;
      }
    }
    return true;
  };
  var prerelease = function(version3, options) {
    var parsed = parse(version3, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  var intersects = function(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  };
  var coerce2 = function(version3, options) {
    if (version3 instanceof SemVer) {
      return version3;
    }
    if (typeof version3 === "number") {
      version3 = String(version3);
    }
    if (typeof version3 !== "string") {
      return null;
    }
    options = options || {};
    var match = null;
    if (!options.rtl) {
      match = version3.match(re[t.COERCE]);
    } else {
      var next;
      while ((next = re[t.COERCERTL].exec(version3)) && (!match || match.index + match[0].length !== version3.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      re[t.COERCERTL].lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    return parse(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
  };
  exports = module.exports = SemVer;
  var debug;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re = exports.re = [];
  var src = exports.src = [];
  var t = exports.tokens = {};
  var R = 0;
  tok("NUMERICIDENTIFIER");
  src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  tok("NUMERICIDENTIFIERLOOSE");
  src[t.NUMERICIDENTIFIERLOOSE] = "[0-9]+";
  tok("NONNUMERICIDENTIFIER");
  src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  tok("MAINVERSION");
  src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
  tok("MAINVERSIONLOOSE");
  src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
  tok("PRERELEASEIDENTIFIER");
  src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASEIDENTIFIERLOOSE");
  src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASE");
  src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
  tok("PRERELEASELOOSE");
  src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
  tok("BUILDIDENTIFIER");
  src[t.BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
  tok("BUILD");
  src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
  tok("FULL");
  tok("FULLPLAIN");
  src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
  src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
  tok("LOOSEPLAIN");
  src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
  tok("LOOSE");
  src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
  tok("GTLT");
  src[t.GTLT] = "((?:<|>)?=?)";
  tok("XRANGEIDENTIFIERLOOSE");
  src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  tok("XRANGEIDENTIFIER");
  src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
  tok("XRANGEPLAIN");
  src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGEPLAINLOOSE");
  src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGE");
  src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
  tok("XRANGELOOSE");
  src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COERCE");
  src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  tok("COERCERTL");
  re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
  tok("LONETILDE");
  src[t.LONETILDE] = "(?:~>?)";
  tok("TILDETRIM");
  src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
  re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
  var tildeTrimReplace = "$1~";
  tok("TILDE");
  src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
  tok("TILDELOOSE");
  src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("LONECARET");
  src[t.LONECARET] = "(?:\\^)";
  tok("CARETTRIM");
  src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
  re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
  var caretTrimReplace = "$1^";
  tok("CARET");
  src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
  tok("CARETLOOSE");
  src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COMPARATORLOOSE");
  src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
  tok("COMPARATOR");
  src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
  tok("COMPARATORTRIM");
  src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
  re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
  var comparatorTrimReplace = "$1$2$3";
  tok("HYPHENRANGE");
  src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
  tok("HYPHENRANGELOOSE");
  src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
  tok("STAR");
  src[t.STAR] = "(<|>)?=?\\s*\\*";
  for (i = 0;i < R; i++) {
    debug(i, src[i]);
    if (!re[i]) {
      re[i] = new RegExp(src[i]);
    }
  }
  var i;
  exports.parse = parse;
  exports.valid = valid;
  exports.clean = clean;
  exports.SemVer = SemVer;
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug("prerelease compare", i2, a, b);
      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.compareBuild = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    var i2 = 0;
    do {
      var a = this.build[i2];
      var b = other.build[i2];
      debug("prerelease compare", i2, a, b);
      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports.inc = inc;
  exports.diff = diff;
  exports.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  exports.rcompareIdentifiers = rcompareIdentifiers;
  exports.major = major;
  exports.minor = minor;
  exports.patch = patch;
  exports.compare = compare;
  exports.compareLoose = compareLoose;
  exports.compareBuild = compareBuild;
  exports.rcompare = rcompare;
  exports.sort = sort;
  exports.rsort = rsort;
  exports.gt = gt;
  exports.lt = lt;
  exports.eq = eq;
  exports.neq = neq;
  exports.gte = gte;
  exports.lte = lte;
  exports.cmp = cmp;
  exports.Comparator = Comparator;
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m[1] !== undefined ? m[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version3) {
    debug("Comparator.test", version3, this.options.loose);
    if (this.semver === ANY || version3 === ANY) {
      return true;
    }
    if (typeof version3 === "string") {
      try {
        version3 = new SemVer(version3, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp(version3, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports.Range = Range;
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug("hyphen replace", range);
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
    debug("comparator trim", range, re[t.COMPARATORTRIM]);
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    var set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
        return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  exports.toComparators = toComparators;
  Range.prototype.test = function(version3) {
    if (!version3) {
      return false;
    }
    if (typeof version3 === "string") {
      try {
        version3 = new SemVer(version3, this.options);
      } catch (er) {
        return false;
      }
    }
    for (var i2 = 0;i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version3, this.options)) {
        return true;
      }
    }
    return false;
  };
  exports.satisfies = satisfies;
  exports.maxSatisfying = maxSatisfying;
  exports.minSatisfying = minSatisfying;
  exports.minVersion = minVersion;
  exports.validRange = validRange;
  exports.ltr = ltr;
  exports.gtr = gtr;
  exports.outside = outside;
  exports.prerelease = prerelease;
  exports.intersects = intersects;
  exports.coerce = coerce2;
});

// ../node_modules/.pnpm/fastify-plugin@1.6.1/node_modules/fastify-plugin/stackParser.js
var require_stackParser = __commonJS((exports, module) => {
  var fpStackTracePattern = /at\s{1}(?:.*\.)?plugin\s{1}.*\n\s*(.*)/;
  var fileNamePattern = /(\w*(\.\w*)*)\..*/;
  module.exports = function extractPluginName(stack) {
    const m = stack.match(fpStackTracePattern);
    return m ? m[1].split(/[/\\]/).slice(-1)[0].match(fileNamePattern)[1] : "anonymous";
  };
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fastify-cors@3.0.3/node_modules/fastify-plugin/index.js
var require_fastify_plugin = __commonJS((exports, module) => {
  var plugin = function(fn, options = {}) {
    if (typeof fn.default !== "undefined") {
      fn = fn.default;
    }
    if (typeof fn !== "function") {
      throw new TypeError(`fastify-plugin expects a function, instead got a '${typeof fn}'`);
    }
    fn[Symbol.for("skip-override")] = true;
    const pluginName = options && options.name || checkName(fn);
    if (typeof options === "string") {
      checkVersion(options, pluginName);
      options = {};
    }
    if (typeof options !== "object" || Array.isArray(options) || options === null) {
      throw new TypeError("The options object should be an object");
    }
    if (!options.name) {
      options.name = pluginName;
    }
    fn[Symbol.for("fastify.display-name")] = options.name;
    if (options.fastify) {
      checkVersion(options.fastify, pluginName);
    }
    fn[Symbol.for("plugin-meta")] = options;
    return fn;
  };
  var checkName = function(fn) {
    if (fn.name.length > 0)
      return fn.name;
    try {
      throw new Error("anonymous function");
    } catch (e) {
      return extractPluginName(e.stack);
    }
  };
  var checkVersion = function(version3, pluginName) {
    if (typeof version3 !== "string") {
      throw new TypeError(`fastify-plugin expects a version string, instead got '${typeof version3}'`);
    }
    var fastifyVersion;
    try {
      fastifyVersion = require_package3().version.replace(/-rc\.\d+/, "");
    } catch (_) {
      console2.info("fastify not found, proceeding anyway");
    }
    if (fastifyVersion && !semver.satisfies(fastifyVersion, version3)) {
      throw new Error(`fastify-plugin: ${pluginName} - expected '${version3}' fastify version, '${fastifyVersion}' is installed`);
    }
  };
  var semver = require_semver3();
  var console2 = __require("console");
  var extractPluginName = require_stackParser();
  module.exports = plugin;
});

// /home/mous/work/pimlico/alto/node_modules/.pnpm/fastify-cors@3.0.3/node_modules/vary/index.js
var require_vary = __commonJS((exports, module) => {
  var append = function(header, field) {
    if (typeof header !== "string") {
      throw new TypeError("header argument is required");
    }
    if (!field) {
      throw new TypeError("field argument is required");
    }
    var fields = !Array.isArray(field) ? parse(String(field)) : field;
    for (var j = 0;j < fields.length; j++) {
      if (!FIELD_NAME_REGEXP.test(fields[j])) {
        throw new TypeError("field argument contains an invalid header name");
      }
    }
    if (header === "*") {
      return header;
    }
    var val = header;
    var vals = parse(header.toLowerCase());
    if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
      return "*";
    }
    for (var i = 0;i < fields.length; i++) {
      var fld = fields[i].toLowerCase();
      if (vals.indexOf(fld) === -1) {
        vals.push(fld);
        val = val ? val + ", " + fields[i] : fields[i];
      }
    }
    return val;
  };
  var parse = function(header) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = header.length;i < len; i++) {
      switch (header.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          list.push(header.substring(start, end));
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    list.push(header.substring(start, end));
    return list;
  };
  var vary = function(res, field) {
    if (!res || !res.getHeader || !res.setHeader) {
      throw new TypeError("res argument is required");
    }
    var val = res.getHeader("Vary") || "";
    var header = Array.isArray(val) ? val.join(", ") : String(val);
    if (val = append(header, field)) {
      res.setHeader("Vary", val);
    }
  };
  /*!
   * vary
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = vary;
  module.exports.append = append;
  var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
});

// /home/mous/work/pimlico/alto/src/node_modules/fastify-cors/index.js
var require_fastify_cors = __commonJS((exports, module) => {
  var fastifyCors = function(fastify, opts, next) {
    const {
      origin,
      credentials,
      exposedHeaders,
      allowedHeaders,
      methods,
      maxAge,
      preflightContinue,
      optionsSuccessStatus,
      preflight,
      hideOptionsRoute
    } = Object.assign({
      origin: "*",
      methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
      preflightContinue: false,
      optionsSuccessStatus: 204,
      credentials: false,
      exposedHeaders: null,
      allowedHeaders: null,
      maxAge: null,
      preflight: true,
      hideOptionsRoute: true
    }, opts);
    const isOriginFalsy = !origin;
    const isOriginString = typeof origin === "string";
    const isOriginFunction = typeof origin === "function";
    if (preflight === true) {
      fastify.options("*", { schema: { hide: hideOptionsRoute } }, (req, reply) => reply.send());
    }
    fastify.addHook("onRequest", onRequest);
    function onRequest(req, reply, next2) {
      vary(reply, "Origin");
      if (isOriginFalsy)
        return next2();
      configureOrigin(req, reply, (err, origin2) => {
        if (err !== null)
          return next2(err);
        if (origin2 === false)
          return next2();
        if (credentials) {
          reply.header("Access-Control-Allow-Credentials", "true");
        }
        if (exposedHeaders !== null) {
          reply.header("Access-Control-Expose-Headers", Array.isArray(exposedHeaders) ? exposedHeaders.join(", ") : exposedHeaders);
        }
        if (req.raw.method === "OPTIONS" && preflight === true) {
          reply.header("Access-Control-Allow-Methods", Array.isArray(methods) ? methods.join(", ") : methods);
          if (allowedHeaders === null) {
            vary(reply, "Access-Control-Request-Headers");
            var reqAllowedHeaders = req.headers["access-control-request-headers"];
            if (reqAllowedHeaders !== undefined) {
              reply.header("Access-Control-Allow-Headers", reqAllowedHeaders);
            }
          } else {
            reply.header("Access-Control-Allow-Headers", Array.isArray(allowedHeaders) ? allowedHeaders.join(", ") : allowedHeaders);
          }
          if (maxAge !== null) {
            reply.header("Access-Control-Max-Age", String(maxAge));
          }
          if (preflightContinue) {
            next2();
          } else {
            reply.code(optionsSuccessStatus).header("Content-Length", "0").send();
          }
        } else {
          next2();
        }
      });
    }
    function configureOrigin(req, reply, callback) {
      var reqOrigin = req.headers.origin;
      if (isOriginFunction) {
        var result = origin.call(fastify, reqOrigin, _onOrigin);
        if (result && typeof result.then === "function") {
          result.then((res) => _onOrigin(null, res), callback);
        }
      } else {
        _configureOrigin(origin);
      }
      function _onOrigin(err, origin2) {
        if (err !== null || origin2 === false) {
          return callback(err, origin2);
        }
        _configureOrigin(origin2);
      }
      function _configureOrigin(origin2) {
        if (!origin2 || origin2 === "*") {
          reply.header("Access-Control-Allow-Origin", "*");
        } else if (isOriginString) {
          reply.header("Access-Control-Allow-Origin", origin2);
        } else {
          reply.header("Access-Control-Allow-Origin", isOriginAllowed(reqOrigin, origin2) ? reqOrigin : false);
        }
        callback(null, origin2);
      }
    }
    function isOriginAllowed(reqOrigin, origin2) {
      if (Array.isArray(origin2)) {
        for (var i = 0;i < origin2.length; ++i) {
          if (isOriginAllowed(reqOrigin, origin2[i])) {
            return true;
          }
        }
        return false;
      } else if (typeof origin2 === "string") {
        return reqOrigin === origin2;
      } else if (origin2 instanceof RegExp) {
        return origin2.test(reqOrigin);
      } else {
        return !!origin2;
      }
    }
    next();
  };
  var vary = function(reply, field) {
    var value = reply.getHeader("Vary") || "";
    var header = Array.isArray(value) ? value.join(", ") : String(value);
    if (value = append(header, field)) {
      reply.header("Vary", value);
    }
  };
  var fp = require_fastify_plugin();
  var append = require_vary().append;
  module.exports = fp(fastifyCors, {
    fastify: ">=2.x",
    name: "fastify-cors"
  });
});

// cli/alto.ts
var sentry13 = __toESM(require_cjs4(), 1);
var import_dotenv = __toESM(require_main(), 1);

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/lib/platform-shims/esm.mjs
import {notStrictEqual, strictEqual} from "assert";

// ../node_modules/.pnpm/cliui@8.0.1/node_modules/cliui/build/lib/index.js
var addBorder = function(col, ts, style) {
  if (col.border) {
    if (/[.']-+[.']/.test(ts)) {
      return "";
    }
    if (ts.trim().length !== 0) {
      return style;
    }
    return "  ";
  }
  return "";
};
var _minWidth = function(col) {
  const padding = col.padding || [];
  const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
  if (col.border) {
    return minWidth + 4;
  }
  return minWidth;
};
var getWindowWidth = function() {
  if (typeof process === "object" && process.stdout && process.stdout.columns) {
    return process.stdout.columns;
  }
  return 80;
};
var alignRight = function(str, width) {
  str = str.trim();
  const strWidth = mixin.stringWidth(str);
  if (strWidth < width) {
    return " ".repeat(width - strWidth) + str;
  }
  return str;
};
var alignCenter = function(str, width) {
  str = str.trim();
  const strWidth = mixin.stringWidth(str);
  if (strWidth >= width) {
    return str;
  }
  return " ".repeat(width - strWidth >> 1) + str;
};
function cliui(opts, _mixin) {
  mixin = _mixin;
  return new UI({
    width: (opts === null || opts === undefined ? undefined : opts.width) || getWindowWidth(),
    wrap: opts === null || opts === undefined ? undefined : opts.wrap
  });
}
var align = {
  right: alignRight,
  center: alignCenter
};
var top = 0;
var right = 1;
var bottom = 2;
var left = 3;

class UI {
  constructor(opts) {
    var _a;
    this.width = opts.width;
    this.wrap = (_a = opts.wrap) !== null && _a !== undefined ? _a : true;
    this.rows = [];
  }
  span(...args) {
    const cols = this.div(...args);
    cols.span = true;
  }
  resetOutput() {
    this.rows = [];
  }
  div(...args) {
    if (args.length === 0) {
      this.div("");
    }
    if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === "string") {
      return this.applyLayoutDSL(args[0]);
    }
    const cols = args.map((arg) => {
      if (typeof arg === "string") {
        return this.colFromString(arg);
      }
      return arg;
    });
    this.rows.push(cols);
    return cols;
  }
  shouldApplyLayoutDSL(...args) {
    return args.length === 1 && typeof args[0] === "string" && /[\t\n]/.test(args[0]);
  }
  applyLayoutDSL(str) {
    const rows = str.split("\n").map((row) => row.split("\t"));
    let leftColumnWidth = 0;
    rows.forEach((columns) => {
      if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {
        leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));
      }
    });
    rows.forEach((columns) => {
      this.div(...columns.map((r, i) => {
        return {
          text: r.trim(),
          padding: this.measurePadding(r),
          width: i === 0 && columns.length > 1 ? leftColumnWidth : undefined
        };
      }));
    });
    return this.rows[this.rows.length - 1];
  }
  colFromString(text) {
    return {
      text,
      padding: this.measurePadding(text)
    };
  }
  measurePadding(str) {
    const noAnsi = mixin.stripAnsi(str);
    return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
  }
  toString() {
    const lines = [];
    this.rows.forEach((row) => {
      this.rowToString(row, lines);
    });
    return lines.filter((line) => !line.hidden).map((line) => line.text).join("\n");
  }
  rowToString(row, lines) {
    this.rasterize(row).forEach((rrow, r) => {
      let str = "";
      rrow.forEach((col, c) => {
        const { width } = row[c];
        const wrapWidth = this.negatePadding(row[c]);
        let ts = col;
        if (wrapWidth > mixin.stringWidth(col)) {
          ts += " ".repeat(wrapWidth - mixin.stringWidth(col));
        }
        if (row[c].align && row[c].align !== "left" && this.wrap) {
          const fn = align[row[c].align];
          ts = fn(ts, wrapWidth);
          if (mixin.stringWidth(ts) < wrapWidth) {
            ts += " ".repeat((width || 0) - mixin.stringWidth(ts) - 1);
          }
        }
        const padding = row[c].padding || [0, 0, 0, 0];
        if (padding[left]) {
          str += " ".repeat(padding[left]);
        }
        str += addBorder(row[c], ts, "| ");
        str += ts;
        str += addBorder(row[c], ts, " |");
        if (padding[right]) {
          str += " ".repeat(padding[right]);
        }
        if (r === 0 && lines.length > 0) {
          str = this.renderInline(str, lines[lines.length - 1]);
        }
      });
      lines.push({
        text: str.replace(/ +$/, ""),
        span: row.span
      });
    });
    return lines;
  }
  renderInline(source, previousLine) {
    const match = source.match(/^ */);
    const leadingWhitespace = match ? match[0].length : 0;
    const target = previousLine.text;
    const targetTextWidth = mixin.stringWidth(target.trimRight());
    if (!previousLine.span) {
      return source;
    }
    if (!this.wrap) {
      previousLine.hidden = true;
      return target + source;
    }
    if (leadingWhitespace < targetTextWidth) {
      return source;
    }
    previousLine.hidden = true;
    return target.trimRight() + " ".repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
  }
  rasterize(row) {
    const rrows = [];
    const widths = this.columnWidths(row);
    let wrapped;
    row.forEach((col, c) => {
      col.width = widths[c];
      if (this.wrap) {
        wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split("\n");
      } else {
        wrapped = col.text.split("\n");
      }
      if (col.border) {
        wrapped.unshift("." + "-".repeat(this.negatePadding(col) + 2) + ".");
        wrapped.push("'" + "-".repeat(this.negatePadding(col) + 2) + "'");
      }
      if (col.padding) {
        wrapped.unshift(...new Array(col.padding[top] || 0).fill(""));
        wrapped.push(...new Array(col.padding[bottom] || 0).fill(""));
      }
      wrapped.forEach((str, r) => {
        if (!rrows[r]) {
          rrows.push([]);
        }
        const rrow = rrows[r];
        for (let i = 0;i < c; i++) {
          if (rrow[i] === undefined) {
            rrow.push("");
          }
        }
        rrow.push(str);
      });
    });
    return rrows;
  }
  negatePadding(col) {
    let wrapWidth = col.width || 0;
    if (col.padding) {
      wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
    }
    if (col.border) {
      wrapWidth -= 4;
    }
    return wrapWidth;
  }
  columnWidths(row) {
    if (!this.wrap) {
      return row.map((col) => {
        return col.width || mixin.stringWidth(col.text);
      });
    }
    let unset = row.length;
    let remainingWidth = this.width;
    const widths = row.map((col) => {
      if (col.width) {
        unset--;
        remainingWidth -= col.width;
        return col.width;
      }
      return;
    });
    const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
    return widths.map((w, i) => {
      if (w === undefined) {
        return Math.max(unsetWidth, _minWidth(row[i]));
      }
      return w;
    });
  }
}
var mixin;

// ../node_modules/.pnpm/cliui@8.0.1/node_modules/cliui/build/lib/string-utils.js
function stripAnsi(str) {
  return str.replace(ansi, "");
}
function wrap(str, width) {
  const [start, end] = str.match(ansi) || ["", ""];
  str = stripAnsi(str);
  let wrapped = "";
  for (let i = 0;i < str.length; i++) {
    if (i !== 0 && i % width === 0) {
      wrapped += "\n";
    }
    wrapped += str.charAt(i);
  }
  if (start && end) {
    wrapped = `${start}${wrapped}${end}`;
  }
  return wrapped;
}
var ansi = new RegExp("\x1B(?:\\[(?:\\d+[ABCDEFGJKSTm]|\\d+;\\d+[Hfm]|" + "\\d+;\\d+;\\d+m|6n|s|u|\\?25[lh])|\\w)", "g");

// /home/mous/work/pimlico/alto/node_modules/.pnpm/yargs@17.7.2/node_modules/cliui/index.mjs
function ui(opts) {
  return cliui(opts, {
    stringWidth: (str) => {
      return [...str].length;
    },
    stripAnsi,
    wrap
  });
}

// /home/mous/work/pimlico/alto/node_modules/.pnpm/yargs@17.7.2/node_modules/escalade/sync/index.mjs
import {dirname, resolve} from "path";
import {readdirSync, statSync} from "fs";
function sync_default(start, callback) {
  let dir = resolve(".", start);
  let tmp, stats = statSync(dir);
  if (!stats.isDirectory()) {
    dir = dirname(dir);
  }
  while (true) {
    tmp = callback(dir, readdirSync(dir));
    if (tmp)
      return resolve(dir, tmp);
    dir = dirname(tmp = dir);
    if (tmp === dir)
      break;
  }
}

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/lib/platform-shims/esm.mjs
import {inspect} from "util";
import {readFileSync as readFileSync3} from "fs";
import {fileURLToPath} from "url";

// /home/mous/work/pimlico/alto/node_modules/.pnpm/yargs@17.7.2/node_modules/yargs-parser/build/lib/index.js
import {format} from "util";
import {normalize, resolve as resolve2} from "path";

// ../node_modules/.pnpm/yargs-parser@21.1.1/node_modules/yargs-parser/build/lib/string-utils.js
function camelCase(str) {
  const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
  if (!isCamelCase) {
    str = str.toLowerCase();
  }
  if (str.indexOf("-") === -1 && str.indexOf("_") === -1) {
    return str;
  } else {
    let camelcase = "";
    let nextChrUpper = false;
    const leadingHyphens = str.match(/^-+/);
    for (let i = leadingHyphens ? leadingHyphens[0].length : 0;i < str.length; i++) {
      let chr = str.charAt(i);
      if (nextChrUpper) {
        nextChrUpper = false;
        chr = chr.toUpperCase();
      }
      if (i !== 0 && (chr === "-" || chr === "_")) {
        nextChrUpper = true;
      } else if (chr !== "-" && chr !== "_") {
        camelcase += chr;
      }
    }
    return camelcase;
  }
}
function decamelize(str, joinString) {
  const lowercase = str.toLowerCase();
  joinString = joinString || "-";
  let notCamelcase = "";
  for (let i = 0;i < str.length; i++) {
    const chrLower = lowercase.charAt(i);
    const chrString = str.charAt(i);
    if (chrLower !== chrString && i > 0) {
      notCamelcase += `${joinString}${lowercase.charAt(i)}`;
    } else {
      notCamelcase += chrString;
    }
  }
  return notCamelcase;
}
function looksLikeNumber(x) {
  if (x === null || x === undefined)
    return false;
  if (typeof x === "number")
    return true;
  if (/^0x[0-9a-f]+$/i.test(x))
    return true;
  if (/^0[^.]/.test(x))
    return false;
  return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}

// ../node_modules/.pnpm/yargs-parser@21.1.1/node_modules/yargs-parser/build/lib/tokenize-arg-string.js
function tokenizeArgString(argString) {
  if (Array.isArray(argString)) {
    return argString.map((e) => typeof e !== "string" ? e + "" : e);
  }
  argString = argString.trim();
  let i = 0;
  let prevC = null;
  let c = null;
  let opening = null;
  const args = [];
  for (let ii = 0;ii < argString.length; ii++) {
    prevC = c;
    c = argString.charAt(ii);
    if (c === " " && !opening) {
      if (!(prevC === " ")) {
        i++;
      }
      continue;
    }
    if (c === opening) {
      opening = null;
    } else if ((c === "'" || c === '"') && !opening) {
      opening = c;
    }
    if (!args[i])
      args[i] = "";
    args[i] += c;
  }
  return args;
}

// ../node_modules/.pnpm/yargs-parser@21.1.1/node_modules/yargs-parser/build/lib/yargs-parser-types.js
var DefaultValuesForTypeKey;
(function(DefaultValuesForTypeKey2) {
  DefaultValuesForTypeKey2["BOOLEAN"] = "boolean";
  DefaultValuesForTypeKey2["STRING"] = "string";
  DefaultValuesForTypeKey2["NUMBER"] = "number";
  DefaultValuesForTypeKey2["ARRAY"] = "array";
})(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));

// ../node_modules/.pnpm/yargs-parser@21.1.1/node_modules/yargs-parser/build/lib/yargs-parser.js
var combineAliases = function(aliases) {
  const aliasArrays = [];
  const combined = Object.create(null);
  let change = true;
  Object.keys(aliases).forEach(function(key) {
    aliasArrays.push([].concat(aliases[key], key));
  });
  while (change) {
    change = false;
    for (let i = 0;i < aliasArrays.length; i++) {
      for (let ii = i + 1;ii < aliasArrays.length; ii++) {
        const intersect = aliasArrays[i].filter(function(v) {
          return aliasArrays[ii].indexOf(v) !== -1;
        });
        if (intersect.length) {
          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
          aliasArrays.splice(ii, 1);
          change = true;
          break;
        }
      }
    }
  }
  aliasArrays.forEach(function(aliasArray) {
    aliasArray = aliasArray.filter(function(v, i, self2) {
      return self2.indexOf(v) === i;
    });
    const lastAlias = aliasArray.pop();
    if (lastAlias !== undefined && typeof lastAlias === "string") {
      combined[lastAlias] = aliasArray;
    }
  });
  return combined;
};
var increment = function(orig) {
  return orig !== undefined ? orig + 1 : 1;
};
var sanitizeKey = function(key) {
  if (key === "__proto__")
    return "___proto___";
  return key;
};
var stripQuotes = function(val) {
  return typeof val === "string" && (val[0] === "'" || val[0] === '"') && val[val.length - 1] === val[0] ? val.substring(1, val.length - 1) : val;
};
var mixin2;

class YargsParser {
  constructor(_mixin) {
    mixin2 = _mixin;
  }
  parse(argsInput, options) {
    const opts = Object.assign({
      alias: undefined,
      array: undefined,
      boolean: undefined,
      config: undefined,
      configObjects: undefined,
      configuration: undefined,
      coerce: undefined,
      count: undefined,
      default: undefined,
      envPrefix: undefined,
      narg: undefined,
      normalize: undefined,
      string: undefined,
      number: undefined,
      __: undefined,
      key: undefined
    }, options);
    const args = tokenizeArgString(argsInput);
    const inputIsString = typeof argsInput === "string";
    const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
    const configuration = Object.assign({
      "boolean-negation": true,
      "camel-case-expansion": true,
      "combine-arrays": false,
      "dot-notation": true,
      "duplicate-arguments-array": true,
      "flatten-duplicate-arrays": true,
      "greedy-arrays": true,
      "halt-at-non-option": false,
      "nargs-eats-options": false,
      "negation-prefix": "no-",
      "parse-numbers": true,
      "parse-positional-numbers": true,
      "populate--": false,
      "set-placeholder-key": false,
      "short-option-groups": true,
      "strip-aliased": false,
      "strip-dashed": false,
      "unknown-options-as-args": false
    }, opts.configuration);
    const defaults = Object.assign(Object.create(null), opts.default);
    const configObjects = opts.configObjects || [];
    const envPrefix = opts.envPrefix;
    const notFlagsOption = configuration["populate--"];
    const notFlagsArgv = notFlagsOption ? "--" : "_";
    const newAliases = Object.create(null);
    const defaulted = Object.create(null);
    const __ = opts.__ || mixin2.format;
    const flags = {
      aliases: Object.create(null),
      arrays: Object.create(null),
      bools: Object.create(null),
      strings: Object.create(null),
      numbers: Object.create(null),
      counts: Object.create(null),
      normalize: Object.create(null),
      configs: Object.create(null),
      nargs: Object.create(null),
      coercions: Object.create(null),
      keys: []
    };
    const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
    const negatedBoolean = new RegExp("^--" + configuration["negation-prefix"] + "(.+)");
    [].concat(opts.array || []).filter(Boolean).forEach(function(opt) {
      const key = typeof opt === "object" ? opt.key : opt;
      const assignment = Object.keys(opt).map(function(key2) {
        const arrayFlagKeys = {
          boolean: "bools",
          string: "strings",
          number: "numbers"
        };
        return arrayFlagKeys[key2];
      }).filter(Boolean).pop();
      if (assignment) {
        flags[assignment][key] = true;
      }
      flags.arrays[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.boolean || []).filter(Boolean).forEach(function(key) {
      flags.bools[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.string || []).filter(Boolean).forEach(function(key) {
      flags.strings[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.number || []).filter(Boolean).forEach(function(key) {
      flags.numbers[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.count || []).filter(Boolean).forEach(function(key) {
      flags.counts[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.normalize || []).filter(Boolean).forEach(function(key) {
      flags.normalize[key] = true;
      flags.keys.push(key);
    });
    if (typeof opts.narg === "object") {
      Object.entries(opts.narg).forEach(([key, value]) => {
        if (typeof value === "number") {
          flags.nargs[key] = value;
          flags.keys.push(key);
        }
      });
    }
    if (typeof opts.coerce === "object") {
      Object.entries(opts.coerce).forEach(([key, value]) => {
        if (typeof value === "function") {
          flags.coercions[key] = value;
          flags.keys.push(key);
        }
      });
    }
    if (typeof opts.config !== "undefined") {
      if (Array.isArray(opts.config) || typeof opts.config === "string") {
        [].concat(opts.config).filter(Boolean).forEach(function(key) {
          flags.configs[key] = true;
        });
      } else if (typeof opts.config === "object") {
        Object.entries(opts.config).forEach(([key, value]) => {
          if (typeof value === "boolean" || typeof value === "function") {
            flags.configs[key] = value;
          }
        });
      }
    }
    extendAliases(opts.key, aliases, opts.default, flags.arrays);
    Object.keys(defaults).forEach(function(key) {
      (flags.aliases[key] || []).forEach(function(alias) {
        defaults[alias] = defaults[key];
      });
    });
    let error = null;
    checkConfiguration();
    let notFlags = [];
    const argv = Object.assign(Object.create(null), { _: [] });
    const argvReturn = {};
    for (let i = 0;i < args.length; i++) {
      const arg = args[i];
      const truncatedArg = arg.replace(/^-{3,}/, "---");
      let broken;
      let key;
      let letters;
      let m;
      let next;
      let value;
      if (arg !== "--" && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {
        pushPositional(arg);
      } else if (truncatedArg.match(/^---+(=|$)/)) {
        pushPositional(arg);
        continue;
      } else if (arg.match(/^--.+=/) || !configuration["short-option-groups"] && arg.match(/^-.+=/)) {
        m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
        if (m !== null && Array.isArray(m) && m.length >= 3) {
          if (checkAllAliases(m[1], flags.arrays)) {
            i = eatArray(i, m[1], args, m[2]);
          } else if (checkAllAliases(m[1], flags.nargs) !== false) {
            i = eatNargs(i, m[1], args, m[2]);
          } else {
            setArg(m[1], m[2], true);
          }
        }
      } else if (arg.match(negatedBoolean) && configuration["boolean-negation"]) {
        m = arg.match(negatedBoolean);
        if (m !== null && Array.isArray(m) && m.length >= 2) {
          key = m[1];
          setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
        }
      } else if (arg.match(/^--.+/) || !configuration["short-option-groups"] && arg.match(/^-[^-]+/)) {
        m = arg.match(/^--?(.+)/);
        if (m !== null && Array.isArray(m) && m.length >= 2) {
          key = m[1];
          if (checkAllAliases(key, flags.arrays)) {
            i = eatArray(i, key, args);
          } else if (checkAllAliases(key, flags.nargs) !== false) {
            i = eatNargs(i, key, args);
          } else {
            next = args[i + 1];
            if (next !== undefined && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
              setArg(key, next);
              i++;
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next);
              i++;
            } else {
              setArg(key, defaultValue(key));
            }
          }
        }
      } else if (arg.match(/^-.\..+=/)) {
        m = arg.match(/^-([^=]+)=([\s\S]*)$/);
        if (m !== null && Array.isArray(m) && m.length >= 3) {
          setArg(m[1], m[2]);
        }
      } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
        next = args[i + 1];
        m = arg.match(/^-(.\..+)/);
        if (m !== null && Array.isArray(m) && m.length >= 2) {
          key = m[1];
          if (next !== undefined && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
            setArg(key, next);
            i++;
          } else {
            setArg(key, defaultValue(key));
          }
        }
      } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
        letters = arg.slice(1, -1).split("");
        broken = false;
        for (let j = 0;j < letters.length; j++) {
          next = arg.slice(j + 2);
          if (letters[j + 1] && letters[j + 1] === "=") {
            value = arg.slice(j + 3);
            key = letters[j];
            if (checkAllAliases(key, flags.arrays)) {
              i = eatArray(i, key, args, value);
            } else if (checkAllAliases(key, flags.nargs) !== false) {
              i = eatNargs(i, key, args, value);
            } else {
              setArg(key, value);
            }
            broken = true;
            break;
          }
          if (next === "-") {
            setArg(letters[j], next);
            continue;
          }
          if (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {
            setArg(letters[j], next);
            broken = true;
            break;
          }
          if (letters[j + 1] && letters[j + 1].match(/\W/)) {
            setArg(letters[j], next);
            broken = true;
            break;
          } else {
            setArg(letters[j], defaultValue(letters[j]));
          }
        }
        key = arg.slice(-1)[0];
        if (!broken && key !== "-") {
          if (checkAllAliases(key, flags.arrays)) {
            i = eatArray(i, key, args);
          } else if (checkAllAliases(key, flags.nargs) !== false) {
            i = eatNargs(i, key, args);
          } else {
            next = args[i + 1];
            if (next !== undefined && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
              setArg(key, next);
              i++;
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next);
              i++;
            } else {
              setArg(key, defaultValue(key));
            }
          }
        }
      } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
        key = arg.slice(1);
        setArg(key, defaultValue(key));
      } else if (arg === "--") {
        notFlags = args.slice(i + 1);
        break;
      } else if (configuration["halt-at-non-option"]) {
        notFlags = args.slice(i);
        break;
      } else {
        pushPositional(arg);
      }
    }
    applyEnvVars(argv, true);
    applyEnvVars(argv, false);
    setConfig(argv);
    setConfigObjects();
    applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
    applyCoercions(argv);
    if (configuration["set-placeholder-key"])
      setPlaceholderKeys(argv);
    Object.keys(flags.counts).forEach(function(key) {
      if (!hasKey(argv, key.split(".")))
        setArg(key, 0);
    });
    if (notFlagsOption && notFlags.length)
      argv[notFlagsArgv] = [];
    notFlags.forEach(function(key) {
      argv[notFlagsArgv].push(key);
    });
    if (configuration["camel-case-expansion"] && configuration["strip-dashed"]) {
      Object.keys(argv).filter((key) => key !== "--" && key.includes("-")).forEach((key) => {
        delete argv[key];
      });
    }
    if (configuration["strip-aliased"]) {
      [].concat(...Object.keys(aliases).map((k) => aliases[k])).forEach((alias) => {
        if (configuration["camel-case-expansion"] && alias.includes("-")) {
          delete argv[alias.split(".").map((prop) => camelCase(prop)).join(".")];
        }
        delete argv[alias];
      });
    }
    function pushPositional(arg) {
      const maybeCoercedNumber = maybeCoerceNumber("_", arg);
      if (typeof maybeCoercedNumber === "string" || typeof maybeCoercedNumber === "number") {
        argv._.push(maybeCoercedNumber);
      }
    }
    function eatNargs(i, key, args2, argAfterEqualSign) {
      let ii;
      let toEat = checkAllAliases(key, flags.nargs);
      toEat = typeof toEat !== "number" || isNaN(toEat) ? 1 : toEat;
      if (toEat === 0) {
        if (!isUndefined(argAfterEqualSign)) {
          error = Error(__("Argument unexpected for: %s", key));
        }
        setArg(key, defaultValue(key));
        return i;
      }
      let available = isUndefined(argAfterEqualSign) ? 0 : 1;
      if (configuration["nargs-eats-options"]) {
        if (args2.length - (i + 1) + available < toEat) {
          error = Error(__("Not enough arguments following: %s", key));
        }
        available = toEat;
      } else {
        for (ii = i + 1;ii < args2.length; ii++) {
          if (!args2[ii].match(/^-[^0-9]/) || args2[ii].match(negative) || isUnknownOptionAsArg(args2[ii]))
            available++;
          else
            break;
        }
        if (available < toEat)
          error = Error(__("Not enough arguments following: %s", key));
      }
      let consumed = Math.min(available, toEat);
      if (!isUndefined(argAfterEqualSign) && consumed > 0) {
        setArg(key, argAfterEqualSign);
        consumed--;
      }
      for (ii = i + 1;ii < consumed + i + 1; ii++) {
        setArg(key, args2[ii]);
      }
      return i + consumed;
    }
    function eatArray(i, key, args2, argAfterEqualSign) {
      let argsToSet = [];
      let next = argAfterEqualSign || args2[i + 1];
      const nargsCount = checkAllAliases(key, flags.nargs);
      if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {
        argsToSet.push(true);
      } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
        if (defaults[key] !== undefined) {
          const defVal = defaults[key];
          argsToSet = Array.isArray(defVal) ? defVal : [defVal];
        }
      } else {
        if (!isUndefined(argAfterEqualSign)) {
          argsToSet.push(processValue(key, argAfterEqualSign, true));
        }
        for (let ii = i + 1;ii < args2.length; ii++) {
          if (!configuration["greedy-arrays"] && argsToSet.length > 0 || nargsCount && typeof nargsCount === "number" && argsToSet.length >= nargsCount)
            break;
          next = args2[ii];
          if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
            break;
          i = ii;
          argsToSet.push(processValue(key, next, inputIsString));
        }
      }
      if (typeof nargsCount === "number" && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {
        error = Error(__("Not enough arguments following: %s", key));
      }
      setArg(key, argsToSet);
      return i;
    }
    function setArg(key, val, shouldStripQuotes = inputIsString) {
      if (/-/.test(key) && configuration["camel-case-expansion"]) {
        const alias = key.split(".").map(function(prop) {
          return camelCase(prop);
        }).join(".");
        addNewAlias(key, alias);
      }
      const value = processValue(key, val, shouldStripQuotes);
      const splitKey = key.split(".");
      setKey(argv, splitKey, value);
      if (flags.aliases[key]) {
        flags.aliases[key].forEach(function(x) {
          const keyProperties = x.split(".");
          setKey(argv, keyProperties, value);
        });
      }
      if (splitKey.length > 1 && configuration["dot-notation"]) {
        (flags.aliases[splitKey[0]] || []).forEach(function(x) {
          let keyProperties = x.split(".");
          const a = [].concat(splitKey);
          a.shift();
          keyProperties = keyProperties.concat(a);
          if (!(flags.aliases[key] || []).includes(keyProperties.join("."))) {
            setKey(argv, keyProperties, value);
          }
        });
      }
      if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
        const keys = [key].concat(flags.aliases[key] || []);
        keys.forEach(function(key2) {
          Object.defineProperty(argvReturn, key2, {
            enumerable: true,
            get() {
              return val;
            },
            set(value2) {
              val = typeof value2 === "string" ? mixin2.normalize(value2) : value2;
            }
          });
        });
      }
    }
    function addNewAlias(key, alias) {
      if (!(flags.aliases[key] && flags.aliases[key].length)) {
        flags.aliases[key] = [alias];
        newAliases[alias] = true;
      }
      if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
        addNewAlias(alias, key);
      }
    }
    function processValue(key, val, shouldStripQuotes) {
      if (shouldStripQuotes) {
        val = stripQuotes(val);
      }
      if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
        if (typeof val === "string")
          val = val === "true";
      }
      let value = Array.isArray(val) ? val.map(function(v) {
        return maybeCoerceNumber(key, v);
      }) : maybeCoerceNumber(key, val);
      if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === "boolean")) {
        value = increment();
      }
      if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
        if (Array.isArray(val))
          value = val.map((val2) => {
            return mixin2.normalize(val2);
          });
        else
          value = mixin2.normalize(val);
      }
      return value;
    }
    function maybeCoerceNumber(key, value) {
      if (!configuration["parse-positional-numbers"] && key === "_")
        return value;
      if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
        const shouldCoerceNumber = looksLikeNumber(value) && configuration["parse-numbers"] && Number.isSafeInteger(Math.floor(parseFloat(`${value}`)));
        if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) {
          value = Number(value);
        }
      }
      return value;
    }
    function setConfig(argv2) {
      const configLookup = Object.create(null);
      applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
      Object.keys(flags.configs).forEach(function(configKey) {
        const configPath = argv2[configKey] || configLookup[configKey];
        if (configPath) {
          try {
            let config = null;
            const resolvedConfigPath = mixin2.resolve(mixin2.cwd(), configPath);
            const resolveConfig = flags.configs[configKey];
            if (typeof resolveConfig === "function") {
              try {
                config = resolveConfig(resolvedConfigPath);
              } catch (e) {
                config = e;
              }
              if (config instanceof Error) {
                error = config;
                return;
              }
            } else {
              config = mixin2.require(resolvedConfigPath);
            }
            setConfigObject(config);
          } catch (ex) {
            if (ex.name === "PermissionDenied")
              error = ex;
            else if (argv2[configKey])
              error = Error(__("Invalid JSON config file: %s", configPath));
          }
        }
      });
    }
    function setConfigObject(config, prev) {
      Object.keys(config).forEach(function(key) {
        const value = config[key];
        const fullKey = prev ? prev + "." + key : key;
        if (typeof value === "object" && value !== null && !Array.isArray(value) && configuration["dot-notation"]) {
          setConfigObject(value, fullKey);
        } else {
          if (!hasKey(argv, fullKey.split(".")) || checkAllAliases(fullKey, flags.arrays) && configuration["combine-arrays"]) {
            setArg(fullKey, value);
          }
        }
      });
    }
    function setConfigObjects() {
      if (typeof configObjects !== "undefined") {
        configObjects.forEach(function(configObject) {
          setConfigObject(configObject);
        });
      }
    }
    function applyEnvVars(argv2, configOnly) {
      if (typeof envPrefix === "undefined")
        return;
      const prefix = typeof envPrefix === "string" ? envPrefix : "";
      const env = mixin2.env();
      Object.keys(env).forEach(function(envVar) {
        if (prefix === "" || envVar.lastIndexOf(prefix, 0) === 0) {
          const keys = envVar.split("__").map(function(key, i) {
            if (i === 0) {
              key = key.substring(prefix.length);
            }
            return camelCase(key);
          });
          if ((configOnly && flags.configs[keys.join(".")] || !configOnly) && !hasKey(argv2, keys)) {
            setArg(keys.join("."), env[envVar]);
          }
        }
      });
    }
    function applyCoercions(argv2) {
      let coerce;
      const applied = new Set;
      Object.keys(argv2).forEach(function(key) {
        if (!applied.has(key)) {
          coerce = checkAllAliases(key, flags.coercions);
          if (typeof coerce === "function") {
            try {
              const value = maybeCoerceNumber(key, coerce(argv2[key]));
              [].concat(flags.aliases[key] || [], key).forEach((ali) => {
                applied.add(ali);
                argv2[ali] = value;
              });
            } catch (err) {
              error = err;
            }
          }
        }
      });
    }
    function setPlaceholderKeys(argv2) {
      flags.keys.forEach((key) => {
        if (~key.indexOf("."))
          return;
        if (typeof argv2[key] === "undefined")
          argv2[key] = undefined;
      });
      return argv2;
    }
    function applyDefaultsAndAliases(obj, aliases2, defaults2, canLog = false) {
      Object.keys(defaults2).forEach(function(key) {
        if (!hasKey(obj, key.split("."))) {
          setKey(obj, key.split("."), defaults2[key]);
          if (canLog)
            defaulted[key] = true;
          (aliases2[key] || []).forEach(function(x) {
            if (hasKey(obj, x.split(".")))
              return;
            setKey(obj, x.split("."), defaults2[key]);
          });
        }
      });
    }
    function hasKey(obj, keys) {
      let o = obj;
      if (!configuration["dot-notation"])
        keys = [keys.join(".")];
      keys.slice(0, -1).forEach(function(key2) {
        o = o[key2] || {};
      });
      const key = keys[keys.length - 1];
      if (typeof o !== "object")
        return false;
      else
        return key in o;
    }
    function setKey(obj, keys, value) {
      let o = obj;
      if (!configuration["dot-notation"])
        keys = [keys.join(".")];
      keys.slice(0, -1).forEach(function(key2) {
        key2 = sanitizeKey(key2);
        if (typeof o === "object" && o[key2] === undefined) {
          o[key2] = {};
        }
        if (typeof o[key2] !== "object" || Array.isArray(o[key2])) {
          if (Array.isArray(o[key2])) {
            o[key2].push({});
          } else {
            o[key2] = [o[key2], {}];
          }
          o = o[key2][o[key2].length - 1];
        } else {
          o = o[key2];
        }
      });
      const key = sanitizeKey(keys[keys.length - 1]);
      const isTypeArray = checkAllAliases(keys.join("."), flags.arrays);
      const isValueArray = Array.isArray(value);
      let duplicate = configuration["duplicate-arguments-array"];
      if (!duplicate && checkAllAliases(key, flags.nargs)) {
        duplicate = true;
        if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {
          o[key] = undefined;
        }
      }
      if (value === increment()) {
        o[key] = increment(o[key]);
      } else if (Array.isArray(o[key])) {
        if (duplicate && isTypeArray && isValueArray) {
          o[key] = configuration["flatten-duplicate-arrays"] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
        } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
          o[key] = value;
        } else {
          o[key] = o[key].concat([value]);
        }
      } else if (o[key] === undefined && isTypeArray) {
        o[key] = isValueArray ? value : [value];
      } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {
        o[key] = [o[key], value];
      } else {
        o[key] = value;
      }
    }
    function extendAliases(...args2) {
      args2.forEach(function(obj) {
        Object.keys(obj || {}).forEach(function(key) {
          if (flags.aliases[key])
            return;
          flags.aliases[key] = [].concat(aliases[key] || []);
          flags.aliases[key].concat(key).forEach(function(x) {
            if (/-/.test(x) && configuration["camel-case-expansion"]) {
              const c = camelCase(x);
              if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                flags.aliases[key].push(c);
                newAliases[c] = true;
              }
            }
          });
          flags.aliases[key].concat(key).forEach(function(x) {
            if (x.length > 1 && /[A-Z]/.test(x) && configuration["camel-case-expansion"]) {
              const c = decamelize(x, "-");
              if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                flags.aliases[key].push(c);
                newAliases[c] = true;
              }
            }
          });
          flags.aliases[key].forEach(function(x) {
            flags.aliases[x] = [key].concat(flags.aliases[key].filter(function(y) {
              return x !== y;
            }));
          });
        });
      });
    }
    function checkAllAliases(key, flag) {
      const toCheck = [].concat(flags.aliases[key] || [], key);
      const keys = Object.keys(flag);
      const setAlias = toCheck.find((key2) => keys.includes(key2));
      return setAlias ? flag[setAlias] : false;
    }
    function hasAnyFlag(key) {
      const flagsKeys = Object.keys(flags);
      const toCheck = [].concat(flagsKeys.map((k) => flags[k]));
      return toCheck.some(function(flag) {
        return Array.isArray(flag) ? flag.includes(key) : flag[key];
      });
    }
    function hasFlagsMatching(arg, ...patterns) {
      const toCheck = [].concat(...patterns);
      return toCheck.some(function(pattern) {
        const match = arg.match(pattern);
        return match && hasAnyFlag(match[1]);
      });
    }
    function hasAllShortFlags(arg) {
      if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
        return false;
      }
      let hasAllFlags = true;
      let next;
      const letters = arg.slice(1).split("");
      for (let j = 0;j < letters.length; j++) {
        next = arg.slice(j + 2);
        if (!hasAnyFlag(letters[j])) {
          hasAllFlags = false;
          break;
        }
        if (letters[j + 1] && letters[j + 1] === "=" || next === "-" || /[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\W/)) {
          break;
        }
      }
      return hasAllFlags;
    }
    function isUnknownOptionAsArg(arg) {
      return configuration["unknown-options-as-args"] && isUnknownOption(arg);
    }
    function isUnknownOption(arg) {
      arg = arg.replace(/^-{3,}/, "--");
      if (arg.match(negative)) {
        return false;
      }
      if (hasAllShortFlags(arg)) {
        return false;
      }
      const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
      const normalFlag = /^-+([^=]+?)$/;
      const flagEndingInHyphen = /^-+([^=]+?)-$/;
      const flagEndingInDigits = /^-+([^=]+?\d+)$/;
      const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
      return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
    }
    function defaultValue(key) {
      if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {
        return defaults[key];
      } else {
        return defaultForType(guessType(key));
      }
    }
    function defaultForType(type) {
      const def = {
        [DefaultValuesForTypeKey.BOOLEAN]: true,
        [DefaultValuesForTypeKey.STRING]: "",
        [DefaultValuesForTypeKey.NUMBER]: undefined,
        [DefaultValuesForTypeKey.ARRAY]: []
      };
      return def[type];
    }
    function guessType(key) {
      let type = DefaultValuesForTypeKey.BOOLEAN;
      if (checkAllAliases(key, flags.strings))
        type = DefaultValuesForTypeKey.STRING;
      else if (checkAllAliases(key, flags.numbers))
        type = DefaultValuesForTypeKey.NUMBER;
      else if (checkAllAliases(key, flags.bools))
        type = DefaultValuesForTypeKey.BOOLEAN;
      else if (checkAllAliases(key, flags.arrays))
        type = DefaultValuesForTypeKey.ARRAY;
      return type;
    }
    function isUndefined(num) {
      return num === undefined;
    }
    function checkConfiguration() {
      Object.keys(flags.counts).find((key) => {
        if (checkAllAliases(key, flags.arrays)) {
          error = Error(__("Invalid configuration: %s, opts.count excludes opts.array.", key));
          return true;
        } else if (checkAllAliases(key, flags.nargs)) {
          error = Error(__("Invalid configuration: %s, opts.count excludes opts.narg.", key));
          return true;
        }
        return false;
      });
    }
    return {
      aliases: Object.assign({}, flags.aliases),
      argv: Object.assign(argvReturn, argv),
      configuration,
      defaulted: Object.assign({}, defaulted),
      error,
      newAliases: Object.assign({}, newAliases)
    };
  }
}

// /home/mous/work/pimlico/alto/node_modules/.pnpm/yargs@17.7.2/node_modules/yargs-parser/build/lib/index.js
import {readFileSync} from "fs";
var _a;
var _b;
var _c;
var minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;
var nodeVersion = (_b = (_a = process === null || process === undefined ? undefined : process.versions) === null || _a === undefined ? undefined : _a.node) !== null && _b !== undefined ? _b : (_c = process === null || process === undefined ? undefined : process.version) === null || _c === undefined ? undefined : _c.slice(1);
if (nodeVersion) {
  const major = Number(nodeVersion.match(/^([^.]+)/)[1]);
  if (major < minNodeVersion) {
    throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
  }
}
var env = process ? process.env : {};
var parser = new YargsParser({
  cwd: process.cwd,
  env: () => {
    return env;
  },
  format,
  normalize,
  resolve: resolve2,
  require: (path) => {
    if (typeof __require !== "undefined") {
      return __require(path);
    } else if (path.match(/\.json$/)) {
      return JSON.parse(readFileSync(path, "utf8"));
    } else {
      throw Error("only .json config files are supported in ESM");
    }
  }
});
var yargsParser = function Parser(args, opts) {
  const result = parser.parse(args.slice(), opts);
  return result.argv;
};
yargsParser.detailed = function(args, opts) {
  return parser.parse(args.slice(), opts);
};
yargsParser.camelCase = camelCase;
yargsParser.decamelize = decamelize;
yargsParser.looksLikeNumber = looksLikeNumber;
var lib_default = yargsParser;

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/lib/platform-shims/esm.mjs
import {basename, dirname as dirname2, extname, relative, resolve as resolve4} from "path";

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/utils/process-argv.js
var getProcessArgvBinIndex = function() {
  if (isBundledElectronApp())
    return 0;
  return 1;
};
var isBundledElectronApp = function() {
  return isElectronApp() && !process.defaultApp;
};
var isElectronApp = function() {
  return !!process.versions.electron;
};
function hideBin(argv) {
  return argv.slice(getProcessArgvBinIndex() + 1);
}
function getProcessArgvBin() {
  return process.argv[getProcessArgvBinIndex()];
}

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/yerror.js
class YError extends Error {
  constructor(msg) {
    super(msg || "yargs error");
    this.name = "YError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, YError);
    }
  }
}

// ../node_modules/.pnpm/y18n@5.0.8/node_modules/y18n/build/lib/platform-shims/node.js
import {readFileSync as readFileSync2, statSync as statSync2, writeFile} from "fs";
import {format as format2} from "util";
import {resolve as resolve3} from "path";
var node_default = {
  fs: {
    readFileSync: readFileSync2,
    writeFile
  },
  format: format2,
  resolve: resolve3,
  exists: (file) => {
    try {
      return statSync2(file).isFile();
    } catch (err) {
      return false;
    }
  }
};

// ../node_modules/.pnpm/y18n@5.0.8/node_modules/y18n/build/lib/index.js
function y18n(opts, _shim) {
  shim = _shim;
  const y18n2 = new Y18N(opts);
  return {
    __: y18n2.__.bind(y18n2),
    __n: y18n2.__n.bind(y18n2),
    setLocale: y18n2.setLocale.bind(y18n2),
    getLocale: y18n2.getLocale.bind(y18n2),
    updateLocale: y18n2.updateLocale.bind(y18n2),
    locale: y18n2.locale
  };
}
var shim;

class Y18N {
  constructor(opts) {
    opts = opts || {};
    this.directory = opts.directory || "./locales";
    this.updateFiles = typeof opts.updateFiles === "boolean" ? opts.updateFiles : true;
    this.locale = opts.locale || "en";
    this.fallbackToLanguage = typeof opts.fallbackToLanguage === "boolean" ? opts.fallbackToLanguage : true;
    this.cache = Object.create(null);
    this.writeQueue = [];
  }
  __(...args) {
    if (typeof arguments[0] !== "string") {
      return this._taggedLiteral(arguments[0], ...arguments);
    }
    const str = args.shift();
    let cb = function() {
    };
    if (typeof args[args.length - 1] === "function")
      cb = args.pop();
    cb = cb || function() {
    };
    if (!this.cache[this.locale])
      this._readLocaleFile();
    if (!this.cache[this.locale][str] && this.updateFiles) {
      this.cache[this.locale][str] = str;
      this._enqueueWrite({
        directory: this.directory,
        locale: this.locale,
        cb
      });
    } else {
      cb();
    }
    return shim.format.apply(shim.format, [this.cache[this.locale][str] || str].concat(args));
  }
  __n() {
    const args = Array.prototype.slice.call(arguments);
    const singular = args.shift();
    const plural = args.shift();
    const quantity = args.shift();
    let cb = function() {
    };
    if (typeof args[args.length - 1] === "function")
      cb = args.pop();
    if (!this.cache[this.locale])
      this._readLocaleFile();
    let str = quantity === 1 ? singular : plural;
    if (this.cache[this.locale][singular]) {
      const entry = this.cache[this.locale][singular];
      str = entry[quantity === 1 ? "one" : "other"];
    }
    if (!this.cache[this.locale][singular] && this.updateFiles) {
      this.cache[this.locale][singular] = {
        one: singular,
        other: plural
      };
      this._enqueueWrite({
        directory: this.directory,
        locale: this.locale,
        cb
      });
    } else {
      cb();
    }
    const values = [str];
    if (~str.indexOf("%d"))
      values.push(quantity);
    return shim.format.apply(shim.format, values.concat(args));
  }
  setLocale(locale) {
    this.locale = locale;
  }
  getLocale() {
    return this.locale;
  }
  updateLocale(obj) {
    if (!this.cache[this.locale])
      this._readLocaleFile();
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        this.cache[this.locale][key] = obj[key];
      }
    }
  }
  _taggedLiteral(parts, ...args) {
    let str = "";
    parts.forEach(function(part, i) {
      const arg = args[i + 1];
      str += part;
      if (typeof arg !== "undefined") {
        str += "%s";
      }
    });
    return this.__.apply(this, [str].concat([].slice.call(args, 1)));
  }
  _enqueueWrite(work) {
    this.writeQueue.push(work);
    if (this.writeQueue.length === 1)
      this._processWriteQueue();
  }
  _processWriteQueue() {
    const _this = this;
    const work = this.writeQueue[0];
    const directory = work.directory;
    const locale = work.locale;
    const cb = work.cb;
    const languageFile = this._resolveLocaleFile(directory, locale);
    const serializedLocale = JSON.stringify(this.cache[locale], null, 2);
    shim.fs.writeFile(languageFile, serializedLocale, "utf-8", function(err) {
      _this.writeQueue.shift();
      if (_this.writeQueue.length > 0)
        _this._processWriteQueue();
      cb(err);
    });
  }
  _readLocaleFile() {
    let localeLookup = {};
    const languageFile = this._resolveLocaleFile(this.directory, this.locale);
    try {
      if (shim.fs.readFileSync) {
        localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, "utf-8"));
      }
    } catch (err) {
      if (err instanceof SyntaxError) {
        err.message = "syntax error in " + languageFile;
      }
      if (err.code === "ENOENT")
        localeLookup = {};
      else
        throw err;
    }
    this.cache[this.locale] = localeLookup;
  }
  _resolveLocaleFile(directory, locale) {
    let file = shim.resolve(directory, "./", locale + ".json");
    if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf("_")) {
      const languageFile = shim.resolve(directory, "./", locale.split("_")[0] + ".json");
      if (this._fileExistsSync(languageFile))
        file = languageFile;
    }
    return file;
  }
  _fileExistsSync(file) {
    return shim.exists(file);
  }
}

// /home/mous/work/pimlico/alto/node_modules/.pnpm/yargs@17.7.2/node_modules/y18n/index.mjs
var y18n2 = (opts) => {
  return y18n(opts, node_default);
};
var y18n_default = y18n2;

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/lib/platform-shims/esm.mjs
var REQUIRE_ERROR = "require is not supported by ESM";
var REQUIRE_DIRECTORY_ERROR = "loading a directory of commands is not supported yet for ESM";
var __dirname2;
try {
  __dirname2 = fileURLToPath(import.meta.url);
} catch (e) {
  __dirname2 = process.cwd();
}
var mainFilename = __dirname2.substring(0, __dirname2.lastIndexOf("node_modules"));
var esm_default = {
  assert: {
    notStrictEqual,
    strictEqual
  },
  cliui: ui,
  findUp: sync_default,
  getEnv: (key) => {
    return process.env[key];
  },
  inspect,
  getCallerFile: () => {
    throw new YError(REQUIRE_DIRECTORY_ERROR);
  },
  getProcessArgvBin,
  mainFilename: mainFilename || process.cwd(),
  Parser: lib_default,
  path: {
    basename,
    dirname: dirname2,
    extname,
    relative,
    resolve: resolve4
  },
  process: {
    argv: () => process.argv,
    cwd: process.cwd,
    emitWarning: (warning, type) => process.emitWarning(warning, type),
    execPath: () => process.execPath,
    exit: process.exit,
    nextTick: process.nextTick,
    stdColumns: typeof process.stdout.columns !== "undefined" ? process.stdout.columns : null
  },
  readFileSync: readFileSync3,
  require: () => {
    throw new YError(REQUIRE_ERROR);
  },
  requireDirectory: () => {
    throw new YError(REQUIRE_DIRECTORY_ERROR);
  },
  stringWidth: (str) => {
    return [...str].length;
  },
  y18n: y18n_default({
    directory: resolve4(__dirname2, "../../../locales"),
    updateFiles: false
  })
};

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/typings/common-types.js
function assertNotStrictEqual(actual, expected, shim2, message) {
  shim2.assert.notStrictEqual(actual, expected, message);
}
function assertSingleKey(actual, shim2) {
  shim2.assert.strictEqual(typeof actual, "string");
}
function objectKeys(object) {
  return Object.keys(object);
}

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/utils/is-promise.js
function isPromise(maybePromise) {
  return !!maybePromise && !!maybePromise.then && typeof maybePromise.then === "function";
}

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/parse-command.js
function parseCommand(cmd) {
  const extraSpacesStrippedCommand = cmd.replace(/\s{2,}/g, " ");
  const splitCommand = extraSpacesStrippedCommand.split(/\s+(?![^[]*]|[^<]*>)/);
  const bregex = /\.*[\][<>]/g;
  const firstCommand = splitCommand.shift();
  if (!firstCommand)
    throw new Error(`No command found in: ${cmd}`);
  const parsedCommand = {
    cmd: firstCommand.replace(bregex, ""),
    demanded: [],
    optional: []
  };
  splitCommand.forEach((cmd2, i) => {
    let variadic = false;
    cmd2 = cmd2.replace(/\s/g, "");
    if (/\.+[\]>]/.test(cmd2) && i === splitCommand.length - 1)
      variadic = true;
    if (/^\[/.test(cmd2)) {
      parsedCommand.optional.push({
        cmd: cmd2.replace(bregex, "").split("|"),
        variadic
      });
    } else {
      parsedCommand.demanded.push({
        cmd: cmd2.replace(bregex, "").split("|"),
        variadic
      });
    }
  });
  return parsedCommand;
}

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/argsert.js
function argsert(arg1, arg2, arg3) {
  function parseArgs() {
    return typeof arg1 === "object" ? [{ demanded: [], optional: [] }, arg1, arg2] : [
      parseCommand(`cmd ${arg1}`),
      arg2,
      arg3
    ];
  }
  try {
    let position = 0;
    const [parsed, callerArguments, _length] = parseArgs();
    const args = [].slice.call(callerArguments);
    while (args.length && args[args.length - 1] === undefined)
      args.pop();
    const length = _length || args.length;
    if (length < parsed.demanded.length) {
      throw new YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);
    }
    const totalCommands = parsed.demanded.length + parsed.optional.length;
    if (length > totalCommands) {
      throw new YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);
    }
    parsed.demanded.forEach((demanded) => {
      const arg = args.shift();
      const observedType = guessType(arg);
      const matchingTypes = demanded.cmd.filter((type) => type === observedType || type === "*");
      if (matchingTypes.length === 0)
        argumentTypeError(observedType, demanded.cmd, position);
      position += 1;
    });
    parsed.optional.forEach((optional) => {
      if (args.length === 0)
        return;
      const arg = args.shift();
      const observedType = guessType(arg);
      const matchingTypes = optional.cmd.filter((type) => type === observedType || type === "*");
      if (matchingTypes.length === 0)
        argumentTypeError(observedType, optional.cmd, position);
      position += 1;
    });
  } catch (err) {
    console.warn(err.stack);
  }
}
var guessType = function(arg) {
  if (Array.isArray(arg)) {
    return "array";
  } else if (arg === null) {
    return "null";
  }
  return typeof arg;
};
var argumentTypeError = function(observedType, allowedTypes, position) {
  throw new YError(`Invalid ${positionName[position] || "manyith"} argument. Expected ${allowedTypes.join(" or ")} but received ${observedType}.`);
};
var positionName = ["first", "second", "third", "fourth", "fifth", "sixth"];

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/middleware.js
function commandMiddlewareFactory(commandMiddleware) {
  if (!commandMiddleware)
    return [];
  return commandMiddleware.map((middleware) => {
    middleware.applyBeforeValidation = false;
    return middleware;
  });
}
function applyMiddleware(argv, yargs, middlewares, beforeValidation) {
  return middlewares.reduce((acc, middleware) => {
    if (middleware.applyBeforeValidation !== beforeValidation) {
      return acc;
    }
    if (middleware.mutates) {
      if (middleware.applied)
        return acc;
      middleware.applied = true;
    }
    if (isPromise(acc)) {
      return acc.then((initialObj) => Promise.all([initialObj, middleware(initialObj, yargs)])).then(([initialObj, middlewareObj]) => Object.assign(initialObj, middlewareObj));
    } else {
      const result = middleware(acc, yargs);
      return isPromise(result) ? result.then((middlewareObj) => Object.assign(acc, middlewareObj)) : Object.assign(acc, result);
    }
  }, argv);
}

class GlobalMiddleware {
  constructor(yargs) {
    this.globalMiddleware = [];
    this.frozens = [];
    this.yargs = yargs;
  }
  addMiddleware(callback, applyBeforeValidation, global2 = true, mutates = false) {
    argsert("<array|function> [boolean] [boolean] [boolean]", [callback, applyBeforeValidation, global2], arguments.length);
    if (Array.isArray(callback)) {
      for (let i = 0;i < callback.length; i++) {
        if (typeof callback[i] !== "function") {
          throw Error("middleware must be a function");
        }
        const m = callback[i];
        m.applyBeforeValidation = applyBeforeValidation;
        m.global = global2;
      }
      Array.prototype.push.apply(this.globalMiddleware, callback);
    } else if (typeof callback === "function") {
      const m = callback;
      m.applyBeforeValidation = applyBeforeValidation;
      m.global = global2;
      m.mutates = mutates;
      this.globalMiddleware.push(callback);
    }
    return this.yargs;
  }
  addCoerceMiddleware(callback, option) {
    const aliases = this.yargs.getAliases();
    this.globalMiddleware = this.globalMiddleware.filter((m) => {
      const toCheck = [...aliases[option] || [], option];
      if (!m.option)
        return true;
      else
        return !toCheck.includes(m.option);
    });
    callback.option = option;
    return this.addMiddleware(callback, true, true, true);
  }
  getMiddleware() {
    return this.globalMiddleware;
  }
  freeze() {
    this.frozens.push([...this.globalMiddleware]);
  }
  unfreeze() {
    const frozen = this.frozens.pop();
    if (frozen !== undefined)
      this.globalMiddleware = frozen;
  }
  reset() {
    this.globalMiddleware = this.globalMiddleware.filter((m) => m.global);
  }
}

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/utils/maybe-async-result.js
function maybeAsyncResult(getResult, resultHandler, errorHandler = (err) => {
  throw err;
}) {
  try {
    const result = isFunction(getResult) ? getResult() : getResult;
    return isPromise(result) ? result.then((result2) => resultHandler(result2)) : resultHandler(result);
  } catch (err) {
    return errorHandler(err);
  }
}
var isFunction = function(arg) {
  return typeof arg === "function";
};

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/utils/which-module.js
function whichModule(exported) {
  if (typeof __require === "undefined")
    return null;
  for (let i = 0, files = Object.keys(__require.cache), mod;i < files.length; i++) {
    mod = __require.cache[files[i]];
    if (mod.exports === exported)
      return mod;
  }
  return null;
}

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/command.js
function command(usage, validation, globalMiddleware, shim2) {
  return new CommandInstance(usage, validation, globalMiddleware, shim2);
}
function isCommandBuilderDefinition(builder) {
  return typeof builder === "object" && !!builder.builder && typeof builder.handler === "function";
}
var isCommandAndAliases = function(cmd) {
  return cmd.every((c) => typeof c === "string");
};
function isCommandBuilderCallback(builder) {
  return typeof builder === "function";
}
var isCommandBuilderOptionDefinitions = function(builder) {
  return typeof builder === "object";
};
function isCommandHandlerDefinition(cmd) {
  return typeof cmd === "object" && !Array.isArray(cmd);
}
var DEFAULT_MARKER = /(^\*)|(^\$0)/;

class CommandInstance {
  constructor(usage, validation, globalMiddleware, shim2) {
    this.requireCache = new Set;
    this.handlers = {};
    this.aliasMap = {};
    this.frozens = [];
    this.shim = shim2;
    this.usage = usage;
    this.globalMiddleware = globalMiddleware;
    this.validation = validation;
  }
  addDirectory(dir, req, callerFile, opts) {
    opts = opts || {};
    if (typeof opts.recurse !== "boolean")
      opts.recurse = false;
    if (!Array.isArray(opts.extensions))
      opts.extensions = ["js"];
    const parentVisit = typeof opts.visit === "function" ? opts.visit : (o) => o;
    opts.visit = (obj, joined, filename) => {
      const visited = parentVisit(obj, joined, filename);
      if (visited) {
        if (this.requireCache.has(joined))
          return visited;
        else
          this.requireCache.add(joined);
        this.addHandler(visited);
      }
      return visited;
    };
    this.shim.requireDirectory({ require: req, filename: callerFile }, dir, opts);
  }
  addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {
    let aliases = [];
    const middlewares = commandMiddlewareFactory(commandMiddleware);
    handler = handler || (() => {
    });
    if (Array.isArray(cmd)) {
      if (isCommandAndAliases(cmd)) {
        [cmd, ...aliases] = cmd;
      } else {
        for (const command2 of cmd) {
          this.addHandler(command2);
        }
      }
    } else if (isCommandHandlerDefinition(cmd)) {
      let command2 = Array.isArray(cmd.command) || typeof cmd.command === "string" ? cmd.command : this.moduleName(cmd);
      if (cmd.aliases)
        command2 = [].concat(command2).concat(cmd.aliases);
      this.addHandler(command2, this.extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);
      return;
    } else if (isCommandBuilderDefinition(builder)) {
      this.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);
      return;
    }
    if (typeof cmd === "string") {
      const parsedCommand = parseCommand(cmd);
      aliases = aliases.map((alias) => parseCommand(alias).cmd);
      let isDefault = false;
      const parsedAliases = [parsedCommand.cmd].concat(aliases).filter((c) => {
        if (DEFAULT_MARKER.test(c)) {
          isDefault = true;
          return false;
        }
        return true;
      });
      if (parsedAliases.length === 0 && isDefault)
        parsedAliases.push("$0");
      if (isDefault) {
        parsedCommand.cmd = parsedAliases[0];
        aliases = parsedAliases.slice(1);
        cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);
      }
      aliases.forEach((alias) => {
        this.aliasMap[alias] = parsedCommand.cmd;
      });
      if (description !== false) {
        this.usage.command(cmd, description, isDefault, aliases, deprecated);
      }
      this.handlers[parsedCommand.cmd] = {
        original: cmd,
        description,
        handler,
        builder: builder || {},
        middlewares,
        deprecated,
        demanded: parsedCommand.demanded,
        optional: parsedCommand.optional
      };
      if (isDefault)
        this.defaultCommand = this.handlers[parsedCommand.cmd];
    }
  }
  getCommandHandlers() {
    return this.handlers;
  }
  getCommands() {
    return Object.keys(this.handlers).concat(Object.keys(this.aliasMap));
  }
  hasDefaultCommand() {
    return !!this.defaultCommand;
  }
  runCommand(command2, yargs, parsed, commandIndex, helpOnly, helpOrVersionSet) {
    const commandHandler = this.handlers[command2] || this.handlers[this.aliasMap[command2]] || this.defaultCommand;
    const currentContext = yargs.getInternalMethods().getContext();
    const parentCommands = currentContext.commands.slice();
    const isDefaultCommand = !command2;
    if (command2) {
      currentContext.commands.push(command2);
      currentContext.fullCommands.push(commandHandler.original);
    }
    const builderResult = this.applyBuilderUpdateUsageAndParse(isDefaultCommand, commandHandler, yargs, parsed.aliases, parentCommands, commandIndex, helpOnly, helpOrVersionSet);
    return isPromise(builderResult) ? builderResult.then((result) => this.applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, result.innerArgv, currentContext, helpOnly, result.aliases, yargs)) : this.applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, builderResult.innerArgv, currentContext, helpOnly, builderResult.aliases, yargs);
  }
  applyBuilderUpdateUsageAndParse(isDefaultCommand, commandHandler, yargs, aliases, parentCommands, commandIndex, helpOnly, helpOrVersionSet) {
    const builder = commandHandler.builder;
    let innerYargs = yargs;
    if (isCommandBuilderCallback(builder)) {
      yargs.getInternalMethods().getUsageInstance().freeze();
      const builderOutput = builder(yargs.getInternalMethods().reset(aliases), helpOrVersionSet);
      if (isPromise(builderOutput)) {
        return builderOutput.then((output) => {
          innerYargs = isYargsInstance(output) ? output : yargs;
          return this.parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly);
        });
      }
    } else if (isCommandBuilderOptionDefinitions(builder)) {
      yargs.getInternalMethods().getUsageInstance().freeze();
      innerYargs = yargs.getInternalMethods().reset(aliases);
      Object.keys(commandHandler.builder).forEach((key) => {
        innerYargs.option(key, builder[key]);
      });
    }
    return this.parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly);
  }
  parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly) {
    if (isDefaultCommand)
      innerYargs.getInternalMethods().getUsageInstance().unfreeze(true);
    if (this.shouldUpdateUsage(innerYargs)) {
      innerYargs.getInternalMethods().getUsageInstance().usage(this.usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
    }
    const innerArgv = innerYargs.getInternalMethods().runYargsParserAndExecuteCommands(null, undefined, true, commandIndex, helpOnly);
    return isPromise(innerArgv) ? innerArgv.then((argv) => ({
      aliases: innerYargs.parsed.aliases,
      innerArgv: argv
    })) : {
      aliases: innerYargs.parsed.aliases,
      innerArgv
    };
  }
  shouldUpdateUsage(yargs) {
    return !yargs.getInternalMethods().getUsageInstance().getUsageDisabled() && yargs.getInternalMethods().getUsageInstance().getUsage().length === 0;
  }
  usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {
    const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, "").trim() : commandHandler.original;
    const pc = parentCommands.filter((c2) => {
      return !DEFAULT_MARKER.test(c2);
    });
    pc.push(c);
    return `\$0 ${pc.join(" ")}`;
  }
  handleValidationAndGetResult(isDefaultCommand, commandHandler, innerArgv, currentContext, aliases, yargs, middlewares, positionalMap) {
    if (!yargs.getInternalMethods().getHasOutput()) {
      const validation = yargs.getInternalMethods().runValidation(aliases, positionalMap, yargs.parsed.error, isDefaultCommand);
      innerArgv = maybeAsyncResult(innerArgv, (result) => {
        validation(result);
        return result;
      });
    }
    if (commandHandler.handler && !yargs.getInternalMethods().getHasOutput()) {
      yargs.getInternalMethods().setHasOutput();
      const populateDoubleDash = !!yargs.getOptions().configuration["populate--"];
      yargs.getInternalMethods().postProcess(innerArgv, populateDoubleDash, false, false);
      innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false);
      innerArgv = maybeAsyncResult(innerArgv, (result) => {
        const handlerResult = commandHandler.handler(result);
        return isPromise(handlerResult) ? handlerResult.then(() => result) : result;
      });
      if (!isDefaultCommand) {
        yargs.getInternalMethods().getUsageInstance().cacheHelpMessage();
      }
      if (isPromise(innerArgv) && !yargs.getInternalMethods().hasParseCallback()) {
        innerArgv.catch((error) => {
          try {
            yargs.getInternalMethods().getUsageInstance().fail(null, error);
          } catch (_err) {
          }
        });
      }
    }
    if (!isDefaultCommand) {
      currentContext.commands.pop();
      currentContext.fullCommands.pop();
    }
    return innerArgv;
  }
  applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, innerArgv, currentContext, helpOnly, aliases, yargs) {
    let positionalMap = {};
    if (helpOnly)
      return innerArgv;
    if (!yargs.getInternalMethods().getHasOutput()) {
      positionalMap = this.populatePositionals(commandHandler, innerArgv, currentContext, yargs);
    }
    const middlewares = this.globalMiddleware.getMiddleware().slice(0).concat(commandHandler.middlewares);
    const maybePromiseArgv = applyMiddleware(innerArgv, yargs, middlewares, true);
    return isPromise(maybePromiseArgv) ? maybePromiseArgv.then((resolvedInnerArgv) => this.handleValidationAndGetResult(isDefaultCommand, commandHandler, resolvedInnerArgv, currentContext, aliases, yargs, middlewares, positionalMap)) : this.handleValidationAndGetResult(isDefaultCommand, commandHandler, maybePromiseArgv, currentContext, aliases, yargs, middlewares, positionalMap);
  }
  populatePositionals(commandHandler, argv, context, yargs) {
    argv._ = argv._.slice(context.commands.length);
    const demanded = commandHandler.demanded.slice(0);
    const optional = commandHandler.optional.slice(0);
    const positionalMap = {};
    this.validation.positionalCount(demanded.length, argv._.length);
    while (demanded.length) {
      const demand = demanded.shift();
      this.populatePositional(demand, argv, positionalMap);
    }
    while (optional.length) {
      const maybe = optional.shift();
      this.populatePositional(maybe, argv, positionalMap);
    }
    argv._ = context.commands.concat(argv._.map((a) => "" + a));
    this.postProcessPositionals(argv, positionalMap, this.cmdToParseOptions(commandHandler.original), yargs);
    return positionalMap;
  }
  populatePositional(positional, argv, positionalMap) {
    const cmd = positional.cmd[0];
    if (positional.variadic) {
      positionalMap[cmd] = argv._.splice(0).map(String);
    } else {
      if (argv._.length)
        positionalMap[cmd] = [String(argv._.shift())];
    }
  }
  cmdToParseOptions(cmdString) {
    const parseOptions = {
      array: [],
      default: {},
      alias: {},
      demand: {}
    };
    const parsed = parseCommand(cmdString);
    parsed.demanded.forEach((d) => {
      const [cmd, ...aliases] = d.cmd;
      if (d.variadic) {
        parseOptions.array.push(cmd);
        parseOptions.default[cmd] = [];
      }
      parseOptions.alias[cmd] = aliases;
      parseOptions.demand[cmd] = true;
    });
    parsed.optional.forEach((o) => {
      const [cmd, ...aliases] = o.cmd;
      if (o.variadic) {
        parseOptions.array.push(cmd);
        parseOptions.default[cmd] = [];
      }
      parseOptions.alias[cmd] = aliases;
    });
    return parseOptions;
  }
  postProcessPositionals(argv, positionalMap, parseOptions, yargs) {
    const options = Object.assign({}, yargs.getOptions());
    options.default = Object.assign(parseOptions.default, options.default);
    for (const key of Object.keys(parseOptions.alias)) {
      options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);
    }
    options.array = options.array.concat(parseOptions.array);
    options.config = {};
    const unparsed = [];
    Object.keys(positionalMap).forEach((key) => {
      positionalMap[key].map((value) => {
        if (options.configuration["unknown-options-as-args"])
          options.key[key] = true;
        unparsed.push(`--${key}`);
        unparsed.push(value);
      });
    });
    if (!unparsed.length)
      return;
    const config = Object.assign({}, options.configuration, {
      "populate--": false
    });
    const parsed = this.shim.Parser.detailed(unparsed, Object.assign({}, options, {
      configuration: config
    }));
    if (parsed.error) {
      yargs.getInternalMethods().getUsageInstance().fail(parsed.error.message, parsed.error);
    } else {
      const positionalKeys = Object.keys(positionalMap);
      Object.keys(positionalMap).forEach((key) => {
        positionalKeys.push(...parsed.aliases[key]);
      });
      Object.keys(parsed.argv).forEach((key) => {
        if (positionalKeys.includes(key)) {
          if (!positionalMap[key])
            positionalMap[key] = parsed.argv[key];
          if (!this.isInConfigs(yargs, key) && !this.isDefaulted(yargs, key) && Object.prototype.hasOwnProperty.call(argv, key) && Object.prototype.hasOwnProperty.call(parsed.argv, key) && (Array.isArray(argv[key]) || Array.isArray(parsed.argv[key]))) {
            argv[key] = [].concat(argv[key], parsed.argv[key]);
          } else {
            argv[key] = parsed.argv[key];
          }
        }
      });
    }
  }
  isDefaulted(yargs, key) {
    const { default: defaults } = yargs.getOptions();
    return Object.prototype.hasOwnProperty.call(defaults, key) || Object.prototype.hasOwnProperty.call(defaults, this.shim.Parser.camelCase(key));
  }
  isInConfigs(yargs, key) {
    const { configObjects } = yargs.getOptions();
    return configObjects.some((c) => Object.prototype.hasOwnProperty.call(c, key)) || configObjects.some((c) => Object.prototype.hasOwnProperty.call(c, this.shim.Parser.camelCase(key)));
  }
  runDefaultBuilderOn(yargs) {
    if (!this.defaultCommand)
      return;
    if (this.shouldUpdateUsage(yargs)) {
      const commandString = DEFAULT_MARKER.test(this.defaultCommand.original) ? this.defaultCommand.original : this.defaultCommand.original.replace(/^[^[\]<>]*/, "$0 ");
      yargs.getInternalMethods().getUsageInstance().usage(commandString, this.defaultCommand.description);
    }
    const builder = this.defaultCommand.builder;
    if (isCommandBuilderCallback(builder)) {
      return builder(yargs, true);
    } else if (!isCommandBuilderDefinition(builder)) {
      Object.keys(builder).forEach((key) => {
        yargs.option(key, builder[key]);
      });
    }
    return;
  }
  moduleName(obj) {
    const mod = whichModule(obj);
    if (!mod)
      throw new Error(`No command name given for module: ${this.shim.inspect(obj)}`);
    return this.commandFromFilename(mod.filename);
  }
  commandFromFilename(filename) {
    return this.shim.path.basename(filename, this.shim.path.extname(filename));
  }
  extractDesc({ describe, description, desc }) {
    for (const test of [describe, description, desc]) {
      if (typeof test === "string" || test === false)
        return test;
      assertNotStrictEqual(test, true, this.shim);
    }
    return false;
  }
  freeze() {
    this.frozens.push({
      handlers: this.handlers,
      aliasMap: this.aliasMap,
      defaultCommand: this.defaultCommand
    });
  }
  unfreeze() {
    const frozen = this.frozens.pop();
    assertNotStrictEqual(frozen, undefined, this.shim);
    ({
      handlers: this.handlers,
      aliasMap: this.aliasMap,
      defaultCommand: this.defaultCommand
    } = frozen);
  }
  reset() {
    this.handlers = {};
    this.aliasMap = {};
    this.defaultCommand = undefined;
    this.requireCache = new Set;
    return this;
  }
}

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/utils/obj-filter.js
function objFilter(original = {}, filter = () => true) {
  const obj = {};
  objectKeys(original).forEach((key) => {
    if (filter(key, original[key])) {
      obj[key] = original[key];
    }
  });
  return obj;
}

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/utils/set-blocking.js
function setBlocking(blocking) {
  if (typeof process === "undefined")
    return;
  [process.stdout, process.stderr].forEach((_stream) => {
    const stream = _stream;
    if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === "function") {
      stream._handle.setBlocking(blocking);
    }
  });
}

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/usage.js
var isBoolean = function(fail) {
  return typeof fail === "boolean";
};
function usage(yargs, shim2) {
  const __ = shim2.y18n.__;
  const self2 = {};
  const fails = [];
  self2.failFn = function failFn(f) {
    fails.push(f);
  };
  let failMessage = null;
  let globalFailMessage = null;
  let showHelpOnFail = true;
  self2.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) {
    const [enabled, message] = typeof arg1 === "string" ? [true, arg1] : [arg1, arg2];
    if (yargs.getInternalMethods().isGlobalContext()) {
      globalFailMessage = message;
    }
    failMessage = message;
    showHelpOnFail = enabled;
    return self2;
  };
  let failureOutput = false;
  self2.fail = function fail(msg, err) {
    const logger = yargs.getInternalMethods().getLoggerInstance();
    if (fails.length) {
      for (let i = fails.length - 1;i >= 0; --i) {
        const fail = fails[i];
        if (isBoolean(fail)) {
          if (err)
            throw err;
          else if (msg)
            throw Error(msg);
        } else {
          fail(msg, err, self2);
        }
      }
    } else {
      if (yargs.getExitProcess())
        setBlocking(true);
      if (!failureOutput) {
        failureOutput = true;
        if (showHelpOnFail) {
          yargs.showHelp("error");
          logger.error();
        }
        if (msg || err)
          logger.error(msg || err);
        const globalOrCommandFailMessage = failMessage || globalFailMessage;
        if (globalOrCommandFailMessage) {
          if (msg || err)
            logger.error("");
          logger.error(globalOrCommandFailMessage);
        }
      }
      err = err || new YError(msg);
      if (yargs.getExitProcess()) {
        return yargs.exit(1);
      } else if (yargs.getInternalMethods().hasParseCallback()) {
        return yargs.exit(1, err);
      } else {
        throw err;
      }
    }
  };
  let usages = [];
  let usageDisabled = false;
  self2.usage = (msg, description) => {
    if (msg === null) {
      usageDisabled = true;
      usages = [];
      return self2;
    }
    usageDisabled = false;
    usages.push([msg, description || ""]);
    return self2;
  };
  self2.getUsage = () => {
    return usages;
  };
  self2.getUsageDisabled = () => {
    return usageDisabled;
  };
  self2.getPositionalGroupName = () => {
    return __("Positionals:");
  };
  let examples = [];
  self2.example = (cmd, description) => {
    examples.push([cmd, description || ""]);
  };
  let commands = [];
  self2.command = function command(cmd, description, isDefault, aliases, deprecated = false) {
    if (isDefault) {
      commands = commands.map((cmdArray) => {
        cmdArray[2] = false;
        return cmdArray;
      });
    }
    commands.push([cmd, description || "", isDefault, aliases, deprecated]);
  };
  self2.getCommands = () => commands;
  let descriptions = {};
  self2.describe = function describe(keyOrKeys, desc) {
    if (Array.isArray(keyOrKeys)) {
      keyOrKeys.forEach((k) => {
        self2.describe(k, desc);
      });
    } else if (typeof keyOrKeys === "object") {
      Object.keys(keyOrKeys).forEach((k) => {
        self2.describe(k, keyOrKeys[k]);
      });
    } else {
      descriptions[keyOrKeys] = desc;
    }
  };
  self2.getDescriptions = () => descriptions;
  let epilogs = [];
  self2.epilog = (msg) => {
    epilogs.push(msg);
  };
  let wrapSet = false;
  let wrap2;
  self2.wrap = (cols) => {
    wrapSet = true;
    wrap2 = cols;
  };
  self2.getWrap = () => {
    if (shim2.getEnv("YARGS_DISABLE_WRAP")) {
      return null;
    }
    if (!wrapSet) {
      wrap2 = windowWidth();
      wrapSet = true;
    }
    return wrap2;
  };
  const deferY18nLookupPrefix = "__yargsString__:";
  self2.deferY18nLookup = (str) => deferY18nLookupPrefix + str;
  self2.help = function help() {
    if (cachedHelpMessage)
      return cachedHelpMessage;
    normalizeAliases();
    const base$0 = yargs.customScriptName ? yargs.$0 : shim2.path.basename(yargs.$0);
    const demandedOptions = yargs.getDemandedOptions();
    const demandedCommands = yargs.getDemandedCommands();
    const deprecatedOptions = yargs.getDeprecatedOptions();
    const groups = yargs.getGroups();
    const options = yargs.getOptions();
    let keys = [];
    keys = keys.concat(Object.keys(descriptions));
    keys = keys.concat(Object.keys(demandedOptions));
    keys = keys.concat(Object.keys(demandedCommands));
    keys = keys.concat(Object.keys(options.default));
    keys = keys.filter(filterHiddenOptions);
    keys = Object.keys(keys.reduce((acc, key) => {
      if (key !== "_")
        acc[key] = true;
      return acc;
    }, {}));
    const theWrap = self2.getWrap();
    const ui2 = shim2.cliui({
      width: theWrap,
      wrap: !!theWrap
    });
    if (!usageDisabled) {
      if (usages.length) {
        usages.forEach((usage2) => {
          ui2.div({ text: `${usage2[0].replace(/\$0/g, base$0)}` });
          if (usage2[1]) {
            ui2.div({ text: `${usage2[1]}`, padding: [1, 0, 0, 0] });
          }
        });
        ui2.div();
      } else if (commands.length) {
        let u = null;
        if (demandedCommands._) {
          u = `${base$0} <${__("command")}>\n`;
        } else {
          u = `${base$0} [${__("command")}]\n`;
        }
        ui2.div(`${u}`);
      }
    }
    if (commands.length > 1 || commands.length === 1 && !commands[0][2]) {
      ui2.div(__("Commands:"));
      const context = yargs.getInternalMethods().getContext();
      const parentCommands = context.commands.length ? `${context.commands.join(" ")} ` : "";
      if (yargs.getInternalMethods().getParserConfiguration()["sort-commands"] === true) {
        commands = commands.sort((a, b) => a[0].localeCompare(b[0]));
      }
      const prefix = base$0 ? `${base$0} ` : "";
      commands.forEach((command2) => {
        const commandString = `${prefix}${parentCommands}${command2[0].replace(/^\$0 ?/, "")}`;
        ui2.span({
          text: commandString,
          padding: [0, 2, 0, 2],
          width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4
        }, { text: command2[1] });
        const hints = [];
        if (command2[2])
          hints.push(`[${__("default")}]`);
        if (command2[3] && command2[3].length) {
          hints.push(`[${__("aliases:")} ${command2[3].join(", ")}]`);
        }
        if (command2[4]) {
          if (typeof command2[4] === "string") {
            hints.push(`[${__("deprecated: %s", command2[4])}]`);
          } else {
            hints.push(`[${__("deprecated")}]`);
          }
        }
        if (hints.length) {
          ui2.div({
            text: hints.join(" "),
            padding: [0, 0, 0, 2],
            align: "right"
          });
        } else {
          ui2.div();
        }
      });
      ui2.div();
    }
    const aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);
    keys = keys.filter((key) => !yargs.parsed.newAliases[key] && aliasKeys.every((alias) => (options.alias[alias] || []).indexOf(key) === -1));
    const defaultGroup = __("Options:");
    if (!groups[defaultGroup])
      groups[defaultGroup] = [];
    addUngroupedKeys(keys, options.alias, groups, defaultGroup);
    const isLongSwitch = (sw) => /^--/.test(getText(sw));
    const displayedGroups = Object.keys(groups).filter((groupName) => groups[groupName].length > 0).map((groupName) => {
      const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map((key) => {
        if (aliasKeys.includes(key))
          return key;
        for (let i = 0, aliasKey;(aliasKey = aliasKeys[i]) !== undefined; i++) {
          if ((options.alias[aliasKey] || []).includes(key))
            return aliasKey;
        }
        return key;
      });
      return { groupName, normalizedKeys };
    }).filter(({ normalizedKeys }) => normalizedKeys.length > 0).map(({ groupName, normalizedKeys }) => {
      const switches = normalizedKeys.reduce((acc, key) => {
        acc[key] = [key].concat(options.alias[key] || []).map((sw) => {
          if (groupName === self2.getPositionalGroupName())
            return sw;
          else {
            return (/^[0-9]$/.test(sw) ? options.boolean.includes(key) ? "-" : "--" : sw.length > 1 ? "--" : "-") + sw;
          }
        }).sort((sw1, sw2) => isLongSwitch(sw1) === isLongSwitch(sw2) ? 0 : isLongSwitch(sw1) ? 1 : -1).join(", ");
        return acc;
      }, {});
      return { groupName, normalizedKeys, switches };
    });
    const shortSwitchesUsed = displayedGroups.filter(({ groupName }) => groupName !== self2.getPositionalGroupName()).some(({ normalizedKeys, switches }) => !normalizedKeys.every((key) => isLongSwitch(switches[key])));
    if (shortSwitchesUsed) {
      displayedGroups.filter(({ groupName }) => groupName !== self2.getPositionalGroupName()).forEach(({ normalizedKeys, switches }) => {
        normalizedKeys.forEach((key) => {
          if (isLongSwitch(switches[key])) {
            switches[key] = addIndentation(switches[key], "-x, ".length);
          }
        });
      });
    }
    displayedGroups.forEach(({ groupName, normalizedKeys, switches }) => {
      ui2.div(groupName);
      normalizedKeys.forEach((key) => {
        const kswitch = switches[key];
        let desc = descriptions[key] || "";
        let type = null;
        if (desc.includes(deferY18nLookupPrefix))
          desc = __(desc.substring(deferY18nLookupPrefix.length));
        if (options.boolean.includes(key))
          type = `[${__("boolean")}]`;
        if (options.count.includes(key))
          type = `[${__("count")}]`;
        if (options.string.includes(key))
          type = `[${__("string")}]`;
        if (options.normalize.includes(key))
          type = `[${__("string")}]`;
        if (options.array.includes(key))
          type = `[${__("array")}]`;
        if (options.number.includes(key))
          type = `[${__("number")}]`;
        const deprecatedExtra = (deprecated) => typeof deprecated === "string" ? `[${__("deprecated: %s", deprecated)}]` : `[${__("deprecated")}]`;
        const extra = [
          key in deprecatedOptions ? deprecatedExtra(deprecatedOptions[key]) : null,
          type,
          key in demandedOptions ? `[${__("required")}]` : null,
          options.choices && options.choices[key] ? `[${__("choices:")} ${self2.stringifiedValues(options.choices[key])}]` : null,
          defaultString(options.default[key], options.defaultDescription[key])
        ].filter(Boolean).join(" ");
        ui2.span({
          text: getText(kswitch),
          padding: [0, 2, 0, 2 + getIndentation(kswitch)],
          width: maxWidth(switches, theWrap) + 4
        }, desc);
        const shouldHideOptionExtras = yargs.getInternalMethods().getUsageConfiguration()["hide-types"] === true;
        if (extra && !shouldHideOptionExtras)
          ui2.div({ text: extra, padding: [0, 0, 0, 2], align: "right" });
        else
          ui2.div();
      });
      ui2.div();
    });
    if (examples.length) {
      ui2.div(__("Examples:"));
      examples.forEach((example) => {
        example[0] = example[0].replace(/\$0/g, base$0);
      });
      examples.forEach((example) => {
        if (example[1] === "") {
          ui2.div({
            text: example[0],
            padding: [0, 2, 0, 2]
          });
        } else {
          ui2.div({
            text: example[0],
            padding: [0, 2, 0, 2],
            width: maxWidth(examples, theWrap) + 4
          }, {
            text: example[1]
          });
        }
      });
      ui2.div();
    }
    if (epilogs.length > 0) {
      const e = epilogs.map((epilog) => epilog.replace(/\$0/g, base$0)).join("\n");
      ui2.div(`${e}\n`);
    }
    return ui2.toString().replace(/\s*$/, "");
  };
  function maxWidth(table, theWrap, modifier) {
    let width = 0;
    if (!Array.isArray(table)) {
      table = Object.values(table).map((v) => [v]);
    }
    table.forEach((v) => {
      width = Math.max(shim2.stringWidth(modifier ? `${modifier} ${getText(v[0])}` : getText(v[0])) + getIndentation(v[0]), width);
    });
    if (theWrap)
      width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));
    return width;
  }
  function normalizeAliases() {
    const demandedOptions = yargs.getDemandedOptions();
    const options = yargs.getOptions();
    (Object.keys(options.alias) || []).forEach((key) => {
      options.alias[key].forEach((alias) => {
        if (descriptions[alias])
          self2.describe(key, descriptions[alias]);
        if (alias in demandedOptions)
          yargs.demandOption(key, demandedOptions[alias]);
        if (options.boolean.includes(alias))
          yargs.boolean(key);
        if (options.count.includes(alias))
          yargs.count(key);
        if (options.string.includes(alias))
          yargs.string(key);
        if (options.normalize.includes(alias))
          yargs.normalize(key);
        if (options.array.includes(alias))
          yargs.array(key);
        if (options.number.includes(alias))
          yargs.number(key);
      });
    });
  }
  let cachedHelpMessage;
  self2.cacheHelpMessage = function() {
    cachedHelpMessage = this.help();
  };
  self2.clearCachedHelpMessage = function() {
    cachedHelpMessage = undefined;
  };
  self2.hasCachedHelpMessage = function() {
    return !!cachedHelpMessage;
  };
  function addUngroupedKeys(keys, aliases, groups, defaultGroup) {
    let groupedKeys = [];
    let toCheck = null;
    Object.keys(groups).forEach((group) => {
      groupedKeys = groupedKeys.concat(groups[group]);
    });
    keys.forEach((key) => {
      toCheck = [key].concat(aliases[key]);
      if (!toCheck.some((k) => groupedKeys.indexOf(k) !== -1)) {
        groups[defaultGroup].push(key);
      }
    });
    return groupedKeys;
  }
  function filterHiddenOptions(key) {
    return yargs.getOptions().hiddenOptions.indexOf(key) < 0 || yargs.parsed.argv[yargs.getOptions().showHiddenOpt];
  }
  self2.showHelp = (level) => {
    const logger = yargs.getInternalMethods().getLoggerInstance();
    if (!level)
      level = "error";
    const emit = typeof level === "function" ? level : logger[level];
    emit(self2.help());
  };
  self2.functionDescription = (fn) => {
    const description = fn.name ? shim2.Parser.decamelize(fn.name, "-") : __("generated-value");
    return ["(", description, ")"].join("");
  };
  self2.stringifiedValues = function stringifiedValues(values, separator) {
    let string = "";
    const sep = separator || ", ";
    const array = [].concat(values);
    if (!values || !array.length)
      return string;
    array.forEach((value) => {
      if (string.length)
        string += sep;
      string += JSON.stringify(value);
    });
    return string;
  };
  function defaultString(value, defaultDescription) {
    let string = `[${__("default:")} `;
    if (value === undefined && !defaultDescription)
      return null;
    if (defaultDescription) {
      string += defaultDescription;
    } else {
      switch (typeof value) {
        case "string":
          string += `"${value}"`;
          break;
        case "object":
          string += JSON.stringify(value);
          break;
        default:
          string += value;
      }
    }
    return `${string}]`;
  }
  function windowWidth() {
    const maxWidth2 = 80;
    if (shim2.process.stdColumns) {
      return Math.min(maxWidth2, shim2.process.stdColumns);
    } else {
      return maxWidth2;
    }
  }
  let version = null;
  self2.version = (ver) => {
    version = ver;
  };
  self2.showVersion = (level) => {
    const logger = yargs.getInternalMethods().getLoggerInstance();
    if (!level)
      level = "error";
    const emit = typeof level === "function" ? level : logger[level];
    emit(version);
  };
  self2.reset = function reset(localLookup) {
    failMessage = null;
    failureOutput = false;
    usages = [];
    usageDisabled = false;
    epilogs = [];
    examples = [];
    commands = [];
    descriptions = objFilter(descriptions, (k) => !localLookup[k]);
    return self2;
  };
  const frozens = [];
  self2.freeze = function freeze() {
    frozens.push({
      failMessage,
      failureOutput,
      usages,
      usageDisabled,
      epilogs,
      examples,
      commands,
      descriptions
    });
  };
  self2.unfreeze = function unfreeze(defaultCommand = false) {
    const frozen = frozens.pop();
    if (!frozen)
      return;
    if (defaultCommand) {
      descriptions = { ...frozen.descriptions, ...descriptions };
      commands = [...frozen.commands, ...commands];
      usages = [...frozen.usages, ...usages];
      examples = [...frozen.examples, ...examples];
      epilogs = [...frozen.epilogs, ...epilogs];
    } else {
      ({
        failMessage,
        failureOutput,
        usages,
        usageDisabled,
        epilogs,
        examples,
        commands,
        descriptions
      } = frozen);
    }
  };
  return self2;
}
var isIndentedText = function(text) {
  return typeof text === "object";
};
var addIndentation = function(text, indent) {
  return isIndentedText(text) ? { text: text.text, indentation: text.indentation + indent } : { text, indentation: indent };
};
var getIndentation = function(text) {
  return isIndentedText(text) ? text.indentation : 0;
};
var getText = function(text) {
  return isIndentedText(text) ? text.text : text;
};

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/completion-templates.js
var completionShTemplate = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc
#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.
#
_{{app_name}}_yargs_completions()
{
    local cur_word args type_list

    cur_word="\${COMP_WORDS[COMP_CWORD]}"
    args=("\${COMP_WORDS[@]}")

    # ask yargs to generate completions.
    type_list=$({{app_path}} --get-yargs-completions "\${args[@]}")

    COMPREPLY=( $(compgen -W "\${type_list}" -- \${cur_word}) )

    # if no match was found, fall back to filename completion
    if [ \${#COMPREPLY[@]} -eq 0 ]; then
      COMPREPLY=()
    fi

    return 0
}
complete -o bashdefault -o default -F _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
var completionZshTemplate = `#compdef {{app_name}}
###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zprofile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'
' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/completion.js
function completion(yargs, usage2, command3, shim2) {
  return new Completion(yargs, usage2, command3, shim2);
}
var isSyncCompletionFunction = function(completionFunction) {
  return completionFunction.length < 3;
};
var isFallbackCompletionFunction = function(completionFunction) {
  return completionFunction.length > 3;
};

class Completion {
  constructor(yargs, usage2, command3, shim2) {
    var _a2, _b2, _c2;
    this.yargs = yargs;
    this.usage = usage2;
    this.command = command3;
    this.shim = shim2;
    this.completionKey = "get-yargs-completions";
    this.aliases = null;
    this.customCompletionFunction = null;
    this.indexAfterLastReset = 0;
    this.zshShell = (_c2 = ((_a2 = this.shim.getEnv("SHELL")) === null || _a2 === undefined ? undefined : _a2.includes("zsh")) || ((_b2 = this.shim.getEnv("ZSH_NAME")) === null || _b2 === undefined ? undefined : _b2.includes("zsh"))) !== null && _c2 !== undefined ? _c2 : false;
  }
  defaultCompletion(args, argv, current, done) {
    const handlers = this.command.getCommandHandlers();
    for (let i = 0, ii = args.length;i < ii; ++i) {
      if (handlers[args[i]] && handlers[args[i]].builder) {
        const builder = handlers[args[i]].builder;
        if (isCommandBuilderCallback(builder)) {
          this.indexAfterLastReset = i + 1;
          const y = this.yargs.getInternalMethods().reset();
          builder(y, true);
          return y.argv;
        }
      }
    }
    const completions = [];
    this.commandCompletions(completions, args, current);
    this.optionCompletions(completions, args, argv, current);
    this.choicesFromOptionsCompletions(completions, args, argv, current);
    this.choicesFromPositionalsCompletions(completions, args, argv, current);
    done(null, completions);
  }
  commandCompletions(completions, args, current) {
    const parentCommands = this.yargs.getInternalMethods().getContext().commands;
    if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current && !this.previousArgHasChoices(args)) {
      this.usage.getCommands().forEach((usageCommand) => {
        const commandName = parseCommand(usageCommand[0]).cmd;
        if (args.indexOf(commandName) === -1) {
          if (!this.zshShell) {
            completions.push(commandName);
          } else {
            const desc = usageCommand[1] || "";
            completions.push(commandName.replace(/:/g, "\\:") + ":" + desc);
          }
        }
      });
    }
  }
  optionCompletions(completions, args, argv, current) {
    if ((current.match(/^-/) || current === "" && completions.length === 0) && !this.previousArgHasChoices(args)) {
      const options = this.yargs.getOptions();
      const positionalKeys = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
      Object.keys(options.key).forEach((key) => {
        const negable = !!options.configuration["boolean-negation"] && options.boolean.includes(key);
        const isPositionalKey = positionalKeys.includes(key);
        if (!isPositionalKey && !options.hiddenOptions.includes(key) && !this.argsContainKey(args, key, negable)) {
          this.completeOptionKey(key, completions, current, negable && !!options.default[key]);
        }
      });
    }
  }
  choicesFromOptionsCompletions(completions, args, argv, current) {
    if (this.previousArgHasChoices(args)) {
      const choices = this.getPreviousArgChoices(args);
      if (choices && choices.length > 0) {
        completions.push(...choices.map((c) => c.replace(/:/g, "\\:")));
      }
    }
  }
  choicesFromPositionalsCompletions(completions, args, argv, current) {
    if (current === "" && completions.length > 0 && this.previousArgHasChoices(args)) {
      return;
    }
    const positionalKeys = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
    const offset = Math.max(this.indexAfterLastReset, this.yargs.getInternalMethods().getContext().commands.length + 1);
    const positionalKey = positionalKeys[argv._.length - offset - 1];
    if (!positionalKey) {
      return;
    }
    const choices = this.yargs.getOptions().choices[positionalKey] || [];
    for (const choice of choices) {
      if (choice.startsWith(current)) {
        completions.push(choice.replace(/:/g, "\\:"));
      }
    }
  }
  getPreviousArgChoices(args) {
    if (args.length < 1)
      return;
    let previousArg = args[args.length - 1];
    let filter = "";
    if (!previousArg.startsWith("-") && args.length > 1) {
      filter = previousArg;
      previousArg = args[args.length - 2];
    }
    if (!previousArg.startsWith("-"))
      return;
    const previousArgKey = previousArg.replace(/^-+/, "");
    const options = this.yargs.getOptions();
    const possibleAliases = [
      previousArgKey,
      ...this.yargs.getAliases()[previousArgKey] || []
    ];
    let choices;
    for (const possibleAlias of possibleAliases) {
      if (Object.prototype.hasOwnProperty.call(options.key, possibleAlias) && Array.isArray(options.choices[possibleAlias])) {
        choices = options.choices[possibleAlias];
        break;
      }
    }
    if (choices) {
      return choices.filter((choice) => !filter || choice.startsWith(filter));
    }
  }
  previousArgHasChoices(args) {
    const choices = this.getPreviousArgChoices(args);
    return choices !== undefined && choices.length > 0;
  }
  argsContainKey(args, key, negable) {
    const argsContains = (s) => args.indexOf((/^[^0-9]$/.test(s) ? "-" : "--") + s) !== -1;
    if (argsContains(key))
      return true;
    if (negable && argsContains(`no-${key}`))
      return true;
    if (this.aliases) {
      for (const alias of this.aliases[key]) {
        if (argsContains(alias))
          return true;
      }
    }
    return false;
  }
  completeOptionKey(key, completions, current, negable) {
    var _a2, _b2, _c2, _d;
    let keyWithDesc = key;
    if (this.zshShell) {
      const descs = this.usage.getDescriptions();
      const aliasKey = (_b2 = (_a2 = this === null || this === undefined ? undefined : this.aliases) === null || _a2 === undefined ? undefined : _a2[key]) === null || _b2 === undefined ? undefined : _b2.find((alias) => {
        const desc2 = descs[alias];
        return typeof desc2 === "string" && desc2.length > 0;
      });
      const descFromAlias = aliasKey ? descs[aliasKey] : undefined;
      const desc = (_d = (_c2 = descs[key]) !== null && _c2 !== undefined ? _c2 : descFromAlias) !== null && _d !== undefined ? _d : "";
      keyWithDesc = `${key.replace(/:/g, "\\:")}:${desc.replace("__yargsString__:", "").replace(/(\r\n|\n|\r)/gm, " ")}`;
    }
    const startsByTwoDashes = (s) => /^--/.test(s);
    const isShortOption = (s) => /^[^0-9]$/.test(s);
    const dashes = !startsByTwoDashes(current) && isShortOption(key) ? "-" : "--";
    completions.push(dashes + keyWithDesc);
    if (negable) {
      completions.push(dashes + "no-" + keyWithDesc);
    }
  }
  customCompletion(args, argv, current, done) {
    assertNotStrictEqual(this.customCompletionFunction, null, this.shim);
    if (isSyncCompletionFunction(this.customCompletionFunction)) {
      const result = this.customCompletionFunction(current, argv);
      if (isPromise(result)) {
        return result.then((list) => {
          this.shim.process.nextTick(() => {
            done(null, list);
          });
        }).catch((err) => {
          this.shim.process.nextTick(() => {
            done(err, undefined);
          });
        });
      }
      return done(null, result);
    } else if (isFallbackCompletionFunction(this.customCompletionFunction)) {
      return this.customCompletionFunction(current, argv, (onCompleted = done) => this.defaultCompletion(args, argv, current, onCompleted), (completions) => {
        done(null, completions);
      });
    } else {
      return this.customCompletionFunction(current, argv, (completions) => {
        done(null, completions);
      });
    }
  }
  getCompletion(args, done) {
    const current = args.length ? args[args.length - 1] : "";
    const argv = this.yargs.parse(args, true);
    const completionFunction = this.customCompletionFunction ? (argv2) => this.customCompletion(args, argv2, current, done) : (argv2) => this.defaultCompletion(args, argv2, current, done);
    return isPromise(argv) ? argv.then(completionFunction) : completionFunction(argv);
  }
  generateCompletionScript($0, cmd) {
    let script = this.zshShell ? completionZshTemplate : completionShTemplate;
    const name = this.shim.path.basename($0);
    if ($0.match(/\.js$/))
      $0 = `./${$0}`;
    script = script.replace(/{{app_name}}/g, name);
    script = script.replace(/{{completion_command}}/g, cmd);
    return script.replace(/{{app_path}}/g, $0);
  }
  registerFunction(fn) {
    this.customCompletionFunction = fn;
  }
  setParsed(parsed) {
    this.aliases = parsed.aliases;
  }
}

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/utils/levenshtein.js
function levenshtein(a, b) {
  if (a.length === 0)
    return b.length;
  if (b.length === 0)
    return a.length;
  const matrix = [];
  let i;
  for (i = 0;i <= b.length; i++) {
    matrix[i] = [i];
  }
  let j;
  for (j = 0;j <= a.length; j++) {
    matrix[0][j] = j;
  }
  for (i = 1;i <= b.length; i++) {
    for (j = 1;j <= a.length; j++) {
      if (b.charAt(i - 1) === a.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        if (i > 1 && j > 1 && b.charAt(i - 2) === a.charAt(j - 1) && b.charAt(i - 1) === a.charAt(j - 2)) {
          matrix[i][j] = matrix[i - 2][j - 2] + 1;
        } else {
          matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
        }
      }
    }
  }
  return matrix[b.length][a.length];
}

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/validation.js
function validation(yargs, usage2, shim2) {
  const __ = shim2.y18n.__;
  const __n = shim2.y18n.__n;
  const self2 = {};
  self2.nonOptionCount = function nonOptionCount(argv) {
    const demandedCommands = yargs.getDemandedCommands();
    const positionalCount = argv._.length + (argv["--"] ? argv["--"].length : 0);
    const _s = positionalCount - yargs.getInternalMethods().getContext().commands.length;
    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {
      if (_s < demandedCommands._.min) {
        if (demandedCommands._.minMsg !== undefined) {
          usage2.fail(demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.min.toString()) : null);
        } else {
          usage2.fail(__n("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", _s, _s.toString(), demandedCommands._.min.toString()));
        }
      } else if (_s > demandedCommands._.max) {
        if (demandedCommands._.maxMsg !== undefined) {
          usage2.fail(demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.max.toString()) : null);
        } else {
          usage2.fail(__n("Too many non-option arguments: got %s, maximum of %s", "Too many non-option arguments: got %s, maximum of %s", _s, _s.toString(), demandedCommands._.max.toString()));
        }
      }
    }
  };
  self2.positionalCount = function positionalCount(required, observed) {
    if (observed < required) {
      usage2.fail(__n("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", observed, observed + "", required + ""));
    }
  };
  self2.requiredArguments = function requiredArguments(argv, demandedOptions) {
    let missing = null;
    for (const key of Object.keys(demandedOptions)) {
      if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === "undefined") {
        missing = missing || {};
        missing[key] = demandedOptions[key];
      }
    }
    if (missing) {
      const customMsgs = [];
      for (const key of Object.keys(missing)) {
        const msg = missing[key];
        if (msg && customMsgs.indexOf(msg) < 0) {
          customMsgs.push(msg);
        }
      }
      const customMsg = customMsgs.length ? `\n${customMsgs.join("\n")}` : "";
      usage2.fail(__n("Missing required argument: %s", "Missing required arguments: %s", Object.keys(missing).length, Object.keys(missing).join(", ") + customMsg));
    }
  };
  self2.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) {
    var _a2;
    const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();
    const unknown = [];
    const currentContext = yargs.getInternalMethods().getContext();
    Object.keys(argv).forEach((key) => {
      if (!specialKeys.includes(key) && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs.getInternalMethods().getParseContext(), key) && !self2.isValidAndSomeAliasIsNotNew(key, aliases)) {
        unknown.push(key);
      }
    });
    if (checkPositionals && (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand)) {
      argv._.slice(currentContext.commands.length).forEach((key) => {
        if (!commandKeys.includes("" + key)) {
          unknown.push("" + key);
        }
      });
    }
    if (checkPositionals) {
      const demandedCommands = yargs.getDemandedCommands();
      const maxNonOptDemanded = ((_a2 = demandedCommands._) === null || _a2 === undefined ? undefined : _a2.max) || 0;
      const expected = currentContext.commands.length + maxNonOptDemanded;
      if (expected < argv._.length) {
        argv._.slice(expected).forEach((key) => {
          key = String(key);
          if (!currentContext.commands.includes(key) && !unknown.includes(key)) {
            unknown.push(key);
          }
        });
      }
    }
    if (unknown.length) {
      usage2.fail(__n("Unknown argument: %s", "Unknown arguments: %s", unknown.length, unknown.map((s) => s.trim() ? s : `"${s}"`).join(", ")));
    }
  };
  self2.unknownCommands = function unknownCommands(argv) {
    const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();
    const unknown = [];
    const currentContext = yargs.getInternalMethods().getContext();
    if (currentContext.commands.length > 0 || commandKeys.length > 0) {
      argv._.slice(currentContext.commands.length).forEach((key) => {
        if (!commandKeys.includes("" + key)) {
          unknown.push("" + key);
        }
      });
    }
    if (unknown.length > 0) {
      usage2.fail(__n("Unknown command: %s", "Unknown commands: %s", unknown.length, unknown.join(", ")));
      return true;
    } else {
      return false;
    }
  };
  self2.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {
    if (!Object.prototype.hasOwnProperty.call(aliases, key)) {
      return false;
    }
    const newAliases = yargs.parsed.newAliases;
    return [key, ...aliases[key]].some((a) => !Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]);
  };
  self2.limitedChoices = function limitedChoices(argv) {
    const options = yargs.getOptions();
    const invalid = {};
    if (!Object.keys(options.choices).length)
      return;
    Object.keys(argv).forEach((key) => {
      if (specialKeys.indexOf(key) === -1 && Object.prototype.hasOwnProperty.call(options.choices, key)) {
        [].concat(argv[key]).forEach((value) => {
          if (options.choices[key].indexOf(value) === -1 && value !== undefined) {
            invalid[key] = (invalid[key] || []).concat(value);
          }
        });
      }
    });
    const invalidKeys = Object.keys(invalid);
    if (!invalidKeys.length)
      return;
    let msg = __("Invalid values:");
    invalidKeys.forEach((key) => {
      msg += `\n  ${__("Argument: %s, Given: %s, Choices: %s", key, usage2.stringifiedValues(invalid[key]), usage2.stringifiedValues(options.choices[key]))}`;
    });
    usage2.fail(msg);
  };
  let implied = {};
  self2.implies = function implies(key, value) {
    argsert("<string|object> [array|number|string]", [key, value], arguments.length);
    if (typeof key === "object") {
      Object.keys(key).forEach((k) => {
        self2.implies(k, key[k]);
      });
    } else {
      yargs.global(key);
      if (!implied[key]) {
        implied[key] = [];
      }
      if (Array.isArray(value)) {
        value.forEach((i) => self2.implies(key, i));
      } else {
        assertNotStrictEqual(value, undefined, shim2);
        implied[key].push(value);
      }
    }
  };
  self2.getImplied = function getImplied() {
    return implied;
  };
  function keyExists(argv, val) {
    const num = Number(val);
    val = isNaN(num) ? val : num;
    if (typeof val === "number") {
      val = argv._.length >= val;
    } else if (val.match(/^--no-.+/)) {
      val = val.match(/^--no-(.+)/)[1];
      val = !Object.prototype.hasOwnProperty.call(argv, val);
    } else {
      val = Object.prototype.hasOwnProperty.call(argv, val);
    }
    return val;
  }
  self2.implications = function implications(argv) {
    const implyFail = [];
    Object.keys(implied).forEach((key) => {
      const origKey = key;
      (implied[key] || []).forEach((value) => {
        let key2 = origKey;
        const origValue = value;
        key2 = keyExists(argv, key2);
        value = keyExists(argv, value);
        if (key2 && !value) {
          implyFail.push(` ${origKey} -> ${origValue}`);
        }
      });
    });
    if (implyFail.length) {
      let msg = `${__("Implications failed:")}\n`;
      implyFail.forEach((value) => {
        msg += value;
      });
      usage2.fail(msg);
    }
  };
  let conflicting = {};
  self2.conflicts = function conflicts(key, value) {
    argsert("<string|object> [array|string]", [key, value], arguments.length);
    if (typeof key === "object") {
      Object.keys(key).forEach((k) => {
        self2.conflicts(k, key[k]);
      });
    } else {
      yargs.global(key);
      if (!conflicting[key]) {
        conflicting[key] = [];
      }
      if (Array.isArray(value)) {
        value.forEach((i) => self2.conflicts(key, i));
      } else {
        conflicting[key].push(value);
      }
    }
  };
  self2.getConflicting = () => conflicting;
  self2.conflicting = function conflictingFn(argv) {
    Object.keys(argv).forEach((key) => {
      if (conflicting[key]) {
        conflicting[key].forEach((value) => {
          if (value && argv[key] !== undefined && argv[value] !== undefined) {
            usage2.fail(__("Arguments %s and %s are mutually exclusive", key, value));
          }
        });
      }
    });
    if (yargs.getInternalMethods().getParserConfiguration()["strip-dashed"]) {
      Object.keys(conflicting).forEach((key) => {
        conflicting[key].forEach((value) => {
          if (value && argv[shim2.Parser.camelCase(key)] !== undefined && argv[shim2.Parser.camelCase(value)] !== undefined) {
            usage2.fail(__("Arguments %s and %s are mutually exclusive", key, value));
          }
        });
      });
    }
  };
  self2.recommendCommands = function recommendCommands(cmd, potentialCommands) {
    const threshold = 3;
    potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);
    let recommended = null;
    let bestDistance = Infinity;
    for (let i = 0, candidate;(candidate = potentialCommands[i]) !== undefined; i++) {
      const d = levenshtein(cmd, candidate);
      if (d <= threshold && d < bestDistance) {
        bestDistance = d;
        recommended = candidate;
      }
    }
    if (recommended)
      usage2.fail(__("Did you mean %s?", recommended));
  };
  self2.reset = function reset(localLookup) {
    implied = objFilter(implied, (k) => !localLookup[k]);
    conflicting = objFilter(conflicting, (k) => !localLookup[k]);
    return self2;
  };
  const frozens = [];
  self2.freeze = function freeze() {
    frozens.push({
      implied,
      conflicting
    });
  };
  self2.unfreeze = function unfreeze() {
    const frozen = frozens.pop();
    assertNotStrictEqual(frozen, undefined, shim2);
    ({ implied, conflicting } = frozen);
  };
  return self2;
}
var specialKeys = ["$0", "--", "_"];

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/utils/apply-extends.js
function applyExtends(config, cwd, mergeExtends, _shim) {
  shim2 = _shim;
  let defaultConfig = {};
  if (Object.prototype.hasOwnProperty.call(config, "extends")) {
    if (typeof config.extends !== "string")
      return defaultConfig;
    const isPath = /\.json|\..*rc$/.test(config.extends);
    let pathToDefault = null;
    if (!isPath) {
      try {
        pathToDefault = __require.resolve(config.extends);
      } catch (_err) {
        return config;
      }
    } else {
      pathToDefault = getPathToDefaultConfig(cwd, config.extends);
    }
    checkForCircularExtends(pathToDefault);
    previouslyVisitedConfigs.push(pathToDefault);
    defaultConfig = isPath ? JSON.parse(shim2.readFileSync(pathToDefault, "utf8")) : __require(config.extends);
    delete config.extends;
    defaultConfig = applyExtends(defaultConfig, shim2.path.dirname(pathToDefault), mergeExtends, shim2);
  }
  previouslyVisitedConfigs = [];
  return mergeExtends ? mergeDeep(defaultConfig, config) : Object.assign({}, defaultConfig, config);
}
var checkForCircularExtends = function(cfgPath) {
  if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {
    throw new YError(`Circular extended configurations: '${cfgPath}'.`);
  }
};
var getPathToDefaultConfig = function(cwd, pathToExtend) {
  return shim2.path.resolve(cwd, pathToExtend);
};
var mergeDeep = function(config1, config2) {
  const target = {};
  function isObject(obj) {
    return obj && typeof obj === "object" && !Array.isArray(obj);
  }
  Object.assign(target, config1);
  for (const key of Object.keys(config2)) {
    if (isObject(config2[key]) && isObject(target[key])) {
      target[key] = mergeDeep(config1[key], config2[key]);
    } else {
      target[key] = config2[key];
    }
  }
  return target;
};
var previouslyVisitedConfigs = [];
var shim2;

// ../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/yargs-factory.js
function YargsFactory(_shim) {
  return (processArgs = [], cwd = _shim.process.cwd(), parentRequire) => {
    const yargs = new YargsInstance(processArgs, cwd, parentRequire, _shim);
    Object.defineProperty(yargs, "argv", {
      get: () => {
        return yargs.parse();
      },
      enumerable: true
    });
    yargs.help();
    yargs.version();
    return yargs;
  };
}
function isYargsInstance(y) {
  return !!y && typeof y.getInternalMethods === "function";
}
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _YargsInstance_command;
var _YargsInstance_cwd;
var _YargsInstance_context;
var _YargsInstance_completion;
var _YargsInstance_completionCommand;
var _YargsInstance_defaultShowHiddenOpt;
var _YargsInstance_exitError;
var _YargsInstance_detectLocale;
var _YargsInstance_emittedWarnings;
var _YargsInstance_exitProcess;
var _YargsInstance_frozens;
var _YargsInstance_globalMiddleware;
var _YargsInstance_groups;
var _YargsInstance_hasOutput;
var _YargsInstance_helpOpt;
var _YargsInstance_isGlobalContext;
var _YargsInstance_logger;
var _YargsInstance_output;
var _YargsInstance_options;
var _YargsInstance_parentRequire;
var _YargsInstance_parserConfig;
var _YargsInstance_parseFn;
var _YargsInstance_parseContext;
var _YargsInstance_pkgs;
var _YargsInstance_preservedGroups;
var _YargsInstance_processArgs;
var _YargsInstance_recommendCommands;
var _YargsInstance_shim;
var _YargsInstance_strict;
var _YargsInstance_strictCommands;
var _YargsInstance_strictOptions;
var _YargsInstance_usage;
var _YargsInstance_usageConfig;
var _YargsInstance_versionOpt;
var _YargsInstance_validation;
var kCopyDoubleDash = Symbol("copyDoubleDash");
var kCreateLogger = Symbol("copyDoubleDash");
var kDeleteFromParserHintObject = Symbol("deleteFromParserHintObject");
var kEmitWarning = Symbol("emitWarning");
var kFreeze = Symbol("freeze");
var kGetDollarZero = Symbol("getDollarZero");
var kGetParserConfiguration = Symbol("getParserConfiguration");
var kGetUsageConfiguration = Symbol("getUsageConfiguration");
var kGuessLocale = Symbol("guessLocale");
var kGuessVersion = Symbol("guessVersion");
var kParsePositionalNumbers = Symbol("parsePositionalNumbers");
var kPkgUp = Symbol("pkgUp");
var kPopulateParserHintArray = Symbol("populateParserHintArray");
var kPopulateParserHintSingleValueDictionary = Symbol("populateParserHintSingleValueDictionary");
var kPopulateParserHintArrayDictionary = Symbol("populateParserHintArrayDictionary");
var kPopulateParserHintDictionary = Symbol("populateParserHintDictionary");
var kSanitizeKey = Symbol("sanitizeKey");
var kSetKey = Symbol("setKey");
var kUnfreeze = Symbol("unfreeze");
var kValidateAsync = Symbol("validateAsync");
var kGetCommandInstance = Symbol("getCommandInstance");
var kGetContext = Symbol("getContext");
var kGetHasOutput = Symbol("getHasOutput");
var kGetLoggerInstance = Symbol("getLoggerInstance");
var kGetParseContext = Symbol("getParseContext");
var kGetUsageInstance = Symbol("getUsageInstance");
var kGetValidationInstance = Symbol("getValidationInstance");
var kHasParseCallback = Symbol("hasParseCallback");
var kIsGlobalContext = Symbol("isGlobalContext");
var kPostProcess = Symbol("postProcess");
var kRebase = Symbol("rebase");
var kReset = Symbol("reset");
var kRunYargsParserAndExecuteCommands = Symbol("runYargsParserAndExecuteCommands");
var kRunValidation = Symbol("runValidation");
var kSetHasOutput = Symbol("setHasOutput");
var kTrackManuallySetKeys = Symbol("kTrackManuallySetKeys");

class YargsInstance {
  constructor(processArgs = [], cwd, parentRequire, shim3) {
    this.customScriptName = false;
    this.parsed = false;
    _YargsInstance_command.set(this, undefined);
    _YargsInstance_cwd.set(this, undefined);
    _YargsInstance_context.set(this, { commands: [], fullCommands: [] });
    _YargsInstance_completion.set(this, null);
    _YargsInstance_completionCommand.set(this, null);
    _YargsInstance_defaultShowHiddenOpt.set(this, "show-hidden");
    _YargsInstance_exitError.set(this, null);
    _YargsInstance_detectLocale.set(this, true);
    _YargsInstance_emittedWarnings.set(this, {});
    _YargsInstance_exitProcess.set(this, true);
    _YargsInstance_frozens.set(this, []);
    _YargsInstance_globalMiddleware.set(this, undefined);
    _YargsInstance_groups.set(this, {});
    _YargsInstance_hasOutput.set(this, false);
    _YargsInstance_helpOpt.set(this, null);
    _YargsInstance_isGlobalContext.set(this, true);
    _YargsInstance_logger.set(this, undefined);
    _YargsInstance_output.set(this, "");
    _YargsInstance_options.set(this, undefined);
    _YargsInstance_parentRequire.set(this, undefined);
    _YargsInstance_parserConfig.set(this, {});
    _YargsInstance_parseFn.set(this, null);
    _YargsInstance_parseContext.set(this, null);
    _YargsInstance_pkgs.set(this, {});
    _YargsInstance_preservedGroups.set(this, {});
    _YargsInstance_processArgs.set(this, undefined);
    _YargsInstance_recommendCommands.set(this, false);
    _YargsInstance_shim.set(this, undefined);
    _YargsInstance_strict.set(this, false);
    _YargsInstance_strictCommands.set(this, false);
    _YargsInstance_strictOptions.set(this, false);
    _YargsInstance_usage.set(this, undefined);
    _YargsInstance_usageConfig.set(this, {});
    _YargsInstance_versionOpt.set(this, null);
    _YargsInstance_validation.set(this, undefined);
    __classPrivateFieldSet(this, _YargsInstance_shim, shim3, "f");
    __classPrivateFieldSet(this, _YargsInstance_processArgs, processArgs, "f");
    __classPrivateFieldSet(this, _YargsInstance_cwd, cwd, "f");
    __classPrivateFieldSet(this, _YargsInstance_parentRequire, parentRequire, "f");
    __classPrivateFieldSet(this, _YargsInstance_globalMiddleware, new GlobalMiddleware(this), "f");
    this.$0 = this[kGetDollarZero]();
    this[kReset]();
    __classPrivateFieldSet(this, _YargsInstance_command, __classPrivateFieldGet(this, _YargsInstance_command, "f"), "f");
    __classPrivateFieldSet(this, _YargsInstance_usage, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), "f");
    __classPrivateFieldSet(this, _YargsInstance_validation, __classPrivateFieldGet(this, _YargsInstance_validation, "f"), "f");
    __classPrivateFieldSet(this, _YargsInstance_options, __classPrivateFieldGet(this, _YargsInstance_options, "f"), "f");
    __classPrivateFieldGet(this, _YargsInstance_options, "f").showHiddenOpt = __classPrivateFieldGet(this, _YargsInstance_defaultShowHiddenOpt, "f");
    __classPrivateFieldSet(this, _YargsInstance_logger, this[kCreateLogger](), "f");
  }
  addHelpOpt(opt, msg) {
    const defaultHelpOpt = "help";
    argsert("[string|boolean] [string]", [opt, msg], arguments.length);
    if (__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")) {
      this[kDeleteFromParserHintObject](__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"));
      __classPrivateFieldSet(this, _YargsInstance_helpOpt, null, "f");
    }
    if (opt === false && msg === undefined)
      return this;
    __classPrivateFieldSet(this, _YargsInstance_helpOpt, typeof opt === "string" ? opt : defaultHelpOpt, "f");
    this.boolean(__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"));
    this.describe(__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"), msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup("Show help"));
    return this;
  }
  help(opt, msg) {
    return this.addHelpOpt(opt, msg);
  }
  addShowHiddenOpt(opt, msg) {
    argsert("[string|boolean] [string]", [opt, msg], arguments.length);
    if (opt === false && msg === undefined)
      return this;
    const showHiddenOpt = typeof opt === "string" ? opt : __classPrivateFieldGet(this, _YargsInstance_defaultShowHiddenOpt, "f");
    this.boolean(showHiddenOpt);
    this.describe(showHiddenOpt, msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup("Show hidden options"));
    __classPrivateFieldGet(this, _YargsInstance_options, "f").showHiddenOpt = showHiddenOpt;
    return this;
  }
  showHidden(opt, msg) {
    return this.addShowHiddenOpt(opt, msg);
  }
  alias(key, value) {
    argsert("<object|string|array> [string|array]", [key, value], arguments.length);
    this[kPopulateParserHintArrayDictionary](this.alias.bind(this), "alias", key, value);
    return this;
  }
  array(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("array", keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  boolean(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("boolean", keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  check(f, global2) {
    argsert("<function> [boolean]", [f, global2], arguments.length);
    this.middleware((argv, _yargs) => {
      return maybeAsyncResult(() => {
        return f(argv, _yargs.getOptions());
      }, (result) => {
        if (!result) {
          __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(__classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.__("Argument check failed: %s", f.toString()));
        } else if (typeof result === "string" || result instanceof Error) {
          __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(result.toString(), result);
        }
        return argv;
      }, (err) => {
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(err.message ? err.message : err.toString(), err);
        return argv;
      });
    }, false, global2);
    return this;
  }
  choices(key, value) {
    argsert("<object|string|array> [string|array]", [key, value], arguments.length);
    this[kPopulateParserHintArrayDictionary](this.choices.bind(this), "choices", key, value);
    return this;
  }
  coerce(keys, value) {
    argsert("<object|string|array> [function]", [keys, value], arguments.length);
    if (Array.isArray(keys)) {
      if (!value) {
        throw new YError("coerce callback must be provided");
      }
      for (const key of keys) {
        this.coerce(key, value);
      }
      return this;
    } else if (typeof keys === "object") {
      for (const key of Object.keys(keys)) {
        this.coerce(key, keys[key]);
      }
      return this;
    }
    if (!value) {
      throw new YError("coerce callback must be provided");
    }
    __classPrivateFieldGet(this, _YargsInstance_options, "f").key[keys] = true;
    __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").addCoerceMiddleware((argv, yargs) => {
      let aliases;
      const shouldCoerce = Object.prototype.hasOwnProperty.call(argv, keys);
      if (!shouldCoerce) {
        return argv;
      }
      return maybeAsyncResult(() => {
        aliases = yargs.getAliases();
        return value(argv[keys]);
      }, (result) => {
        argv[keys] = result;
        const stripAliased = yargs.getInternalMethods().getParserConfiguration()["strip-aliased"];
        if (aliases[keys] && stripAliased !== true) {
          for (const alias of aliases[keys]) {
            argv[alias] = result;
          }
        }
        return argv;
      }, (err) => {
        throw new YError(err.message);
      });
    }, keys);
    return this;
  }
  conflicts(key1, key2) {
    argsert("<string|object> [string|array]", [key1, key2], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_validation, "f").conflicts(key1, key2);
    return this;
  }
  config(key = "config", msg, parseFn) {
    argsert("[object|string] [string|function] [function]", [key, msg, parseFn], arguments.length);
    if (typeof key === "object" && !Array.isArray(key)) {
      key = applyExtends(key, __classPrivateFieldGet(this, _YargsInstance_cwd, "f"), this[kGetParserConfiguration]()["deep-merge-config"] || false, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = (__classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || []).concat(key);
      return this;
    }
    if (typeof msg === "function") {
      parseFn = msg;
      msg = undefined;
    }
    this.describe(key, msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup("Path to JSON config file"));
    (Array.isArray(key) ? key : [key]).forEach((k) => {
      __classPrivateFieldGet(this, _YargsInstance_options, "f").config[k] = parseFn || true;
    });
    return this;
  }
  completion(cmd, desc, fn) {
    argsert("[string] [string|boolean|function] [function]", [cmd, desc, fn], arguments.length);
    if (typeof desc === "function") {
      fn = desc;
      desc = undefined;
    }
    __classPrivateFieldSet(this, _YargsInstance_completionCommand, cmd || __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") || "completion", "f");
    if (!desc && desc !== false) {
      desc = "generate completion script";
    }
    this.command(__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f"), desc);
    if (fn)
      __classPrivateFieldGet(this, _YargsInstance_completion, "f").registerFunction(fn);
    return this;
  }
  command(cmd, description, builder, handler, middlewares, deprecated) {
    argsert("<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]", [cmd, description, builder, handler, middlewares, deprecated], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_command, "f").addHandler(cmd, description, builder, handler, middlewares, deprecated);
    return this;
  }
  commands(cmd, description, builder, handler, middlewares, deprecated) {
    return this.command(cmd, description, builder, handler, middlewares, deprecated);
  }
  commandDir(dir, opts) {
    argsert("<string> [object]", [dir, opts], arguments.length);
    const req = __classPrivateFieldGet(this, _YargsInstance_parentRequire, "f") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").require;
    __classPrivateFieldGet(this, _YargsInstance_command, "f").addDirectory(dir, req, __classPrivateFieldGet(this, _YargsInstance_shim, "f").getCallerFile(), opts);
    return this;
  }
  count(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("count", keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  default(key, value, defaultDescription) {
    argsert("<object|string|array> [*] [string]", [key, value, defaultDescription], arguments.length);
    if (defaultDescription) {
      assertSingleKey(key, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = defaultDescription;
    }
    if (typeof value === "function") {
      assertSingleKey(key, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      if (!__classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key])
        __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = __classPrivateFieldGet(this, _YargsInstance_usage, "f").functionDescription(value);
      value = value.call();
    }
    this[kPopulateParserHintSingleValueDictionary](this.default.bind(this), "default", key, value);
    return this;
  }
  defaults(key, value, defaultDescription) {
    return this.default(key, value, defaultDescription);
  }
  demandCommand(min = 1, max, minMsg, maxMsg) {
    argsert("[number] [number|string] [string|null|undefined] [string|null|undefined]", [min, max, minMsg, maxMsg], arguments.length);
    if (typeof max !== "number") {
      minMsg = max;
      max = Infinity;
    }
    this.global("_", false);
    __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedCommands._ = {
      min,
      max,
      minMsg,
      maxMsg
    };
    return this;
  }
  demand(keys, max, msg) {
    if (Array.isArray(max)) {
      max.forEach((key) => {
        assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
        this.demandOption(key, msg);
      });
      max = Infinity;
    } else if (typeof max !== "number") {
      msg = max;
      max = Infinity;
    }
    if (typeof keys === "number") {
      assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      this.demandCommand(keys, max, msg, msg);
    } else if (Array.isArray(keys)) {
      keys.forEach((key) => {
        assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
        this.demandOption(key, msg);
      });
    } else {
      if (typeof msg === "string") {
        this.demandOption(keys, msg);
      } else if (msg === true || typeof msg === "undefined") {
        this.demandOption(keys);
      }
    }
    return this;
  }
  demandOption(keys, msg) {
    argsert("<object|string|array> [string]", [keys, msg], arguments.length);
    this[kPopulateParserHintSingleValueDictionary](this.demandOption.bind(this), "demandedOptions", keys, msg);
    return this;
  }
  deprecateOption(option, message) {
    argsert("<string> [string|boolean]", [option, message], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_options, "f").deprecatedOptions[option] = message;
    return this;
  }
  describe(keys, description) {
    argsert("<object|string|array> [string]", [keys, description], arguments.length);
    this[kSetKey](keys, true);
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").describe(keys, description);
    return this;
  }
  detectLocale(detect) {
    argsert("<boolean>", [detect], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_detectLocale, detect, "f");
    return this;
  }
  env(prefix) {
    argsert("[string|boolean]", [prefix], arguments.length);
    if (prefix === false)
      delete __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix;
    else
      __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix = prefix || "";
    return this;
  }
  epilogue(msg) {
    argsert("<string>", [msg], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").epilog(msg);
    return this;
  }
  epilog(msg) {
    return this.epilogue(msg);
  }
  example(cmd, description) {
    argsert("<string|array> [string]", [cmd, description], arguments.length);
    if (Array.isArray(cmd)) {
      cmd.forEach((exampleParams) => this.example(...exampleParams));
    } else {
      __classPrivateFieldGet(this, _YargsInstance_usage, "f").example(cmd, description);
    }
    return this;
  }
  exit(code, err) {
    __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
    __classPrivateFieldSet(this, _YargsInstance_exitError, err, "f");
    if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"))
      __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.exit(code);
  }
  exitProcess(enabled = true) {
    argsert("[boolean]", [enabled], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_exitProcess, enabled, "f");
    return this;
  }
  fail(f) {
    argsert("<function|boolean>", [f], arguments.length);
    if (typeof f === "boolean" && f !== false) {
      throw new YError("Invalid first argument. Expected function or boolean 'false'");
    }
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").failFn(f);
    return this;
  }
  getAliases() {
    return this.parsed ? this.parsed.aliases : {};
  }
  async getCompletion(args, done) {
    argsert("<array> [function]", [args, done], arguments.length);
    if (!done) {
      return new Promise((resolve5, reject) => {
        __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(args, (err, completions) => {
          if (err)
            reject(err);
          else
            resolve5(completions);
        });
      });
    } else {
      return __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(args, done);
    }
  }
  getDemandedOptions() {
    argsert([], 0);
    return __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedOptions;
  }
  getDemandedCommands() {
    argsert([], 0);
    return __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedCommands;
  }
  getDeprecatedOptions() {
    argsert([], 0);
    return __classPrivateFieldGet(this, _YargsInstance_options, "f").deprecatedOptions;
  }
  getDetectLocale() {
    return __classPrivateFieldGet(this, _YargsInstance_detectLocale, "f");
  }
  getExitProcess() {
    return __classPrivateFieldGet(this, _YargsInstance_exitProcess, "f");
  }
  getGroups() {
    return Object.assign({}, __classPrivateFieldGet(this, _YargsInstance_groups, "f"), __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f"));
  }
  getHelp() {
    __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
    if (!__classPrivateFieldGet(this, _YargsInstance_usage, "f").hasCachedHelpMessage()) {
      if (!this.parsed) {
        const parse = this[kRunYargsParserAndExecuteCommands](__classPrivateFieldGet(this, _YargsInstance_processArgs, "f"), undefined, undefined, 0, true);
        if (isPromise(parse)) {
          return parse.then(() => {
            return __classPrivateFieldGet(this, _YargsInstance_usage, "f").help();
          });
        }
      }
      const builderResponse = __classPrivateFieldGet(this, _YargsInstance_command, "f").runDefaultBuilderOn(this);
      if (isPromise(builderResponse)) {
        return builderResponse.then(() => {
          return __classPrivateFieldGet(this, _YargsInstance_usage, "f").help();
        });
      }
    }
    return Promise.resolve(__classPrivateFieldGet(this, _YargsInstance_usage, "f").help());
  }
  getOptions() {
    return __classPrivateFieldGet(this, _YargsInstance_options, "f");
  }
  getStrict() {
    return __classPrivateFieldGet(this, _YargsInstance_strict, "f");
  }
  getStrictCommands() {
    return __classPrivateFieldGet(this, _YargsInstance_strictCommands, "f");
  }
  getStrictOptions() {
    return __classPrivateFieldGet(this, _YargsInstance_strictOptions, "f");
  }
  global(globals, global2) {
    argsert("<string|array> [boolean]", [globals, global2], arguments.length);
    globals = [].concat(globals);
    if (global2 !== false) {
      __classPrivateFieldGet(this, _YargsInstance_options, "f").local = __classPrivateFieldGet(this, _YargsInstance_options, "f").local.filter((l) => globals.indexOf(l) === -1);
    } else {
      globals.forEach((g) => {
        if (!__classPrivateFieldGet(this, _YargsInstance_options, "f").local.includes(g))
          __classPrivateFieldGet(this, _YargsInstance_options, "f").local.push(g);
      });
    }
    return this;
  }
  group(opts, groupName) {
    argsert("<string|array> <string>", [opts, groupName], arguments.length);
    const existing = __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName] || __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName];
    if (__classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName]) {
      delete __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName];
    }
    const seen = {};
    __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName] = (existing || []).concat(opts).filter((key) => {
      if (seen[key])
        return false;
      return seen[key] = true;
    });
    return this;
  }
  hide(key) {
    argsert("<string>", [key], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_options, "f").hiddenOptions.push(key);
    return this;
  }
  implies(key, value) {
    argsert("<string|object> [number|string|array]", [key, value], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_validation, "f").implies(key, value);
    return this;
  }
  locale(locale) {
    argsert("[string]", [locale], arguments.length);
    if (locale === undefined) {
      this[kGuessLocale]();
      return __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.getLocale();
    }
    __classPrivateFieldSet(this, _YargsInstance_detectLocale, false, "f");
    __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.setLocale(locale);
    return this;
  }
  middleware(callback, applyBeforeValidation, global2) {
    return __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").addMiddleware(callback, !!applyBeforeValidation, global2);
  }
  nargs(key, value) {
    argsert("<string|object|array> [number]", [key, value], arguments.length);
    this[kPopulateParserHintSingleValueDictionary](this.nargs.bind(this), "narg", key, value);
    return this;
  }
  normalize(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("normalize", keys);
    return this;
  }
  number(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("number", keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  option(key, opt) {
    argsert("<string|object> [object]", [key, opt], arguments.length);
    if (typeof key === "object") {
      Object.keys(key).forEach((k) => {
        this.options(k, key[k]);
      });
    } else {
      if (typeof opt !== "object") {
        opt = {};
      }
      this[kTrackManuallySetKeys](key);
      if (__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f") && (key === "version" || (opt === null || opt === undefined ? undefined : opt.alias) === "version")) {
        this[kEmitWarning]([
          '"version" is a reserved word.',
          "Please do one of the following:",
          '- Disable version with `yargs.version(false)` if using "version" as an option',
          "- Use the built-in `yargs.version` method instead (if applicable)",
          "- Use a different option key",
          "https://yargs.js.org/docs/#api-reference-version"
        ].join("\n"), undefined, "versionWarning");
      }
      __classPrivateFieldGet(this, _YargsInstance_options, "f").key[key] = true;
      if (opt.alias)
        this.alias(key, opt.alias);
      const deprecate = opt.deprecate || opt.deprecated;
      if (deprecate) {
        this.deprecateOption(key, deprecate);
      }
      const demand = opt.demand || opt.required || opt.require;
      if (demand) {
        this.demand(key, demand);
      }
      if (opt.demandOption) {
        this.demandOption(key, typeof opt.demandOption === "string" ? opt.demandOption : undefined);
      }
      if (opt.conflicts) {
        this.conflicts(key, opt.conflicts);
      }
      if ("default" in opt) {
        this.default(key, opt.default);
      }
      if (opt.implies !== undefined) {
        this.implies(key, opt.implies);
      }
      if (opt.nargs !== undefined) {
        this.nargs(key, opt.nargs);
      }
      if (opt.config) {
        this.config(key, opt.configParser);
      }
      if (opt.normalize) {
        this.normalize(key);
      }
      if (opt.choices) {
        this.choices(key, opt.choices);
      }
      if (opt.coerce) {
        this.coerce(key, opt.coerce);
      }
      if (opt.group) {
        this.group(key, opt.group);
      }
      if (opt.boolean || opt.type === "boolean") {
        this.boolean(key);
        if (opt.alias)
          this.boolean(opt.alias);
      }
      if (opt.array || opt.type === "array") {
        this.array(key);
        if (opt.alias)
          this.array(opt.alias);
      }
      if (opt.number || opt.type === "number") {
        this.number(key);
        if (opt.alias)
          this.number(opt.alias);
      }
      if (opt.string || opt.type === "string") {
        this.string(key);
        if (opt.alias)
          this.string(opt.alias);
      }
      if (opt.count || opt.type === "count") {
        this.count(key);
      }
      if (typeof opt.global === "boolean") {
        this.global(key, opt.global);
      }
      if (opt.defaultDescription) {
        __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = opt.defaultDescription;
      }
      if (opt.skipValidation) {
        this.skipValidation(key);
      }
      const desc = opt.describe || opt.description || opt.desc;
      const descriptions = __classPrivateFieldGet(this, _YargsInstance_usage, "f").getDescriptions();
      if (!Object.prototype.hasOwnProperty.call(descriptions, key) || typeof desc === "string") {
        this.describe(key, desc);
      }
      if (opt.hidden) {
        this.hide(key);
      }
      if (opt.requiresArg) {
        this.requiresArg(key);
      }
    }
    return this;
  }
  options(key, opt) {
    return this.option(key, opt);
  }
  parse(args, shortCircuit, _parseFn) {
    argsert("[string|array] [function|boolean|object] [function]", [args, shortCircuit, _parseFn], arguments.length);
    this[kFreeze]();
    if (typeof args === "undefined") {
      args = __classPrivateFieldGet(this, _YargsInstance_processArgs, "f");
    }
    if (typeof shortCircuit === "object") {
      __classPrivateFieldSet(this, _YargsInstance_parseContext, shortCircuit, "f");
      shortCircuit = _parseFn;
    }
    if (typeof shortCircuit === "function") {
      __classPrivateFieldSet(this, _YargsInstance_parseFn, shortCircuit, "f");
      shortCircuit = false;
    }
    if (!shortCircuit)
      __classPrivateFieldSet(this, _YargsInstance_processArgs, args, "f");
    if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f"))
      __classPrivateFieldSet(this, _YargsInstance_exitProcess, false, "f");
    const parsed = this[kRunYargsParserAndExecuteCommands](args, !!shortCircuit);
    const tmpParsed = this.parsed;
    __classPrivateFieldGet(this, _YargsInstance_completion, "f").setParsed(this.parsed);
    if (isPromise(parsed)) {
      return parsed.then((argv) => {
        if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f"))
          __classPrivateFieldGet(this, _YargsInstance_parseFn, "f").call(this, __classPrivateFieldGet(this, _YargsInstance_exitError, "f"), argv, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
        return argv;
      }).catch((err) => {
        if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f")) {
          __classPrivateFieldGet(this, _YargsInstance_parseFn, "f")(err, this.parsed.argv, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
        }
        throw err;
      }).finally(() => {
        this[kUnfreeze]();
        this.parsed = tmpParsed;
      });
    } else {
      if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f"))
        __classPrivateFieldGet(this, _YargsInstance_parseFn, "f").call(this, __classPrivateFieldGet(this, _YargsInstance_exitError, "f"), parsed, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
      this[kUnfreeze]();
      this.parsed = tmpParsed;
    }
    return parsed;
  }
  parseAsync(args, shortCircuit, _parseFn) {
    const maybePromise = this.parse(args, shortCircuit, _parseFn);
    return !isPromise(maybePromise) ? Promise.resolve(maybePromise) : maybePromise;
  }
  parseSync(args, shortCircuit, _parseFn) {
    const maybePromise = this.parse(args, shortCircuit, _parseFn);
    if (isPromise(maybePromise)) {
      throw new YError(".parseSync() must not be used with asynchronous builders, handlers, or middleware");
    }
    return maybePromise;
  }
  parserConfiguration(config) {
    argsert("<object>", [config], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_parserConfig, config, "f");
    return this;
  }
  pkgConf(key, rootPath) {
    argsert("<string> [string]", [key, rootPath], arguments.length);
    let conf = null;
    const obj = this[kPkgUp](rootPath || __classPrivateFieldGet(this, _YargsInstance_cwd, "f"));
    if (obj[key] && typeof obj[key] === "object") {
      conf = applyExtends(obj[key], rootPath || __classPrivateFieldGet(this, _YargsInstance_cwd, "f"), this[kGetParserConfiguration]()["deep-merge-config"] || false, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = (__classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || []).concat(conf);
    }
    return this;
  }
  positional(key, opts) {
    argsert("<string> <object>", [key, opts], arguments.length);
    const supportedOpts = [
      "default",
      "defaultDescription",
      "implies",
      "normalize",
      "choices",
      "conflicts",
      "coerce",
      "type",
      "describe",
      "desc",
      "description",
      "alias"
    ];
    opts = objFilter(opts, (k, v) => {
      if (k === "type" && !["string", "number", "boolean"].includes(v))
        return false;
      return supportedOpts.includes(k);
    });
    const fullCommand = __classPrivateFieldGet(this, _YargsInstance_context, "f").fullCommands[__classPrivateFieldGet(this, _YargsInstance_context, "f").fullCommands.length - 1];
    const parseOptions = fullCommand ? __classPrivateFieldGet(this, _YargsInstance_command, "f").cmdToParseOptions(fullCommand) : {
      array: [],
      alias: {},
      default: {},
      demand: {}
    };
    objectKeys(parseOptions).forEach((pk) => {
      const parseOption = parseOptions[pk];
      if (Array.isArray(parseOption)) {
        if (parseOption.indexOf(key) !== -1)
          opts[pk] = true;
      } else {
        if (parseOption[key] && !(pk in opts))
          opts[pk] = parseOption[key];
      }
    });
    this.group(key, __classPrivateFieldGet(this, _YargsInstance_usage, "f").getPositionalGroupName());
    return this.option(key, opts);
  }
  recommendCommands(recommend = true) {
    argsert("[boolean]", [recommend], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_recommendCommands, recommend, "f");
    return this;
  }
  required(keys, max, msg) {
    return this.demand(keys, max, msg);
  }
  require(keys, max, msg) {
    return this.demand(keys, max, msg);
  }
  requiresArg(keys) {
    argsert("<array|string|object> [number]", [keys], arguments.length);
    if (typeof keys === "string" && __classPrivateFieldGet(this, _YargsInstance_options, "f").narg[keys]) {
      return this;
    } else {
      this[kPopulateParserHintSingleValueDictionary](this.requiresArg.bind(this), "narg", keys, NaN);
    }
    return this;
  }
  showCompletionScript($0, cmd) {
    argsert("[string] [string]", [$0, cmd], arguments.length);
    $0 = $0 || this.$0;
    __classPrivateFieldGet(this, _YargsInstance_logger, "f").log(__classPrivateFieldGet(this, _YargsInstance_completion, "f").generateCompletionScript($0, cmd || __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") || "completion"));
    return this;
  }
  showHelp(level) {
    argsert("[string|function]", [level], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
    if (!__classPrivateFieldGet(this, _YargsInstance_usage, "f").hasCachedHelpMessage()) {
      if (!this.parsed) {
        const parse = this[kRunYargsParserAndExecuteCommands](__classPrivateFieldGet(this, _YargsInstance_processArgs, "f"), undefined, undefined, 0, true);
        if (isPromise(parse)) {
          parse.then(() => {
            __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
          });
          return this;
        }
      }
      const builderResponse = __classPrivateFieldGet(this, _YargsInstance_command, "f").runDefaultBuilderOn(this);
      if (isPromise(builderResponse)) {
        builderResponse.then(() => {
          __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
        });
        return this;
      }
    }
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
    return this;
  }
  scriptName(scriptName) {
    this.customScriptName = true;
    this.$0 = scriptName;
    return this;
  }
  showHelpOnFail(enabled, message) {
    argsert("[boolean|string] [string]", [enabled, message], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelpOnFail(enabled, message);
    return this;
  }
  showVersion(level) {
    argsert("[string|function]", [level], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").showVersion(level);
    return this;
  }
  skipValidation(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("skipValidation", keys);
    return this;
  }
  strict(enabled) {
    argsert("[boolean]", [enabled], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_strict, enabled !== false, "f");
    return this;
  }
  strictCommands(enabled) {
    argsert("[boolean]", [enabled], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_strictCommands, enabled !== false, "f");
    return this;
  }
  strictOptions(enabled) {
    argsert("[boolean]", [enabled], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_strictOptions, enabled !== false, "f");
    return this;
  }
  string(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("string", keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  terminalWidth() {
    argsert([], 0);
    return __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.stdColumns;
  }
  updateLocale(obj) {
    return this.updateStrings(obj);
  }
  updateStrings(obj) {
    argsert("<object>", [obj], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_detectLocale, false, "f");
    __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.updateLocale(obj);
    return this;
  }
  usage(msg, description, builder, handler) {
    argsert("<string|null|undefined> [string|boolean] [function|object] [function]", [msg, description, builder, handler], arguments.length);
    if (description !== undefined) {
      assertNotStrictEqual(msg, null, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      if ((msg || "").match(/^\$0( |$)/)) {
        return this.command(msg, description, builder, handler);
      } else {
        throw new YError(".usage() description must start with $0 if being used as alias for .command()");
      }
    } else {
      __classPrivateFieldGet(this, _YargsInstance_usage, "f").usage(msg);
      return this;
    }
  }
  usageConfiguration(config) {
    argsert("<object>", [config], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_usageConfig, config, "f");
    return this;
  }
  version(opt, msg, ver) {
    const defaultVersionOpt = "version";
    argsert("[boolean|string] [string] [string]", [opt, msg, ver], arguments.length);
    if (__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f")) {
      this[kDeleteFromParserHintObject](__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"));
      __classPrivateFieldGet(this, _YargsInstance_usage, "f").version(undefined);
      __classPrivateFieldSet(this, _YargsInstance_versionOpt, null, "f");
    }
    if (arguments.length === 0) {
      ver = this[kGuessVersion]();
      opt = defaultVersionOpt;
    } else if (arguments.length === 1) {
      if (opt === false) {
        return this;
      }
      ver = opt;
      opt = defaultVersionOpt;
    } else if (arguments.length === 2) {
      ver = msg;
      msg = undefined;
    }
    __classPrivateFieldSet(this, _YargsInstance_versionOpt, typeof opt === "string" ? opt : defaultVersionOpt, "f");
    msg = msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup("Show version number");
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").version(ver || undefined);
    this.boolean(__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"));
    this.describe(__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"), msg);
    return this;
  }
  wrap(cols) {
    argsert("<number|null|undefined>", [cols], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").wrap(cols);
    return this;
  }
  [(_YargsInstance_command = new WeakMap, _YargsInstance_cwd = new WeakMap, _YargsInstance_context = new WeakMap, _YargsInstance_completion = new WeakMap, _YargsInstance_completionCommand = new WeakMap, _YargsInstance_defaultShowHiddenOpt = new WeakMap, _YargsInstance_exitError = new WeakMap, _YargsInstance_detectLocale = new WeakMap, _YargsInstance_emittedWarnings = new WeakMap, _YargsInstance_exitProcess = new WeakMap, _YargsInstance_frozens = new WeakMap, _YargsInstance_globalMiddleware = new WeakMap, _YargsInstance_groups = new WeakMap, _YargsInstance_hasOutput = new WeakMap, _YargsInstance_helpOpt = new WeakMap, _YargsInstance_isGlobalContext = new WeakMap, _YargsInstance_logger = new WeakMap, _YargsInstance_output = new WeakMap, _YargsInstance_options = new WeakMap, _YargsInstance_parentRequire = new WeakMap, _YargsInstance_parserConfig = new WeakMap, _YargsInstance_parseFn = new WeakMap, _YargsInstance_parseContext = new WeakMap, _YargsInstance_pkgs = new WeakMap, _YargsInstance_preservedGroups = new WeakMap, _YargsInstance_processArgs = new WeakMap, _YargsInstance_recommendCommands = new WeakMap, _YargsInstance_shim = new WeakMap, _YargsInstance_strict = new WeakMap, _YargsInstance_strictCommands = new WeakMap, _YargsInstance_strictOptions = new WeakMap, _YargsInstance_usage = new WeakMap, _YargsInstance_usageConfig = new WeakMap, _YargsInstance_versionOpt = new WeakMap, _YargsInstance_validation = new WeakMap, kCopyDoubleDash)](argv) {
    if (!argv._ || !argv["--"])
      return argv;
    argv._.push.apply(argv._, argv["--"]);
    try {
      delete argv["--"];
    } catch (_err) {
    }
    return argv;
  }
  [kCreateLogger]() {
    return {
      log: (...args) => {
        if (!this[kHasParseCallback]())
          console.log(...args);
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
        if (__classPrivateFieldGet(this, _YargsInstance_output, "f").length)
          __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + "\n", "f");
        __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + args.join(" "), "f");
      },
      error: (...args) => {
        if (!this[kHasParseCallback]())
          console.error(...args);
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
        if (__classPrivateFieldGet(this, _YargsInstance_output, "f").length)
          __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + "\n", "f");
        __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + args.join(" "), "f");
      }
    };
  }
  [kDeleteFromParserHintObject](optionKey) {
    objectKeys(__classPrivateFieldGet(this, _YargsInstance_options, "f")).forEach((hintKey) => {
      if (((key) => key === "configObjects")(hintKey))
        return;
      const hint = __classPrivateFieldGet(this, _YargsInstance_options, "f")[hintKey];
      if (Array.isArray(hint)) {
        if (hint.includes(optionKey))
          hint.splice(hint.indexOf(optionKey), 1);
      } else if (typeof hint === "object") {
        delete hint[optionKey];
      }
    });
    delete __classPrivateFieldGet(this, _YargsInstance_usage, "f").getDescriptions()[optionKey];
  }
  [kEmitWarning](warning, type, deduplicationId) {
    if (!__classPrivateFieldGet(this, _YargsInstance_emittedWarnings, "f")[deduplicationId]) {
      __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.emitWarning(warning, type);
      __classPrivateFieldGet(this, _YargsInstance_emittedWarnings, "f")[deduplicationId] = true;
    }
  }
  [kFreeze]() {
    __classPrivateFieldGet(this, _YargsInstance_frozens, "f").push({
      options: __classPrivateFieldGet(this, _YargsInstance_options, "f"),
      configObjects: __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects.slice(0),
      exitProcess: __classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"),
      groups: __classPrivateFieldGet(this, _YargsInstance_groups, "f"),
      strict: __classPrivateFieldGet(this, _YargsInstance_strict, "f"),
      strictCommands: __classPrivateFieldGet(this, _YargsInstance_strictCommands, "f"),
      strictOptions: __classPrivateFieldGet(this, _YargsInstance_strictOptions, "f"),
      completionCommand: __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f"),
      output: __classPrivateFieldGet(this, _YargsInstance_output, "f"),
      exitError: __classPrivateFieldGet(this, _YargsInstance_exitError, "f"),
      hasOutput: __classPrivateFieldGet(this, _YargsInstance_hasOutput, "f"),
      parsed: this.parsed,
      parseFn: __classPrivateFieldGet(this, _YargsInstance_parseFn, "f"),
      parseContext: __classPrivateFieldGet(this, _YargsInstance_parseContext, "f")
    });
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").freeze();
    __classPrivateFieldGet(this, _YargsInstance_validation, "f").freeze();
    __classPrivateFieldGet(this, _YargsInstance_command, "f").freeze();
    __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").freeze();
  }
  [kGetDollarZero]() {
    let $0 = "";
    let default$0;
    if (/\b(node|iojs|electron)(\.exe)?$/.test(__classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv()[0])) {
      default$0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv().slice(1, 2);
    } else {
      default$0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv().slice(0, 1);
    }
    $0 = default$0.map((x) => {
      const b = this[kRebase](__classPrivateFieldGet(this, _YargsInstance_cwd, "f"), x);
      return x.match(/^(\/|([a-zA-Z]:)?\\)/) && b.length < x.length ? b : x;
    }).join(" ").trim();
    if (__classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("_") && __classPrivateFieldGet(this, _YargsInstance_shim, "f").getProcessArgvBin() === __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("_")) {
      $0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("_").replace(`${__classPrivateFieldGet(this, _YargsInstance_shim, "f").path.dirname(__classPrivateFieldGet(this, _YargsInstance_shim, "f").process.execPath())}/`, "");
    }
    return $0;
  }
  [kGetParserConfiguration]() {
    return __classPrivateFieldGet(this, _YargsInstance_parserConfig, "f");
  }
  [kGetUsageConfiguration]() {
    return __classPrivateFieldGet(this, _YargsInstance_usageConfig, "f");
  }
  [kGuessLocale]() {
    if (!__classPrivateFieldGet(this, _YargsInstance_detectLocale, "f"))
      return;
    const locale = __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("LC_ALL") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("LC_MESSAGES") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("LANG") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("LANGUAGE") || "en_US";
    this.locale(locale.replace(/[.:].*/, ""));
  }
  [kGuessVersion]() {
    const obj = this[kPkgUp]();
    return obj.version || "unknown";
  }
  [kParsePositionalNumbers](argv) {
    const args = argv["--"] ? argv["--"] : argv._;
    for (let i = 0, arg;(arg = args[i]) !== undefined; i++) {
      if (__classPrivateFieldGet(this, _YargsInstance_shim, "f").Parser.looksLikeNumber(arg) && Number.isSafeInteger(Math.floor(parseFloat(`${arg}`)))) {
        args[i] = Number(arg);
      }
    }
    return argv;
  }
  [kPkgUp](rootPath) {
    const npath = rootPath || "*";
    if (__classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath])
      return __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath];
    let obj = {};
    try {
      let startDir = rootPath || __classPrivateFieldGet(this, _YargsInstance_shim, "f").mainFilename;
      if (!rootPath && __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.extname(startDir)) {
        startDir = __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.dirname(startDir);
      }
      const pkgJsonPath = __classPrivateFieldGet(this, _YargsInstance_shim, "f").findUp(startDir, (dir, names) => {
        if (names.includes("package.json")) {
          return "package.json";
        } else {
          return;
        }
      });
      assertNotStrictEqual(pkgJsonPath, undefined, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      obj = JSON.parse(__classPrivateFieldGet(this, _YargsInstance_shim, "f").readFileSync(pkgJsonPath, "utf8"));
    } catch (_noop) {
    }
    __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath] = obj || {};
    return __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath];
  }
  [kPopulateParserHintArray](type, keys) {
    keys = [].concat(keys);
    keys.forEach((key) => {
      key = this[kSanitizeKey](key);
      __classPrivateFieldGet(this, _YargsInstance_options, "f")[type].push(key);
    });
  }
  [kPopulateParserHintSingleValueDictionary](builder, type, key, value) {
    this[kPopulateParserHintDictionary](builder, type, key, value, (type2, key2, value2) => {
      __classPrivateFieldGet(this, _YargsInstance_options, "f")[type2][key2] = value2;
    });
  }
  [kPopulateParserHintArrayDictionary](builder, type, key, value) {
    this[kPopulateParserHintDictionary](builder, type, key, value, (type2, key2, value2) => {
      __classPrivateFieldGet(this, _YargsInstance_options, "f")[type2][key2] = (__classPrivateFieldGet(this, _YargsInstance_options, "f")[type2][key2] || []).concat(value2);
    });
  }
  [kPopulateParserHintDictionary](builder, type, key, value, singleKeyHandler) {
    if (Array.isArray(key)) {
      key.forEach((k) => {
        builder(k, value);
      });
    } else if (((key2) => typeof key2 === "object")(key)) {
      for (const k of objectKeys(key)) {
        builder(k, key[k]);
      }
    } else {
      singleKeyHandler(type, this[kSanitizeKey](key), value);
    }
  }
  [kSanitizeKey](key) {
    if (key === "__proto__")
      return "___proto___";
    return key;
  }
  [kSetKey](key, set) {
    this[kPopulateParserHintSingleValueDictionary](this[kSetKey].bind(this), "key", key, set);
    return this;
  }
  [kUnfreeze]() {
    var _a2, _b2, _c2, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const frozen = __classPrivateFieldGet(this, _YargsInstance_frozens, "f").pop();
    assertNotStrictEqual(frozen, undefined, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
    let configObjects;
    _a2 = this, _b2 = this, _c2 = this, _d = this, _e = this, _f = this, _g = this, _h = this, _j = this, _k = this, _l = this, _m = this, {
      options: { set value(_o) {
        __classPrivateFieldSet(_a2, _YargsInstance_options, _o, "f");
      } }.value,
      configObjects,
      exitProcess: { set value(_o) {
        __classPrivateFieldSet(_b2, _YargsInstance_exitProcess, _o, "f");
      } }.value,
      groups: { set value(_o) {
        __classPrivateFieldSet(_c2, _YargsInstance_groups, _o, "f");
      } }.value,
      output: { set value(_o) {
        __classPrivateFieldSet(_d, _YargsInstance_output, _o, "f");
      } }.value,
      exitError: { set value(_o) {
        __classPrivateFieldSet(_e, _YargsInstance_exitError, _o, "f");
      } }.value,
      hasOutput: { set value(_o) {
        __classPrivateFieldSet(_f, _YargsInstance_hasOutput, _o, "f");
      } }.value,
      parsed: this.parsed,
      strict: { set value(_o) {
        __classPrivateFieldSet(_g, _YargsInstance_strict, _o, "f");
      } }.value,
      strictCommands: { set value(_o) {
        __classPrivateFieldSet(_h, _YargsInstance_strictCommands, _o, "f");
      } }.value,
      strictOptions: { set value(_o) {
        __classPrivateFieldSet(_j, _YargsInstance_strictOptions, _o, "f");
      } }.value,
      completionCommand: { set value(_o) {
        __classPrivateFieldSet(_k, _YargsInstance_completionCommand, _o, "f");
      } }.value,
      parseFn: { set value(_o) {
        __classPrivateFieldSet(_l, _YargsInstance_parseFn, _o, "f");
      } }.value,
      parseContext: { set value(_o) {
        __classPrivateFieldSet(_m, _YargsInstance_parseContext, _o, "f");
      } }.value
    } = frozen;
    __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = configObjects;
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").unfreeze();
    __classPrivateFieldGet(this, _YargsInstance_validation, "f").unfreeze();
    __classPrivateFieldGet(this, _YargsInstance_command, "f").unfreeze();
    __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").unfreeze();
  }
  [kValidateAsync](validation3, argv) {
    return maybeAsyncResult(argv, (result) => {
      validation3(result);
      return result;
    });
  }
  getInternalMethods() {
    return {
      getCommandInstance: this[kGetCommandInstance].bind(this),
      getContext: this[kGetContext].bind(this),
      getHasOutput: this[kGetHasOutput].bind(this),
      getLoggerInstance: this[kGetLoggerInstance].bind(this),
      getParseContext: this[kGetParseContext].bind(this),
      getParserConfiguration: this[kGetParserConfiguration].bind(this),
      getUsageConfiguration: this[kGetUsageConfiguration].bind(this),
      getUsageInstance: this[kGetUsageInstance].bind(this),
      getValidationInstance: this[kGetValidationInstance].bind(this),
      hasParseCallback: this[kHasParseCallback].bind(this),
      isGlobalContext: this[kIsGlobalContext].bind(this),
      postProcess: this[kPostProcess].bind(this),
      reset: this[kReset].bind(this),
      runValidation: this[kRunValidation].bind(this),
      runYargsParserAndExecuteCommands: this[kRunYargsParserAndExecuteCommands].bind(this),
      setHasOutput: this[kSetHasOutput].bind(this)
    };
  }
  [kGetCommandInstance]() {
    return __classPrivateFieldGet(this, _YargsInstance_command, "f");
  }
  [kGetContext]() {
    return __classPrivateFieldGet(this, _YargsInstance_context, "f");
  }
  [kGetHasOutput]() {
    return __classPrivateFieldGet(this, _YargsInstance_hasOutput, "f");
  }
  [kGetLoggerInstance]() {
    return __classPrivateFieldGet(this, _YargsInstance_logger, "f");
  }
  [kGetParseContext]() {
    return __classPrivateFieldGet(this, _YargsInstance_parseContext, "f") || {};
  }
  [kGetUsageInstance]() {
    return __classPrivateFieldGet(this, _YargsInstance_usage, "f");
  }
  [kGetValidationInstance]() {
    return __classPrivateFieldGet(this, _YargsInstance_validation, "f");
  }
  [kHasParseCallback]() {
    return !!__classPrivateFieldGet(this, _YargsInstance_parseFn, "f");
  }
  [kIsGlobalContext]() {
    return __classPrivateFieldGet(this, _YargsInstance_isGlobalContext, "f");
  }
  [kPostProcess](argv, populateDoubleDash, calledFromCommand, runGlobalMiddleware) {
    if (calledFromCommand)
      return argv;
    if (isPromise(argv))
      return argv;
    if (!populateDoubleDash) {
      argv = this[kCopyDoubleDash](argv);
    }
    const parsePositionalNumbers = this[kGetParserConfiguration]()["parse-positional-numbers"] || this[kGetParserConfiguration]()["parse-positional-numbers"] === undefined;
    if (parsePositionalNumbers) {
      argv = this[kParsePositionalNumbers](argv);
    }
    if (runGlobalMiddleware) {
      argv = applyMiddleware(argv, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), false);
    }
    return argv;
  }
  [kReset](aliases = {}) {
    __classPrivateFieldSet(this, _YargsInstance_options, __classPrivateFieldGet(this, _YargsInstance_options, "f") || {}, "f");
    const tmpOptions = {};
    tmpOptions.local = __classPrivateFieldGet(this, _YargsInstance_options, "f").local || [];
    tmpOptions.configObjects = __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || [];
    const localLookup = {};
    tmpOptions.local.forEach((l) => {
      localLookup[l] = true;
      (aliases[l] || []).forEach((a) => {
        localLookup[a] = true;
      });
    });
    Object.assign(__classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f"), Object.keys(__classPrivateFieldGet(this, _YargsInstance_groups, "f")).reduce((acc, groupName) => {
      const keys = __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName].filter((key) => !(key in localLookup));
      if (keys.length > 0) {
        acc[groupName] = keys;
      }
      return acc;
    }, {}));
    __classPrivateFieldSet(this, _YargsInstance_groups, {}, "f");
    const arrayOptions = [
      "array",
      "boolean",
      "string",
      "skipValidation",
      "count",
      "normalize",
      "number",
      "hiddenOptions"
    ];
    const objectOptions = [
      "narg",
      "key",
      "alias",
      "default",
      "defaultDescription",
      "config",
      "choices",
      "demandedOptions",
      "demandedCommands",
      "deprecatedOptions"
    ];
    arrayOptions.forEach((k) => {
      tmpOptions[k] = (__classPrivateFieldGet(this, _YargsInstance_options, "f")[k] || []).filter((k2) => !localLookup[k2]);
    });
    objectOptions.forEach((k) => {
      tmpOptions[k] = objFilter(__classPrivateFieldGet(this, _YargsInstance_options, "f")[k], (k2) => !localLookup[k2]);
    });
    tmpOptions.envPrefix = __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix;
    __classPrivateFieldSet(this, _YargsInstance_options, tmpOptions, "f");
    __classPrivateFieldSet(this, _YargsInstance_usage, __classPrivateFieldGet(this, _YargsInstance_usage, "f") ? __classPrivateFieldGet(this, _YargsInstance_usage, "f").reset(localLookup) : usage(this, __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
    __classPrivateFieldSet(this, _YargsInstance_validation, __classPrivateFieldGet(this, _YargsInstance_validation, "f") ? __classPrivateFieldGet(this, _YargsInstance_validation, "f").reset(localLookup) : validation(this, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
    __classPrivateFieldSet(this, _YargsInstance_command, __classPrivateFieldGet(this, _YargsInstance_command, "f") ? __classPrivateFieldGet(this, _YargsInstance_command, "f").reset() : command(__classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_validation, "f"), __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
    if (!__classPrivateFieldGet(this, _YargsInstance_completion, "f"))
      __classPrivateFieldSet(this, _YargsInstance_completion, completion(this, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_command, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
    __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").reset();
    __classPrivateFieldSet(this, _YargsInstance_completionCommand, null, "f");
    __classPrivateFieldSet(this, _YargsInstance_output, "", "f");
    __classPrivateFieldSet(this, _YargsInstance_exitError, null, "f");
    __classPrivateFieldSet(this, _YargsInstance_hasOutput, false, "f");
    this.parsed = false;
    return this;
  }
  [kRebase](base, dir) {
    return __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.relative(base, dir);
  }
  [kRunYargsParserAndExecuteCommands](args, shortCircuit, calledFromCommand, commandIndex = 0, helpOnly = false) {
    let skipValidation = !!calledFromCommand || helpOnly;
    args = args || __classPrivateFieldGet(this, _YargsInstance_processArgs, "f");
    __classPrivateFieldGet(this, _YargsInstance_options, "f").__ = __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.__;
    __classPrivateFieldGet(this, _YargsInstance_options, "f").configuration = this[kGetParserConfiguration]();
    const populateDoubleDash = !!__classPrivateFieldGet(this, _YargsInstance_options, "f").configuration["populate--"];
    const config = Object.assign({}, __classPrivateFieldGet(this, _YargsInstance_options, "f").configuration, {
      "populate--": true
    });
    const parsed = __classPrivateFieldGet(this, _YargsInstance_shim, "f").Parser.detailed(args, Object.assign({}, __classPrivateFieldGet(this, _YargsInstance_options, "f"), {
      configuration: { "parse-positional-numbers": false, ...config }
    }));
    const argv = Object.assign(parsed.argv, __classPrivateFieldGet(this, _YargsInstance_parseContext, "f"));
    let argvPromise = undefined;
    const aliases = parsed.aliases;
    let helpOptSet = false;
    let versionOptSet = false;
    Object.keys(argv).forEach((key) => {
      if (key === __classPrivateFieldGet(this, _YargsInstance_helpOpt, "f") && argv[key]) {
        helpOptSet = true;
      } else if (key === __classPrivateFieldGet(this, _YargsInstance_versionOpt, "f") && argv[key]) {
        versionOptSet = true;
      }
    });
    argv.$0 = this.$0;
    this.parsed = parsed;
    if (commandIndex === 0) {
      __classPrivateFieldGet(this, _YargsInstance_usage, "f").clearCachedHelpMessage();
    }
    try {
      this[kGuessLocale]();
      if (shortCircuit) {
        return this[kPostProcess](argv, populateDoubleDash, !!calledFromCommand, false);
      }
      if (__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")) {
        const helpCmds = [__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")].concat(aliases[__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")] || []).filter((k) => k.length > 1);
        if (helpCmds.includes("" + argv._[argv._.length - 1])) {
          argv._.pop();
          helpOptSet = true;
        }
      }
      __classPrivateFieldSet(this, _YargsInstance_isGlobalContext, false, "f");
      const handlerKeys = __classPrivateFieldGet(this, _YargsInstance_command, "f").getCommands();
      const requestCompletions = __classPrivateFieldGet(this, _YargsInstance_completion, "f").completionKey in argv;
      const skipRecommendation = helpOptSet || requestCompletions || helpOnly;
      if (argv._.length) {
        if (handlerKeys.length) {
          let firstUnknownCommand;
          for (let i = commandIndex || 0, cmd;argv._[i] !== undefined; i++) {
            cmd = String(argv._[i]);
            if (handlerKeys.includes(cmd) && cmd !== __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) {
              const innerArgv = __classPrivateFieldGet(this, _YargsInstance_command, "f").runCommand(cmd, this, parsed, i + 1, helpOnly, helpOptSet || versionOptSet || helpOnly);
              return this[kPostProcess](innerArgv, populateDoubleDash, !!calledFromCommand, false);
            } else if (!firstUnknownCommand && cmd !== __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) {
              firstUnknownCommand = cmd;
              break;
            }
          }
          if (!__classPrivateFieldGet(this, _YargsInstance_command, "f").hasDefaultCommand() && __classPrivateFieldGet(this, _YargsInstance_recommendCommands, "f") && firstUnknownCommand && !skipRecommendation) {
            __classPrivateFieldGet(this, _YargsInstance_validation, "f").recommendCommands(firstUnknownCommand, handlerKeys);
          }
        }
        if (__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") && argv._.includes(__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) && !requestCompletions) {
          if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"))
            setBlocking(true);
          this.showCompletionScript();
          this.exit(0);
        }
      }
      if (__classPrivateFieldGet(this, _YargsInstance_command, "f").hasDefaultCommand() && !skipRecommendation) {
        const innerArgv = __classPrivateFieldGet(this, _YargsInstance_command, "f").runCommand(null, this, parsed, 0, helpOnly, helpOptSet || versionOptSet || helpOnly);
        return this[kPostProcess](innerArgv, populateDoubleDash, !!calledFromCommand, false);
      }
      if (requestCompletions) {
        if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"))
          setBlocking(true);
        args = [].concat(args);
        const completionArgs = args.slice(args.indexOf(`--${__classPrivateFieldGet(this, _YargsInstance_completion, "f").completionKey}`) + 1);
        __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(completionArgs, (err, completions) => {
          if (err)
            throw new YError(err.message);
          (completions || []).forEach((completion3) => {
            __classPrivateFieldGet(this, _YargsInstance_logger, "f").log(completion3);
          });
          this.exit(0);
        });
        return this[kPostProcess](argv, !populateDoubleDash, !!calledFromCommand, false);
      }
      if (!__classPrivateFieldGet(this, _YargsInstance_hasOutput, "f")) {
        if (helpOptSet) {
          if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"))
            setBlocking(true);
          skipValidation = true;
          this.showHelp("log");
          this.exit(0);
        } else if (versionOptSet) {
          if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"))
            setBlocking(true);
          skipValidation = true;
          __classPrivateFieldGet(this, _YargsInstance_usage, "f").showVersion("log");
          this.exit(0);
        }
      }
      if (!skipValidation && __classPrivateFieldGet(this, _YargsInstance_options, "f").skipValidation.length > 0) {
        skipValidation = Object.keys(argv).some((key) => __classPrivateFieldGet(this, _YargsInstance_options, "f").skipValidation.indexOf(key) >= 0 && argv[key] === true);
      }
      if (!skipValidation) {
        if (parsed.error)
          throw new YError(parsed.error.message);
        if (!requestCompletions) {
          const validation3 = this[kRunValidation](aliases, {}, parsed.error);
          if (!calledFromCommand) {
            argvPromise = applyMiddleware(argv, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), true);
          }
          argvPromise = this[kValidateAsync](validation3, argvPromise !== null && argvPromise !== undefined ? argvPromise : argv);
          if (isPromise(argvPromise) && !calledFromCommand) {
            argvPromise = argvPromise.then(() => {
              return applyMiddleware(argv, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), false);
            });
          }
        }
      }
    } catch (err) {
      if (err instanceof YError)
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(err.message, err);
      else
        throw err;
    }
    return this[kPostProcess](argvPromise !== null && argvPromise !== undefined ? argvPromise : argv, populateDoubleDash, !!calledFromCommand, true);
  }
  [kRunValidation](aliases, positionalMap, parseErrors, isDefaultCommand) {
    const demandedOptions = { ...this.getDemandedOptions() };
    return (argv) => {
      if (parseErrors)
        throw new YError(parseErrors.message);
      __classPrivateFieldGet(this, _YargsInstance_validation, "f").nonOptionCount(argv);
      __classPrivateFieldGet(this, _YargsInstance_validation, "f").requiredArguments(argv, demandedOptions);
      let failedStrictCommands = false;
      if (__classPrivateFieldGet(this, _YargsInstance_strictCommands, "f")) {
        failedStrictCommands = __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownCommands(argv);
      }
      if (__classPrivateFieldGet(this, _YargsInstance_strict, "f") && !failedStrictCommands) {
        __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownArguments(argv, aliases, positionalMap, !!isDefaultCommand);
      } else if (__classPrivateFieldGet(this, _YargsInstance_strictOptions, "f")) {
        __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownArguments(argv, aliases, {}, false, false);
      }
      __classPrivateFieldGet(this, _YargsInstance_validation, "f").limitedChoices(argv);
      __classPrivateFieldGet(this, _YargsInstance_validation, "f").implications(argv);
      __classPrivateFieldGet(this, _YargsInstance_validation, "f").conflicting(argv);
    };
  }
  [kSetHasOutput]() {
    __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
  }
  [kTrackManuallySetKeys](keys) {
    if (typeof keys === "string") {
      __classPrivateFieldGet(this, _YargsInstance_options, "f").key[keys] = true;
    } else {
      for (const k of keys) {
        __classPrivateFieldGet(this, _YargsInstance_options, "f").key[k] = true;
      }
    }
  }
}

// /home/mous/work/pimlico/alto/src/node_modules/yargs/index.mjs
var Yargs = YargsFactory(esm_default);
var yargs_default = Yargs;

// entrypoint-0.6/types/contracts/BundleBulker.ts
var BundleBulkerAbi = [
  {
    type: "fallback",
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "ENTRY_POINT",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "idToInflator",
    inputs: [
      {
        name: "",
        type: "uint32",
        internalType: "uint32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract IInflator"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "inflate",
    inputs: [
      {
        name: "compressed",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [
      {
        name: "ops",
        type: "tuple[]",
        internalType: "struct UserOperation[]",
        components: [
          {
            name: "sender",
            type: "address",
            internalType: "address"
          },
          {
            name: "nonce",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "initCode",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "callData",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "callGasLimit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "verificationGasLimit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "maxFeePerGas",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "paymasterAndData",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "signature",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "beneficiary",
        type: "address",
        internalType: "address payable"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "inflatorToID",
    inputs: [
      {
        name: "",
        type: "address",
        internalType: "contract IInflator"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint32",
        internalType: "uint32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "registerInflator",
    inputs: [
      {
        name: "inflatorId",
        type: "uint32",
        internalType: "uint32"
      },
      {
        name: "inflator",
        type: "address",
        internalType: "contract IInflator"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  }
];
// entrypoint-0.6/types/contracts/CallEngine.ts
var CallEngineAbi = [
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        internalType: "struct Instruction[]",
        name: "instructions",
        type: "tuple[]"
      }
    ],
    name: "execute",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];
// entrypoint-0.6/types/contracts/EntryPoint.ts
var EntryPointAbi = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "preOpGas",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "paid",
        type: "uint256"
      },
      {
        internalType: "uint48",
        name: "validAfter",
        type: "uint48"
      },
      {
        internalType: "uint48",
        name: "validUntil",
        type: "uint48"
      },
      {
        internalType: "bool",
        name: "targetSuccess",
        type: "bool"
      },
      {
        internalType: "bytes",
        name: "targetResult",
        type: "bytes"
      }
    ],
    name: "ExecutionResult",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "opIndex",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "reason",
        type: "string"
      }
    ],
    name: "FailedOp",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "SenderAddressResult",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "aggregator",
        type: "address"
      }
    ],
    name: "SignatureValidationFailed",
    type: "error"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "preOpGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "prefund",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "sigFailed",
            type: "bool"
          },
          {
            internalType: "uint48",
            name: "validAfter",
            type: "uint48"
          },
          {
            internalType: "uint48",
            name: "validUntil",
            type: "uint48"
          },
          {
            internalType: "bytes",
            name: "paymasterContext",
            type: "bytes"
          }
        ],
        internalType: "struct IEntryPoint.ReturnInfo",
        name: "returnInfo",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "stake",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "unstakeDelaySec",
            type: "uint256"
          }
        ],
        internalType: "struct IStakeManager.StakeInfo",
        name: "senderInfo",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "stake",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "unstakeDelaySec",
            type: "uint256"
          }
        ],
        internalType: "struct IStakeManager.StakeInfo",
        name: "factoryInfo",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "stake",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "unstakeDelaySec",
            type: "uint256"
          }
        ],
        internalType: "struct IStakeManager.StakeInfo",
        name: "paymasterInfo",
        type: "tuple"
      }
    ],
    name: "ValidationResult",
    type: "error"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "preOpGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "prefund",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "sigFailed",
            type: "bool"
          },
          {
            internalType: "uint48",
            name: "validAfter",
            type: "uint48"
          },
          {
            internalType: "uint48",
            name: "validUntil",
            type: "uint48"
          },
          {
            internalType: "bytes",
            name: "paymasterContext",
            type: "bytes"
          }
        ],
        internalType: "struct IEntryPoint.ReturnInfo",
        name: "returnInfo",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "stake",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "unstakeDelaySec",
            type: "uint256"
          }
        ],
        internalType: "struct IStakeManager.StakeInfo",
        name: "senderInfo",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "stake",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "unstakeDelaySec",
            type: "uint256"
          }
        ],
        internalType: "struct IStakeManager.StakeInfo",
        name: "factoryInfo",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "stake",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "unstakeDelaySec",
            type: "uint256"
          }
        ],
        internalType: "struct IStakeManager.StakeInfo",
        name: "paymasterInfo",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "address",
            name: "aggregator",
            type: "address"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "stakeInfo",
            type: "tuple"
          }
        ],
        internalType: "struct IEntryPoint.AggregatorStakeInfo",
        name: "aggregatorInfo",
        type: "tuple"
      }
    ],
    name: "ValidationResultWithAggregation",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "factory",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "paymaster",
        type: "address"
      }
    ],
    name: "AccountDeployed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [],
    name: "BeforeExecution",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalDeposit",
        type: "uint256"
      }
    ],
    name: "Deposited",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "aggregator",
        type: "address"
      }
    ],
    name: "SignatureAggregatorChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalStaked",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "unstakeDelaySec",
        type: "uint256"
      }
    ],
    name: "StakeLocked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "withdrawTime",
        type: "uint256"
      }
    ],
    name: "StakeUnlocked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "StakeWithdrawn",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "paymaster",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "actualGasCost",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "actualGasUsed",
        type: "uint256"
      }
    ],
    name: "UserOperationEvent",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "UserOperationRevertReason",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Withdrawn",
    type: "event"
  },
  {
    inputs: [],
    name: "SIG_VALIDATION_FAILED",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "initCode",
        type: "bytes"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "paymasterAndData",
        type: "bytes"
      }
    ],
    name: "_validateSenderAndPaymaster",
    outputs: [],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "unstakeDelaySec",
        type: "uint32"
      }
    ],
    name: "addStake",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "depositTo",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "deposits",
    outputs: [
      {
        internalType: "uint112",
        name: "deposit",
        type: "uint112"
      },
      {
        internalType: "bool",
        name: "staked",
        type: "bool"
      },
      {
        internalType: "uint112",
        name: "stake",
        type: "uint112"
      },
      {
        internalType: "uint32",
        name: "unstakeDelaySec",
        type: "uint32"
      },
      {
        internalType: "uint48",
        name: "withdrawTime",
        type: "uint48"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "getDepositInfo",
    outputs: [
      {
        components: [
          {
            internalType: "uint112",
            name: "deposit",
            type: "uint112"
          },
          {
            internalType: "bool",
            name: "staked",
            type: "bool"
          },
          {
            internalType: "uint112",
            name: "stake",
            type: "uint112"
          },
          {
            internalType: "uint32",
            name: "unstakeDelaySec",
            type: "uint32"
          },
          {
            internalType: "uint48",
            name: "withdrawTime",
            type: "uint48"
          }
        ],
        internalType: "struct IStakeManager.DepositInfo",
        name: "info",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "uint192",
        name: "key",
        type: "uint192"
      }
    ],
    name: "getNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "initCode",
        type: "bytes"
      }
    ],
    name: "getSenderAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "callGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxFeePerGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct UserOperation",
        name: "userOp",
        type: "tuple"
      }
    ],
    name: "getUserOpHash",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation[]",
            name: "userOps",
            type: "tuple[]"
          },
          {
            internalType: "contract IAggregator",
            name: "aggregator",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct IEntryPoint.UserOpsPerAggregator[]",
        name: "opsPerAggregator",
        type: "tuple[]"
      },
      {
        internalType: "address payable",
        name: "beneficiary",
        type: "address"
      }
    ],
    name: "handleAggregatedOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "callGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxFeePerGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct UserOperation[]",
        name: "ops",
        type: "tuple[]"
      },
      {
        internalType: "address payable",
        name: "beneficiary",
        type: "address"
      }
    ],
    name: "handleOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint192",
        name: "key",
        type: "uint192"
      }
    ],
    name: "incrementNonce",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "callData",
        type: "bytes"
      },
      {
        components: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "paymaster",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              }
            ],
            internalType: "struct EntryPoint.MemoryUserOp",
            name: "mUserOp",
            type: "tuple"
          },
          {
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "prefund",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "contextOffset",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "preOpGas",
            type: "uint256"
          }
        ],
        internalType: "struct EntryPoint.UserOpInfo",
        name: "opInfo",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "context",
        type: "bytes"
      }
    ],
    name: "innerHandleOp",
    outputs: [
      {
        internalType: "uint256",
        name: "actualGasCost",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint192",
        name: "",
        type: "uint192"
      }
    ],
    name: "nonceSequenceNumber",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "callGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxFeePerGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct UserOperation",
        name: "op",
        type: "tuple"
      },
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "targetCallData",
        type: "bytes"
      }
    ],
    name: "simulateHandleOp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "callGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxFeePerGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct UserOperation",
        name: "userOp",
        type: "tuple"
      }
    ],
    name: "simulateValidation",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unlockStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address payable",
        name: "withdrawAddress",
        type: "address"
      }
    ],
    name: "withdrawStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address payable",
        name: "withdrawAddress",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "withdrawAmount",
        type: "uint256"
      }
    ],
    name: "withdrawTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
// entrypoint-0.6/types/contracts/IPaymaster.ts
var PaymasterAbi = [
  {
    inputs: [
      {
        internalType: "enum IPaymaster.PostOpMode",
        name: "mode",
        type: "uint8"
      },
      {
        internalType: "bytes",
        name: "context",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "actualGasCost",
        type: "uint256"
      }
    ],
    name: "postOp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "callGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxFeePerGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct UserOperation",
        name: "userOp",
        type: "tuple"
      },
      {
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "maxCost",
        type: "uint256"
      }
    ],
    name: "validatePaymasterUserOp",
    outputs: [
      {
        internalType: "bytes",
        name: "context",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "validationData",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
// entrypoint-0.6/types/contracts/IOpInflator.ts
var IOpInflatorAbi = [
  {
    type: "function",
    name: "inflate",
    inputs: [
      {
        name: "compressed",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [
      {
        name: "op",
        type: "tuple",
        internalType: "struct UserOperation",
        components: [
          {
            name: "sender",
            type: "address",
            internalType: "address"
          },
          {
            name: "nonce",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "initCode",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "callData",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "callGasLimit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "verificationGasLimit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "maxFeePerGas",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "paymasterAndData",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "signature",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      }
    ],
    stateMutability: "view"
  }
];
// entrypoint-0.6/types/contracts/PerOpInflator.ts
var PerOpInfaltorAbi = [
  {
    type: "constructor",
    inputs: [
      {
        name: "_owner",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "beneficiary",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address payable"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "idToInflator",
    inputs: [
      {
        name: "",
        type: "uint32",
        internalType: "uint32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract IOpInflator"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "inflate",
    inputs: [
      {
        name: "compressed",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple[]",
        internalType: "struct UserOperation[]",
        components: [
          {
            name: "sender",
            type: "address",
            internalType: "address"
          },
          {
            name: "nonce",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "initCode",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "callData",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "callGasLimit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "verificationGasLimit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "maxFeePerGas",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "paymasterAndData",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "signature",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "",
        type: "address",
        internalType: "address payable"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "inflatorToID",
    inputs: [
      {
        name: "",
        type: "address",
        internalType: "contract IOpInflator"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint32",
        internalType: "uint32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "owner",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "registerOpInflator",
    inputs: [
      {
        name: "inflatorId",
        type: "uint32",
        internalType: "uint32"
      },
      {
        name: "inflator",
        type: "address",
        internalType: "contract IOpInflator"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "renounceOwnership",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setBeneficiary",
    inputs: [
      {
        name: "_beneficiary",
        type: "address",
        internalType: "address payable"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "transferOwnership",
    inputs: [
      {
        name: "newOwner",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "event",
    name: "OwnershipTransferred",
    inputs: [
      {
        name: "previousOwner",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "newOwner",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  }
];
// entrypoint-0.6/types/contracts/SenderCreator.ts
var SenderCreatorAbi = [
  {
    inputs: [
      {
        internalType: "bytes",
        name: "initCode",
        type: "bytes"
      }
    ],
    name: "createSender",
    outputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
// entrypoint-0.6/types/contracts/CodeHashGetter.ts
var CodeHashGetterAbi = [
  {
    inputs: [
      {
        internalType: "address[]",
        name: "addresses",
        type: "address[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "hash",
        type: "bytes32"
      }
    ],
    name: "CodeHashesResult",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "addresses",
        type: "address[]"
      }
    ],
    name: "getCodeHashes",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var CodeHashGetterBytecode = "0x608060405234801561001057600080fd5b506040516102b03803806102b083398101604081905261002f9161016a565b6100388161005d565b60405163091cd00560e01b815260040161005491815260200190565b60405180910390fd5b60008082516001600160401b0381111561007957610079610138565b6040519080825280602002602001820160405280156100a2578160200160208202803683370190505b50905060005b8351811015610104578381815181106100c3576100c361022e565b60200260200101516001600160a01b03163f8282815181106100e7576100e761022e565b6020908102919091010152806100fc81610244565b9150506100a8565b50600081604051602001610118919061026b565b60408051601f198184030181529190528051602090910120949350505050565b634e487b7160e01b600052604160045260246000fd5b80516001600160a01b038116811461016557600080fd5b919050565b6000602080838503121561017d57600080fd5b82516001600160401b038082111561019457600080fd5b818501915085601f8301126101a857600080fd5b8151818111156101ba576101ba610138565b8060051b604051601f19603f830116810181811085821117156101df576101df610138565b6040529182528482019250838101850191888311156101fd57600080fd5b938501935b82851015610222576102138561014e565b84529385019392850192610202565b98975050505050505050565b634e487b7160e01b600052603260045260246000fd5b60006001820161026457634e487b7160e01b600052601160045260246000fd5b5060010190565b6020808252825182820181905260009190848201906040850190845b818110156102a357835183529284019291840191600101610287565b5090969550505050505056fe";
// entrypoint-0.6/types/contracts/EntryPointSimulations.ts
var EntryPointSimulationsAbi = [
  {
    inputs: [
      {
        name: "reason",
        type: "string"
      }
    ],
    name: "Error",
    type: "error"
  }
];
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/getAction.js
function getAction(client, action, name) {
  return (params) => client[action.name || name]?.(params) ?? action(client, params);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/abi/encodeEventTopics.js
init_abi();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/log.js
init_base();

class FilterTypeNotSupportedError extends BaseError {
  constructor(type) {
    super(`Filter type "${type}" is not supported.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FilterTypeNotSupportedError"
    });
  }
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/abi/encodeEventTopics.js
init_toBytes();
init_getEventSelector();
init_keccak256();
init_encodeAbiParameters();
init_formatAbiItem2();
init_getAbiItem();
function encodeEventTopics({ abi: abi5, eventName, args }) {
  let abiItem = abi5[0];
  if (eventName) {
    abiItem = getAbiItem({
      abi: abi5,
      args,
      name: eventName
    });
    if (!abiItem)
      throw new AbiEventNotFoundError(eventName, {
        docsPath: "/docs/contract/encodeEventTopics"
      });
  }
  if (abiItem.type !== "event")
    throw new AbiEventNotFoundError(undefined, {
      docsPath: "/docs/contract/encodeEventTopics"
    });
  const definition = formatAbiItem2(abiItem);
  const signature = getEventSelector(definition);
  let topics = [];
  if (args && "inputs" in abiItem) {
    const indexedInputs = abiItem.inputs?.filter((param) => ("indexed" in param) && param.indexed);
    const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x) => args[x.name]) ?? [] : [];
    if (args_.length > 0) {
      topics = indexedInputs?.map((param, i) => Array.isArray(args_[i]) ? args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] })) : args_[i] ? encodeArg({ param, value: args_[i] }) : null) ?? [];
    }
  }
  return [signature, ...topics];
}
var encodeArg = function({ param, value }) {
  if (param.type === "string" || param.type === "bytes")
    return keccak256(toBytes2(value));
  if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    throw new FilterTypeNotSupportedError(param.type);
  return encodeAbiParameters([param], [value]);
};

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/createContractEventFilter.js
init_toHex();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/filters/createFilterRequestScope.js
function createFilterRequestScope(client, { method }) {
  const requestMap = {};
  if (client.transport.type === "fallback")
    client.transport.onResponse?.(({ method: method_, response: id, status, transport }) => {
      if (status === "success" && method === method_)
        requestMap[id] = transport.request;
    });
  return (id) => requestMap[id] || client.request;
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/createContractEventFilter.js
async function createContractEventFilter(client, { address: address2, abi: abi5, args, eventName, fromBlock, strict, toBlock }) {
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newFilter"
  });
  const topics = eventName ? encodeEventTopics({
    abi: abi5,
    args,
    eventName
  }) : undefined;
  const id = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address: address2,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        topics
      }
    ]
  });
  return {
    abi: abi5,
    args,
    eventName,
    id,
    request: getRequest(id),
    strict,
    type: "event"
  };
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/estimateContractGas.js
init_parseAccount();
init_encodeFunctionData();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/errors/getContractError.js
init_abi();
init_base();
init_contract();
init_rpc();
function getContractError(err, { abi: abi10, address: address3, args, docsPath, functionName, sender }) {
  const { code, data: data3, message, shortMessage } = err instanceof RawContractError ? err : err instanceof BaseError ? err.walk((err2) => ("data" in err2)) || err.walk() : {};
  const cause = (() => {
    if (err instanceof AbiDecodingZeroDataError)
      return new ContractFunctionZeroDataError({ functionName });
    if ([EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(code) && (data3 || message || shortMessage)) {
      return new ContractFunctionRevertedError({
        abi: abi10,
        data: typeof data3 === "object" ? data3.data : data3,
        functionName,
        message: shortMessage ?? message
      });
    }
    return err;
  })();
  return new ContractFunctionExecutionError(cause, {
    abi: abi10,
    args,
    contractAddress: address3,
    docsPath,
    functionName,
    sender
  });
}
var EXECUTION_REVERTED_ERROR_CODE = 3;

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/estimateGas.js
init_parseAccount();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/account.js
init_base();

class AccountNotFoundError extends BaseError {
  constructor({ docsPath } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."
    ].join("\n"), {
      docsPath,
      docsSlug: "account"
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AccountNotFoundError"
    });
  }
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/estimateGas.js
init_toHex();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/estimateGas.js
init_formatEther();
init_formatGwei();
init_base();
init_transaction();

class EstimateGasExecutionError extends BaseError {
  constructor(cause, { account, docsPath, chain, data: data3, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    const prettyArgs = prettyPrint({
      from: account?.address,
      to,
      value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
      data: data3,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EstimateGasExecutionError"
    });
    this.cause = cause;
  }
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/errors/getEstimateGasError.js
init_node();
init_getNodeError();
function getEstimateGasError(err, { docsPath, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new EstimateGasExecutionError(cause, {
    docsPath,
    ...args
  });
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/estimateGas.js
init_extract();
init_transactionRequest();
init_assertRequest();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
init_parseAccount();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/fee.js
init_formatGwei();
init_base();

class BaseFeeScalarError extends BaseError {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseFeeScalarError"
    });
  }
}

class Eip1559FeesNotSupportedError extends BaseError {
  constructor() {
    super("Chain does not support EIP-1559 fees.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Eip1559FeesNotSupportedError"
    });
  }
}

class MaxFeePerGasTooLowError extends BaseError {
  constructor({ maxPriorityFeePerGas }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(maxPriorityFeePerGas)} gwei).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "MaxFeePerGasTooLowError"
    });
  }
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js
init_fromHex();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/block.js
init_base();

class BlockNotFoundError extends BaseError {
  constructor({ blockHash, blockNumber }) {
    let identifier = "Block";
    if (blockHash)
      identifier = `Block at hash "${blockHash}"`;
    if (blockNumber)
      identifier = `Block at number "${blockNumber}"`;
    super(`${identifier} could not be found.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BlockNotFoundError"
    });
  }
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getBlock.js
init_toHex();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/formatters/block.js
init_formatter();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/formatters/transaction.js
init_fromHex();
init_formatter();
function formatTransaction(transaction4) {
  const transaction_ = {
    ...transaction4,
    blockHash: transaction4.blockHash ? transaction4.blockHash : null,
    blockNumber: transaction4.blockNumber ? BigInt(transaction4.blockNumber) : null,
    chainId: transaction4.chainId ? hexToNumber(transaction4.chainId) : undefined,
    gas: transaction4.gas ? BigInt(transaction4.gas) : undefined,
    gasPrice: transaction4.gasPrice ? BigInt(transaction4.gasPrice) : undefined,
    maxFeePerGas: transaction4.maxFeePerGas ? BigInt(transaction4.maxFeePerGas) : undefined,
    maxPriorityFeePerGas: transaction4.maxPriorityFeePerGas ? BigInt(transaction4.maxPriorityFeePerGas) : undefined,
    nonce: transaction4.nonce ? hexToNumber(transaction4.nonce) : undefined,
    to: transaction4.to ? transaction4.to : null,
    transactionIndex: transaction4.transactionIndex ? Number(transaction4.transactionIndex) : null,
    type: transaction4.type ? transactionType[transaction4.type] : undefined,
    typeHex: transaction4.type ? transaction4.type : undefined,
    value: transaction4.value ? BigInt(transaction4.value) : undefined,
    v: transaction4.v ? BigInt(transaction4.v) : undefined
  };
  transaction_.yParity = (() => {
    if (transaction4.yParity)
      return Number(transaction4.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  return transaction_;
}
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559"
};
var defineTransaction = defineFormatter("transaction", formatTransaction);

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = block.transactions?.map((transaction5) => {
    if (typeof transaction5 === "string")
      return transaction5;
    return formatTransaction(transaction5);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : undefined,
    timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock = defineFormatter("block", formatBlock);

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getBlock.js
async function getBlock(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
  const blockTag = blockTag_ ?? "latest";
  const includeTransactions = includeTransactions_ ?? false;
  const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
  let block3 = null;
  if (blockHash) {
    block3 = await client.request({
      method: "eth_getBlockByHash",
      params: [blockHash, includeTransactions]
    });
  } else {
    block3 = await client.request({
      method: "eth_getBlockByNumber",
      params: [blockNumberHex || blockTag, includeTransactions]
    });
  }
  if (!block3)
    throw new BlockNotFoundError({ blockHash, blockNumber });
  const format3 = client.chain?.formatters?.block?.format || formatBlock;
  return format3(block3);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getGasPrice.js
async function getGasPrice(client) {
  const gasPrice = await client.request({
    method: "eth_gasPrice"
  });
  return BigInt(gasPrice);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js
async function estimateMaxPriorityFeePerGas(client, args) {
  return internal_estimateMaxPriorityFeePerGas(client, args);
}
async function internal_estimateMaxPriorityFeePerGas(client, args) {
  const { block: block_, chain = client.chain, request: request2 } = args || {};
  if (typeof chain?.fees?.defaultPriorityFee === "function") {
    const block3 = block_ || await getAction(client, getBlock, "getBlock")({});
    return chain.fees.defaultPriorityFee({
      block: block3,
      client,
      request: request2
    });
  }
  if (typeof chain?.fees?.defaultPriorityFee !== "undefined")
    return chain?.fees?.defaultPriorityFee;
  try {
    const maxPriorityFeePerGasHex = await client.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return hexToBigInt(maxPriorityFeePerGasHex);
  } catch {
    const [block3, gasPrice] = await Promise.all([
      block_ ? Promise.resolve(block_) : getAction(client, getBlock, "getBlock")({}),
      getAction(client, getGasPrice, "getGasPrice")({})
    ]);
    if (typeof block3.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError;
    const maxPriorityFeePerGas = gasPrice - block3.baseFeePerGas;
    if (maxPriorityFeePerGas < 0n)
      return 0n;
    return maxPriorityFeePerGas;
  }
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/estimateFeesPerGas.js
async function estimateFeesPerGas(client, args) {
  return internal_estimateFeesPerGas(client, args);
}
async function internal_estimateFeesPerGas(client, args) {
  const { block: block_, chain = client.chain, request: request2, type = "eip1559" } = args || {};
  const baseFeeMultiplier = await (async () => {
    if (typeof chain?.fees?.baseFeeMultiplier === "function")
      return chain.fees.baseFeeMultiplier({
        block: block_,
        client,
        request: request2
      });
    return chain?.fees?.baseFeeMultiplier ?? 1.2;
  })();
  if (baseFeeMultiplier < 1)
    throw new BaseFeeScalarError;
  const decimals = baseFeeMultiplier.toString().split(".")[1]?.length ?? 0;
  const denominator = 10 ** decimals;
  const multiply = (base19) => base19 * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
  const block3 = block_ ? block_ : await getAction(client, getBlock, "getBlock")({});
  if (typeof chain?.fees?.estimateFeesPerGas === "function")
    return chain.fees.estimateFeesPerGas({
      block: block_,
      client,
      multiply,
      request: request2,
      type
    });
  if (type === "eip1559") {
    if (typeof block3.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError;
    const maxPriorityFeePerGas = request2?.maxPriorityFeePerGas ? request2.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(client, {
      block: block3,
      chain,
      request: request2
    });
    const baseFeePerGas = multiply(block3.baseFeePerGas);
    const maxFeePerGas = request2?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
  const gasPrice = request2?.gasPrice ?? multiply(await getAction(client, getGasPrice, "getGasPrice")({}));
  return {
    gasPrice
  };
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getTransactionCount.js
init_fromHex();
init_toHex();
async function getTransactionCount(client, { address: address4, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [address4, blockNumber ? numberToHex(blockNumber) : blockTag]
  });
  return hexToNumber(count);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
init_assertRequest();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/transaction/getTransactionType.js
init_transaction();
function getTransactionType(transaction6) {
  if (transaction6.type)
    return transaction6.type;
  if (typeof transaction6.maxFeePerGas !== "undefined" || typeof transaction6.maxPriorityFeePerGas !== "undefined")
    return "eip1559";
  if (typeof transaction6.gasPrice !== "undefined") {
    if (typeof transaction6.accessList !== "undefined")
      return "eip2930";
    return "legacy";
  }
  throw new InvalidSerializableTransactionError({ transaction: transaction6 });
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
async function prepareTransactionRequest(client, args) {
  const { account: account_ = client.account, chain, gas, nonce, type } = args;
  if (!account_)
    throw new AccountNotFoundError;
  const account2 = parseAccount(account_);
  const block3 = await getAction(client, getBlock, "getBlock")({ blockTag: "latest" });
  const request2 = { ...args, from: account2.address };
  if (typeof nonce === "undefined")
    request2.nonce = await getAction(client, getTransactionCount, "getTransactionCount")({
      address: account2.address,
      blockTag: "pending"
    });
  if (typeof type === "undefined") {
    try {
      request2.type = getTransactionType(request2);
    } catch {
      request2.type = typeof block3.baseFeePerGas === "bigint" ? "eip1559" : "legacy";
    }
  }
  if (request2.type === "eip1559") {
    const { maxFeePerGas, maxPriorityFeePerGas } = await internal_estimateFeesPerGas(client, {
      block: block3,
      chain,
      request: request2
    });
    if (typeof args.maxPriorityFeePerGas === "undefined" && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas)
      throw new MaxFeePerGasTooLowError({
        maxPriorityFeePerGas
      });
    request2.maxPriorityFeePerGas = maxPriorityFeePerGas;
    request2.maxFeePerGas = maxFeePerGas;
  } else {
    if (typeof args.maxFeePerGas !== "undefined" || typeof args.maxPriorityFeePerGas !== "undefined")
      throw new Eip1559FeesNotSupportedError;
    const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(client, {
      block: block3,
      chain,
      request: request2,
      type: "legacy"
    });
    request2.gasPrice = gasPrice_;
  }
  if (typeof gas === "undefined")
    request2.gas = await getAction(client, estimateGas3, "estimateGas")({
      ...request2,
      account: { address: account2.address, type: "json-rpc" }
    });
  assertRequest(request2);
  return request2;
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/estimateGas.js
async function estimateGas3(client, args) {
  const account_ = args.account ?? client.account;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/public/estimateGas"
    });
  const account3 = parseAccount(account_);
  try {
    const { accessList, blockNumber, blockTag, data: data3, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = account3.type === "local" ? await prepareTransactionRequest(client, args) : args;
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
    const block3 = blockNumberHex || blockTag;
    assertRequest(args);
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format3 = chainFormat || formatTransactionRequest;
    const request2 = format3({
      ...extract(rest, { format: chainFormat }),
      from: account3.address,
      accessList,
      data: data3,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    const balance = await client.request({
      method: "eth_estimateGas",
      params: block3 ? [request2, block3] : [request2]
    });
    return BigInt(balance);
  } catch (err) {
    throw getEstimateGasError(err, {
      ...args,
      account: account3,
      chain: client.chain
    });
  }
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/estimateContractGas.js
async function estimateContractGas(client, { abi: abi10, address: address4, args, functionName, ...request2 }) {
  const data3 = encodeFunctionData({
    abi: abi10,
    args,
    functionName
  });
  try {
    const gas = await getAction(client, estimateGas3, "estimateGas")({
      data: data3,
      to: address4,
      ...request2
    });
    return gas;
  } catch (err) {
    const account3 = request2.account ? parseAccount(request2.account) : undefined;
    throw getContractError(err, {
      abi: abi10,
      address: address4,
      args,
      docsPath: "/docs/contract/estimateContractGas",
      functionName,
      sender: account3?.address
    });
  }
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getContractEvents.js
init_getAbiItem();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getLogs.js
init_abi();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/abi/decodeEventLog.js
init_abi();
init_getEventSelector();
init_decodeAbiParameters();
init_formatAbiItem2();
function decodeEventLog({ abi: abi11, data: data3, strict: strict_, topics }) {
  const strict = strict_ ?? true;
  const [signature, ...argTopics] = topics;
  if (!signature)
    throw new AbiEventSignatureEmptyTopicsError({
      docsPath
    });
  const abiItem = abi11.find((x) => x.type === "event" && signature === getEventSelector(formatAbiItem2(x)));
  if (!(abiItem && ("name" in abiItem)) || abiItem.type !== "event")
    throw new AbiEventSignatureNotFoundError(signature, {
      docsPath
    });
  const { name, inputs } = abiItem;
  const isUnnamed = inputs?.some((x) => !(("name" in x) && x.name));
  let args = isUnnamed ? [] : {};
  const indexedInputs = inputs.filter((x) => ("indexed" in x) && x.indexed);
  for (let i = 0;i < indexedInputs.length; i++) {
    const param = indexedInputs[i];
    const topic = argTopics[i];
    if (!topic)
      throw new DecodeLogTopicsMismatch({
        abiItem,
        param
      });
    args[param.name || i] = decodeTopic({ param, value: topic });
  }
  const nonIndexedInputs = inputs.filter((x) => !(("indexed" in x) && x.indexed));
  if (nonIndexedInputs.length > 0) {
    if (data3 && data3 !== "0x") {
      try {
        const decodedData = decodeAbiParameters(nonIndexedInputs, data3);
        if (decodedData) {
          if (isUnnamed)
            args = [...args, ...decodedData];
          else {
            for (let i = 0;i < nonIndexedInputs.length; i++) {
              args[nonIndexedInputs[i].name] = decodedData[i];
            }
          }
        }
      } catch (err) {
        if (strict) {
          if (err instanceof AbiDecodingDataSizeTooSmallError)
            throw new DecodeLogDataMismatch({
              abiItem,
              data: err.data,
              params: err.params,
              size: err.size
            });
          throw err;
        }
      }
    } else if (strict) {
      throw new DecodeLogDataMismatch({
        abiItem,
        data: "0x",
        params: nonIndexedInputs,
        size: 0
      });
    }
  }
  return {
    eventName: name,
    args: Object.values(args).length > 0 ? args : undefined
  };
}
var decodeTopic = function({ param, value }) {
  if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    return value;
  const decodedArg = decodeAbiParameters([param], value) || [];
  return decodedArg[0];
};
var docsPath = "/docs/contract/decodeEventLog";

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getLogs.js
init_toHex();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/formatters/log.js
function formatLog(log2, { args, eventName } = {}) {
  return {
    ...log2,
    blockHash: log2.blockHash ? log2.blockHash : null,
    blockNumber: log2.blockNumber ? BigInt(log2.blockNumber) : null,
    logIndex: log2.logIndex ? Number(log2.logIndex) : null,
    transactionHash: log2.transactionHash ? log2.transactionHash : null,
    transactionIndex: log2.transactionIndex ? Number(log2.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getLogs.js
async function getLogs(client, { address: address4, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
  const strict = strict_ ?? false;
  const events = events_ ?? (event ? [event] : undefined);
  let topics = [];
  if (events) {
    topics = [
      events.flatMap((event2) => encodeEventTopics({
        abi: [event2],
        eventName: event2.name,
        args
      }))
    ];
    if (event)
      topics = topics[0];
  }
  let logs;
  if (blockHash) {
    logs = await client.request({
      method: "eth_getLogs",
      params: [{ address: address4, topics, blockHash }]
    });
  } else {
    logs = await client.request({
      method: "eth_getLogs",
      params: [
        {
          address: address4,
          topics,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock
        }
      ]
    });
  }
  return logs.map((log3) => {
    try {
      const { eventName, args: args2 } = events ? decodeEventLog({
        abi: events,
        data: log3.data,
        topics: log3.topics,
        strict
      }) : { eventName: undefined, args: undefined };
      return formatLog(log3, { args: args2, eventName });
    } catch (err) {
      let eventName;
      let isUnnamed;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if (strict)
          return;
        eventName = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x) => !(("name" in x) && x.name));
      }
      return formatLog(log3, { args: isUnnamed ? [] : {}, eventName });
    }
  }).filter(Boolean);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getContractEvents.js
async function getContractEvents(client, { abi: abi12, address: address4, args, blockHash, eventName, fromBlock, toBlock, strict }) {
  const event = eventName ? getAbiItem({ abi: abi12, name: eventName }) : undefined;
  const events = !event ? abi12.filter((x) => x.type === "event") : undefined;
  return getAction(client, getLogs, "getLogs")({
    address: address4,
    args,
    blockHash,
    event,
    events,
    fromBlock,
    toBlock,
    strict
  });
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/readContract.js
init_decodeFunctionResult();
init_encodeFunctionData();
init_call();
async function readContract(client, { abi: abi13, address: address5, args, functionName, ...callRequest }) {
  const calldata = encodeFunctionData({
    abi: abi13,
    args,
    functionName
  });
  try {
    const { data: data3 } = await getAction(client, call2, "call")({
      data: calldata,
      to: address5,
      ...callRequest
    });
    return decodeFunctionResult({
      abi: abi13,
      args,
      functionName,
      data: data3 || "0x"
    });
  } catch (err) {
    throw getContractError(err, {
      abi: abi13,
      address: address5,
      args,
      docsPath: "/docs/contract/readContract",
      functionName
    });
  }
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/simulateContract.js
init_parseAccount();
init_decodeFunctionResult();
init_encodeFunctionData();
init_call();
async function simulateContract(client, { abi: abi13, address: address5, args, dataSuffix, functionName, ...callRequest }) {
  const account3 = callRequest.account ? parseAccount(callRequest.account) : undefined;
  const calldata = encodeFunctionData({
    abi: abi13,
    args,
    functionName
  });
  try {
    const { data: data3 } = await getAction(client, call2, "call")({
      batch: false,
      data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address5,
      ...callRequest
    });
    const result = decodeFunctionResult({
      abi: abi13,
      args,
      functionName,
      data: data3 || "0x"
    });
    return {
      result,
      request: {
        abi: abi13,
        address: address5,
        args,
        dataSuffix,
        functionName,
        ...callRequest
      }
    };
  } catch (err) {
    throw getContractError(err, {
      abi: abi13,
      address: address5,
      args,
      docsPath: "/docs/contract/simulateContract",
      functionName,
      sender: account3?.address
    });
  }
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/observe.js
function observe(observerId, callbacks, fn) {
  const callbackId = ++callbackCount;
  const getListeners = () => listenersCache.get(observerId) || [];
  const unsubscribe = () => {
    const listeners2 = getListeners();
    listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));
  };
  const unwatch = () => {
    const cleanup2 = cleanupCache.get(observerId);
    if (getListeners().length === 1 && cleanup2)
      cleanup2();
    unsubscribe();
  };
  const listeners = getListeners();
  listenersCache.set(observerId, [
    ...listeners,
    { id: callbackId, fns: callbacks }
  ]);
  if (listeners && listeners.length > 0)
    return unwatch;
  const emit = {};
  for (const key in callbacks) {
    emit[key] = (...args) => {
      const listeners2 = getListeners();
      if (listeners2.length === 0)
        return;
      for (const listener of listeners2)
        listener.fns[key]?.(...args);
    };
  }
  const cleanup = fn(emit);
  if (typeof cleanup === "function")
    cleanupCache.set(observerId, cleanup);
  return unwatch;
}
var listenersCache = new Map;
var cleanupCache = new Map;
var callbackCount = 0;

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/wait.js
async function wait(time) {
  return new Promise((res) => setTimeout(res, time));
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/poll.js
function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
  let active = true;
  const unwatch = () => active = false;
  const watch = async () => {
    let data3 = undefined;
    if (emitOnBegin)
      data3 = await fn({ unpoll: unwatch });
    const initialWait = await initialWaitTime?.(data3) ?? interval;
    await wait(initialWait);
    const poll2 = async () => {
      if (!active)
        return;
      await fn({ unpoll: unwatch });
      await wait(interval);
      poll2();
    };
    poll2();
  };
  watch();
  return unwatch;
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/watchContractEvent.js
init_stringify();
init_abi();
init_rpc();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/promise/withCache.js
function getCache(cacheKey) {
  const buildCache = (cacheKey2, cache) => ({
    clear: () => cache.delete(cacheKey2),
    get: () => cache.get(cacheKey2),
    set: (data3) => cache.set(cacheKey2, data3)
  });
  const promise = buildCache(cacheKey, promiseCache);
  const response = buildCache(cacheKey, responseCache);
  return {
    clear: () => {
      promise.clear();
      response.clear();
    },
    promise,
    response
  };
}
async function withCache(fn, { cacheKey, cacheTime = Infinity }) {
  const cache = getCache(cacheKey);
  const response = cache.response.get();
  if (response && cacheTime > 0) {
    const age = new Date().getTime() - response.created.getTime();
    if (age < cacheTime)
      return response.data;
  }
  let promise = cache.promise.get();
  if (!promise) {
    promise = fn();
    cache.promise.set(promise);
  }
  try {
    const data3 = await promise;
    cache.response.set({ created: new Date, data: data3 });
    return data3;
  } finally {
    cache.promise.clear();
  }
}
var promiseCache = new Map;
var responseCache = new Map;

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getBlockNumber.js
async function getBlockNumber(client, { cacheTime = client.cacheTime, maxAge } = {}) {
  const blockNumberHex = await withCache(() => client.request({
    method: "eth_blockNumber"
  }), { cacheKey: cacheKey(client.uid), cacheTime: maxAge ?? cacheTime });
  return BigInt(blockNumberHex);
}
var cacheKey = (id) => `blockNumber.${id}`;

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getFilterChanges.js
init_abi();
async function getFilterChanges(_client, { filter }) {
  const strict = "strict" in filter && filter.strict;
  const logs = await filter.request({
    method: "eth_getFilterChanges",
    params: [filter.id]
  });
  return logs.map((log4) => {
    if (typeof log4 === "string")
      return log4;
    try {
      const { eventName, args } = "abi" in filter && filter.abi ? decodeEventLog({
        abi: filter.abi,
        data: log4.data,
        topics: log4.topics,
        strict
      }) : { eventName: undefined, args: undefined };
      return formatLog(log4, { args, eventName });
    } catch (err) {
      let eventName;
      let isUnnamed;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if ("strict" in filter && filter.strict)
          return;
        eventName = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x) => !(("name" in x) && x.name));
      }
      return formatLog(log4, { args: isUnnamed ? [] : {}, eventName });
    }
  }).filter(Boolean);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/uninstallFilter.js
async function uninstallFilter(_client, { filter }) {
  return filter.request({
    method: "eth_uninstallFilter",
    params: [filter.id]
  });
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/watchContractEvent.js
function watchContractEvent(client, { abi: abi15, address: address5, args, batch = true, eventName, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  const pollContractEvent = () => {
    const observerId = stringify([
      "watchContractEvent",
      address5,
      args,
      batch,
      client.uid,
      eventName,
      pollingInterval
    ]);
    const strict = strict_ ?? false;
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      let filter;
      let initialized = false;
      const unwatch = poll(async () => {
        if (!initialized) {
          try {
            filter = await getAction(client, createContractEventFilter, "createContractEventFilter")({
              abi: abi15,
              address: address5,
              args,
              eventName,
              strict
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter) {
            logs = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
          } else {
            const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getAction(client, getContractEvents, "getContractEvents")({
                abi: abi15,
                address: address5,
                args,
                eventName,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber,
                strict
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            for (const log5 of logs)
              emit.onLogs([log5]);
        } catch (err) {
          if (filter && err instanceof InvalidInputRpcError)
            initialized = false;
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
        unwatch();
      };
    });
  };
  const subscribeContractEvent = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const topics = eventName ? encodeEventTopics({
          abi: abi15,
          eventName,
          args
        }) : [];
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["logs", { address: address5, topics }],
          onData(data3) {
            if (!active)
              return;
            const log5 = data3.result;
            try {
              const { eventName: eventName2, args: args2 } = decodeEventLog({
                abi: abi15,
                data: log5.data,
                topics: log5.topics,
                strict: strict_
              });
              const formatted = formatLog(log5, {
                args: args2,
                eventName: eventName2
              });
              onLogs([formatted]);
            } catch (err) {
              let eventName2;
              let isUnnamed;
              if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                if (strict_)
                  return;
                eventName2 = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x) => !(("name" in x) && x.name));
              }
              const formatted = formatLog(log5, {
                args: isUnnamed ? [] : {},
                eventName: eventName2
              });
              onLogs([formatted]);
            }
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollContractEvent() : subscribeContractEvent();
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/wallet/writeContract.js
init_encodeFunctionData();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/wallet/sendTransaction.js
init_parseAccount();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/chain/assertCurrentChain.js
init_chain();
function assertCurrentChain({ chain: chain4, currentChainId }) {
  if (!chain4)
    throw new ChainNotFoundError;
  if (currentChainId !== chain4.id)
    throw new ChainMismatchError({ chain: chain4, currentChainId });
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/errors/getTransactionError.js
init_node();
init_transaction();
init_getNodeError();
function getTransactionError(err, { docsPath: docsPath3, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new TransactionExecutionError(cause, {
    docsPath: docsPath3,
    ...args
  });
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/wallet/sendTransaction.js
init_extract();
init_transactionRequest();
init_assertRequest();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getChainId.js
init_fromHex();
async function getChainId(client) {
  const chainIdHex = await client.request({
    method: "eth_chainId"
  });
  return hexToNumber(chainIdHex);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/wallet/sendRawTransaction.js
async function sendRawTransaction(client, { serializedTransaction }) {
  return client.request({
    method: "eth_sendRawTransaction",
    params: [serializedTransaction]
  });
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/wallet/sendTransaction.js
async function sendTransaction(client, args) {
  const { account: account_ = client.account, chain: chain4 = client.chain, accessList, data: data3, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const account4 = parseAccount(account_);
  try {
    assertRequest(args);
    let chainId;
    if (chain4 !== null) {
      chainId = await getAction(client, getChainId, "getChainId")({});
      assertCurrentChain({
        currentChainId: chainId,
        chain: chain4
      });
    }
    if (account4.type === "local") {
      const request4 = await getAction(client, prepareTransactionRequest, "prepareTransactionRequest")({
        account: account4,
        accessList,
        chain: chain4,
        data: data3,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value,
        ...rest
      });
      if (!chainId)
        chainId = await getAction(client, getChainId, "getChainId")({});
      const serializer = chain4?.serializers?.transaction;
      const serializedTransaction = await account4.signTransaction({
        ...request4,
        chainId
      }, { serializer });
      return await getAction(client, sendRawTransaction, "sendRawTransaction")({
        serializedTransaction
      });
    }
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format3 = chainFormat || formatTransactionRequest;
    const request3 = format3({
      ...extract(rest, { format: chainFormat }),
      accessList,
      data: data3,
      from: account4.address,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    return await client.request({
      method: "eth_sendTransaction",
      params: [request3]
    });
  } catch (err) {
    throw getTransactionError(err, {
      ...args,
      account: account4,
      chain: args.chain || undefined
    });
  }
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/wallet/writeContract.js
async function writeContract(client, { abi: abi15, address: address5, args, dataSuffix, functionName, ...request3 }) {
  const data3 = encodeFunctionData({
    abi: abi15,
    args,
    functionName
  });
  const hash4 = await getAction(client, sendTransaction, "sendTransaction")({
    data: `${data3}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
    to: address5,
    ...request3
  });
  return hash4;
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/getContract.js
function getContract({ abi: abi15, address: address5, publicClient, walletClient }) {
  const hasPublicClient = publicClient !== undefined && publicClient !== null;
  const hasWalletClient = walletClient !== undefined && walletClient !== null;
  const contract5 = {};
  let hasReadFunction = false;
  let hasWriteFunction = false;
  let hasEvent = false;
  for (const item of abi15) {
    if (item.type === "function")
      if (item.stateMutability === "view" || item.stateMutability === "pure")
        hasReadFunction = true;
      else
        hasWriteFunction = true;
    else if (item.type === "event")
      hasEvent = true;
    if (hasReadFunction && hasWriteFunction && hasEvent)
      break;
  }
  if (hasPublicClient) {
    if (hasReadFunction)
      contract5.read = new Proxy({}, {
        get(_, functionName) {
          return (...parameters) => {
            const { args, options } = getFunctionParameters(parameters);
            return getAction(publicClient, readContract, "readContract")({
              abi: abi15,
              address: address5,
              functionName,
              args,
              ...options
            });
          };
        }
      });
    if (hasWriteFunction)
      contract5.simulate = new Proxy({}, {
        get(_, functionName) {
          return (...parameters) => {
            const { args, options } = getFunctionParameters(parameters);
            return getAction(publicClient, simulateContract, "simulateContract")({
              abi: abi15,
              address: address5,
              functionName,
              args,
              ...options
            });
          };
        }
      });
    if (hasEvent) {
      contract5.createEventFilter = new Proxy({}, {
        get(_, eventName) {
          return (...parameters) => {
            const abiEvent = abi15.find((x) => x.type === "event" && x.name === eventName);
            const { args, options } = getEventParameters(parameters, abiEvent);
            return getAction(publicClient, createContractEventFilter, "createContractEventFilter")({
              abi: abi15,
              address: address5,
              eventName,
              args,
              ...options
            });
          };
        }
      });
      contract5.getEvents = new Proxy({}, {
        get(_, eventName) {
          return (...parameters) => {
            const abiEvent = abi15.find((x) => x.type === "event" && x.name === eventName);
            const { args, options } = getEventParameters(parameters, abiEvent);
            return getAction(publicClient, getContractEvents, "getContractEvents")({
              abi: abi15,
              address: address5,
              eventName,
              args,
              ...options
            });
          };
        }
      });
      contract5.watchEvent = new Proxy({}, {
        get(_, eventName) {
          return (...parameters) => {
            const abiEvent = abi15.find((x) => x.type === "event" && x.name === eventName);
            const { args, options } = getEventParameters(parameters, abiEvent);
            return getAction(publicClient, watchContractEvent, "watchContractEvent")({
              abi: abi15,
              address: address5,
              eventName,
              args,
              ...options
            });
          };
        }
      });
    }
  }
  if (hasWalletClient) {
    if (hasWriteFunction)
      contract5.write = new Proxy({}, {
        get(_, functionName) {
          return (...parameters) => {
            const { args, options } = getFunctionParameters(parameters);
            return getAction(walletClient, writeContract, "writeContract")({
              abi: abi15,
              address: address5,
              functionName,
              args,
              ...options
            });
          };
        }
      });
  }
  if (hasPublicClient || hasWalletClient) {
    if (hasWriteFunction)
      contract5.estimateGas = new Proxy({}, {
        get(_, functionName) {
          return (...parameters) => {
            const { args, options } = getFunctionParameters(parameters);
            const client = publicClient ?? walletClient;
            return getAction(client, estimateContractGas, "estimateContractGas")({
              abi: abi15,
              address: address5,
              functionName,
              args,
              ...options,
              account: options.account ?? walletClient.account
            });
          };
        }
      });
  }
  contract5.address = address5;
  contract5.abi = abi15;
  return contract5;
}
function getFunctionParameters(values) {
  const hasArgs = values.length && Array.isArray(values[0]);
  const args = hasArgs ? values[0] : [];
  const options = (hasArgs ? values[1] : values[0]) ?? {};
  return { args, options };
}
function getEventParameters(values, abiEvent) {
  let hasArgs = false;
  if (Array.isArray(values[0]))
    hasArgs = true;
  else if (values.length === 1) {
    hasArgs = abiEvent.inputs.some((x) => x.indexed);
  } else if (values.length === 2) {
    hasArgs = true;
  }
  const args = hasArgs ? values[0] : undefined;
  const options = (hasArgs ? values[1] : values[0]) ?? {};
  return { args, options };
}
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/wallet/addChain.js
init_toHex();
async function addChain(client, { chain: chain4 }) {
  const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain4;
  await client.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: numberToHex(id),
        chainName: name,
        nativeCurrency,
        rpcUrls: rpcUrls.default.http,
        blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : undefined
      }
    ]
  });
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/accounts.js
init_parseAccount();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
init_getAddress();
init_keccak256();
function publicKeyToAddress(publicKey) {
  const address5 = keccak256(`0x${publicKey.substring(4)}`).substring(26);
  return checksumAddress(`0x${address5}`);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/uid.js
function uid(length = 11) {
  if (!buffer || index + length > size7 * 2) {
    buffer = "";
    index = 0;
    for (let i = 0;i < size7; i++) {
      buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer.substring(index, index++ + length);
}
var size7 = 256;
var index = size7;
var buffer;

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/clients/createClient.js
function createClient(parameters) {
  const { batch, cacheTime = parameters.pollingInterval ?? 4000, key = "base", name = "Base Client", pollingInterval = 4000, type = "base" } = parameters;
  const chain4 = parameters.chain;
  const account4 = parameters.account ? parseAccount(parameters.account) : undefined;
  const { config, request: request3, value } = parameters.transport({
    chain: chain4,
    pollingInterval
  });
  const transport = { ...config, ...value };
  const client = {
    account: account4,
    batch,
    cacheTime,
    chain: chain4,
    key,
    name,
    pollingInterval,
    request: request3,
    transport,
    type,
    uid: uid()
  };
  function extend(base22) {
    return (extendFn) => {
      const extended = extendFn(base22);
      for (const key2 in client)
        delete extended[key2];
      const combined = { ...base22, ...extended };
      return Object.assign(combined, { extend: extend(combined) });
    };
  }
  return Object.assign(client, { extend: extend(client) });
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/buildRequest.js
init_base();
init_request();
init_rpc();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/promise/withRetry.js
function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true } = {}) {
  return new Promise((resolve5, reject) => {
    const attemptRetry = async ({ count = 0 } = {}) => {
      const retry = async ({ error }) => {
        const delay = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
        if (delay)
          await wait(delay);
        attemptRetry({ count: count + 1 });
      };
      try {
        const data3 = await fn();
        resolve5(data3);
      } catch (err) {
        if (count < retryCount && await shouldRetry({ count, error: err }))
          return retry({ error: err });
        reject(err);
      }
    };
    attemptRetry();
  });
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/buildRequest.js
function buildRequest(request4, { retryDelay = 150, retryCount = 3 } = {}) {
  return async (args) => withRetry(async () => {
    try {
      return await request4(args);
    } catch (err_) {
      const err = err_;
      switch (err.code) {
        case ParseRpcError.code:
          throw new ParseRpcError(err);
        case InvalidRequestRpcError.code:
          throw new InvalidRequestRpcError(err);
        case MethodNotFoundRpcError.code:
          throw new MethodNotFoundRpcError(err);
        case InvalidParamsRpcError.code:
          throw new InvalidParamsRpcError(err);
        case InternalRpcError.code:
          throw new InternalRpcError(err);
        case InvalidInputRpcError.code:
          throw new InvalidInputRpcError(err);
        case ResourceNotFoundRpcError.code:
          throw new ResourceNotFoundRpcError(err);
        case ResourceUnavailableRpcError.code:
          throw new ResourceUnavailableRpcError(err);
        case TransactionRejectedRpcError.code:
          throw new TransactionRejectedRpcError(err);
        case MethodNotSupportedRpcError.code:
          throw new MethodNotSupportedRpcError(err);
        case LimitExceededRpcError.code:
          throw new LimitExceededRpcError(err);
        case JsonRpcVersionUnsupportedError.code:
          throw new JsonRpcVersionUnsupportedError(err);
        case UserRejectedRequestError.code:
          throw new UserRejectedRequestError(err);
        case UnauthorizedProviderError.code:
          throw new UnauthorizedProviderError(err);
        case UnsupportedProviderMethodError.code:
          throw new UnsupportedProviderMethodError(err);
        case ProviderDisconnectedError.code:
          throw new ProviderDisconnectedError(err);
        case ChainDisconnectedError.code:
          throw new ChainDisconnectedError(err);
        case SwitchChainError.code:
          throw new SwitchChainError(err);
        case 5000:
          throw new UserRejectedRequestError(err);
        default:
          if (err_ instanceof BaseError)
            throw err_;
          throw new UnknownRpcError(err);
      }
    }
  }, {
    delay: ({ count, error }) => {
      if (error && error instanceof HttpRequestError) {
        const retryAfter = error?.headers?.get("Retry-After");
        if (retryAfter?.match(/\d/))
          return parseInt(retryAfter) * 1000;
      }
      return ~~(1 << count) * retryDelay;
    },
    retryCount,
    shouldRetry: ({ error }) => !isDeterministicError(error)
  });
}
var isDeterministicError = (error) => {
  if ("code" in error)
    return error.code !== -1 && error.code !== -32004 && error.code !== -32005 && error.code !== -32042 && error.code !== -32603;
  if (error instanceof HttpRequestError && error.status)
    return error.status !== 403 && error.status !== 408 && error.status !== 413 && error.status !== 429 && error.status !== 500 && error.status !== 502 && error.status !== 503 && error.status !== 504;
  return false;
};

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/clients/transports/createTransport.js
function createTransport({ key, name, request: request4, retryCount = 3, retryDelay = 150, timeout, type }, value) {
  return {
    config: { key, name, request: request4, retryCount, retryDelay, timeout, type },
    request: buildRequest(request4, { retryCount, retryDelay }),
    value
  };
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/transport.js
init_base();

class UrlRequiredError extends BaseError {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro"
    });
  }
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/rpc.js
init_request();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/promise/withTimeout.js
function withTimeout(fn, { errorInstance = new Error("timed out"), timeout, signal }) {
  return new Promise((resolve5, reject) => {
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController;
        if (timeout > 0) {
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject(errorInstance);
            }
          }, timeout);
        }
        resolve5(await fn({ signal: controller?.signal }));
      } catch (err) {
        if (err.name === "AbortError")
          reject(errorInstance);
        reject(err);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/rpc.js
init_stringify();
async function http(url, { body, fetchOptions = {}, timeout = 1e4 }) {
  const { headers, method, signal: signal_ } = fetchOptions;
  try {
    const response = await withTimeout(async ({ signal }) => {
      const response2 = await fetch(url, {
        ...fetchOptions,
        body: Array.isArray(body) ? stringify(body.map((body2) => ({
          jsonrpc: "2.0",
          id: body2.id ?? id++,
          ...body2
        }))) : stringify({ jsonrpc: "2.0", id: body.id ?? id++, ...body }),
        headers: {
          ...headers,
          "Content-Type": "application/json"
        },
        method: method || "POST",
        signal: signal_ || (timeout > 0 ? signal : undefined)
      });
      return response2;
    }, {
      errorInstance: new TimeoutError({ body, url }),
      timeout,
      signal: true
    });
    let data3;
    if (response.headers.get("Content-Type")?.startsWith("application/json")) {
      data3 = await response.json();
    } else {
      data3 = await response.text();
    }
    if (!response.ok) {
      throw new HttpRequestError({
        body,
        details: stringify(data3.error) || response.statusText,
        headers: response.headers,
        status: response.status,
        url
      });
    }
    return data3;
  } catch (err) {
    if (err instanceof HttpRequestError)
      throw err;
    if (err instanceof TimeoutError)
      throw err;
    throw new HttpRequestError({
      body,
      details: err.message,
      url
    });
  }
}
var webSocket = function(socket, { body, onResponse }) {
  if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING)
    throw new WebSocketRequestError({
      body,
      url: socket.url,
      details: "Socket is closed."
    });
  const id_ = id++;
  const callback = ({ data: data3 }) => {
    const message = JSON.parse(data3);
    if (typeof message.id === "number" && id_ !== message.id)
      return;
    onResponse?.(message);
    if (body.method === "eth_subscribe" && typeof message.result === "string") {
      socket.subscriptions.set(message.result, callback);
    }
    if (body.method === "eth_unsubscribe") {
      socket.subscriptions.delete(body.params?.[0]);
    }
  };
  socket.requests.set(id_, callback);
  socket.send(JSON.stringify({ jsonrpc: "2.0", ...body, id: id_ }));
  return socket;
};
async function webSocketAsync(socket, { body, timeout = 1e4 }) {
  return withTimeout(() => new Promise((onResponse) => rpc4.webSocket(socket, {
    body,
    onResponse
  })), {
    errorInstance: new TimeoutError({ body, url: socket.url }),
    timeout
  });
}
var id = 0;
var rpc4 = {
  http,
  webSocket,
  webSocketAsync
};

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/ens/getEnsAddress.js
init_abis();
init_decodeFunctionResult();
init_encodeFunctionData();
init_getChainContractAddress();
init_trim();
init_toHex();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/ens/errors.js
init_solidity();
init_base();
init_contract();
function isNullUniversalResolverError(err, callType) {
  if (!(err instanceof BaseError))
    return false;
  const cause = err.walk((e) => e instanceof ContractFunctionRevertedError);
  if (!(cause instanceof ContractFunctionRevertedError))
    return false;
  if (cause.data?.errorName === "ResolverNotFound")
    return true;
  if (cause.data?.errorName === "ResolverWildcardNotSupported")
    return true;
  if (cause.reason?.includes("Wildcard on non-extended resolvers is not supported"))
    return true;
  if (callType === "reverse" && cause.reason === panicReasons[50])
    return true;
  return false;
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/ens/namehash.js
init_concat();
init_toBytes();
init_toHex();
init_keccak256();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/ens/encodedLabelToLabelhash.js
init_isHex();
function encodedLabelToLabelhash(label) {
  if (label.length !== 66)
    return null;
  if (label.indexOf("[") !== 0)
    return null;
  if (label.indexOf("]") !== 65)
    return null;
  const hash4 = `0x${label.slice(1, 65)}`;
  if (!isHex(hash4))
    return null;
  return hash4;
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/ens/namehash.js
function namehash(name) {
  let result = new Uint8Array(32).fill(0);
  if (!name)
    return bytesToHex(result);
  const labels = name.split(".");
  for (let i = labels.length - 1;i >= 0; i -= 1) {
    const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i]);
    const hashed = hashFromEncodedLabel ? toBytes2(hashFromEncodedLabel) : keccak256(stringToBytes(labels[i]), "bytes");
    result = keccak256(concat([result, hashed]), "bytes");
  }
  return bytesToHex(result);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/ens/packetToBytes.js
init_toBytes();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/ens/encodeLabelhash.js
function encodeLabelhash(hash4) {
  return `[${hash4.slice(2)}]`;
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/ens/labelhash.js
init_toBytes();
init_toHex();
init_keccak256();
function labelhash(label) {
  const result = new Uint8Array(32).fill(0);
  if (!label)
    return bytesToHex(result);
  return encodedLabelToLabelhash(label) || keccak256(stringToBytes(label));
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/ens/packetToBytes.js
function packetToBytes(packet) {
  const value = packet.replace(/^\.|\.$/gm, "");
  if (value.length === 0)
    return new Uint8Array(1);
  const bytes2 = new Uint8Array(stringToBytes(value).byteLength + 2);
  let offset = 0;
  const list = value.split(".");
  for (let i = 0;i < list.length; i++) {
    let encoded = stringToBytes(list[i]);
    if (encoded.byteLength > 255)
      encoded = stringToBytes(encodeLabelhash(labelhash(list[i])));
    bytes2[offset] = encoded.length;
    bytes2.set(encoded, offset + 1);
    offset += encoded.length + 1;
  }
  if (bytes2.byteLength !== offset + 1)
    return bytes2.slice(0, offset + 1);
  return bytes2;
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/ens/getEnsAddress.js
async function getEnsAddress(client, { blockNumber, blockTag, coinType, name, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const functionData = encodeFunctionData({
      abi: addressResolverAbi,
      functionName: "addr",
      ...coinType != null ? { args: [namehash(name), BigInt(coinType)] } : { args: [namehash(name)] }
    });
    const res = await getAction(client, readContract, "readContract")({
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [toHex2(packetToBytes(name)), functionData],
      blockNumber,
      blockTag
    });
    if (res[0] === "0x")
      return null;
    const address5 = decodeFunctionResult({
      abi: addressResolverAbi,
      args: coinType != null ? [namehash(name), BigInt(coinType)] : undefined,
      functionName: "addr",
      data: res[0]
    });
    if (address5 === "0x")
      return null;
    if (trim(address5) === "0x00")
      return null;
    return address5;
  } catch (err) {
    if (isNullUniversalResolverError(err, "resolve"))
      return null;
    throw err;
  }
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/ens.js
init_base();

class EnsAvatarInvalidMetadataError extends BaseError {
  constructor({ data: data3 }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: [
        "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
        "",
        `Provided data: ${JSON.stringify(data3)}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarInvalidMetadataError"
    });
  }
}

class EnsAvatarInvalidNftUriError extends BaseError {
  constructor({ reason }) {
    super(`ENS NFT avatar URI is invalid. ${reason}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarInvalidNftUriError"
    });
  }
}

class EnsAvatarUriResolutionError extends BaseError {
  constructor({ uri }) {
    super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarUriResolutionError"
    });
  }
}

class EnsAvatarUnsupportedNamespaceError extends BaseError {
  constructor({ namespace }) {
    super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarUnsupportedNamespaceError"
    });
  }
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/ens/avatar/utils.js
async function isImageUri(uri) {
  try {
    const res = await fetch(uri, { method: "HEAD" });
    if (res.status === 200) {
      const contentType = res.headers.get("content-type");
      return contentType?.startsWith("image/");
    }
    return false;
  } catch (error) {
    if (typeof error === "object" && typeof error.response !== "undefined") {
      return false;
    }
    if (!globalThis.hasOwnProperty("Image"))
      return false;
    return new Promise((resolve5) => {
      const img = new Image;
      img.onload = () => {
        resolve5(true);
      };
      img.onerror = () => {
        resolve5(false);
      };
      img.src = uri;
    });
  }
}
function getGateway(custom, defaultGateway) {
  if (!custom)
    return defaultGateway;
  if (custom.endsWith("/"))
    return custom.slice(0, -1);
  return custom;
}
function resolveAvatarUri({ uri, gatewayUrls }) {
  const isEncoded = base64Regex.test(uri);
  if (isEncoded)
    return { uri, isOnChain: true, isEncoded };
  const ipfsGateway = getGateway(gatewayUrls?.ipfs, "https://ipfs.io");
  const arweaveGateway = getGateway(gatewayUrls?.arweave, "https://arweave.net");
  const networkRegexMatch = uri.match(networkRegex);
  const { protocol, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
  const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
  const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
  if (uri.startsWith("http") && !isIPNS && !isIPFS) {
    let replacedUri = uri;
    if (gatewayUrls?.arweave)
      replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
    return { uri: replacedUri, isOnChain: false, isEncoded: false };
  }
  if ((isIPNS || isIPFS) && target) {
    return {
      uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  if (protocol === "ar:/" && target) {
    return {
      uri: `${arweaveGateway}/${target}${subtarget || ""}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  let parsedUri = uri.replace(dataURIRegex, "");
  if (parsedUri.startsWith("<svg")) {
    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
  }
  if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
    return {
      uri: parsedUri,
      isOnChain: true,
      isEncoded: false
    };
  }
  throw new EnsAvatarUriResolutionError({ uri });
}
function getJsonImage(data3) {
  if (typeof data3 !== "object" || !("image" in data3) && !("image_url" in data3) && !("image_data" in data3)) {
    throw new EnsAvatarInvalidMetadataError({ data: data3 });
  }
  return data3.image || data3.image_url || data3.image_data;
}
async function getMetadataAvatarUri({ gatewayUrls, uri }) {
  try {
    const res = await fetch(uri).then((res2) => res2.json());
    const image = await parseAvatarUri({
      gatewayUrls,
      uri: getJsonImage(res)
    });
    return image;
  } catch {
    throw new EnsAvatarUriResolutionError({ uri });
  }
}
async function parseAvatarUri({ gatewayUrls, uri }) {
  const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
  if (isOnChain)
    return resolvedURI;
  const isImage = await isImageUri(resolvedURI);
  if (isImage)
    return resolvedURI;
  throw new EnsAvatarUriResolutionError({ uri });
}
function parseNftUri(uri_) {
  let uri = uri_;
  if (uri.startsWith("did:nft:")) {
    uri = uri.replace("did:nft:", "").replace(/_/g, "/");
  }
  const [reference, asset_namespace, tokenID] = uri.split("/");
  const [eip_namespace, chainID] = reference.split(":");
  const [erc_namespace, contractAddress] = asset_namespace.split(":");
  if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
    throw new EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
  if (!chainID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
  if (!contractAddress)
    throw new EnsAvatarInvalidNftUriError({
      reason: "Contract address not found"
    });
  if (!tokenID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
  if (!erc_namespace)
    throw new EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
  return {
    chainID: parseInt(chainID),
    namespace: erc_namespace.toLowerCase(),
    contractAddress,
    tokenID
  };
}
async function getNftTokenUri(client, { nft }) {
  if (nft.namespace === "erc721") {
    return readContract(client, {
      address: nft.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(nft.tokenID)]
    });
  }
  if (nft.namespace === "erc1155") {
    return readContract(client, {
      address: nft.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(nft.tokenID)]
    });
  }
  throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
}
var networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
var ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
var base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
var dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/ens/avatar/parseAvatarRecord.js
async function parseAvatarRecord(client, { gatewayUrls, record }) {
  if (/eip155:/i.test(record))
    return parseNftAvatarUri(client, { gatewayUrls, record });
  return parseAvatarUri({ uri: record, gatewayUrls });
}
async function parseNftAvatarUri(client, { gatewayUrls, record }) {
  const nft = parseNftUri(record);
  const nftUri = await getNftTokenUri(client, { nft });
  const { uri: resolvedNftUri, isOnChain, isEncoded } = resolveAvatarUri({ uri: nftUri, gatewayUrls });
  if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
    const encodedJson = isEncoded ? atob(resolvedNftUri.replace("data:application/json;base64,", "")) : resolvedNftUri;
    const decoded = JSON.parse(encodedJson);
    return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls });
  }
  let uriTokenId = nft.tokenID;
  if (nft.namespace === "erc1155")
    uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
  return getMetadataAvatarUri({
    gatewayUrls,
    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
  });
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/ens/getEnsText.js
init_abis();
init_decodeFunctionResult();
init_encodeFunctionData();
init_getChainContractAddress();
init_toHex();
async function getEnsText(client, { blockNumber, blockTag, name, key, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const res = await getAction(client, readContract, "readContract")({
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [
        toHex2(packetToBytes(name)),
        encodeFunctionData({
          abi: textResolverAbi,
          functionName: "text",
          args: [namehash(name), key]
        })
      ],
      blockNumber,
      blockTag
    });
    if (res[0] === "0x")
      return null;
    const record = decodeFunctionResult({
      abi: textResolverAbi,
      functionName: "text",
      data: res[0]
    });
    return record === "" ? null : record;
  } catch (err) {
    if (isNullUniversalResolverError(err, "resolve"))
      return null;
    throw err;
  }
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/ens/getEnsAvatar.js
async function getEnsAvatar(client, { blockNumber, blockTag, gatewayUrls, name, universalResolverAddress }) {
  const record = await getAction(client, getEnsText, "getEnsText")({
    blockNumber,
    blockTag,
    key: "avatar",
    name,
    universalResolverAddress
  });
  if (!record)
    return null;
  try {
    return await parseAvatarRecord(client, { record, gatewayUrls });
  } catch {
    return null;
  }
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/ens/getEnsName.js
init_abis();
init_getChainContractAddress();
init_toHex();
async function getEnsName(client, { address: address5, blockNumber, blockTag, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  const reverseNode = `${address5.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const [name, resolvedAddress] = await getAction(client, readContract, "readContract")({
      address: universalResolverAddress,
      abi: universalResolverReverseAbi,
      functionName: "reverse",
      args: [toHex2(packetToBytes(reverseNode))],
      blockNumber,
      blockTag
    });
    if (address5.toLowerCase() !== resolvedAddress.toLowerCase())
      return null;
    return name;
  } catch (err) {
    if (isNullUniversalResolverError(err, "reverse"))
      return null;
    throw err;
  }
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/ens/getEnsResolver.js
init_getChainContractAddress();
init_toHex();
async function getEnsResolver(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  const [resolverAddress] = await getAction(client, readContract, "readContract")({
    address: universalResolverAddress,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "findResolver",
    args: [toHex2(packetToBytes(name))],
    blockNumber,
    blockTag
  });
  return resolverAddress;
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/clients/decorators/public.js
init_call();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/createBlockFilter.js
async function createBlockFilter(client) {
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newBlockFilter"
  });
  const id2 = await client.request({
    method: "eth_newBlockFilter"
  });
  return { id: id2, request: getRequest(id2), type: "block" };
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/createEventFilter.js
init_toHex();
async function createEventFilter(client, { address: address5, args, event, events: events_, fromBlock, strict, toBlock } = {}) {
  const events = events_ ?? (event ? [event] : undefined);
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newFilter"
  });
  let topics = [];
  if (events) {
    topics = [
      events.flatMap((event2) => encodeEventTopics({
        abi: [event2],
        eventName: event2.name,
        args
      }))
    ];
    if (event)
      topics = topics[0];
  }
  const id2 = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address: address5,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        ...topics.length ? { topics } : {}
      }
    ]
  });
  return {
    abi: events,
    args,
    eventName: event ? event.name : undefined,
    fromBlock,
    id: id2,
    request: getRequest(id2),
    strict,
    toBlock,
    type: "event"
  };
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/createPendingTransactionFilter.js
async function createPendingTransactionFilter(client) {
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newPendingTransactionFilter"
  });
  const id2 = await client.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id: id2, request: getRequest(id2), type: "transaction" };
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getBalance.js
init_toHex();
async function getBalance(client, { address: address5, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
  const balance = await client.request({
    method: "eth_getBalance",
    params: [address5, blockNumberHex || blockTag]
  });
  return BigInt(balance);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getBlockTransactionCount.js
init_fromHex();
init_toHex();
async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = "latest" } = {}) {
  const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
  let count;
  if (blockHash) {
    count = await client.request({
      method: "eth_getBlockTransactionCountByHash",
      params: [blockHash]
    });
  } else {
    count = await client.request({
      method: "eth_getBlockTransactionCountByNumber",
      params: [blockNumberHex || blockTag]
    });
  }
  return hexToNumber(count);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getBytecode.js
init_toHex();
async function getBytecode(client, { address: address5, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
  const hex = await client.request({
    method: "eth_getCode",
    params: [address5, blockNumberHex || blockTag]
  });
  if (hex === "0x")
    return;
  return hex;
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getFeeHistory.js
init_toHex();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/formatters/feeHistory.js
function formatFeeHistory(feeHistory) {
  return {
    baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
    gasUsedRatio: feeHistory.gasUsedRatio,
    oldestBlock: BigInt(feeHistory.oldestBlock),
    reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value)))
  };
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getFeeHistory.js
async function getFeeHistory(client, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
  const feeHistory2 = await client.request({
    method: "eth_feeHistory",
    params: [
      numberToHex(blockCount),
      blockNumberHex || blockTag,
      rewardPercentiles
    ]
  });
  return formatFeeHistory(feeHistory2);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getFilterLogs.js
init_abi();
async function getFilterLogs(_client, { filter }) {
  const strict = filter.strict ?? false;
  const logs = await filter.request({
    method: "eth_getFilterLogs",
    params: [filter.id]
  });
  return logs.map((log6) => {
    try {
      const { eventName, args } = "abi" in filter && filter.abi ? decodeEventLog({
        abi: filter.abi,
        data: log6.data,
        topics: log6.topics,
        strict
      }) : { eventName: undefined, args: undefined };
      return formatLog(log6, { args, eventName });
    } catch (err) {
      let eventName;
      let isUnnamed;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if ("strict" in filter && filter.strict)
          return;
        eventName = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x) => !(("name" in x) && x.name));
      }
      return formatLog(log6, { args: isUnnamed ? [] : {}, eventName });
    }
  }).filter(Boolean);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getProof.js
init_toHex();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/chain/defineChain.js
function defineChain(chain4, config = {}) {
  const { fees = chain4.fees, formatters = chain4.formatters, serializers = chain4.serializers } = config;
  return {
    ...chain4,
    fees,
    formatters,
    serializers
  };
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/regex.js
var bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/typedData.js
init_abi();
init_address();
init_isAddress();
init_size();
init_toHex();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/signature/hashTypedData.js
init_encodeAbiParameters();
init_concat();
init_toHex();
init_keccak256();
function hashTypedData({ domain: domain_, message, primaryType, types: types_ }) {
  const domain = typeof domain_ === "undefined" ? {} : domain_;
  const types = {
    EIP712Domain: getTypesForEIP712Domain({ domain }),
    ...types_
  };
  validateTypedData({
    domain,
    message,
    primaryType,
    types
  });
  const parts = ["0x1901"];
  if (domain)
    parts.push(hashDomain({
      domain,
      types
    }));
  if (primaryType !== "EIP712Domain") {
    parts.push(hashStruct({
      data: message,
      primaryType,
      types
    }));
  }
  return keccak256(concat(parts));
}
function hashDomain({ domain, types }) {
  return hashStruct({
    data: domain,
    primaryType: "EIP712Domain",
    types
  });
}
var hashStruct = function({ data: data3, primaryType, types }) {
  const encoded = encodeData({
    data: data3,
    primaryType,
    types
  });
  return keccak256(encoded);
};
var encodeData = function({ data: data3, primaryType, types }) {
  const encodedTypes = [{ type: "bytes32" }];
  const encodedValues = [hashType({ primaryType, types })];
  for (const field of types[primaryType]) {
    const [type, value] = encodeField({
      types,
      name: field.name,
      type: field.type,
      value: data3[field.name]
    });
    encodedTypes.push(type);
    encodedValues.push(value);
  }
  return encodeAbiParameters(encodedTypes, encodedValues);
};
var hashType = function({ primaryType, types }) {
  const encodedHashType = toHex2(encodeType({ primaryType, types }));
  return keccak256(encodedHashType);
};
var encodeType = function({ primaryType, types }) {
  let result = "";
  const unsortedDeps = findTypeDependencies({ primaryType, types });
  unsortedDeps.delete(primaryType);
  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
  for (const type of deps) {
    result += `${type}(${types[type].map(({ name, type: t }) => `${t} ${name}`).join(",")})`;
  }
  return result;
};
var findTypeDependencies = function({ primaryType: primaryType_, types }, results = new Set) {
  const match = primaryType_.match(/^\w*/u);
  const primaryType = match?.[0];
  if (results.has(primaryType) || types[primaryType] === undefined) {
    return results;
  }
  results.add(primaryType);
  for (const field of types[primaryType]) {
    findTypeDependencies({ primaryType: field.type, types }, results);
  }
  return results;
};
var encodeField = function({ types, name, type, value }) {
  if (types[type] !== undefined) {
    return [
      { type: "bytes32" },
      keccak256(encodeData({ data: value, primaryType: type, types }))
    ];
  }
  if (type === "bytes") {
    const prepend = value.length % 2 ? "0" : "";
    value = `0x${prepend + value.slice(2)}`;
    return [{ type: "bytes32" }, keccak256(value)];
  }
  if (type === "string")
    return [{ type: "bytes32" }, keccak256(toHex2(value))];
  if (type.lastIndexOf("]") === type.length - 1) {
    const parsedType = type.slice(0, type.lastIndexOf("["));
    const typeValuePairs = value.map((item) => encodeField({
      name,
      type: parsedType,
      types,
      value: item
    }));
    return [
      { type: "bytes32" },
      keccak256(encodeAbiParameters(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))
    ];
  }
  return [{ type }, value];
};

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/typedData.js
function validateTypedData({ domain, message, primaryType, types: types_ }) {
  const types = types_;
  const validateData = (struct, value_) => {
    for (const param of struct) {
      const { name, type: type_ } = param;
      const type = type_;
      const value = value_[name];
      const integerMatch = type.match(integerRegex);
      if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
        const [_type, base26, size_] = integerMatch;
        numberToHex(value, {
          signed: base26 === "int",
          size: parseInt(size_) / 8
        });
      }
      if (type === "address" && typeof value === "string" && !isAddress(value))
        throw new InvalidAddressError({ address: value });
      const bytesMatch = type.match(bytesRegex);
      if (bytesMatch) {
        const [_type, size_] = bytesMatch;
        if (size_ && size(value) !== parseInt(size_))
          throw new BytesSizeMismatchError({
            expectedSize: parseInt(size_),
            givenSize: size(value)
          });
      }
      const struct2 = types[type];
      if (struct2)
        validateData(struct2, value);
    }
  };
  if (types.EIP712Domain && domain)
    validateData(types.EIP712Domain, domain);
  if (primaryType !== "EIP712Domain") {
    const type = types[primaryType];
    validateData(type, message);
  }
}
function getTypesForEIP712Domain({ domain }) {
  return [
    typeof domain?.name === "string" && { name: "name", type: "string" },
    domain?.version && { name: "version", type: "string" },
    typeof domain?.chainId === "number" && {
      name: "chainId",
      type: "uint256"
    },
    domain?.verifyingContract && {
      name: "verifyingContract",
      type: "address"
    },
    domain?.salt && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/abi/decodeFunctionData.js
init_abi();
init_slice();
init_getFunctionSelector();
init_decodeAbiParameters();
init_formatAbiItem2();
function decodeFunctionData({ abi: abi18, data: data3 }) {
  const signature = slice(data3, 0, 4);
  const description = abi18.find((x) => x.type === "function" && signature === getFunctionSelector(formatAbiItem2(x)));
  if (!description)
    throw new AbiFunctionSignatureNotFoundError(signature, {
      docsPath: "/docs/contract/decodeFunctionData"
    });
  return {
    functionName: description.name,
    args: "inputs" in description && description.inputs && description.inputs.length > 0 ? decodeAbiParameters(description.inputs, slice(data3, 4)) : undefined
  };
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/abi/encodeDeployData.js
init_abi();
init_concat();
init_encodeAbiParameters();
function encodeDeployData({ abi: abi19, args, bytecode }) {
  if (!args || args.length === 0)
    return bytecode;
  const description = abi19.find((x) => ("type" in x) && x.type === "constructor");
  if (!description)
    throw new AbiConstructorNotFoundError({ docsPath: docsPath3 });
  if (!("inputs" in description))
    throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath3 });
  if (!description.inputs || description.inputs.length === 0)
    throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath3 });
  const data3 = encodeAbiParameters(description.inputs, args);
  return concatHex([bytecode, data3]);
}
var docsPath3 = "/docs/contract/encodeDeployData";
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/errors/cursor.js
init_base();

class NegativeOffsetError extends BaseError {
  constructor({ offset }) {
    super(`Offset \`${offset}\` cannot be negative.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "NegativeOffsetError"
    });
  }
}

class PositionOutOfBoundsError extends BaseError {
  constructor({ length, position }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "PositionOutOfBoundsError"
    });
  }
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/cursor.js
function createCursor(bytes2) {
  const cursor2 = Object.create(staticCursor);
  cursor2.bytes = bytes2;
  cursor2.dataView = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
  return cursor2;
}
var staticCursor = {
  bytes: new Uint8Array,
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new PositionOutOfBoundsError({
        length: this.bytes.length,
        position
      });
  },
  decrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position - offset;
    this.assertPosition(position);
    this.position = position;
  },
  incrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position + offset;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length - 1);
    return this.bytes.subarray(position, position + length);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes2) {
    this.assertPosition(this.position + bytes2.length - 1);
    this.bytes.set(bytes2, this.position);
    this.position += bytes2.length;
  },
  pushUint8(value) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value;
    this.position++;
  },
  pushUint16(value) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value);
    this.position += 2;
  },
  pushUint24(value) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value >> 8);
    this.dataView.setUint8(this.position + 2, value & ~4294967040);
    this.position += 3;
  },
  pushUint32(value) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value);
    this.position += 4;
  },
  readByte() {
    const value = this.inspectByte();
    this.position++;
    return value;
  },
  readBytes(length) {
    const value = this.inspectBytes(length);
    this.position += length;
    return value;
  },
  readUint8() {
    const value = this.inspectUint8();
    this.position += 1;
    return value;
  },
  readUint16() {
    const value = this.inspectUint16();
    this.position += 2;
    return value;
  },
  readUint24() {
    const value = this.inspectUint24();
    this.position += 3;
    return value;
  },
  readUint32() {
    const value = this.inspectUint32();
    this.position += 4;
    return value;
  },
  setPosition(position) {
    this.assertPosition(position);
    this.position = position;
  }
};

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/encoding/toRlp.js
init_toBytes();
init_toHex();
function toRlp(bytes2, to = "hex") {
  const encodable = getEncodable(bytes2);
  const cursor3 = createCursor(new Uint8Array(encodable.length));
  encodable.encode(cursor3);
  if (to === "hex")
    return bytesToHex(cursor3.bytes);
  return cursor3.bytes;
}
var getEncodable = function(bytes2) {
  if (Array.isArray(bytes2))
    return getEncodableList(bytes2.map((x) => getEncodable(x)));
  return getEncodableBytes(bytes2);
};
var getEncodableList = function(list) {
  const bodyLength = list.reduce((acc, x) => acc + x.length, 0);
  const sizeOfBodyLength = getSizeOfLength(bodyLength);
  const length = (() => {
    if (bodyLength <= 55)
      return 1 + bodyLength;
    return 1 + sizeOfBodyLength + bodyLength;
  })();
  return {
    length,
    encode(cursor3) {
      if (bodyLength <= 55) {
        cursor3.pushByte(192 + bodyLength);
      } else {
        cursor3.pushByte(192 + 55 + sizeOfBodyLength);
        if (sizeOfBodyLength === 1)
          cursor3.pushUint8(bodyLength);
        else if (sizeOfBodyLength === 2)
          cursor3.pushUint16(bodyLength);
        else if (sizeOfBodyLength === 3)
          cursor3.pushUint24(bodyLength);
        else
          cursor3.pushUint32(bodyLength);
      }
      for (const { encode } of list) {
        encode(cursor3);
      }
    }
  };
};
var getEncodableBytes = function(bytesOrHex) {
  const bytes2 = typeof bytesOrHex === "string" ? hexToBytes(bytesOrHex) : bytesOrHex;
  const sizeOfBytesLength = getSizeOfLength(bytes2.length);
  const length = (() => {
    if (bytes2.length === 1 && bytes2[0] < 128)
      return 1;
    if (bytes2.length <= 55)
      return 1 + bytes2.length;
    return 1 + sizeOfBytesLength + bytes2.length;
  })();
  return {
    length,
    encode(cursor3) {
      if (bytes2.length === 1 && bytes2[0] < 128) {
        cursor3.pushBytes(bytes2);
      } else if (bytes2.length <= 55) {
        cursor3.pushByte(128 + bytes2.length);
        cursor3.pushBytes(bytes2);
      } else {
        cursor3.pushByte(128 + 55 + sizeOfBytesLength);
        if (sizeOfBytesLength === 1)
          cursor3.pushUint8(bytes2.length);
        else if (sizeOfBytesLength === 2)
          cursor3.pushUint16(bytes2.length);
        else if (sizeOfBytesLength === 3)
          cursor3.pushUint24(bytes2.length);
        else
          cursor3.pushUint32(bytes2.length);
        cursor3.pushBytes(bytes2);
      }
    }
  };
};
var getSizeOfLength = function(length) {
  if (length < 2 ** 8)
    return 1;
  if (length < 2 ** 16)
    return 2;
  if (length < 2 ** 24)
    return 3;
  if (length < 2 ** 32)
    return 4;
  throw new BaseError("Length is too large.");
};

// /home/mous/work/pimlico/alto/src/node_modules/viem/_esm/utils/index.js
init_isHex();
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/formatters/transactionReceipt.js
init_fromHex();
init_formatter();
function formatTransactionReceipt(transactionReceipt) {
  return {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log7) => formatLog(log7)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? statuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
}
var statuses = {
  "0x0": "reverted",
  "0x1": "success"
};
var defineTransactionReceipt = defineFormatter("transactionReceipt", formatTransactionReceipt);

// /home/mous/work/pimlico/alto/src/node_modules/viem/_esm/utils/index.js
init_toHex();
init_fromHex();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/constants/strings.js
var presignMessagePrefix = `\x19Ethereum Signed Message:
`;

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/signature/hashMessage.js
init_concat();
init_toBytes();
init_keccak256();
function hashMessage(message, to_) {
  const messageBytes = (() => {
    if (typeof message === "string")
      return stringToBytes(message);
    if (message.raw instanceof Uint8Array)
      return message.raw;
    return toBytes2(message.raw);
  })();
  const prefixBytes = stringToBytes(`${presignMessagePrefix}${messageBytes.length}`);
  return keccak256(concat([prefixBytes, messageBytes]), to_);
}
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/transaction/assertTransaction.js
init_address();
init_base();
init_chain();
init_node();
init_isAddress();
function assertTransactionEIP1559(transaction8) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction8;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (gasPrice)
    throw new BaseError("`gasPrice` is not a valid EIP-1559 Transaction attribute.");
  if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
function assertTransactionEIP2930(transaction8) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction8;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (maxPriorityFeePerGas || maxFeePerGas)
    throw new BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (gasPrice && gasPrice > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });
}
function assertTransactionLegacy(transaction8) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, accessList } = transaction8;
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (typeof chainId !== "undefined" && chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (maxPriorityFeePerGas || maxFeePerGas)
    throw new BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (gasPrice && gasPrice > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });
  if (accessList)
    throw new BaseError("`accessList` is not a valid Legacy Transaction attribute.");
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/transaction/serializeTransaction.js
init_transaction();
init_concat();
init_trim();
init_toHex();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/transaction/serializeAccessList.js
init_address();
init_transaction();
init_isAddress();
function serializeAccessList(accessList) {
  if (!accessList || accessList.length === 0)
    return [];
  const serializedAccessList = [];
  for (let i = 0;i < accessList.length; i++) {
    const { address: address8, storageKeys } = accessList[i];
    for (let j = 0;j < storageKeys.length; j++) {
      if (storageKeys[j].length - 2 !== 64) {
        throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j] });
      }
    }
    if (!isAddress(address8)) {
      throw new InvalidAddressError({ address: address8 });
    }
    serializedAccessList.push([address8, storageKeys]);
  }
  return serializedAccessList;
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/transaction/serializeTransaction.js
function serializeTransaction(transaction10, signature) {
  const type = getTransactionType(transaction10);
  if (type === "eip1559")
    return serializeTransactionEIP1559(transaction10, signature);
  if (type === "eip2930")
    return serializeTransactionEIP2930(transaction10, signature);
  return serializeTransactionLegacy(transaction10, signature);
}
var serializeTransactionEIP1559 = function(transaction10, signature) {
  const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data: data3 } = transaction10;
  assertTransactionEIP1559(transaction10);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    toHex2(chainId),
    nonce ? toHex2(nonce) : "0x",
    maxPriorityFeePerGas ? toHex2(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex2(maxFeePerGas) : "0x",
    gas ? toHex2(gas) : "0x",
    to ?? "0x",
    value ? toHex2(value) : "0x",
    data3 ?? "0x",
    serializedAccessList
  ];
  if (signature) {
    const yParity = (() => {
      if (signature.v === 0n)
        return "0x";
      if (signature.v === 1n)
        return toHex2(1);
      return signature.v === 27n ? "0x" : toHex2(1);
    })();
    serializedTransaction.push(yParity, trim(signature.r), trim(signature.s));
  }
  return concatHex([
    "0x02",
    toRlp(serializedTransaction)
  ]);
};
var serializeTransactionEIP2930 = function(transaction10, signature) {
  const { chainId, gas, data: data3, nonce, to, value, accessList, gasPrice } = transaction10;
  assertTransactionEIP2930(transaction10);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    toHex2(chainId),
    nonce ? toHex2(nonce) : "0x",
    gasPrice ? toHex2(gasPrice) : "0x",
    gas ? toHex2(gas) : "0x",
    to ?? "0x",
    value ? toHex2(value) : "0x",
    data3 ?? "0x",
    serializedAccessList
  ];
  if (signature) {
    const yParity = (() => {
      if (signature.v === 0n)
        return "0x";
      if (signature.v === 1n)
        return toHex2(1);
      return signature.v === 27n ? "0x" : toHex2(1);
    })();
    serializedTransaction.push(yParity, trim(signature.r), trim(signature.s));
  }
  return concatHex([
    "0x01",
    toRlp(serializedTransaction)
  ]);
};
var serializeTransactionLegacy = function(transaction10, signature) {
  const { chainId = 0, gas, data: data3, nonce, to, value, gasPrice } = transaction10;
  assertTransactionLegacy(transaction10);
  let serializedTransaction = [
    nonce ? toHex2(nonce) : "0x",
    gasPrice ? toHex2(gasPrice) : "0x",
    gas ? toHex2(gas) : "0x",
    to ?? "0x",
    value ? toHex2(value) : "0x",
    data3 ?? "0x"
  ];
  if (signature) {
    const v = (() => {
      if (chainId > 0)
        return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
      if (signature.v >= 35n) {
        const inferredChainId = (signature.v - 35n) / 2n;
        if (inferredChainId > 0)
          return signature.v;
        return 27n + (signature.v === 35n ? 0n : 1n);
      }
      const v2 = 27n + (signature.v === 27n ? 0n : 1n);
      if (signature.v !== v2)
        throw new InvalidLegacyVError({ v: signature.v });
      return v2;
    })();
    serializedTransaction = [
      ...serializedTransaction,
      toHex2(v),
      signature.r,
      signature.s
    ];
  } else if (chainId > 0) {
    serializedTransaction = [
      ...serializedTransaction,
      toHex2(chainId),
      "0x",
      "0x"
    ];
  }
  return toRlp(serializedTransaction);
};

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/unit/parseUnits.js
function parseUnits(value, decimals) {
  let [integer, fraction = "0"] = value.split(".");
  const negative = integer.startsWith("-");
  if (negative)
    integer = integer.slice(1);
  fraction = fraction.replace(/(0+)$/, "");
  if (decimals === 0) {
    if (Math.round(Number(`.${fraction}`)) === 1)
      integer = `${BigInt(integer) + 1n}`;
    fraction = "";
  } else if (fraction.length > decimals) {
    const [left2, unit3, right2] = [
      fraction.slice(0, decimals - 1),
      fraction.slice(decimals - 1, decimals),
      fraction.slice(decimals)
    ];
    const rounded = Math.round(Number(`${unit3}.${right2}`));
    if (rounded > 9)
      fraction = `${BigInt(left2) + BigInt(1)}0`.padStart(left2.length + 1, "0");
    else
      fraction = `${left2}${rounded}`;
    if (fraction.length > decimals) {
      fraction = fraction.slice(1);
      integer = `${BigInt(integer) + 1n}`;
    }
    fraction = fraction.slice(0, decimals);
  } else {
    fraction = fraction.padEnd(decimals, "0");
  }
  return BigInt(`${negative ? "-" : ""}${integer}${fraction}`);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/unit/parseGwei.js
init_unit();
function parseGwei(ether, unit4 = "wei") {
  return parseUnits(ether, gweiUnits[unit4]);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/formatters/proof.js
var formatStorageProof = function(storageProof) {
  return storageProof.map((proof) => ({
    ...proof,
    value: BigInt(proof.value)
  }));
};
function formatProof(proof) {
  return {
    ...proof,
    balance: proof.balance ? BigInt(proof.balance) : undefined,
    nonce: proof.nonce ? hexToNumber(proof.nonce) : undefined,
    storageProof: proof.storageProof ? formatStorageProof(proof.storageProof) : undefined
  };
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getProof.js
async function getProof(client, { address: address8, blockNumber, blockTag: blockTag_, storageKeys }) {
  const blockTag = blockTag_ ?? "latest";
  const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
  const proof2 = await client.request({
    method: "eth_getProof",
    params: [address8, storageKeys, blockNumberHex || blockTag]
  });
  return formatProof(proof2);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getStorageAt.js
init_toHex();
async function getStorageAt(client, { address: address8, blockNumber, blockTag = "latest", slot }) {
  const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
  const data3 = await client.request({
    method: "eth_getStorageAt",
    params: [address8, slot, blockNumberHex || blockTag]
  });
  return data3;
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getTransaction.js
init_transaction();
init_toHex();
async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash: hash4, index: index2 }) {
  const blockTag = blockTag_ || "latest";
  const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
  let transaction12 = null;
  if (hash4) {
    transaction12 = await client.request({
      method: "eth_getTransactionByHash",
      params: [hash4]
    });
  } else if (blockHash) {
    transaction12 = await client.request({
      method: "eth_getTransactionByBlockHashAndIndex",
      params: [blockHash, numberToHex(index2)]
    });
  } else if (blockNumberHex || blockTag) {
    transaction12 = await client.request({
      method: "eth_getTransactionByBlockNumberAndIndex",
      params: [blockNumberHex || blockTag, numberToHex(index2)]
    });
  }
  if (!transaction12)
    throw new TransactionNotFoundError({
      blockHash,
      blockNumber,
      blockTag,
      hash: hash4,
      index: index2
    });
  const format3 = client.chain?.formatters?.transaction?.format || formatTransaction;
  return format3(transaction12);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getTransactionConfirmations.js
async function getTransactionConfirmations(client, { hash: hash4, transactionReceipt }) {
  const [blockNumber, transaction12] = await Promise.all([
    getAction(client, getBlockNumber, "getBlockNumber")({}),
    hash4 ? getAction(client, getTransaction, "getBlockNumber")({ hash: hash4 }) : undefined
  ]);
  const transactionBlockNumber = transactionReceipt?.blockNumber || transaction12?.blockNumber;
  if (!transactionBlockNumber)
    return 0n;
  return blockNumber - transactionBlockNumber + 1n;
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/getTransactionReceipt.js
init_transaction();
async function getTransactionReceipt(client, { hash: hash4 }) {
  const receipt = await client.request({
    method: "eth_getTransactionReceipt",
    params: [hash4]
  });
  if (!receipt)
    throw new TransactionReceiptNotFoundError({ hash: hash4 });
  const format3 = client.chain?.formatters?.transactionReceipt?.format || formatTransactionReceipt;
  return format3(receipt);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/multicall.js
init_abis();
init_abi();
init_base();
init_contract();
init_decodeFunctionResult();
init_encodeFunctionData();
init_getChainContractAddress();
async function multicall(client, args) {
  const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, contracts, multicallAddress: multicallAddress_ } = args;
  const batchSize = batchSize_ ?? (typeof client.batch?.multicall === "object" && client.batch.multicall.batchSize || 1024);
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    multicallAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "multicall3"
    });
  }
  const chunkedCalls = [[]];
  let currentChunk = 0;
  let currentChunkSize = 0;
  for (let i = 0;i < contracts.length; i++) {
    const { abi: abi20, address: address8, args: args2, functionName } = contracts[i];
    try {
      const callData = encodeFunctionData({
        abi: abi20,
        args: args2,
        functionName
      });
      currentChunkSize += (callData.length - 2) / 2;
      if (batchSize > 0 && currentChunkSize > batchSize && chunkedCalls[currentChunk].length > 0) {
        currentChunk++;
        currentChunkSize = (callData.length - 2) / 2;
        chunkedCalls[currentChunk] = [];
      }
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData,
          target: address8
        }
      ];
    } catch (err) {
      const error = getContractError(err, {
        abi: abi20,
        address: address8,
        args: args2,
        docsPath: "/docs/contract/multicall",
        functionName
      });
      if (!allowFailure)
        throw error;
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData: "0x",
          target: address8
        }
      ];
    }
  }
  const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => getAction(client, readContract, "readContract")({
    abi: multicall3Abi,
    address: multicallAddress,
    args: [calls],
    blockNumber,
    blockTag,
    functionName: "aggregate3"
  })));
  const results = [];
  for (let i = 0;i < aggregate3Results.length; i++) {
    const result = aggregate3Results[i];
    if (result.status === "rejected") {
      if (!allowFailure)
        throw result.reason;
      for (let j = 0;j < chunkedCalls[i].length; j++) {
        results.push({
          status: "failure",
          error: result.reason,
          result: undefined
        });
      }
      continue;
    }
    const aggregate3Result = result.value;
    for (let j = 0;j < aggregate3Result.length; j++) {
      const { returnData, success } = aggregate3Result[j];
      const { callData } = chunkedCalls[i][j];
      const { abi: abi20, address: address8, functionName, args: args2 } = contracts[results.length];
      try {
        if (callData === "0x")
          throw new AbiDecodingZeroDataError;
        if (!success)
          throw new RawContractError({ data: returnData });
        const result2 = decodeFunctionResult({
          abi: abi20,
          args: args2,
          data: returnData,
          functionName
        });
        results.push(allowFailure ? { result: result2, status: "success" } : result2);
      } catch (err) {
        const error = getContractError(err, {
          abi: abi20,
          address: address8,
          args: args2,
          docsPath: "/docs/contract/multicall",
          functionName
        });
        if (!allowFailure)
          throw error;
        results.push({ error, result: undefined, status: "failure" });
      }
    }
  }
  if (results.length !== contracts.length)
    throw new BaseError("multicall results mismatch");
  return results;
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/verifyHash.js
init_abis();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/constants/contracts.js
var universalSignatureValidatorByteCode = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/verifyHash.js
init_contract();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/data/isBytesEqual.js
init_utils3();
init_toBytes();
init_isHex();
function isBytesEqual(a_, b_) {
  const a = isHex(a_) ? toBytes2(a_) : a_;
  const b = isHex(b_) ? toBytes2(b_) : b_;
  return equalBytes(a, b);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/verifyHash.js
init_call();
async function verifyHash(client, { address: address8, hash: hash4, signature, ...callRequest }) {
  const signatureHex = isHex(signature) ? signature : toHex2(signature);
  try {
    const { data: data3 } = await getAction(client, call2, "call")({
      data: encodeDeployData({
        abi: universalSignatureValidatorAbi,
        args: [address8, hash4, signatureHex],
        bytecode: universalSignatureValidatorByteCode
      }),
      ...callRequest
    });
    return isBytesEqual(data3 ?? "0x0", "0x1");
  } catch (error) {
    if (error instanceof CallExecutionError) {
      return false;
    }
    throw error;
  }
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/verifyMessage.js
async function verifyMessage(client, { address: address8, message, signature, ...callRequest }) {
  const hash4 = hashMessage(message);
  return verifyHash(client, {
    address: address8,
    hash: hash4,
    signature,
    ...callRequest
  });
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/verifyTypedData.js
async function verifyTypedData(client, { address: address8, signature, message, primaryType, types, domain, ...callRequest }) {
  const hash4 = hashTypedData({ message, primaryType, types, domain });
  return verifyHash(client, {
    address: address8,
    hash: hash4,
    signature,
    ...callRequest
  });
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js
init_transaction();
init_stringify();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/watchBlockNumber.js
init_fromHex();
init_stringify();
function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  let prevBlockNumber;
  const pollBlockNumber = () => {
    const observerId = stringify([
      "watchBlockNumber",
      client.uid,
      emitOnBegin,
      emitMissed,
      pollingInterval
    ]);
    return observe(observerId, { onBlockNumber, onError }, (emit) => poll(async () => {
      try {
        const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({ cacheTime: 0 });
        if (prevBlockNumber) {
          if (blockNumber === prevBlockNumber)
            return;
          if (blockNumber - prevBlockNumber > 1 && emitMissed) {
            for (let i = prevBlockNumber + 1n;i < blockNumber; i++) {
              emit.onBlockNumber(i, prevBlockNumber);
              prevBlockNumber = i;
            }
          }
        }
        if (!prevBlockNumber || blockNumber > prevBlockNumber) {
          emit.onBlockNumber(blockNumber, prevBlockNumber);
          prevBlockNumber = blockNumber;
        }
      } catch (err) {
        emit.onError?.(err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlockNumber = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["newHeads"],
          onData(data3) {
            if (!active)
              return;
            const blockNumber = hexToBigInt(data3.result?.number);
            onBlockNumber(blockNumber, prevBlockNumber);
            prevBlockNumber = blockNumber;
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js
async function waitForTransactionReceipt(client, { confirmations = 1, hash: hash4, onReplaced, pollingInterval = client.pollingInterval, timeout }) {
  const observerId = stringify(["waitForTransactionReceipt", client.uid, hash4]);
  let transaction14;
  let replacedTransaction;
  let receipt;
  let retrying = false;
  return new Promise((resolve5, reject) => {
    if (timeout)
      setTimeout(() => reject(new WaitForTransactionReceiptTimeoutError({ hash: hash4 })), timeout);
    const _unobserve = observe(observerId, { onReplaced, resolve: resolve5, reject }, (emit) => {
      const _unwatch = getAction(client, watchBlockNumber, "watchBlockNumber")({
        emitMissed: true,
        emitOnBegin: true,
        poll: true,
        pollingInterval,
        async onBlockNumber(blockNumber_) {
          if (retrying)
            return;
          let blockNumber = blockNumber_;
          const done = (fn) => {
            _unwatch();
            fn();
            _unobserve();
          };
          try {
            if (receipt) {
              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                return;
              done(() => emit.resolve(receipt));
              return;
            }
            if (!transaction14) {
              retrying = true;
              await withRetry(async () => {
                transaction14 = await getAction(client, getTransaction, "getTransaction")({ hash: hash4 });
                if (transaction14.blockNumber)
                  blockNumber = transaction14.blockNumber;
              }, {
                delay: ({ count }) => ~~(1 << count) * 200,
                retryCount: 6
              });
              retrying = false;
            }
            receipt = await getAction(client, getTransactionReceipt, "getTransactionReceipt")({ hash: hash4 });
            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
              return;
            done(() => emit.resolve(receipt));
          } catch (err) {
            if (transaction14 && (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError)) {
              try {
                replacedTransaction = transaction14;
                retrying = true;
                const block4 = await withRetry(() => getAction(client, getBlock, "getBlock")({
                  blockNumber,
                  includeTransactions: true
                }), {
                  delay: ({ count }) => ~~(1 << count) * 200,
                  retryCount: 6,
                  shouldRetry: ({ error }) => error instanceof BlockNotFoundError
                });
                retrying = false;
                const replacementTransaction = block4.transactions.find(({ from, nonce }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce);
                if (!replacementTransaction)
                  return;
                receipt = await getAction(client, getTransactionReceipt, "getTransactionReceipt")({
                  hash: replacementTransaction.hash
                });
                if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                  return;
                let reason = "replaced";
                if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {
                  reason = "repriced";
                } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                  reason = "cancelled";
                }
                done(() => {
                  emit.onReplaced?.({
                    reason,
                    replacedTransaction,
                    transaction: replacementTransaction,
                    transactionReceipt: receipt
                  });
                  emit.resolve(receipt);
                });
              } catch (err_) {
                done(() => emit.reject(err_));
              }
            } else {
              done(() => emit.reject(err));
            }
          }
        }
      });
    });
  });
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/watchBlocks.js
init_stringify();
function watchBlocks(client, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  const includeTransactions = includeTransactions_ ?? false;
  let prevBlock;
  const pollBlocks = () => {
    const observerId = stringify([
      "watchBlocks",
      client.uid,
      emitMissed,
      emitOnBegin,
      includeTransactions,
      pollingInterval
    ]);
    return observe(observerId, { onBlock, onError }, (emit) => poll(async () => {
      try {
        const block5 = await getAction(client, getBlock, "getBlock")({
          blockTag,
          includeTransactions
        });
        if (block5.number && prevBlock?.number) {
          if (block5.number === prevBlock.number)
            return;
          if (block5.number - prevBlock.number > 1 && emitMissed) {
            for (let i = prevBlock?.number + 1n;i < block5.number; i++) {
              const block6 = await getAction(client, getBlock, "getBlock")({
                blockNumber: i,
                includeTransactions
              });
              emit.onBlock(block6, prevBlock);
              prevBlock = block6;
            }
          }
        }
        if (!prevBlock?.number || blockTag === "pending" && !block5?.number || block5.number && block5.number > prevBlock.number) {
          emit.onBlock(block5, prevBlock);
          prevBlock = block5;
        }
      } catch (err) {
        emit.onError?.(err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlocks = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["newHeads"],
          onData(data3) {
            if (!active)
              return;
            const format3 = client.chain?.formatters?.block?.format || formatBlock;
            const block5 = format3(data3.result);
            onBlock(block5, prevBlock);
            prevBlock = block5;
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollBlocks() : subscribeBlocks();
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/watchEvent.js
init_stringify();
init_abi();
init_rpc();
function watchEvent(client, { address: address8, args, batch = true, event, events, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  const strict = strict_ ?? false;
  const pollEvent = () => {
    const observerId = stringify([
      "watchEvent",
      address8,
      args,
      batch,
      client.uid,
      event,
      pollingInterval
    ]);
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      let filter;
      let initialized = false;
      const unwatch = poll(async () => {
        if (!initialized) {
          try {
            filter = await getAction(client, createEventFilter, "createEventFilter")({
              address: address8,
              args,
              event,
              events,
              strict
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter) {
            logs = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
          } else {
            const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getAction(client, getLogs, "getLogs")({
                address: address8,
                args,
                event,
                events,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            for (const log7 of logs)
              emit.onLogs([log7]);
        } catch (err) {
          if (filter && err instanceof InvalidInputRpcError)
            initialized = false;
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
        unwatch();
      };
    });
  };
  const subscribeEvent = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const events_ = events ?? (event ? [event] : undefined);
        let topics = [];
        if (events_) {
          topics = [
            events_.flatMap((event2) => encodeEventTopics({
              abi: [event2],
              eventName: event2.name,
              args
            }))
          ];
          if (event)
            topics = topics[0];
        }
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["logs", { address: address8, topics }],
          onData(data3) {
            if (!active)
              return;
            const log7 = data3.result;
            try {
              const { eventName, args: args2 } = decodeEventLog({
                abi: events_,
                data: log7.data,
                topics: log7.topics,
                strict
              });
              const formatted = formatLog(log7, {
                args: args2,
                eventName
              });
              onLogs([formatted]);
            } catch (err) {
              let eventName;
              let isUnnamed;
              if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                if (strict_)
                  return;
                eventName = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x) => !(("name" in x) && x.name));
              }
              const formatted = formatLog(log7, {
                args: isUnnamed ? [] : {},
                eventName
              });
              onLogs([formatted]);
            }
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollEvent() : subscribeEvent();
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/public/watchPendingTransactions.js
init_stringify();
function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  const pollPendingTransactions = () => {
    const observerId = stringify([
      "watchPendingTransactions",
      client.uid,
      batch,
      pollingInterval
    ]);
    return observe(observerId, { onTransactions, onError }, (emit) => {
      let filter;
      const unwatch = poll(async () => {
        try {
          if (!filter) {
            try {
              filter = await getAction(client, createPendingTransactionFilter, "createPendingTransactionFilter")({});
              return;
            } catch (err) {
              unwatch();
              throw err;
            }
          }
          const hashes = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
          if (hashes.length === 0)
            return;
          if (batch)
            emit.onTransactions(hashes);
          else
            for (const hash4 of hashes)
              emit.onTransactions([hash4]);
        } catch (err) {
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
        unwatch();
      };
    });
  };
  const subscribePendingTransactions = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(data3) {
            if (!active)
              return;
            const transaction14 = data3.result;
            onTransactions([transaction14]);
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/clients/decorators/public.js
function publicActions(client) {
  return {
    call: (args) => call2(client, args),
    createBlockFilter: () => createBlockFilter(client),
    createContractEventFilter: (args) => createContractEventFilter(client, args),
    createEventFilter: (args) => createEventFilter(client, args),
    createPendingTransactionFilter: () => createPendingTransactionFilter(client),
    estimateContractGas: (args) => estimateContractGas(client, args),
    estimateGas: (args) => estimateGas3(client, args),
    getBalance: (args) => getBalance(client, args),
    getBlock: (args) => getBlock(client, args),
    getBlockNumber: (args) => getBlockNumber(client, args),
    getBlockTransactionCount: (args) => getBlockTransactionCount(client, args),
    getBytecode: (args) => getBytecode(client, args),
    getChainId: () => getChainId(client),
    getContractEvents: (args) => getContractEvents(client, args),
    getEnsAddress: (args) => getEnsAddress(client, args),
    getEnsAvatar: (args) => getEnsAvatar(client, args),
    getEnsName: (args) => getEnsName(client, args),
    getEnsResolver: (args) => getEnsResolver(client, args),
    getEnsText: (args) => getEnsText(client, args),
    getFeeHistory: (args) => getFeeHistory(client, args),
    estimateFeesPerGas: (args) => estimateFeesPerGas(client, args),
    getFilterChanges: (args) => getFilterChanges(client, args),
    getFilterLogs: (args) => getFilterLogs(client, args),
    getGasPrice: () => getGasPrice(client),
    getLogs: (args) => getLogs(client, args),
    getProof: (args) => getProof(client, args),
    estimateMaxPriorityFeePerGas: (args) => estimateMaxPriorityFeePerGas(client, args),
    getStorageAt: (args) => getStorageAt(client, args),
    getTransaction: (args) => getTransaction(client, args),
    getTransactionConfirmations: (args) => getTransactionConfirmations(client, args),
    getTransactionCount: (args) => getTransactionCount(client, args),
    getTransactionReceipt: (args) => getTransactionReceipt(client, args),
    multicall: (args) => multicall(client, args),
    prepareTransactionRequest: (args) => prepareTransactionRequest(client, args),
    readContract: (args) => readContract(client, args),
    sendRawTransaction: (args) => sendRawTransaction(client, args),
    simulateContract: (args) => simulateContract(client, args),
    verifyMessage: (args) => verifyMessage(client, args),
    verifyTypedData: (args) => verifyTypedData(client, args),
    uninstallFilter: (args) => uninstallFilter(client, args),
    waitForTransactionReceipt: (args) => waitForTransactionReceipt(client, args),
    watchBlocks: (args) => watchBlocks(client, args),
    watchBlockNumber: (args) => watchBlockNumber(client, args),
    watchContractEvent: (args) => watchContractEvent(client, args),
    watchEvent: (args) => watchEvent(client, args),
    watchPendingTransactions: (args) => watchPendingTransactions(client, args)
  };
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/clients/createPublicClient.js
function createPublicClient(parameters) {
  const { key = "public", name = "Public Client" } = parameters;
  const client = createClient({
    ...parameters,
    key,
    name,
    type: "publicClient"
  });
  return client.extend(publicActions);
}
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/wallet/deployContract.js
function deployContract(walletClient, { abi: abi21, args, bytecode, ...request5 }) {
  const calldata = encodeDeployData({
    abi: abi21,
    args,
    bytecode
  });
  return sendTransaction(walletClient, {
    ...request5,
    data: calldata
  });
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/wallet/getAddresses.js
init_getAddress();
async function getAddresses(client) {
  if (client.account?.type === "local")
    return [client.account.address];
  const addresses = await client.request({ method: "eth_accounts" });
  return addresses.map((address8) => checksumAddress(address8));
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/wallet/getPermissions.js
async function getPermissions(client) {
  const permissions = await client.request({ method: "wallet_getPermissions" });
  return permissions;
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/wallet/requestAddresses.js
init_getAddress();
async function requestAddresses(client) {
  const addresses = await client.request({ method: "eth_requestAccounts" });
  return addresses.map((address8) => getAddress(address8));
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/wallet/requestPermissions.js
async function requestPermissions(client, permissions) {
  return client.request({
    method: "wallet_requestPermissions",
    params: [permissions]
  });
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/wallet/signMessage.js
init_parseAccount();
init_toHex();
async function signMessage(client, { account: account_ = client.account, message }) {
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const account5 = parseAccount(account_);
  if (account5.type === "local")
    return account5.signMessage({ message });
  const message_ = (() => {
    if (typeof message === "string")
      return stringToHex(message);
    if (message.raw instanceof Uint8Array)
      return toHex2(message.raw);
    return message.raw;
  })();
  return client.request({
    method: "personal_sign",
    params: [message_, account5.address]
  });
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/wallet/signTransaction.js
init_parseAccount();
init_transactionRequest();
init_assertRequest();
async function signTransaction(client, args) {
  const { account: account_ = client.account, chain: chain5 = client.chain, ...transaction14 } = args;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTransaction"
    });
  const account6 = parseAccount(account_);
  assertRequest({
    account: account6,
    ...args
  });
  const chainId = await getAction(client, getChainId, "getChainId")({});
  if (chain5 !== null)
    assertCurrentChain({
      currentChainId: chainId,
      chain: chain5
    });
  const formatters = chain5?.formatters || client.chain?.formatters;
  const format3 = formatters?.transactionRequest?.format || formatTransactionRequest;
  if (account6.type === "local")
    return account6.signTransaction({
      ...transaction14,
      chainId
    }, { serializer: client.chain?.serializers?.transaction });
  return await client.request({
    method: "eth_signTransaction",
    params: [
      {
        ...format3(transaction14),
        chainId: numberToHex(chainId),
        from: account6.address
      }
    ]
  });
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/wallet/signTypedData.js
init_parseAccount();
init_isHex();
init_stringify();
async function signTypedData(client, { account: account_ = client.account, domain, message, primaryType, types: types_ }) {
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const account7 = parseAccount(account_);
  const types = {
    EIP712Domain: getTypesForEIP712Domain({ domain }),
    ...types_
  };
  validateTypedData({
    domain,
    message,
    primaryType,
    types
  });
  if (account7.type === "local")
    return account7.signTypedData({
      domain,
      primaryType,
      types,
      message
    });
  const typedData3 = stringify({ domain: domain ?? {}, primaryType, types, message }, (_, value) => isHex(value) ? value.toLowerCase() : value);
  return client.request({
    method: "eth_signTypedData_v4",
    params: [account7.address, typedData3]
  });
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/wallet/switchChain.js
init_toHex();
async function switchChain(client, { id: id2 }) {
  await client.request({
    method: "wallet_switchEthereumChain",
    params: [
      {
        chainId: numberToHex(id2)
      }
    ]
  });
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/actions/wallet/watchAsset.js
async function watchAsset(client, params) {
  const added = await client.request({
    method: "wallet_watchAsset",
    params
  });
  return added;
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/clients/decorators/wallet.js
function walletActions(client) {
  return {
    addChain: (args) => addChain(client, args),
    deployContract: (args) => deployContract(client, args),
    getAddresses: () => getAddresses(client),
    getChainId: () => getChainId(client),
    getPermissions: () => getPermissions(client),
    prepareTransactionRequest: (args) => prepareTransactionRequest(client, args),
    requestAddresses: () => requestAddresses(client),
    requestPermissions: (args) => requestPermissions(client, args),
    sendRawTransaction: (args) => sendRawTransaction(client, args),
    sendTransaction: (args) => sendTransaction(client, args),
    signMessage: (args) => signMessage(client, args),
    signTransaction: (args) => signTransaction(client, args),
    signTypedData: (args) => signTypedData(client, args),
    switchChain: (args) => switchChain(client, args),
    watchAsset: (args) => watchAsset(client, args),
    writeContract: (args) => writeContract(client, args)
  };
}
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/clients/createWalletClient.js
function createWalletClient(parameters) {
  const { key = "wallet", name = "Wallet Client", transport } = parameters;
  const client = createClient({
    ...parameters,
    key,
    name,
    transport: (opts) => transport({ ...opts, retryCount: 0 }),
    type: "walletClient"
  });
  return client.extend(walletActions);
}
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/constants/address.js
var zeroAddress = "0x0000000000000000000000000000000000000000";
// /home/mous/work/pimlico/alto/src/node_modules/viem/_esm/index.js
init_base();
init_contract();
init_node();
init_request();
init_transaction();
init_decodeAbiParameters();
init_decodeErrorResult();
init_decodeFunctionResult();
init_encodeAbiParameters();
init_encodeFunctionData();
init_transactionRequest();
init_getAbiItem();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/utils/signature/signatureToHex.js
init_secp256k1();
init_fromHex();
init_toHex();
function signatureToHex({ r, s, v }) {
  return `0x${new secp256k1.Signature(hexToBigInt(r), hexToBigInt(s)).toCompactHex()}${toHex2(v).slice(2)}`;
}

// /home/mous/work/pimlico/alto/src/node_modules/viem/_esm/index.js
init_toBytes();
init_toHex();
init_concat();
init_formatEther();
init_fromHex();
init_getAddress();
init_getFunctionSelector();
init_keccak256();
init_pad();
init_slice();

// /home/mous/work/pimlico/alto/src/node_modules/zod/lib/index.mjs
var setErrorMap = function(map) {
  overrideErrorMap = map;
};
var getErrorMap = function() {
  return overrideErrorMap;
};
var addIssueToContext = function(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
};
var processCreateParams = function(params) {
  if (!params)
    return {};
  const { errorMap, invalid_type_error, required_error, description } = params;
  if (errorMap && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap)
    return { errorMap, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== undefined ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== undefined ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
};
var isValidIP = function(ip, version3) {
  if ((version3 === "v4" || !version3) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version3 === "v6" || !version3) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
};
var floatSafeRemainder = function(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
};
var deepPartialify = function(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
};
var mergeValues = function(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0;index2 < a.length; index2++) {
      const itemA = a[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
};
var createZodEnum = function(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
};
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data3) => {
  const t = typeof data3;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data3) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data3)) {
        return ZodParsedType.array;
      }
      if (data3 === null) {
        return ZodParsedType.null;
      }
      if (data3.then && typeof data3.then === "function" && data3.catch && typeof data3.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data3 instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data3 instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data3 instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
var makeIssue = (params) => {
  const { data: data3, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data: data3, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === undefined ? undefined : message.message;
})(errorUtil || (errorUtil = {}));

class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};

class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data3, params) {
    const result = this.safeParse(data3, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data3, params) {
    var _a2;
    const ctx = {
      common: {
        issues: [],
        async: (_a2 = params === null || params === undefined ? undefined : params.async) !== null && _a2 !== undefined ? _a2 : false,
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data3,
      parsedType: getParsedType(data3)
    };
    const result = this._parseSync({ data: data3, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data3, params) {
    const result = await this.safeParseAsync(data3, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data3, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap,
        async: true
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data3,
      parsedType: getParsedType(data3)
    };
    const maybeAsyncResult2 = this._parse({ data: data3, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult2) ? maybeAsyncResult2 : Promise.resolve(maybeAsyncResult2));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data3) => {
          if (!data3) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+\$`;
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z\$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z\$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z\$`);
    }
  }
};

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a2) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex3 = datetimeRegex(check);
        if (!regex3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex3, validation3, message) {
    return this.refinement((data3) => regex3.test(data3), {
      validation: validation3,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a2;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      offset: (_a2 = options === null || options === undefined ? undefined : options.offset) !== null && _a2 !== undefined ? _a2 : false,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  regex(regex3, message) {
    return this._addCheck({
      kind: "regex",
      regex: regex3,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === undefined ? undefined : options.position,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a2;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a2 = params === null || params === undefined ? undefined : params.coerce) !== null && _a2 !== undefined ? _a2 : false,
    ...processCreateParams(params)
  });
};

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a2;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a2 = params === null || params === undefined ? undefined : params.coerce) !== null && _a2 !== undefined ? _a2 : false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          var _a2, _b2, _c2, _d;
          const defaultError = (_c2 = (_b2 = (_a2 = this._def).errorMap) === null || _b2 === undefined ? undefined : _b2.call(_a2, issue, ctx).message) !== null && _c2 !== undefined ? _c2 : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== undefined ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left2, right2]) => handleParsed(left2, right2));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left2, right2, params) => {
  return new ZodIntersection({
    left: left2,
    right: right2,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size9, message) {
    return this.min(size9, message).max(size9, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};

class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return ZodEnum.create(values);
  }
  exclude(values) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data3) => {
      return this._def.type.parseAsync(data3, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base29 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base29))
          return base29;
        const result = effect.transform(base29.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base29) => {
          if (!isValid(base29))
            return base29;
          return Promise.resolve(effect.transform(base29.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};

class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data3 = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data3 = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data: data3,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data3 = ctx.data;
    return this._def.type._parse({
      data: data3,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data3, ctx) => {
      var _a2, _b2;
      if (!check(data3)) {
        const p = typeof params === "function" ? params(data3) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b2 = (_a2 = p.fatal) !== null && _a2 !== undefined ? _a2 : fatal) !== null && _b2 !== undefined ? _b2 : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data3) => data3 instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// entrypoint-0.6/types/gasPrice.ts
var gasPrice = z.object({
  maxFee: z.union([z.number(), z.string()]).transform((val) => parseGwei(`${val}`)),
  maxPriorityFee: z.union([z.number(), z.string()]).transform((val) => parseGwei(`${val}`))
}).transform((val) => {
  return {
    maxFeePerGas: val.maxFee,
    maxPriorityFeePerGas: val.maxPriorityFee
  };
});
var gasStationResult = z.object({
  safeLow: gasPrice,
  standard: gasPrice,
  fast: gasPrice
});
// entrypoint-0.6/types/mempool.ts
var deriveUserOperation = (op) => {
  return isCompressedType(op) ? op.inflatedOp : op;
};
var isCompressedType = (op) => {
  return "compressedCalldata" in op;
};
var SubmissionStatus;
(function(SubmissionStatus2) {
  SubmissionStatus2["NotSubmitted"] = "not_submitted";
  SubmissionStatus2["Rejected"] = "rejected";
  SubmissionStatus2["Submitted"] = "submitted";
  SubmissionStatus2["Included"] = "included";
})(SubmissionStatus || (SubmissionStatus = {}));
// entrypoint-0.6/types/utils.ts
var ValidationErrors;
(function(ValidationErrors2) {
  ValidationErrors2[ValidationErrors2["InvalidRequest"] = -32601] = "InvalidRequest";
  ValidationErrors2[ValidationErrors2["InvalidFields"] = -32602] = "InvalidFields";
  ValidationErrors2[ValidationErrors2["SimulateValidation"] = -32500] = "SimulateValidation";
  ValidationErrors2[ValidationErrors2["SimulatePaymasterValidation"] = -32501] = "SimulatePaymasterValidation";
  ValidationErrors2[ValidationErrors2["OpcodeValidation"] = -32502] = "OpcodeValidation";
  ValidationErrors2[ValidationErrors2["ExpiresShortly"] = -32503] = "ExpiresShortly";
  ValidationErrors2[ValidationErrors2["Reputation"] = -32504] = "Reputation";
  ValidationErrors2[ValidationErrors2["InsufficientStake"] = -32505] = "InsufficientStake";
  ValidationErrors2[ValidationErrors2["UnsupportedSignatureAggregator"] = -32506] = "UnsupportedSignatureAggregator";
  ValidationErrors2[ValidationErrors2["InvalidSignature"] = -32507] = "InvalidSignature";
})(ValidationErrors || (ValidationErrors = {}));
var ExecutionErrors;
(function(ExecutionErrors2) {
  ExecutionErrors2[ExecutionErrors2["UserOperationReverted"] = -32521] = "UserOperationReverted";
})(ExecutionErrors || (ExecutionErrors = {}));

class RpcError2 extends Error {
  code;
  data;
  constructor(msg, code, data3 = undefined) {
    super(msg);
    this.code = code;
    this.data = data3;
  }
}
// entrypoint-0.6/types/schemas.ts
var hexDataPattern = /^0x[0-9A-Fa-f]*$/;
var addressPattern = /^0x[0-9,a-f,A-F]{40}$/;
var hexData32Pattern = /^0x([0-9a-fA-F][0-9a-fA-F]){0,32}$/;
var addressSchema = z.string().regex(addressPattern, { message: "not a valid hex address" }).transform((val) => getAddress(val));
var hexNumberSchema = z.string().regex(hexDataPattern).or(z.number()).or(z.bigint()).transform((val) => BigInt(val));
var hexDataSchema = z.string().regex(hexDataPattern, { message: "not valid hex data" }).transform((val) => val);
var hexData32Schema = z.string().regex(hexData32Pattern, { message: "not valid 32-byte hex data" }).transform((val) => val);
var userOperationSchema = z.object({
  sender: addressSchema,
  nonce: hexNumberSchema,
  initCode: hexDataSchema,
  callData: hexDataSchema,
  callGasLimit: hexNumberSchema,
  verificationGasLimit: hexNumberSchema,
  preVerificationGas: hexNumberSchema,
  maxPriorityFeePerGas: hexNumberSchema,
  maxFeePerGas: hexNumberSchema,
  paymasterAndData: hexDataSchema,
  signature: hexDataSchema
}).strict().transform((val) => {
  return val;
});
var partialUserOperationSchema = z.object({
  sender: addressSchema,
  nonce: hexNumberSchema,
  initCode: hexDataSchema,
  callData: hexDataSchema,
  callGasLimit: hexNumberSchema.default(1n),
  verificationGasLimit: hexNumberSchema.default(1n),
  preVerificationGas: hexNumberSchema.default(1n),
  maxPriorityFeePerGas: hexNumberSchema.default(1n),
  maxFeePerGas: hexNumberSchema.default(1n),
  paymasterAndData: hexDataSchema,
  signature: hexDataSchema
}).strict().transform((val) => {
  return val;
});
var jsonRpcSchema = z.object({
  jsonrpc: z.literal("2.0"),
  id: z.number(),
  method: z.string(),
  params: z.array(z.unknown()).optional().transform((val) => val ?? [])
}).strict();
var jsonRpcResultSchema = z.object({
  jsonrpc: z.literal("2.0"),
  id: z.number(),
  result: z.unknown()
}).strict();
var chainIdRequestSchema = z.object({
  method: z.literal("eth_chainId"),
  params: z.tuple([])
});
var supportedEntryPointsRequestSchema = z.object({
  method: z.literal("eth_supportedEntryPoints"),
  params: z.tuple([])
});
var stateOverridesSchema = z.record(addressSchema, z.object({
  balance: hexNumberSchema.optional(),
  nonce: hexNumberSchema.optional(),
  code: hexDataSchema.optional(),
  state: z.unknown().optional(),
  stateDiff: z.unknown().optional()
}));
var estimateUserOperationGasRequestSchema = z.object({
  method: z.literal("eth_estimateUserOperationGas"),
  params: z.union([
    z.tuple([partialUserOperationSchema, addressSchema]),
    z.tuple([
      partialUserOperationSchema,
      addressSchema,
      stateOverridesSchema
    ])
  ])
});
var sendUserOperationRequestSchema = z.object({
  method: z.literal("eth_sendUserOperation"),
  params: z.tuple([userOperationSchema, addressSchema])
});
var getUserOperationByHashRequestSchema = z.object({
  method: z.literal("eth_getUserOperationByHash"),
  params: z.tuple([
    z.string().regex(hexData32Pattern, { message: "Missing/invalid userOpHash" }).transform((val) => val)
  ])
});
var getUserOperationReceiptRequestSchema = z.object({
  method: z.literal("eth_getUserOperationReceipt"),
  params: z.tuple([
    z.string().regex(hexData32Pattern, { message: "Missing/invalid userOpHash" }).transform((val) => val)
  ])
});
var bundlerClearStateRequestSchema = z.object({
  method: z.literal("debug_bundler_clearState"),
  params: z.tuple([])
});
var bundlerClearMempoolRequestSchema = z.object({
  method: z.literal("debug_bundler_clearMempool"),
  params: z.tuple([])
});
var bundlerDumpMempoolRequestSchema = z.object({
  method: z.literal("debug_bundler_dumpMempool"),
  params: z.tuple([addressSchema])
});
var bundlerSendBundleNowRequestSchema = z.object({
  method: z.literal("debug_bundler_sendBundleNow"),
  params: z.tuple([])
});
var bundlerSetBundlingModeRequestSchema = z.object({
  method: z.literal("debug_bundler_setBundlingMode"),
  params: z.tuple([z.enum(["manual", "auto"])])
});
var bundlerSetReputationsRequestSchema = z.object({
  method: z.literal("debug_bundler_setReputation"),
  params: z.tuple([
    z.array(z.object({
      address: addressSchema,
      opsSeen: hexNumberSchema,
      opsIncluded: hexNumberSchema
    })),
    addressSchema
  ])
});
var bundlerDumpReputationsRequestSchema = z.object({
  method: z.literal("debug_bundler_dumpReputation"),
  params: z.tuple([addressSchema])
});
var pimlicoGetStakeStatusRequestSchema = z.object({
  method: z.literal("debug_bundler_getStakeStatus"),
  params: z.tuple([addressSchema, addressSchema])
});
var pimlicoGetUserOperationStatusRequestSchema = z.object({
  method: z.literal("pimlico_getUserOperationStatus"),
  params: z.tuple([hexData32Schema])
});
var pimlicoGetUserOperationGasPriceRequestSchema = z.object({
  method: z.literal("pimlico_getUserOperationGasPrice"),
  params: z.tuple([])
});
var pimlicoSendCompressedUserOperationRequestSchema = z.object({
  method: z.literal("pimlico_sendCompressedUserOperation"),
  params: z.tuple([hexDataSchema, addressSchema, addressSchema])
});
var bundlerRequestSchema = z.discriminatedUnion("method", [
  chainIdRequestSchema,
  supportedEntryPointsRequestSchema,
  estimateUserOperationGasRequestSchema,
  sendUserOperationRequestSchema,
  getUserOperationByHashRequestSchema,
  getUserOperationReceiptRequestSchema,
  bundlerClearStateRequestSchema,
  bundlerClearMempoolRequestSchema,
  bundlerDumpMempoolRequestSchema,
  bundlerSendBundleNowRequestSchema,
  bundlerSetBundlingModeRequestSchema,
  bundlerSetReputationsRequestSchema,
  bundlerDumpReputationsRequestSchema,
  pimlicoGetStakeStatusRequestSchema,
  pimlicoGetUserOperationStatusRequestSchema,
  pimlicoGetUserOperationGasPriceRequestSchema,
  pimlicoSendCompressedUserOperationRequestSchema
]);
var chainIdResponseSchema = z.object({
  method: z.literal("eth_chainId"),
  result: hexNumberSchema
});
var supportedEntryPointsResponseSchema = z.object({
  method: z.literal("eth_supportedEntryPoints"),
  result: z.array(addressSchema)
});
var estimateUserOperationGasResponseSchema = z.object({
  method: z.literal("eth_estimateUserOperationGas"),
  result: z.object({
    callGasLimit: hexNumberSchema,
    preVerificationGas: hexNumberSchema,
    verificationGasLimit: hexNumberSchema,
    verificationGas: hexNumberSchema.optional()
  })
});
var sendUserOperationResponseSchema = z.object({
  method: z.literal("eth_sendUserOperation"),
  result: hexData32Schema
});
var getUserOperationByHashResponseSchema = z.object({
  method: z.literal("eth_getUserOperationByHash"),
  result: z.object({
    userOperation: userOperationSchema,
    entryPoint: addressSchema,
    blockNumber: hexNumberSchema,
    blockHash: hexData32Schema,
    transactionHash: hexData32Schema
  }).or(z.null())
});
var logSchema = z.object({
  logIndex: hexNumberSchema,
  transactionIndex: hexNumberSchema,
  transactionHash: hexData32Schema,
  blockHash: hexData32Schema,
  blockNumber: hexNumberSchema,
  address: addressSchema,
  data: hexDataSchema,
  topics: z.array(hexData32Schema)
});
var receiptSchema = z.object({
  transactionHash: hexData32Schema,
  transactionIndex: hexNumberSchema,
  blockHash: hexData32Schema,
  blockNumber: hexNumberSchema,
  from: addressSchema,
  to: addressSchema.or(z.null()),
  cumulativeGasUsed: hexNumberSchema,
  gasUsed: hexNumberSchema,
  contractAddress: addressSchema.or(z.null()),
  logs: z.array(logSchema),
  logsBloom: z.string().regex(/^0x[0-9a-f]{512}$/),
  status: hexNumberSchema.or(z.null()),
  effectiveGasPrice: hexNumberSchema
});
var getUserOperationReceiptResponseSchema = z.object({
  method: z.literal("eth_getUserOperationReceipt"),
  result: z.object({
    userOpHash: hexData32Schema,
    sender: addressSchema,
    nonce: hexNumberSchema,
    actualGasCost: hexNumberSchema,
    actualGasUsed: hexNumberSchema,
    success: z.boolean(),
    logs: z.array(logSchema),
    receipt: receiptSchema
  }).or(z.null())
});
var bundlerClearStateResponseSchema = z.object({
  method: z.literal("debug_bundler_clearState"),
  result: z.literal("ok")
});
var bundlerClearMempoolResponseSchema = z.object({
  method: z.literal("debug_bundler_clearMempool"),
  result: z.literal("ok")
});
var bundlerDumpMempoolResponseSchema = z.object({
  method: z.literal("debug_bundler_dumpMempool"),
  result: z.array(userOperationSchema)
});
var bundlerGetStakeStatusResponseSchema = z.object({
  method: z.literal("debug_bundler_getStakeStatus"),
  result: z.object({
    stakeInfo: z.object({
      addr: z.string(),
      stake: z.string().or(z.number()).or(z.bigint()).transform((val) => Number(val).toString()),
      unstakeDelaySec: z.string().or(z.number()).or(z.bigint()).transform((val) => Number(val).toString())
    }),
    isStaked: z.boolean()
  })
});
var bundlerSendBundleNowResponseSchema = z.object({
  method: z.literal("debug_bundler_sendBundleNow"),
  result: hexData32Schema
});
var bundlerSetBundlingModeResponseSchema = z.object({
  method: z.literal("debug_bundler_setBundlingMode"),
  result: z.literal("ok")
});
var bundlerSetReputationsResponseSchema = z.object({
  method: z.literal("debug_bundler_setReputation"),
  result: z.literal("ok")
});
var bundlerDumpReputationsResponseSchema = z.object({
  method: z.literal("debug_bundler_dumpReputation"),
  result: z.array(z.object({
    address: addressSchema,
    opsSeen: hexNumberSchema,
    opsIncluded: hexNumberSchema,
    status: hexNumberSchema.optional()
  }))
});
var userOperationStatus = z.object({
  status: z.enum([
    "not_found",
    "not_submitted",
    "submitted",
    "rejected",
    "reverted",
    "included",
    "failed"
  ]),
  transactionHash: hexData32Schema.or(z.null())
});
var pimlicoGetUserOperationStatusResponseSchema = z.object({
  method: z.literal("pimlico_getUserOperationStatus"),
  result: userOperationStatus
});
var gasPriceSchema = z.object({
  slow: z.object({
    maxFeePerGas: z.bigint(),
    maxPriorityFeePerGas: z.bigint()
  }),
  standard: z.object({
    maxFeePerGas: z.bigint(),
    maxPriorityFeePerGas: z.bigint()
  }),
  fast: z.object({
    maxFeePerGas: z.bigint(),
    maxPriorityFeePerGas: z.bigint()
  })
});
var pimlicoGetUserOperationGasPriceResponseSchema = z.object({
  method: z.literal("pimlico_getUserOperationGasPrice"),
  result: gasPriceSchema
});
var pimlicoSendCompressedUserOperationResponseSchema = z.object({
  method: z.literal("pimlico_sendCompressedUserOperation"),
  result: hexData32Schema
});
var bundlerResponseSchema = z.discriminatedUnion("method", [
  chainIdResponseSchema,
  supportedEntryPointsResponseSchema,
  estimateUserOperationGasResponseSchema,
  sendUserOperationResponseSchema,
  getUserOperationByHashResponseSchema,
  getUserOperationReceiptResponseSchema,
  bundlerClearStateResponseSchema,
  bundlerClearMempoolResponseSchema,
  bundlerDumpMempoolResponseSchema,
  bundlerGetStakeStatusResponseSchema,
  bundlerSendBundleNowResponseSchema,
  bundlerSetBundlingModeResponseSchema,
  bundlerSetReputationsResponseSchema,
  bundlerDumpReputationsResponseSchema,
  pimlicoGetUserOperationStatusResponseSchema,
  pimlicoGetUserOperationGasPriceResponseSchema,
  pimlicoSendCompressedUserOperationResponseSchema
]);

// entrypoint-0.6/types/validation.ts
var hexPattern = /^0x[0-9a-f]*$/;
var signatureValidationFailedSchema = z.tuple([addressSchema]).transform((val) => {
  return { aggregator: val[0] };
});
var signatureValidationFailedErrorSchema = z.object({
  args: signatureValidationFailedSchema,
  errorName: z.literal("SignatureValidationFailed")
});
var senderAddressResultSchema = z.tuple([addressSchema]).transform((val) => {
  return {
    sender: val[0]
  };
});
var senderAddressResultErrorSchema = z.object({
  args: senderAddressResultSchema,
  errorName: z.literal("SenderAddressResult")
});
var failedOpSchema = z.tuple([z.bigint(), z.string()]).transform((val) => {
  return { opIndex: val[0], reason: val[1] };
});
var failedOpErrorSchema = z.object({
  args: failedOpSchema,
  errorName: z.literal("FailedOp")
});
var executionResultSchema = z.tuple([
  z.bigint(),
  z.bigint(),
  z.number(),
  z.number(),
  z.boolean(),
  z.string().regex(hexPattern)
]).transform((val) => {
  return {
    preOpGas: val[0],
    paid: val[1],
    validAfter: val[2],
    validUntil: val[3],
    targetSuccess: val[4],
    targetResult: val[5]
  };
});
var executionResultErrorSchema = z.object({
  args: executionResultSchema,
  errorName: z.literal("ExecutionResult")
});
var stakeInfoSchema = z.object({
  addr: z.string().optional(),
  stake: z.bigint(),
  unstakeDelaySec: z.bigint()
});
var validationResultSchema = z.tuple([
  z.object({
    preOpGas: z.bigint(),
    prefund: z.bigint(),
    sigFailed: z.boolean(),
    validAfter: z.number(),
    validUntil: z.number(),
    paymasterContext: z.string().regex(hexPattern).transform((val) => val)
  }),
  stakeInfoSchema,
  stakeInfoSchema.optional(),
  stakeInfoSchema.optional()
]).transform((val) => {
  return {
    returnInfo: val[0],
    senderInfo: val[1],
    factoryInfo: val[2],
    paymasterInfo: val[3]
  };
});
var validationResultErrorSchema = z.object({
  args: validationResultSchema,
  errorName: z.literal("ValidationResult")
});
var validationResultWithAggregationSchema = z.tuple([
  z.object({
    preOpGas: z.bigint(),
    prefund: z.bigint(),
    sigFailed: z.boolean(),
    validAfter: z.number(),
    validUntil: z.number(),
    paymasterContext: z.string().regex(hexPattern).transform((val) => val)
  }),
  stakeInfoSchema,
  stakeInfoSchema.optional(),
  stakeInfoSchema.optional(),
  z.object({
    aggregator: addressSchema,
    stakeInfo: stakeInfoSchema
  }).optional()
]).transform((val) => {
  return {
    returnInfo: val[0],
    senderInfo: val[1],
    factoryInfo: val[2],
    paymasterInfo: val[3],
    aggregatorInfo: val[4]
  };
});
var validationResultWithAggregationErrorSchema = z.object({
  args: validationResultWithAggregationSchema,
  errorName: z.literal("ValidationResultWithAggregation")
});
var entryPointErrorsSchema = z.discriminatedUnion("errorName", [
  validationResultErrorSchema,
  executionResultErrorSchema,
  failedOpErrorSchema,
  senderAddressResultErrorSchema,
  signatureValidationFailedErrorSchema,
  validationResultWithAggregationErrorSchema
]);
var errorCauseSchema = z.object({
  name: z.literal("ContractFunctionRevertedError"),
  data: entryPointErrorsSchema
});
var vmExecutionError = z.object({
  name: z.literal("CallExecutionError"),
  cause: z.object({
    name: z.literal("RpcRequestError"),
    cause: z.object({
      data: z.string().transform((val) => {
        const errorHexData = val.split("Reverted ")[1];
        if (errorHexData === "0x" || errorHexData === undefined) {
          throw new RpcError2(`User operation reverted on-chain with unknown error (some chains don't return revert reason) ${val}`);
        }
        const errorResult = decodeErrorResult({
          abi: EntryPointAbi,
          data: errorHexData
        });
        return entryPointErrorsSchema.parse(errorResult);
      })
    })
  })
});
var entryPointExecutionErrorSchema = z.object({
  name: z.literal("ContractFunctionExecutionError"),
  cause: z.discriminatedUnion("name", [
    errorCauseSchema,
    vmExecutionError
  ])
}).transform((val) => {
  if (val.cause.name === "CallExecutionError") {
    return val.cause.cause.cause.data;
  }
  return val.cause.data;
});
// /home/mous/work/pimlico/alto/node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/@scure/bip39/esm/wordlists/czech.js
var wordlist = `abdikace
abeceda
adresa
agrese
akce
aktovka
alej
alkohol
amputace
ananas
andulka
anekdota
anketa
antika
anulovat
archa
arogance
asfalt
asistent
aspirace
astma
astronom
atlas
atletika
atol
autobus
azyl
babka
bachor
bacil
baculka
badatel
bageta
bagr
bahno
bakterie
balada
baletka
balkon
balonek
balvan
balza
bambus
bankomat
barbar
baret
barman
baroko
barva
baterka
batoh
bavlna
bazalka
bazilika
bazuka
bedna
beran
beseda
bestie
beton
bezinka
bezmoc
beztak
bicykl
bidlo
biftek
bikiny
bilance
biograf
biolog
bitva
bizon
blahobyt
blatouch
blecha
bledule
blesk
blikat
blizna
blokovat
bloudit
blud
bobek
bobr
bodlina
bodnout
bohatost
bojkot
bojovat
bokorys
bolest
borec
borovice
bota
boubel
bouchat
bouda
boule
bourat
boxer
bradavka
brambora
branka
bratr
brepta
briketa
brko
brloh
bronz
broskev
brunetka
brusinka
brzda
brzy
bublina
bubnovat
buchta
buditel
budka
budova
bufet
bujarost
bukvice
buldok
bulva
bunda
bunkr
burza
butik
buvol
buzola
bydlet
bylina
bytovka
bzukot
capart
carevna
cedr
cedule
cejch
cejn
cela
celer
celkem
celnice
cenina
cennost
cenovka
centrum
cenzor
cestopis
cetka
chalupa
chapadlo
charita
chata
chechtat
chemie
chichot
chirurg
chlad
chleba
chlubit
chmel
chmura
chobot
chochol
chodba
cholera
chomout
chopit
choroba
chov
chrapot
chrlit
chrt
chrup
chtivost
chudina
chutnat
chvat
chvilka
chvost
chyba
chystat
chytit
cibule
cigareta
cihelna
cihla
cinkot
cirkus
cisterna
citace
citrus
cizinec
cizost
clona
cokoliv
couvat
ctitel
ctnost
cudnost
cuketa
cukr
cupot
cvaknout
cval
cvik
cvrkot
cyklista
daleko
dareba
datel
datum
dcera
debata
dechovka
decibel
deficit
deflace
dekl
dekret
demokrat
deprese
derby
deska
detektiv
dikobraz
diktovat
dioda
diplom
disk
displej
divadlo
divoch
dlaha
dlouho
dluhopis
dnes
dobro
dobytek
docent
dochutit
dodnes
dohled
dohoda
dohra
dojem
dojnice
doklad
dokola
doktor
dokument
dolar
doleva
dolina
doma
dominant
domluvit
domov
donutit
dopad
dopis
doplnit
doposud
doprovod
dopustit
dorazit
dorost
dort
dosah
doslov
dostatek
dosud
dosyta
dotaz
dotek
dotknout
doufat
doutnat
dovozce
dozadu
doznat
dozorce
drahota
drak
dramatik
dravec
draze
drdol
drobnost
drogerie
drozd
drsnost
drtit
drzost
duben
duchovno
dudek
duha
duhovka
dusit
dusno
dutost
dvojice
dvorec
dynamit
ekolog
ekonomie
elektron
elipsa
email
emise
emoce
empatie
epizoda
epocha
epopej
epos
esej
esence
eskorta
eskymo
etiketa
euforie
evoluce
exekuce
exkurze
expedice
exploze
export
extrakt
facka
fajfka
fakulta
fanatik
fantazie
farmacie
favorit
fazole
federace
fejeton
fenka
fialka
figurant
filozof
filtr
finance
finta
fixace
fjord
flanel
flirt
flotila
fond
fosfor
fotbal
fotka
foton
frakce
freska
fronta
fukar
funkce
fyzika
galeje
garant
genetika
geolog
gilotina
glazura
glejt
golem
golfista
gotika
graf
gramofon
granule
grep
gril
grog
groteska
guma
hadice
hadr
hala
halenka
hanba
hanopis
harfa
harpuna
havran
hebkost
hejkal
hejno
hejtman
hektar
helma
hematom
herec
herna
heslo
hezky
historik
hladovka
hlasivky
hlava
hledat
hlen
hlodavec
hloh
hloupost
hltat
hlubina
hluchota
hmat
hmota
hmyz
hnis
hnojivo
hnout
hoblina
hoboj
hoch
hodiny
hodlat
hodnota
hodovat
hojnost
hokej
holinka
holka
holub
homole
honitba
honorace
horal
horda
horizont
horko
horlivec
hormon
hornina
horoskop
horstvo
hospoda
hostina
hotovost
houba
houf
houpat
houska
hovor
hradba
hranice
hravost
hrazda
hrbolek
hrdina
hrdlo
hrdost
hrnek
hrobka
hromada
hrot
hrouda
hrozen
hrstka
hrubost
hryzat
hubenost
hubnout
hudba
hukot
humr
husita
hustota
hvozd
hybnost
hydrant
hygiena
hymna
hysterik
idylka
ihned
ikona
iluze
imunita
infekce
inflace
inkaso
inovace
inspekce
internet
invalida
investor
inzerce
ironie
jablko
jachta
jahoda
jakmile
jakost
jalovec
jantar
jarmark
jaro
jasan
jasno
jatka
javor
jazyk
jedinec
jedle
jednatel
jehlan
jekot
jelen
jelito
jemnost
jenom
jepice
jeseter
jevit
jezdec
jezero
jinak
jindy
jinoch
jiskra
jistota
jitrnice
jizva
jmenovat
jogurt
jurta
kabaret
kabel
kabinet
kachna
kadet
kadidlo
kahan
kajak
kajuta
kakao
kaktus
kalamita
kalhoty
kalibr
kalnost
kamera
kamkoliv
kamna
kanibal
kanoe
kantor
kapalina
kapela
kapitola
kapka
kaple
kapota
kapr
kapusta
kapybara
karamel
karotka
karton
kasa
katalog
katedra
kauce
kauza
kavalec
kazajka
kazeta
kazivost
kdekoliv
kdesi
kedluben
kemp
keramika
kino
klacek
kladivo
klam
klapot
klasika
klaun
klec
klenba
klepat
klesnout
klid
klima
klisna
klobouk
klokan
klopa
kloub
klubovna
klusat
kluzkost
kmen
kmitat
kmotr
kniha
knot
koalice
koberec
kobka
kobliha
kobyla
kocour
kohout
kojenec
kokos
koktejl
kolaps
koleda
kolize
kolo
komando
kometa
komik
komnata
komora
kompas
komunita
konat
koncept
kondice
konec
konfese
kongres
konina
konkurs
kontakt
konzerva
kopanec
kopie
kopnout
koprovka
korbel
korektor
kormidlo
koroptev
korpus
koruna
koryto
korzet
kosatec
kostka
kotel
kotleta
kotoul
koukat
koupelna
kousek
kouzlo
kovboj
koza
kozoroh
krabice
krach
krajina
kralovat
krasopis
kravata
kredit
krejcar
kresba
kreveta
kriket
kritik
krize
krkavec
krmelec
krmivo
krocan
krok
kronika
kropit
kroupa
krovka
krtek
kruhadlo
krupice
krutost
krvinka
krychle
krypta
krystal
kryt
kudlanka
kufr
kujnost
kukla
kulajda
kulich
kulka
kulomet
kultura
kuna
kupodivu
kurt
kurzor
kutil
kvalita
kvasinka
kvestor
kynolog
kyselina
kytara
kytice
kytka
kytovec
kyvadlo
labrador
lachtan
ladnost
laik
lakomec
lamela
lampa
lanovka
lasice
laso
lastura
latinka
lavina
lebka
leckdy
leden
lednice
ledovka
ledvina
legenda
legie
legrace
lehce
lehkost
lehnout
lektvar
lenochod
lentilka
lepenka
lepidlo
letadlo
letec
letmo
letokruh
levhart
levitace
levobok
libra
lichotka
lidojed
lidskost
lihovina
lijavec
lilek
limetka
linie
linka
linoleum
listopad
litina
litovat
lobista
lodivod
logika
logoped
lokalita
loket
lomcovat
lopata
lopuch
lord
losos
lotr
loudal
louh
louka
louskat
lovec
lstivost
lucerna
lucifer
lump
lusk
lustrace
lvice
lyra
lyrika
lysina
madam
madlo
magistr
mahagon
majetek
majitel
majorita
makak
makovice
makrela
malba
malina
malovat
malvice
maminka
mandle
manko
marnost
masakr
maskot
masopust
matice
matrika
maturita
mazanec
mazivo
mazlit
mazurka
mdloba
mechanik
meditace
medovina
melasa
meloun
mentolka
metla
metoda
metr
mezera
migrace
mihnout
mihule
mikina
mikrofon
milenec
milimetr
milost
mimika
mincovna
minibar
minomet
minulost
miska
mistr
mixovat
mladost
mlha
mlhovina
mlok
mlsat
mluvit
mnich
mnohem
mobil
mocnost
modelka
modlitba
mohyla
mokro
molekula
momentka
monarcha
monokl
monstrum
montovat
monzun
mosaz
moskyt
most
motivace
motorka
motyka
moucha
moudrost
mozaika
mozek
mozol
mramor
mravenec
mrkev
mrtvola
mrzet
mrzutost
mstitel
mudrc
muflon
mulat
mumie
munice
muset
mutace
muzeum
muzikant
myslivec
mzda
nabourat
nachytat
nadace
nadbytek
nadhoz
nadobro
nadpis
nahlas
nahnat
nahodile
nahradit
naivita
najednou
najisto
najmout
naklonit
nakonec
nakrmit
nalevo
namazat
namluvit
nanometr
naoko
naopak
naostro
napadat
napevno
naplnit
napnout
naposled
naprosto
narodit
naruby
narychlo
nasadit
nasekat
naslepo
nastat
natolik
navenek
navrch
navzdory
nazvat
nebe
nechat
necky
nedaleko
nedbat
neduh
negace
nehet
nehoda
nejen
nejprve
neklid
nelibost
nemilost
nemoc
neochota
neonka
nepokoj
nerost
nerv
nesmysl
nesoulad
netvor
neuron
nevina
nezvykle
nicota
nijak
nikam
nikdy
nikl
nikterak
nitro
nocleh
nohavice
nominace
nora
norek
nositel
nosnost
nouze
noviny
novota
nozdra
nuda
nudle
nuget
nutit
nutnost
nutrie
nymfa
obal
obarvit
obava
obdiv
obec
obehnat
obejmout
obezita
obhajoba
obilnice
objasnit
objekt
obklopit
oblast
oblek
obliba
obloha
obluda
obnos
obohatit
obojek
obout
obrazec
obrna
obruba
obrys
obsah
obsluha
obstarat
obuv
obvaz
obvinit
obvod
obvykle
obyvatel
obzor
ocas
ocel
ocenit
ochladit
ochota
ochrana
ocitnout
odboj
odbyt
odchod
odcizit
odebrat
odeslat
odevzdat
odezva
odhadce
odhodit
odjet
odjinud
odkaz
odkoupit
odliv
odluka
odmlka
odolnost
odpad
odpis
odplout
odpor
odpustit
odpykat
odrazka
odsoudit
odstup
odsun
odtok
odtud
odvaha
odveta
odvolat
odvracet
odznak
ofina
ofsajd
ohlas
ohnisko
ohrada
ohrozit
ohryzek
okap
okenice
oklika
okno
okouzlit
okovy
okrasa
okres
okrsek
okruh
okupant
okurka
okusit
olejnina
olizovat
omak
omeleta
omezit
omladina
omlouvat
omluva
omyl
onehdy
opakovat
opasek
operace
opice
opilost
opisovat
opora
opozice
opravdu
oproti
orbital
orchestr
orgie
orlice
orloj
ortel
osada
oschnout
osika
osivo
oslava
oslepit
oslnit
oslovit
osnova
osoba
osolit
ospalec
osten
ostraha
ostuda
ostych
osvojit
oteplit
otisk
otop
otrhat
otrlost
otrok
otruby
otvor
ovanout
ovar
oves
ovlivnit
ovoce
oxid
ozdoba
pachatel
pacient
padouch
pahorek
pakt
palanda
palec
palivo
paluba
pamflet
pamlsek
panenka
panika
panna
panovat
panstvo
pantofle
paprika
parketa
parodie
parta
paruka
paryba
paseka
pasivita
pastelka
patent
patrona
pavouk
pazneht
pazourek
pecka
pedagog
pejsek
peklo
peloton
penalta
pendrek
penze
periskop
pero
pestrost
petarda
petice
petrolej
pevnina
pexeso
pianista
piha
pijavice
pikle
piknik
pilina
pilnost
pilulka
pinzeta
pipeta
pisatel
pistole
pitevna
pivnice
pivovar
placenta
plakat
plamen
planeta
plastika
platit
plavidlo
plaz
plech
plemeno
plenta
ples
pletivo
plevel
plivat
plnit
plno
plocha
plodina
plomba
plout
pluk
plyn
pobavit
pobyt
pochod
pocit
poctivec
podat
podcenit
podepsat
podhled
podivit
podklad
podmanit
podnik
podoba
podpora
podraz
podstata
podvod
podzim
poezie
pohanka
pohnutka
pohovor
pohroma
pohyb
pointa
pojistka
pojmout
pokazit
pokles
pokoj
pokrok
pokuta
pokyn
poledne
polibek
polknout
poloha
polynom
pomalu
pominout
pomlka
pomoc
pomsta
pomyslet
ponechat
ponorka
ponurost
popadat
popel
popisek
poplach
poprosit
popsat
popud
poradce
porce
porod
porucha
poryv
posadit
posed
posila
poskok
poslanec
posoudit
pospolu
postava
posudek
posyp
potah
potkan
potlesk
potomek
potrava
potupa
potvora
poukaz
pouto
pouzdro
povaha
povidla
povlak
povoz
povrch
povstat
povyk
povzdech
pozdrav
pozemek
poznatek
pozor
pozvat
pracovat
prahory
praktika
prales
praotec
praporek
prase
pravda
princip
prkno
probudit
procento
prodej
profese
prohra
projekt
prolomit
promile
pronikat
propad
prorok
prosba
proton
proutek
provaz
prskavka
prsten
prudkost
prut
prvek
prvohory
psanec
psovod
pstruh
ptactvo
puberta
puch
pudl
pukavec
puklina
pukrle
pult
pumpa
punc
pupen
pusa
pusinka
pustina
putovat
putyka
pyramida
pysk
pytel
racek
rachot
radiace
radnice
radon
raft
ragby
raketa
rakovina
rameno
rampouch
rande
rarach
rarita
rasovna
rastr
ratolest
razance
razidlo
reagovat
reakce
recept
redaktor
referent
reflex
rejnok
reklama
rekord
rekrut
rektor
reputace
revize
revma
revolver
rezerva
riskovat
riziko
robotika
rodokmen
rohovka
rokle
rokoko
romaneto
ropovod
ropucha
rorejs
rosol
rostlina
rotmistr
rotoped
rotunda
roubenka
roucho
roup
roura
rovina
rovnice
rozbor
rozchod
rozdat
rozeznat
rozhodce
rozinka
rozjezd
rozkaz
rozloha
rozmar
rozpad
rozruch
rozsah
roztok
rozum
rozvod
rubrika
ruchadlo
rukavice
rukopis
ryba
rybolov
rychlost
rydlo
rypadlo
rytina
ryzost
sadista
sahat
sako
samec
samizdat
samota
sanitka
sardinka
sasanka
satelit
sazba
sazenice
sbor
schovat
sebranka
secese
sedadlo
sediment
sedlo
sehnat
sejmout
sekera
sekta
sekunda
sekvoje
semeno
seno
servis
sesadit
seshora
seskok
seslat
sestra
sesuv
sesypat
setba
setina
setkat
setnout
setrvat
sever
seznam
shoda
shrnout
sifon
silnice
sirka
sirotek
sirup
situace
skafandr
skalisko
skanzen
skaut
skeptik
skica
skladba
sklenice
sklo
skluz
skoba
skokan
skoro
skripta
skrz
skupina
skvost
skvrna
slabika
sladidlo
slanina
slast
slavnost
sledovat
slepec
sleva
slezina
slib
slina
sliznice
slon
sloupek
slovo
sluch
sluha
slunce
slupka
slza
smaragd
smetana
smilstvo
smlouva
smog
smrad
smrk
smrtka
smutek
smysl
snad
snaha
snob
sobota
socha
sodovka
sokol
sopka
sotva
souboj
soucit
soudce
souhlas
soulad
soumrak
souprava
soused
soutok
souviset
spalovna
spasitel
spis
splav
spodek
spojenec
spolu
sponzor
spornost
spousta
sprcha
spustit
sranda
sraz
srdce
srna
srnec
srovnat
srpen
srst
srub
stanice
starosta
statika
stavba
stehno
stezka
stodola
stolek
stopa
storno
stoupat
strach
stres
strhnout
strom
struna
studna
stupnice
stvol
styk
subjekt
subtropy
suchar
sudost
sukno
sundat
sunout
surikata
surovina
svah
svalstvo
svetr
svatba
svazek
svisle
svitek
svoboda
svodidlo
svorka
svrab
sykavka
sykot
synek
synovec
sypat
sypkost
syrovost
sysel
sytost
tabletka
tabule
tahoun
tajemno
tajfun
tajga
tajit
tajnost
taktika
tamhle
tampon
tancovat
tanec
tanker
tapeta
tavenina
tazatel
technika
tehdy
tekutina
telefon
temnota
tendence
tenista
tenor
teplota
tepna
teprve
terapie
termoska
textil
ticho
tiskopis
titulek
tkadlec
tkanina
tlapka
tleskat
tlukot
tlupa
tmel
toaleta
topinka
topol
torzo
touha
toulec
tradice
traktor
tramp
trasa
traverza
trefit
trest
trezor
trhavina
trhlina
trochu
trojice
troska
trouba
trpce
trpitel
trpkost
trubec
truchlit
truhlice
trus
trvat
tudy
tuhnout
tuhost
tundra
turista
turnaj
tuzemsko
tvaroh
tvorba
tvrdost
tvrz
tygr
tykev
ubohost
uboze
ubrat
ubrousek
ubrus
ubytovna
ucho
uctivost
udivit
uhradit
ujednat
ujistit
ujmout
ukazatel
uklidnit
uklonit
ukotvit
ukrojit
ulice
ulita
ulovit
umyvadlo
unavit
uniforma
uniknout
upadnout
uplatnit
uplynout
upoutat
upravit
uran
urazit
usednout
usilovat
usmrtit
usnadnit
usnout
usoudit
ustlat
ustrnout
utahovat
utkat
utlumit
utonout
utopenec
utrousit
uvalit
uvolnit
uvozovka
uzdravit
uzel
uzenina
uzlina
uznat
vagon
valcha
valoun
vana
vandal
vanilka
varan
varhany
varovat
vcelku
vchod
vdova
vedro
vegetace
vejce
velbloud
veletrh
velitel
velmoc
velryba
venkov
veranda
verze
veselka
veskrze
vesnice
vespodu
vesta
veterina
veverka
vibrace
vichr
videohra
vidina
vidle
vila
vinice
viset
vitalita
vize
vizitka
vjezd
vklad
vkus
vlajka
vlak
vlasec
vlevo
vlhkost
vliv
vlnovka
vloupat
vnucovat
vnuk
voda
vodivost
vodoznak
vodstvo
vojensky
vojna
vojsko
volant
volba
volit
volno
voskovka
vozidlo
vozovna
vpravo
vrabec
vracet
vrah
vrata
vrba
vrcholek
vrhat
vrstva
vrtule
vsadit
vstoupit
vstup
vtip
vybavit
vybrat
vychovat
vydat
vydra
vyfotit
vyhledat
vyhnout
vyhodit
vyhradit
vyhubit
vyjasnit
vyjet
vyjmout
vyklopit
vykonat
vylekat
vymazat
vymezit
vymizet
vymyslet
vynechat
vynikat
vynutit
vypadat
vyplatit
vypravit
vypustit
vyrazit
vyrovnat
vyrvat
vyslovit
vysoko
vystavit
vysunout
vysypat
vytasit
vytesat
vytratit
vyvinout
vyvolat
vyvrhel
vyzdobit
vyznat
vzadu
vzbudit
vzchopit
vzdor
vzduch
vzdychat
vzestup
vzhledem
vzkaz
vzlykat
vznik
vzorek
vzpoura
vztah
vztek
xylofon
zabrat
zabydlet
zachovat
zadarmo
zadusit
zafoukat
zahltit
zahodit
zahrada
zahynout
zajatec
zajet
zajistit
zaklepat
zakoupit
zalepit
zamezit
zamotat
zamyslet
zanechat
zanikat
zaplatit
zapojit
zapsat
zarazit
zastavit
zasunout
zatajit
zatemnit
zatknout
zaujmout
zavalit
zavelet
zavinit
zavolat
zavrtat
zazvonit
zbavit
zbrusu
zbudovat
zbytek
zdaleka
zdarma
zdatnost
zdivo
zdobit
zdroj
zdvih
zdymadlo
zelenina
zeman
zemina
zeptat
zezadu
zezdola
zhatit
zhltnout
zhluboka
zhotovit
zhruba
zima
zimnice
zjemnit
zklamat
zkoumat
zkratka
zkumavka
zlato
zlehka
zloba
zlom
zlost
zlozvyk
zmapovat
zmar
zmatek
zmije
zmizet
zmocnit
zmodrat
zmrzlina
zmutovat
znak
znalost
znamenat
znovu
zobrazit
zotavit
zoubek
zoufale
zplodit
zpomalit
zprava
zprostit
zprudka
zprvu
zrada
zranit
zrcadlo
zrnitost
zrno
zrovna
zrychlit
zrzavost
zticha
ztratit
zubovina
zubr
zvednout
zvenku
zvesela
zvon
zvrat
zvukovod
zvyk`.split("\n");
// /home/mous/work/pimlico/alto/node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/@scure/bip39/esm/wordlists/english.js
var wordlist2 = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split("\n");
// /home/mous/work/pimlico/alto/node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/@scure/bip39/esm/wordlists/french.js
var wordlist3 = `abaisser
abandon
abdiquer
abeille
abolir
aborder
aboutir
aboyer
abrasif
abreuver
abriter
abroger
abrupt
absence
absolu
absurde
abusif
abyssal
acade\u0301mie
acajou
acarien
accabler
accepter
acclamer
accolade
accroche
accuser
acerbe
achat
acheter
aciduler
acier
acompte
acque\u0301rir
acronyme
acteur
actif
actuel
adepte
ade\u0301quat
adhe\u0301sif
adjectif
adjuger
admettre
admirer
adopter
adorer
adoucir
adresse
adroit
adulte
adverbe
ae\u0301rer
ae\u0301ronef
affaire
affecter
affiche
affreux
affubler
agacer
agencer
agile
agiter
agrafer
agre\u0301able
agrume
aider
aiguille
ailier
aimable
aisance
ajouter
ajuster
alarmer
alchimie
alerte
alge\u0300bre
algue
alie\u0301ner
aliment
alle\u0301ger
alliage
allouer
allumer
alourdir
alpaga
altesse
alve\u0301ole
amateur
ambigu
ambre
ame\u0301nager
amertume
amidon
amiral
amorcer
amour
amovible
amphibie
ampleur
amusant
analyse
anaphore
anarchie
anatomie
ancien
ane\u0301antir
angle
angoisse
anguleux
animal
annexer
annonce
annuel
anodin
anomalie
anonyme
anormal
antenne
antidote
anxieux
apaiser
ape\u0301ritif
aplanir
apologie
appareil
appeler
apporter
appuyer
aquarium
aqueduc
arbitre
arbuste
ardeur
ardoise
argent
arlequin
armature
armement
armoire
armure
arpenter
arracher
arriver
arroser
arsenic
arte\u0301riel
article
aspect
asphalte
aspirer
assaut
asservir
assiette
associer
assurer
asticot
astre
astuce
atelier
atome
atrium
atroce
attaque
attentif
attirer
attraper
aubaine
auberge
audace
audible
augurer
aurore
automne
autruche
avaler
avancer
avarice
avenir
averse
aveugle
aviateur
avide
avion
aviser
avoine
avouer
avril
axial
axiome
badge
bafouer
bagage
baguette
baignade
balancer
balcon
baleine
balisage
bambin
bancaire
bandage
banlieue
bannie\u0300re
banquier
barbier
baril
baron
barque
barrage
bassin
bastion
bataille
bateau
batterie
baudrier
bavarder
belette
be\u0301lier
belote
be\u0301ne\u0301fice
berceau
berger
berline
bermuda
besace
besogne
be\u0301tail
beurre
biberon
bicycle
bidule
bijou
bilan
bilingue
billard
binaire
biologie
biopsie
biotype
biscuit
bison
bistouri
bitume
bizarre
blafard
blague
blanchir
blessant
blinder
blond
bloquer
blouson
bobard
bobine
boire
boiser
bolide
bonbon
bondir
bonheur
bonifier
bonus
bordure
borne
botte
boucle
boueux
bougie
boulon
bouquin
bourse
boussole
boutique
boxeur
branche
brasier
brave
brebis
bre\u0300che
breuvage
bricoler
brigade
brillant
brioche
brique
brochure
broder
bronzer
brousse
broyeur
brume
brusque
brutal
bruyant
buffle
buisson
bulletin
bureau
burin
bustier
butiner
butoir
buvable
buvette
cabanon
cabine
cachette
cadeau
cadre
cafe\u0301ine
caillou
caisson
calculer
calepin
calibre
calmer
calomnie
calvaire
camarade
came\u0301ra
camion
campagne
canal
caneton
canon
cantine
canular
capable
caporal
caprice
capsule
capter
capuche
carabine
carbone
caresser
caribou
carnage
carotte
carreau
carton
cascade
casier
casque
cassure
causer
caution
cavalier
caverne
caviar
ce\u0301dille
ceinture
ce\u0301leste
cellule
cendrier
censurer
central
cercle
ce\u0301re\u0301bral
cerise
cerner
cerveau
cesser
chagrin
chaise
chaleur
chambre
chance
chapitre
charbon
chasseur
chaton
chausson
chavirer
chemise
chenille
che\u0301quier
chercher
cheval
chien
chiffre
chignon
chime\u0300re
chiot
chlorure
chocolat
choisir
chose
chouette
chrome
chute
cigare
cigogne
cimenter
cine\u0301ma
cintrer
circuler
cirer
cirque
citerne
citoyen
citron
civil
clairon
clameur
claquer
classe
clavier
client
cligner
climat
clivage
cloche
clonage
cloporte
cobalt
cobra
cocasse
cocotier
coder
codifier
coffre
cogner
cohe\u0301sion
coiffer
coincer
cole\u0300re
colibri
colline
colmater
colonel
combat
come\u0301die
commande
compact
concert
conduire
confier
congeler
connoter
consonne
contact
convexe
copain
copie
corail
corbeau
cordage
corniche
corpus
correct
corte\u0300ge
cosmique
costume
coton
coude
coupure
courage
couteau
couvrir
coyote
crabe
crainte
cravate
crayon
cre\u0301ature
cre\u0301diter
cre\u0301meux
creuser
crevette
cribler
crier
cristal
crite\u0300re
croire
croquer
crotale
crucial
cruel
crypter
cubique
cueillir
cuille\u0300re
cuisine
cuivre
culminer
cultiver
cumuler
cupide
curatif
curseur
cyanure
cycle
cylindre
cynique
daigner
damier
danger
danseur
dauphin
de\u0301battre
de\u0301biter
de\u0301border
de\u0301brider
de\u0301butant
de\u0301caler
de\u0301cembre
de\u0301chirer
de\u0301cider
de\u0301clarer
de\u0301corer
de\u0301crire
de\u0301cupler
de\u0301dale
de\u0301ductif
de\u0301esse
de\u0301fensif
de\u0301filer
de\u0301frayer
de\u0301gager
de\u0301givrer
de\u0301glutir
de\u0301grafer
de\u0301jeuner
de\u0301lice
de\u0301loger
demander
demeurer
de\u0301molir
de\u0301nicher
de\u0301nouer
dentelle
de\u0301nuder
de\u0301part
de\u0301penser
de\u0301phaser
de\u0301placer
de\u0301poser
de\u0301ranger
de\u0301rober
de\u0301sastre
descente
de\u0301sert
de\u0301signer
de\u0301sobe\u0301ir
dessiner
destrier
de\u0301tacher
de\u0301tester
de\u0301tourer
de\u0301tresse
devancer
devenir
deviner
devoir
diable
dialogue
diamant
dicter
diffe\u0301rer
dige\u0301rer
digital
digne
diluer
dimanche
diminuer
dioxyde
directif
diriger
discuter
disposer
dissiper
distance
divertir
diviser
docile
docteur
dogme
doigt
domaine
domicile
dompter
donateur
donjon
donner
dopamine
dortoir
dorure
dosage
doseur
dossier
dotation
douanier
double
douceur
douter
doyen
dragon
draper
dresser
dribbler
droiture
duperie
duplexe
durable
durcir
dynastie
e\u0301blouir
e\u0301carter
e\u0301charpe
e\u0301chelle
e\u0301clairer
e\u0301clipse
e\u0301clore
e\u0301cluse
e\u0301cole
e\u0301conomie
e\u0301corce
e\u0301couter
e\u0301craser
e\u0301cre\u0301mer
e\u0301crivain
e\u0301crou
e\u0301cume
e\u0301cureuil
e\u0301difier
e\u0301duquer
effacer
effectif
effigie
effort
effrayer
effusion
e\u0301galiser
e\u0301garer
e\u0301jecter
e\u0301laborer
e\u0301largir
e\u0301lectron
e\u0301le\u0301gant
e\u0301le\u0301phant
e\u0301le\u0300ve
e\u0301ligible
e\u0301litisme
e\u0301loge
e\u0301lucider
e\u0301luder
emballer
embellir
embryon
e\u0301meraude
e\u0301mission
emmener
e\u0301motion
e\u0301mouvoir
empereur
employer
emporter
emprise
e\u0301mulsion
encadrer
enche\u0300re
enclave
encoche
endiguer
endosser
endroit
enduire
e\u0301nergie
enfance
enfermer
enfouir
engager
engin
englober
e\u0301nigme
enjamber
enjeu
enlever
ennemi
ennuyeux
enrichir
enrobage
enseigne
entasser
entendre
entier
entourer
entraver
e\u0301nume\u0301rer
envahir
enviable
envoyer
enzyme
e\u0301olien
e\u0301paissir
e\u0301pargne
e\u0301patant
e\u0301paule
e\u0301picerie
e\u0301pide\u0301mie
e\u0301pier
e\u0301pilogue
e\u0301pine
e\u0301pisode
e\u0301pitaphe
e\u0301poque
e\u0301preuve
e\u0301prouver
e\u0301puisant
e\u0301querre
e\u0301quipe
e\u0301riger
e\u0301rosion
erreur
e\u0301ruption
escalier
espadon
espe\u0300ce
espie\u0300gle
espoir
esprit
esquiver
essayer
essence
essieu
essorer
estime
estomac
estrade
e\u0301tage\u0300re
e\u0301taler
e\u0301tanche
e\u0301tatique
e\u0301teindre
e\u0301tendoir
e\u0301ternel
e\u0301thanol
e\u0301thique
ethnie
e\u0301tirer
e\u0301toffer
e\u0301toile
e\u0301tonnant
e\u0301tourdir
e\u0301trange
e\u0301troit
e\u0301tude
euphorie
e\u0301valuer
e\u0301vasion
e\u0301ventail
e\u0301vidence
e\u0301viter
e\u0301volutif
e\u0301voquer
exact
exage\u0301rer
exaucer
exceller
excitant
exclusif
excuse
exe\u0301cuter
exemple
exercer
exhaler
exhorter
exigence
exiler
exister
exotique
expe\u0301dier
explorer
exposer
exprimer
exquis
extensif
extraire
exulter
fable
fabuleux
facette
facile
facture
faiblir
falaise
fameux
famille
farceur
farfelu
farine
farouche
fasciner
fatal
fatigue
faucon
fautif
faveur
favori
fe\u0301brile
fe\u0301conder
fe\u0301de\u0301rer
fe\u0301lin
femme
fe\u0301mur
fendoir
fe\u0301odal
fermer
fe\u0301roce
ferveur
festival
feuille
feutre
fe\u0301vrier
fiasco
ficeler
fictif
fide\u0300le
figure
filature
filetage
filie\u0300re
filleul
filmer
filou
filtrer
financer
finir
fiole
firme
fissure
fixer
flairer
flamme
flasque
flatteur
fle\u0301au
fle\u0300che
fleur
flexion
flocon
flore
fluctuer
fluide
fluvial
folie
fonderie
fongible
fontaine
forcer
forgeron
formuler
fortune
fossile
foudre
fouge\u0300re
fouiller
foulure
fourmi
fragile
fraise
franchir
frapper
frayeur
fre\u0301gate
freiner
frelon
fre\u0301mir
fre\u0301ne\u0301sie
fre\u0300re
friable
friction
frisson
frivole
froid
fromage
frontal
frotter
fruit
fugitif
fuite
fureur
furieux
furtif
fusion
futur
gagner
galaxie
galerie
gambader
garantir
gardien
garnir
garrigue
gazelle
gazon
ge\u0301ant
ge\u0301latine
ge\u0301lule
gendarme
ge\u0301ne\u0301ral
ge\u0301nie
genou
gentil
ge\u0301ologie
ge\u0301ome\u0300tre
ge\u0301ranium
germe
gestuel
geyser
gibier
gicler
girafe
givre
glace
glaive
glisser
globe
gloire
glorieux
golfeur
gomme
gonfler
gorge
gorille
goudron
gouffre
goulot
goupille
gourmand
goutte
graduel
graffiti
graine
grand
grappin
gratuit
gravir
grenat
griffure
griller
grimper
grogner
gronder
grotte
groupe
gruger
grutier
gruye\u0300re
gue\u0301pard
guerrier
guide
guimauve
guitare
gustatif
gymnaste
gyrostat
habitude
hachoir
halte
hameau
hangar
hanneton
haricot
harmonie
harpon
hasard
he\u0301lium
he\u0301matome
herbe
he\u0301risson
hermine
he\u0301ron
he\u0301siter
heureux
hiberner
hibou
hilarant
histoire
hiver
homard
hommage
homoge\u0300ne
honneur
honorer
honteux
horde
horizon
horloge
hormone
horrible
houleux
housse
hublot
huileux
humain
humble
humide
humour
hurler
hydromel
hygie\u0300ne
hymne
hypnose
idylle
ignorer
iguane
illicite
illusion
image
imbiber
imiter
immense
immobile
immuable
impact
impe\u0301rial
implorer
imposer
imprimer
imputer
incarner
incendie
incident
incliner
incolore
indexer
indice
inductif
ine\u0301dit
ineptie
inexact
infini
infliger
informer
infusion
inge\u0301rer
inhaler
inhiber
injecter
injure
innocent
inoculer
inonder
inscrire
insecte
insigne
insolite
inspirer
instinct
insulter
intact
intense
intime
intrigue
intuitif
inutile
invasion
inventer
inviter
invoquer
ironique
irradier
irre\u0301el
irriter
isoler
ivoire
ivresse
jaguar
jaillir
jambe
janvier
jardin
jauger
jaune
javelot
jetable
jeton
jeudi
jeunesse
joindre
joncher
jongler
joueur
jouissif
journal
jovial
joyau
joyeux
jubiler
jugement
junior
jupon
juriste
justice
juteux
juve\u0301nile
kayak
kimono
kiosque
label
labial
labourer
lace\u0301rer
lactose
lagune
laine
laisser
laitier
lambeau
lamelle
lampe
lanceur
langage
lanterne
lapin
largeur
larme
laurier
lavabo
lavoir
lecture
le\u0301gal
le\u0301ger
le\u0301gume
lessive
lettre
levier
lexique
le\u0301zard
liasse
libe\u0301rer
libre
licence
licorne
lie\u0300ge
lie\u0300vre
ligature
ligoter
ligue
limer
limite
limonade
limpide
line\u0301aire
lingot
lionceau
liquide
lisie\u0300re
lister
lithium
litige
littoral
livreur
logique
lointain
loisir
lombric
loterie
louer
lourd
loutre
louve
loyal
lubie
lucide
lucratif
lueur
lugubre
luisant
lumie\u0300re
lunaire
lundi
luron
lutter
luxueux
machine
magasin
magenta
magique
maigre
maillon
maintien
mairie
maison
majorer
malaxer
male\u0301fice
malheur
malice
mallette
mammouth
mandater
maniable
manquant
manteau
manuel
marathon
marbre
marchand
mardi
maritime
marqueur
marron
marteler
mascotte
massif
mate\u0301riel
matie\u0300re
matraque
maudire
maussade
mauve
maximal
me\u0301chant
me\u0301connu
me\u0301daille
me\u0301decin
me\u0301diter
me\u0301duse
meilleur
me\u0301lange
me\u0301lodie
membre
me\u0301moire
menacer
mener
menhir
mensonge
mentor
mercredi
me\u0301rite
merle
messager
mesure
me\u0301tal
me\u0301te\u0301ore
me\u0301thode
me\u0301tier
meuble
miauler
microbe
miette
mignon
migrer
milieu
million
mimique
mince
mine\u0301ral
minimal
minorer
minute
miracle
miroiter
missile
mixte
mobile
moderne
moelleux
mondial
moniteur
monnaie
monotone
monstre
montagne
monument
moqueur
morceau
morsure
mortier
moteur
motif
mouche
moufle
moulin
mousson
mouton
mouvant
multiple
munition
muraille
mure\u0300ne
murmure
muscle
muse\u0301um
musicien
mutation
muter
mutuel
myriade
myrtille
myste\u0300re
mythique
nageur
nappe
narquois
narrer
natation
nation
nature
naufrage
nautique
navire
ne\u0301buleux
nectar
ne\u0301faste
ne\u0301gation
ne\u0301gliger
ne\u0301gocier
neige
nerveux
nettoyer
neurone
neutron
neveu
niche
nickel
nitrate
niveau
noble
nocif
nocturne
noirceur
noisette
nomade
nombreux
nommer
normatif
notable
notifier
notoire
nourrir
nouveau
novateur
novembre
novice
nuage
nuancer
nuire
nuisible
nume\u0301ro
nuptial
nuque
nutritif
obe\u0301ir
objectif
obliger
obscur
observer
obstacle
obtenir
obturer
occasion
occuper
oce\u0301an
octobre
octroyer
octupler
oculaire
odeur
odorant
offenser
officier
offrir
ogive
oiseau
oisillon
olfactif
olivier
ombrage
omettre
onctueux
onduler
one\u0301reux
onirique
opale
opaque
ope\u0301rer
opinion
opportun
opprimer
opter
optique
orageux
orange
orbite
ordonner
oreille
organe
orgueil
orifice
ornement
orque
ortie
osciller
osmose
ossature
otarie
ouragan
ourson
outil
outrager
ouvrage
ovation
oxyde
oxyge\u0300ne
ozone
paisible
palace
palmare\u0300s
palourde
palper
panache
panda
pangolin
paniquer
panneau
panorama
pantalon
papaye
papier
papoter
papyrus
paradoxe
parcelle
paresse
parfumer
parler
parole
parrain
parsemer
partager
parure
parvenir
passion
paste\u0300que
paternel
patience
patron
pavillon
pavoiser
payer
paysage
peigne
peintre
pelage
pe\u0301lican
pelle
pelouse
peluche
pendule
pe\u0301ne\u0301trer
pe\u0301nible
pensif
pe\u0301nurie
pe\u0301pite
pe\u0301plum
perdrix
perforer
pe\u0301riode
permuter
perplexe
persil
perte
peser
pe\u0301tale
petit
pe\u0301trir
peuple
pharaon
phobie
phoque
photon
phrase
physique
piano
pictural
pie\u0300ce
pierre
pieuvre
pilote
pinceau
pipette
piquer
pirogue
piscine
piston
pivoter
pixel
pizza
placard
plafond
plaisir
planer
plaque
plastron
plateau
pleurer
plexus
pliage
plomb
plonger
pluie
plumage
pochette
poe\u0301sie
poe\u0300te
pointe
poirier
poisson
poivre
polaire
policier
pollen
polygone
pommade
pompier
ponctuel
ponde\u0301rer
poney
portique
position
posse\u0301der
posture
potager
poteau
potion
pouce
poulain
poumon
pourpre
poussin
pouvoir
prairie
pratique
pre\u0301cieux
pre\u0301dire
pre\u0301fixe
pre\u0301lude
pre\u0301nom
pre\u0301sence
pre\u0301texte
pre\u0301voir
primitif
prince
prison
priver
proble\u0300me
proce\u0301der
prodige
profond
progre\u0300s
proie
projeter
prologue
promener
propre
prospe\u0300re
prote\u0301ger
prouesse
proverbe
prudence
pruneau
psychose
public
puceron
puiser
pulpe
pulsar
punaise
punitif
pupitre
purifier
puzzle
pyramide
quasar
querelle
question
quie\u0301tude
quitter
quotient
racine
raconter
radieux
ragondin
raideur
raisin
ralentir
rallonge
ramasser
rapide
rasage
ratisser
ravager
ravin
rayonner
re\u0301actif
re\u0301agir
re\u0301aliser
re\u0301animer
recevoir
re\u0301citer
re\u0301clamer
re\u0301colter
recruter
reculer
recycler
re\u0301diger
redouter
refaire
re\u0301flexe
re\u0301former
refrain
refuge
re\u0301galien
re\u0301gion
re\u0301glage
re\u0301gulier
re\u0301ite\u0301rer
rejeter
rejouer
relatif
relever
relief
remarque
reme\u0300de
remise
remonter
remplir
remuer
renard
renfort
renifler
renoncer
rentrer
renvoi
replier
reporter
reprise
reptile
requin
re\u0301serve
re\u0301sineux
re\u0301soudre
respect
rester
re\u0301sultat
re\u0301tablir
retenir
re\u0301ticule
retomber
retracer
re\u0301union
re\u0301ussir
revanche
revivre
re\u0301volte
re\u0301vulsif
richesse
rideau
rieur
rigide
rigoler
rincer
riposter
risible
risque
rituel
rival
rivie\u0300re
rocheux
romance
rompre
ronce
rondin
roseau
rosier
rotatif
rotor
rotule
rouge
rouille
rouleau
routine
royaume
ruban
rubis
ruche
ruelle
rugueux
ruiner
ruisseau
ruser
rustique
rythme
sabler
saboter
sabre
sacoche
safari
sagesse
saisir
salade
salive
salon
saluer
samedi
sanction
sanglier
sarcasme
sardine
saturer
saugrenu
saumon
sauter
sauvage
savant
savonner
scalpel
scandale
sce\u0301le\u0301rat
sce\u0301nario
sceptre
sche\u0301ma
science
scinder
score
scrutin
sculpter
se\u0301ance
se\u0301cable
se\u0301cher
secouer
se\u0301cre\u0301ter
se\u0301datif
se\u0301duire
seigneur
se\u0301jour
se\u0301lectif
semaine
sembler
semence
se\u0301minal
se\u0301nateur
sensible
sentence
se\u0301parer
se\u0301quence
serein
sergent
se\u0301rieux
serrure
se\u0301rum
service
se\u0301same
se\u0301vir
sevrage
sextuple
side\u0301ral
sie\u0300cle
sie\u0301ger
siffler
sigle
signal
silence
silicium
simple
since\u0300re
sinistre
siphon
sirop
sismique
situer
skier
social
socle
sodium
soigneux
soldat
soleil
solitude
soluble
sombre
sommeil
somnoler
sonde
songeur
sonnette
sonore
sorcier
sortir
sosie
sottise
soucieux
soudure
souffle
soulever
soupape
source
soutirer
souvenir
spacieux
spatial
spe\u0301cial
sphe\u0300re
spiral
stable
station
sternum
stimulus
stipuler
strict
studieux
stupeur
styliste
sublime
substrat
subtil
subvenir
succe\u0300s
sucre
suffixe
sugge\u0301rer
suiveur
sulfate
superbe
supplier
surface
suricate
surmener
surprise
sursaut
survie
suspect
syllabe
symbole
syme\u0301trie
synapse
syntaxe
syste\u0300me
tabac
tablier
tactile
tailler
talent
talisman
talonner
tambour
tamiser
tangible
tapis
taquiner
tarder
tarif
tartine
tasse
tatami
tatouage
taupe
taureau
taxer
te\u0301moin
temporel
tenaille
tendre
teneur
tenir
tension
terminer
terne
terrible
te\u0301tine
texte
the\u0300me
the\u0301orie
the\u0301rapie
thorax
tibia
tie\u0300de
timide
tirelire
tiroir
tissu
titane
titre
tituber
toboggan
tole\u0301rant
tomate
tonique
tonneau
toponyme
torche
tordre
tornade
torpille
torrent
torse
tortue
totem
toucher
tournage
tousser
toxine
traction
trafic
tragique
trahir
train
trancher
travail
tre\u0300fle
tremper
tre\u0301sor
treuil
triage
tribunal
tricoter
trilogie
triomphe
tripler
triturer
trivial
trombone
tronc
tropical
troupeau
tuile
tulipe
tumulte
tunnel
turbine
tuteur
tutoyer
tuyau
tympan
typhon
typique
tyran
ubuesque
ultime
ultrason
unanime
unifier
union
unique
unitaire
univers
uranium
urbain
urticant
usage
usine
usuel
usure
utile
utopie
vacarme
vaccin
vagabond
vague
vaillant
vaincre
vaisseau
valable
valise
vallon
valve
vampire
vanille
vapeur
varier
vaseux
vassal
vaste
vecteur
vedette
ve\u0301ge\u0301tal
ve\u0301hicule
veinard
ve\u0301loce
vendredi
ve\u0301ne\u0301rer
venger
venimeux
ventouse
verdure
ve\u0301rin
vernir
verrou
verser
vertu
veston
ve\u0301te\u0301ran
ve\u0301tuste
vexant
vexer
viaduc
viande
victoire
vidange
vide\u0301o
vignette
vigueur
vilain
village
vinaigre
violon
vipe\u0300re
virement
virtuose
virus
visage
viseur
vision
visqueux
visuel
vital
vitesse
viticole
vitrine
vivace
vivipare
vocation
voguer
voile
voisin
voiture
volaille
volcan
voltiger
volume
vorace
vortex
voter
vouloir
voyage
voyelle
wagon
xe\u0301non
yacht
ze\u0300bre
ze\u0301nith
zeste
zoologie`.split("\n");
// /home/mous/work/pimlico/alto/node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/@scure/bip39/esm/wordlists/italian.js
var wordlist4 = `abaco
abbaglio
abbinato
abete
abisso
abolire
abrasivo
abrogato
accadere
accenno
accusato
acetone
achille
acido
acqua
acre
acrilico
acrobata
acuto
adagio
addebito
addome
adeguato
aderire
adipe
adottare
adulare
affabile
affetto
affisso
affranto
aforisma
afoso
africano
agave
agente
agevole
aggancio
agire
agitare
agonismo
agricolo
agrumeto
aguzzo
alabarda
alato
albatro
alberato
albo
albume
alce
alcolico
alettone
alfa
algebra
aliante
alibi
alimento
allagato
allegro
allievo
allodola
allusivo
almeno
alogeno
alpaca
alpestre
altalena
alterno
alticcio
altrove
alunno
alveolo
alzare
amalgama
amanita
amarena
ambito
ambrato
ameba
america
ametista
amico
ammasso
ammenda
ammirare
ammonito
amore
ampio
ampliare
amuleto
anacardo
anagrafe
analista
anarchia
anatra
anca
ancella
ancora
andare
andrea
anello
angelo
angolare
angusto
anima
annegare
annidato
anno
annuncio
anonimo
anticipo
anzi
apatico
apertura
apode
apparire
appetito
appoggio
approdo
appunto
aprile
arabica
arachide
aragosta
araldica
arancio
aratura
arazzo
arbitro
archivio
ardito
arenile
argento
argine
arguto
aria
armonia
arnese
arredato
arringa
arrosto
arsenico
arso
artefice
arzillo
asciutto
ascolto
asepsi
asettico
asfalto
asino
asola
aspirato
aspro
assaggio
asse
assoluto
assurdo
asta
astenuto
astice
astratto
atavico
ateismo
atomico
atono
attesa
attivare
attorno
attrito
attuale
ausilio
austria
autista
autonomo
autunno
avanzato
avere
avvenire
avviso
avvolgere
azione
azoto
azzimo
azzurro
babele
baccano
bacino
baco
badessa
badilata
bagnato
baita
balcone
baldo
balena
ballata
balzano
bambino
bandire
baraonda
barbaro
barca
baritono
barlume
barocco
basilico
basso
batosta
battuto
baule
bava
bavosa
becco
beffa
belgio
belva
benda
benevole
benigno
benzina
bere
berlina
beta
bibita
bici
bidone
bifido
biga
bilancia
bimbo
binocolo
biologo
bipede
bipolare
birbante
birra
biscotto
bisesto
bisnonno
bisonte
bisturi
bizzarro
blando
blatta
bollito
bonifico
bordo
bosco
botanico
bottino
bozzolo
braccio
bradipo
brama
branca
bravura
bretella
brevetto
brezza
briglia
brillante
brindare
broccolo
brodo
bronzina
brullo
bruno
bubbone
buca
budino
buffone
buio
bulbo
buono
burlone
burrasca
bussola
busta
cadetto
caduco
calamaro
calcolo
calesse
calibro
calmo
caloria
cambusa
camerata
camicia
cammino
camola
campale
canapa
candela
cane
canino
canotto
cantina
capace
capello
capitolo
capogiro
cappero
capra
capsula
carapace
carcassa
cardo
carisma
carovana
carretto
cartolina
casaccio
cascata
caserma
caso
cassone
castello
casuale
catasta
catena
catrame
cauto
cavillo
cedibile
cedrata
cefalo
celebre
cellulare
cena
cenone
centesimo
ceramica
cercare
certo
cerume
cervello
cesoia
cespo
ceto
chela
chiaro
chicca
chiedere
chimera
china
chirurgo
chitarra
ciao
ciclismo
cifrare
cigno
cilindro
ciottolo
circa
cirrosi
citrico
cittadino
ciuffo
civetta
civile
classico
clinica
cloro
cocco
codardo
codice
coerente
cognome
collare
colmato
colore
colposo
coltivato
colza
coma
cometa
commando
comodo
computer
comune
conciso
condurre
conferma
congelare
coniuge
connesso
conoscere
consumo
continuo
convegno
coperto
copione
coppia
copricapo
corazza
cordata
coricato
cornice
corolla
corpo
corredo
corsia
cortese
cosmico
costante
cottura
covato
cratere
cravatta
creato
credere
cremoso
crescita
creta
criceto
crinale
crisi
critico
croce
cronaca
crostata
cruciale
crusca
cucire
cuculo
cugino
cullato
cupola
curatore
cursore
curvo
cuscino
custode
dado
daino
dalmata
damerino
daniela
dannoso
danzare
datato
davanti
davvero
debutto
decennio
deciso
declino
decollo
decreto
dedicato
definito
deforme
degno
delegare
delfino
delirio
delta
demenza
denotato
dentro
deposito
derapata
derivare
deroga
descritto
deserto
desiderio
desumere
detersivo
devoto
diametro
dicembre
diedro
difeso
diffuso
digerire
digitale
diluvio
dinamico
dinnanzi
dipinto
diploma
dipolo
diradare
dire
dirotto
dirupo
disagio
discreto
disfare
disgelo
disposto
distanza
disumano
dito
divano
divelto
dividere
divorato
doblone
docente
doganale
dogma
dolce
domato
domenica
dominare
dondolo
dono
dormire
dote
dottore
dovuto
dozzina
drago
druido
dubbio
dubitare
ducale
duna
duomo
duplice
duraturo
ebano
eccesso
ecco
eclissi
economia
edera
edicola
edile
editoria
educare
egemonia
egli
egoismo
egregio
elaborato
elargire
elegante
elencato
eletto
elevare
elfico
elica
elmo
elsa
eluso
emanato
emblema
emesso
emiro
emotivo
emozione
empirico
emulo
endemico
enduro
energia
enfasi
enoteca
entrare
enzima
epatite
epilogo
episodio
epocale
eppure
equatore
erario
erba
erboso
erede
eremita
erigere
ermetico
eroe
erosivo
errante
esagono
esame
esanime
esaudire
esca
esempio
esercito
esibito
esigente
esistere
esito
esofago
esortato
esoso
espanso
espresso
essenza
esso
esteso
estimare
estonia
estroso
esultare
etilico
etnico
etrusco
etto
euclideo
europa
evaso
evidenza
evitato
evoluto
evviva
fabbrica
faccenda
fachiro
falco
famiglia
fanale
fanfara
fango
fantasma
fare
farfalla
farinoso
farmaco
fascia
fastoso
fasullo
faticare
fato
favoloso
febbre
fecola
fede
fegato
felpa
feltro
femmina
fendere
fenomeno
fermento
ferro
fertile
fessura
festivo
fetta
feudo
fiaba
fiducia
fifa
figurato
filo
finanza
finestra
finire
fiore
fiscale
fisico
fiume
flacone
flamenco
flebo
flemma
florido
fluente
fluoro
fobico
focaccia
focoso
foderato
foglio
folata
folclore
folgore
fondente
fonetico
fonia
fontana
forbito
forchetta
foresta
formica
fornaio
foro
fortezza
forzare
fosfato
fosso
fracasso
frana
frassino
fratello
freccetta
frenata
fresco
frigo
frollino
fronde
frugale
frutta
fucilata
fucsia
fuggente
fulmine
fulvo
fumante
fumetto
fumoso
fune
funzione
fuoco
furbo
furgone
furore
fuso
futile
gabbiano
gaffe
galateo
gallina
galoppo
gambero
gamma
garanzia
garbo
garofano
garzone
gasdotto
gasolio
gastrico
gatto
gaudio
gazebo
gazzella
geco
gelatina
gelso
gemello
gemmato
gene
genitore
gennaio
genotipo
gergo
ghepardo
ghiaccio
ghisa
giallo
gilda
ginepro
giocare
gioiello
giorno
giove
girato
girone
gittata
giudizio
giurato
giusto
globulo
glutine
gnomo
gobba
golf
gomito
gommone
gonfio
gonna
governo
gracile
grado
grafico
grammo
grande
grattare
gravoso
grazia
greca
gregge
grifone
grigio
grinza
grotta
gruppo
guadagno
guaio
guanto
guardare
gufo
guidare
ibernato
icona
identico
idillio
idolo
idra
idrico
idrogeno
igiene
ignaro
ignorato
ilare
illeso
illogico
illudere
imballo
imbevuto
imbocco
imbuto
immane
immerso
immolato
impacco
impeto
impiego
importo
impronta
inalare
inarcare
inattivo
incanto
incendio
inchino
incisivo
incluso
incontro
incrocio
incubo
indagine
india
indole
inedito
infatti
infilare
inflitto
ingaggio
ingegno
inglese
ingordo
ingrosso
innesco
inodore
inoltrare
inondato
insano
insetto
insieme
insonnia
insulina
intasato
intero
intonaco
intuito
inumidire
invalido
invece
invito
iperbole
ipnotico
ipotesi
ippica
iride
irlanda
ironico
irrigato
irrorare
isolato
isotopo
isterico
istituto
istrice
italia
iterare
labbro
labirinto
lacca
lacerato
lacrima
lacuna
laddove
lago
lampo
lancetta
lanterna
lardoso
larga
laringe
lastra
latenza
latino
lattuga
lavagna
lavoro
legale
leggero
lembo
lentezza
lenza
leone
lepre
lesivo
lessato
lesto
letterale
leva
levigato
libero
lido
lievito
lilla
limatura
limitare
limpido
lineare
lingua
liquido
lira
lirica
lisca
lite
litigio
livrea
locanda
lode
logica
lombare
londra
longevo
loquace
lorenzo
loto
lotteria
luce
lucidato
lumaca
luminoso
lungo
lupo
luppolo
lusinga
lusso
lutto
macabro
macchina
macero
macinato
madama
magico
maglia
magnete
magro
maiolica
malafede
malgrado
malinteso
malsano
malto
malumore
mana
mancia
mandorla
mangiare
manifesto
mannaro
manovra
mansarda
mantide
manubrio
mappa
maratona
marcire
maretta
marmo
marsupio
maschera
massaia
mastino
materasso
matricola
mattone
maturo
mazurca
meandro
meccanico
mecenate
medesimo
meditare
mega
melassa
melis
melodia
meninge
meno
mensola
mercurio
merenda
merlo
meschino
mese
messere
mestolo
metallo
metodo
mettere
miagolare
mica
micelio
michele
microbo
midollo
miele
migliore
milano
milite
mimosa
minerale
mini
minore
mirino
mirtillo
miscela
missiva
misto
misurare
mitezza
mitigare
mitra
mittente
mnemonico
modello
modifica
modulo
mogano
mogio
mole
molosso
monastero
monco
mondina
monetario
monile
monotono
monsone
montato
monviso
mora
mordere
morsicato
mostro
motivato
motosega
motto
movenza
movimento
mozzo
mucca
mucosa
muffa
mughetto
mugnaio
mulatto
mulinello
multiplo
mummia
munto
muovere
murale
musa
muscolo
musica
mutevole
muto
nababbo
nafta
nanometro
narciso
narice
narrato
nascere
nastrare
naturale
nautica
naviglio
nebulosa
necrosi
negativo
negozio
nemmeno
neofita
neretto
nervo
nessuno
nettuno
neutrale
neve
nevrotico
nicchia
ninfa
nitido
nobile
nocivo
nodo
nome
nomina
nordico
normale
norvegese
nostrano
notare
notizia
notturno
novella
nucleo
nulla
numero
nuovo
nutrire
nuvola
nuziale
oasi
obbedire
obbligo
obelisco
oblio
obolo
obsoleto
occasione
occhio
occidente
occorrere
occultare
ocra
oculato
odierno
odorare
offerta
offrire
offuscato
oggetto
oggi
ognuno
olandese
olfatto
oliato
oliva
ologramma
oltre
omaggio
ombelico
ombra
omega
omissione
ondoso
onere
onice
onnivoro
onorevole
onta
operato
opinione
opposto
oracolo
orafo
ordine
orecchino
orefice
orfano
organico
origine
orizzonte
orma
ormeggio
ornativo
orologio
orrendo
orribile
ortensia
ortica
orzata
orzo
osare
oscurare
osmosi
ospedale
ospite
ossa
ossidare
ostacolo
oste
otite
otre
ottagono
ottimo
ottobre
ovale
ovest
ovino
oviparo
ovocito
ovunque
ovviare
ozio
pacchetto
pace
pacifico
padella
padrone
paese
paga
pagina
palazzina
palesare
pallido
palo
palude
pandoro
pannello
paolo
paonazzo
paprica
parabola
parcella
parere
pargolo
pari
parlato
parola
partire
parvenza
parziale
passivo
pasticca
patacca
patologia
pattume
pavone
peccato
pedalare
pedonale
peggio
peloso
penare
pendice
penisola
pennuto
penombra
pensare
pentola
pepe
pepita
perbene
percorso
perdonato
perforare
pergamena
periodo
permesso
perno
perplesso
persuaso
pertugio
pervaso
pesatore
pesista
peso
pestifero
petalo
pettine
petulante
pezzo
piacere
pianta
piattino
piccino
picozza
piega
pietra
piffero
pigiama
pigolio
pigro
pila
pilifero
pillola
pilota
pimpante
pineta
pinna
pinolo
pioggia
piombo
piramide
piretico
pirite
pirolisi
pitone
pizzico
placebo
planare
plasma
platano
plenario
pochezza
poderoso
podismo
poesia
poggiare
polenta
poligono
pollice
polmonite
polpetta
polso
poltrona
polvere
pomice
pomodoro
ponte
popoloso
porfido
poroso
porpora
porre
portata
posa
positivo
possesso
postulato
potassio
potere
pranzo
prassi
pratica
precluso
predica
prefisso
pregiato
prelievo
premere
prenotare
preparato
presenza
pretesto
prevalso
prima
principe
privato
problema
procura
produrre
profumo
progetto
prolunga
promessa
pronome
proposta
proroga
proteso
prova
prudente
prugna
prurito
psiche
pubblico
pudica
pugilato
pugno
pulce
pulito
pulsante
puntare
pupazzo
pupilla
puro
quadro
qualcosa
quasi
querela
quota
raccolto
raddoppio
radicale
radunato
raffica
ragazzo
ragione
ragno
ramarro
ramingo
ramo
randagio
rantolare
rapato
rapina
rappreso
rasatura
raschiato
rasente
rassegna
rastrello
rata
ravveduto
reale
recepire
recinto
recluta
recondito
recupero
reddito
redimere
regalato
registro
regola
regresso
relazione
remare
remoto
renna
replica
reprimere
reputare
resa
residente
responso
restauro
rete
retina
retorica
rettifica
revocato
riassunto
ribadire
ribelle
ribrezzo
ricarica
ricco
ricevere
riciclato
ricordo
ricreduto
ridicolo
ridurre
rifasare
riflesso
riforma
rifugio
rigare
rigettato
righello
rilassato
rilevato
rimanere
rimbalzo
rimedio
rimorchio
rinascita
rincaro
rinforzo
rinnovo
rinomato
rinsavito
rintocco
rinuncia
rinvenire
riparato
ripetuto
ripieno
riportare
ripresa
ripulire
risata
rischio
riserva
risibile
riso
rispetto
ristoro
risultato
risvolto
ritardo
ritegno
ritmico
ritrovo
riunione
riva
riverso
rivincita
rivolto
rizoma
roba
robotico
robusto
roccia
roco
rodaggio
rodere
roditore
rogito
rollio
romantico
rompere
ronzio
rosolare
rospo
rotante
rotondo
rotula
rovescio
rubizzo
rubrica
ruga
rullino
rumine
rumoroso
ruolo
rupe
russare
rustico
sabato
sabbiare
sabotato
sagoma
salasso
saldatura
salgemma
salivare
salmone
salone
saltare
saluto
salvo
sapere
sapido
saporito
saraceno
sarcasmo
sarto
sassoso
satellite
satira
satollo
saturno
savana
savio
saziato
sbadiglio
sbalzo
sbancato
sbarra
sbattere
sbavare
sbendare
sbirciare
sbloccato
sbocciato
sbrinare
sbruffone
sbuffare
scabroso
scadenza
scala
scambiare
scandalo
scapola
scarso
scatenare
scavato
scelto
scenico
scettro
scheda
schiena
sciarpa
scienza
scindere
scippo
sciroppo
scivolo
sclerare
scodella
scolpito
scomparto
sconforto
scoprire
scorta
scossone
scozzese
scriba
scrollare
scrutinio
scuderia
scultore
scuola
scuro
scusare
sdebitare
sdoganare
seccatura
secondo
sedano
seggiola
segnalato
segregato
seguito
selciato
selettivo
sella
selvaggio
semaforo
sembrare
seme
seminato
sempre
senso
sentire
sepolto
sequenza
serata
serbato
sereno
serio
serpente
serraglio
servire
sestina
setola
settimana
sfacelo
sfaldare
sfamato
sfarzoso
sfaticato
sfera
sfida
sfilato
sfinge
sfocato
sfoderare
sfogo
sfoltire
sforzato
sfratto
sfruttato
sfuggito
sfumare
sfuso
sgabello
sgarbato
sgonfiare
sgorbio
sgrassato
sguardo
sibilo
siccome
sierra
sigla
signore
silenzio
sillaba
simbolo
simpatico
simulato
sinfonia
singolo
sinistro
sino
sintesi
sinusoide
sipario
sisma
sistole
situato
slitta
slogatura
sloveno
smarrito
smemorato
smentito
smeraldo
smilzo
smontare
smottato
smussato
snellire
snervato
snodo
sobbalzo
sobrio
soccorso
sociale
sodale
soffitto
sogno
soldato
solenne
solido
sollazzo
solo
solubile
solvente
somatico
somma
sonda
sonetto
sonnifero
sopire
soppeso
sopra
sorgere
sorpasso
sorriso
sorso
sorteggio
sorvolato
sospiro
sosta
sottile
spada
spalla
spargere
spatola
spavento
spazzola
specie
spedire
spegnere
spelatura
speranza
spessore
spettrale
spezzato
spia
spigoloso
spillato
spinoso
spirale
splendido
sportivo
sposo
spranga
sprecare
spronato
spruzzo
spuntino
squillo
sradicare
srotolato
stabile
stacco
staffa
stagnare
stampato
stantio
starnuto
stasera
statuto
stelo
steppa
sterzo
stiletto
stima
stirpe
stivale
stizzoso
stonato
storico
strappo
stregato
stridulo
strozzare
strutto
stuccare
stufo
stupendo
subentro
succoso
sudore
suggerito
sugo
sultano
suonare
superbo
supporto
surgelato
surrogato
sussurro
sutura
svagare
svedese
sveglio
svelare
svenuto
svezia
sviluppo
svista
svizzera
svolta
svuotare
tabacco
tabulato
tacciare
taciturno
tale
talismano
tampone
tannino
tara
tardivo
targato
tariffa
tarpare
tartaruga
tasto
tattico
taverna
tavolata
tazza
teca
tecnico
telefono
temerario
tempo
temuto
tendone
tenero
tensione
tentacolo
teorema
terme
terrazzo
terzetto
tesi
tesserato
testato
tetro
tettoia
tifare
tigella
timbro
tinto
tipico
tipografo
tiraggio
tiro
titanio
titolo
titubante
tizio
tizzone
toccare
tollerare
tolto
tombola
tomo
tonfo
tonsilla
topazio
topologia
toppa
torba
tornare
torrone
tortora
toscano
tossire
tostatura
totano
trabocco
trachea
trafila
tragedia
tralcio
tramonto
transito
trapano
trarre
trasloco
trattato
trave
treccia
tremolio
trespolo
tributo
tricheco
trifoglio
trillo
trincea
trio
tristezza
triturato
trivella
tromba
trono
troppo
trottola
trovare
truccato
tubatura
tuffato
tulipano
tumulto
tunisia
turbare
turchino
tuta
tutela
ubicato
uccello
uccisore
udire
uditivo
uffa
ufficio
uguale
ulisse
ultimato
umano
umile
umorismo
uncinetto
ungere
ungherese
unicorno
unificato
unisono
unitario
unte
uovo
upupa
uragano
urgenza
urlo
usanza
usato
uscito
usignolo
usuraio
utensile
utilizzo
utopia
vacante
vaccinato
vagabondo
vagliato
valanga
valgo
valico
valletta
valoroso
valutare
valvola
vampata
vangare
vanitoso
vano
vantaggio
vanvera
vapore
varano
varcato
variante
vasca
vedetta
vedova
veduto
vegetale
veicolo
velcro
velina
velluto
veloce
venato
vendemmia
vento
verace
verbale
vergogna
verifica
vero
verruca
verticale
vescica
vessillo
vestale
veterano
vetrina
vetusto
viandante
vibrante
vicenda
vichingo
vicinanza
vidimare
vigilia
vigneto
vigore
vile
villano
vimini
vincitore
viola
vipera
virgola
virologo
virulento
viscoso
visione
vispo
vissuto
visura
vita
vitello
vittima
vivanda
vivido
viziare
voce
voga
volatile
volere
volpe
voragine
vulcano
zampogna
zanna
zappato
zattera
zavorra
zefiro
zelante
zelo
zenzero
zerbino
zibetto
zinco
zircone
zitto
zolla
zotico
zucchero
zufolo
zulu
zuppa`.split("\n");
// /home/mous/work/pimlico/alto/node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/@scure/bip39/esm/wordlists/japanese.js
var wordlist5 = `\u3042\u3044\u3053\u304F\u3057\u3093
\u3042\u3044\u3055\u3064
\u3042\u3044\u305F\u3099
\u3042\u304A\u305D\u3099\u3089
\u3042\u304B\u3061\u3083\u3093
\u3042\u304D\u308B
\u3042\u3051\u304B\u3099\u305F
\u3042\u3051\u308B
\u3042\u3053\u304B\u3099\u308C\u308B
\u3042\u3055\u3044
\u3042\u3055\u3072
\u3042\u3057\u3042\u3068
\u3042\u3057\u3099\u308F\u3046
\u3042\u3059\u3099\u304B\u308B
\u3042\u3059\u3099\u304D
\u3042\u305D\u3075\u3099
\u3042\u305F\u3048\u308B
\u3042\u305F\u305F\u3081\u308B
\u3042\u305F\u308A\u307E\u3048
\u3042\u305F\u308B
\u3042\u3064\u3044
\u3042\u3064\u304B\u3046
\u3042\u3063\u3057\u3085\u304F
\u3042\u3064\u307E\u308A
\u3042\u3064\u3081\u308B
\u3042\u3066\u306A
\u3042\u3066\u306F\u307E\u308B
\u3042\u3072\u308B
\u3042\u3075\u3099\u3089
\u3042\u3075\u3099\u308B
\u3042\u3075\u308C\u308B
\u3042\u307E\u3044
\u3042\u307E\u3068\u3099
\u3042\u307E\u3084\u304B\u3059
\u3042\u307E\u308A
\u3042\u307F\u3082\u306E
\u3042\u3081\u308A\u304B
\u3042\u3084\u307E\u308B
\u3042\u3086\u3080
\u3042\u3089\u3044\u304F\u3099\u307E
\u3042\u3089\u3057
\u3042\u3089\u3059\u3057\u3099
\u3042\u3089\u305F\u3081\u308B
\u3042\u3089\u3086\u308B
\u3042\u3089\u308F\u3059
\u3042\u308A\u304B\u3099\u3068\u3046
\u3042\u308F\u305B\u308B
\u3042\u308F\u3066\u308B
\u3042\u3093\u3044
\u3042\u3093\u304B\u3099\u3044
\u3042\u3093\u3053
\u3042\u3093\u305B\u3099\u3093
\u3042\u3093\u3066\u3044
\u3042\u3093\u306A\u3044
\u3042\u3093\u307E\u308A
\u3044\u3044\u305F\u3099\u3059
\u3044\u304A\u3093
\u3044\u304B\u3099\u3044
\u3044\u304B\u3099\u304F
\u3044\u304D\u304A\u3044
\u3044\u304D\u306A\u308A
\u3044\u304D\u3082\u306E
\u3044\u304D\u308B
\u3044\u304F\u3057\u3099
\u3044\u304F\u3075\u3099\u3093
\u3044\u3051\u306F\u3099\u306A
\u3044\u3051\u3093
\u3044\u3053\u3046
\u3044\u3053\u304F
\u3044\u3053\u3064
\u3044\u3055\u307E\u3057\u3044
\u3044\u3055\u3093
\u3044\u3057\u304D
\u3044\u3057\u3099\u3085\u3046
\u3044\u3057\u3099\u3087\u3046
\u3044\u3057\u3099\u308F\u308B
\u3044\u3059\u3099\u307F
\u3044\u3059\u3099\u308C
\u3044\u305B\u3044
\u3044\u305B\u3048\u3072\u3099
\u3044\u305B\u304B\u3044
\u3044\u305B\u304D
\u3044\u305B\u3099\u3093
\u3044\u305D\u3046\u308D\u3046
\u3044\u305D\u304B\u3099\u3057\u3044
\u3044\u305F\u3099\u3044
\u3044\u305F\u3099\u304F
\u3044\u305F\u3059\u3099\u3089
\u3044\u305F\u307F
\u3044\u305F\u308A\u3042
\u3044\u3061\u304A\u3046
\u3044\u3061\u3057\u3099
\u3044\u3061\u3068\u3099
\u3044\u3061\u306F\u3099
\u3044\u3061\u3075\u3099
\u3044\u3061\u308A\u3085\u3046
\u3044\u3064\u304B
\u3044\u3063\u3057\u3085\u3093
\u3044\u3063\u305B\u3044
\u3044\u3063\u305D\u3046
\u3044\u3063\u305F\u3093
\u3044\u3063\u3061
\u3044\u3063\u3066\u3044
\u3044\u3063\u307B\u309A\u3046
\u3044\u3066\u3055\u3099
\u3044\u3066\u3093
\u3044\u3068\u3099\u3046
\u3044\u3068\u3053
\u3044\u306A\u3044
\u3044\u306A\u304B
\u3044\u306D\u3080\u308A
\u3044\u306E\u3061
\u3044\u306E\u308B
\u3044\u306F\u3064
\u3044\u306F\u3099\u308B
\u3044\u306F\u3093
\u3044\u3072\u3099\u304D
\u3044\u3072\u3093
\u3044\u3075\u304F
\u3044\u3078\u3093
\u3044\u307B\u3046
\u3044\u307F\u3093
\u3044\u3082\u3046\u3068
\u3044\u3082\u305F\u308C
\u3044\u3082\u308A
\u3044\u3084\u304B\u3099\u308B
\u3044\u3084\u3059
\u3044\u3088\u304B\u3093
\u3044\u3088\u304F
\u3044\u3089\u3044
\u3044\u3089\u3059\u3068
\u3044\u308A\u304F\u3099\u3061
\u3044\u308A\u3087\u3046
\u3044\u308C\u3044
\u3044\u308C\u3082\u306E
\u3044\u308C\u308B
\u3044\u308D\u3048\u3093\u3072\u309A\u3064
\u3044\u308F\u3044
\u3044\u308F\u3046
\u3044\u308F\u304B\u3093
\u3044\u308F\u306F\u3099
\u3044\u308F\u3086\u308B
\u3044\u3093\u3051\u3099\u3093\u307E\u3081
\u3044\u3093\u3055\u3064
\u3044\u3093\u3057\u3087\u3046
\u3044\u3093\u3088\u3046
\u3046\u3048\u304D
\u3046\u3048\u308B
\u3046\u304A\u3055\u3099
\u3046\u304B\u3099\u3044
\u3046\u304B\u3075\u3099
\u3046\u304B\u3078\u3099\u308B
\u3046\u304D\u308F
\u3046\u304F\u3089\u3044\u306A
\u3046\u304F\u308C\u308C
\u3046\u3051\u305F\u307E\u308F\u308B
\u3046\u3051\u3064\u3051
\u3046\u3051\u3068\u308B
\u3046\u3051\u3082\u3064
\u3046\u3051\u308B
\u3046\u3053\u3099\u304B\u3059
\u3046\u3053\u3099\u304F
\u3046\u3053\u3093
\u3046\u3055\u304D\u3099
\u3046\u3057\u306A\u3046
\u3046\u3057\u308D\u304B\u3099\u307F
\u3046\u3059\u3044
\u3046\u3059\u304D\u3099
\u3046\u3059\u304F\u3099\u3089\u3044
\u3046\u3059\u3081\u308B
\u3046\u305B\u3064
\u3046\u3061\u3042\u308F\u305B
\u3046\u3061\u304B\u3099\u308F
\u3046\u3061\u304D
\u3046\u3061\u3085\u3046
\u3046\u3063\u304B\u308A
\u3046\u3064\u304F\u3057\u3044
\u3046\u3063\u305F\u3048\u308B
\u3046\u3064\u308B
\u3046\u3068\u3099\u3093
\u3046\u306A\u304D\u3099
\u3046\u306A\u3057\u3099
\u3046\u306A\u3059\u3099\u304F
\u3046\u306A\u308B
\u3046\u306D\u308B
\u3046\u306E\u3046
\u3046\u3075\u3099\u3051\u3099
\u3046\u3075\u3099\u3053\u3099\u3048
\u3046\u307E\u308C\u308B
\u3046\u3081\u308B
\u3046\u3082\u3046
\u3046\u3084\u307E\u3046
\u3046\u3088\u304F
\u3046\u3089\u304B\u3099\u3048\u3059
\u3046\u3089\u304F\u3099\u3061
\u3046\u3089\u306A\u3044
\u3046\u308A\u3042\u3051\u3099
\u3046\u308A\u304D\u308C
\u3046\u308B\u3055\u3044
\u3046\u308C\u3057\u3044
\u3046\u308C\u3086\u304D
\u3046\u308C\u308B
\u3046\u308D\u3053
\u3046\u308F\u304D
\u3046\u308F\u3055
\u3046\u3093\u3053\u3046
\u3046\u3093\u3061\u3093
\u3046\u3093\u3066\u3093
\u3046\u3093\u3068\u3099\u3046
\u3048\u3044\u3048\u3093
\u3048\u3044\u304B\u3099
\u3048\u3044\u304D\u3087\u3046
\u3048\u3044\u3053\u3099
\u3048\u3044\u305B\u3044
\u3048\u3044\u3075\u3099\u3093
\u3048\u3044\u3088\u3046
\u3048\u3044\u308F
\u3048\u304A\u308A
\u3048\u304B\u3099\u304A
\u3048\u304B\u3099\u304F
\u3048\u304D\u305F\u3044
\u3048\u304F\u305B\u308B
\u3048\u3057\u3083\u304F
\u3048\u3059\u3066
\u3048\u3064\u3089\u3093
\u3048\u306E\u304F\u3099
\u3048\u307B\u3046\u307E\u304D
\u3048\u307B\u3093
\u3048\u307E\u304D
\u3048\u3082\u3057\u3099
\u3048\u3082\u306E
\u3048\u3089\u3044
\u3048\u3089\u3075\u3099
\u3048\u308A\u3042
\u3048\u3093\u3048\u3093
\u3048\u3093\u304B\u3044
\u3048\u3093\u304D\u3099
\u3048\u3093\u3051\u3099\u304D
\u3048\u3093\u3057\u3085\u3046
\u3048\u3093\u305B\u3099\u3064
\u3048\u3093\u305D\u304F
\u3048\u3093\u3061\u3087\u3046
\u3048\u3093\u3068\u3064
\u304A\u3044\u304B\u3051\u308B
\u304A\u3044\u3053\u3059
\u304A\u3044\u3057\u3044
\u304A\u3044\u3064\u304F
\u304A\u3046\u3048\u3093
\u304A\u3046\u3055\u307E
\u304A\u3046\u3057\u3099
\u304A\u3046\u305B\u3064
\u304A\u3046\u305F\u3044
\u304A\u3046\u3075\u304F
\u304A\u3046\u3078\u3099\u3044
\u304A\u3046\u3088\u3046
\u304A\u3048\u308B
\u304A\u304A\u3044
\u304A\u304A\u3046
\u304A\u304A\u3068\u3099\u304A\u308A
\u304A\u304A\u3084
\u304A\u304A\u3088\u305D
\u304A\u304B\u3048\u308A
\u304A\u304B\u3059\u3099
\u304A\u304B\u3099\u3080
\u304A\u304B\u308F\u308A
\u304A\u304D\u3099\u306A\u3046
\u304A\u304D\u308B
\u304A\u304F\u3055\u307E
\u304A\u304F\u3057\u3099\u3087\u3046
\u304A\u304F\u308A\u304B\u3099\u306A
\u304A\u304F\u308B
\u304A\u304F\u308C\u308B
\u304A\u3053\u3059
\u304A\u3053\u306A\u3046
\u304A\u3053\u308B
\u304A\u3055\u3048\u308B
\u304A\u3055\u306A\u3044
\u304A\u3055\u3081\u308B
\u304A\u3057\u3044\u308C
\u304A\u3057\u3048\u308B
\u304A\u3057\u3099\u304D\u3099
\u304A\u3057\u3099\u3055\u3093
\u304A\u3057\u3083\u308C
\u304A\u305D\u3089\u304F
\u304A\u305D\u308F\u308B
\u304A\u305F\u304B\u3099\u3044
\u304A\u305F\u304F
\u304A\u305F\u3099\u3084\u304B
\u304A\u3061\u3064\u304F
\u304A\u3063\u3068
\u304A\u3064\u308A
\u304A\u3066\u3099\u304B\u3051
\u304A\u3068\u3057\u3082\u306E
\u304A\u3068\u306A\u3057\u3044
\u304A\u3068\u3099\u308A
\u304A\u3068\u3099\u308D\u304B\u3059
\u304A\u306F\u3099\u3055\u3093
\u304A\u307E\u3044\u308A
\u304A\u3081\u3066\u3099\u3068\u3046
\u304A\u3082\u3044\u3066\u3099
\u304A\u3082\u3046
\u304A\u3082\u305F\u3044
\u304A\u3082\u3061\u3083
\u304A\u3084\u3064
\u304A\u3084\u3086\u3072\u3099
\u304A\u3088\u307B\u3099\u3059
\u304A\u3089\u3093\u305F\u3099
\u304A\u308D\u3059
\u304A\u3093\u304B\u3099\u304F
\u304A\u3093\u3051\u3044
\u304A\u3093\u3057\u3083
\u304A\u3093\u305B\u3093
\u304A\u3093\u305F\u3099\u3093
\u304A\u3093\u3061\u3085\u3046
\u304A\u3093\u3068\u3099\u3051\u3044
\u304B\u3042\u3064
\u304B\u3044\u304B\u3099
\u304B\u3099\u3044\u304D
\u304B\u3099\u3044\u3051\u3093
\u304B\u3099\u3044\u3053\u3046
\u304B\u3044\u3055\u3064
\u304B\u3044\u3057\u3083
\u304B\u3044\u3059\u3044\u3088\u304F
\u304B\u3044\u305B\u3099\u3093
\u304B\u3044\u305D\u3099\u3046\u3068\u3099
\u304B\u3044\u3064\u3046
\u304B\u3044\u3066\u3093
\u304B\u3044\u3068\u3046
\u304B\u3044\u3075\u304F
\u304B\u3099\u3044\u3078\u304D
\u304B\u3044\u307B\u3046
\u304B\u3044\u3088\u3046
\u304B\u3099\u3044\u3089\u3044
\u304B\u3044\u308F
\u304B\u3048\u308B
\u304B\u304A\u308A
\u304B\u304B\u3048\u308B
\u304B\u304B\u3099\u304F
\u304B\u304B\u3099\u3057
\u304B\u304B\u3099\u307F
\u304B\u304F\u3053\u3099
\u304B\u304F\u3068\u304F
\u304B\u3055\u3099\u308B
\u304B\u3099\u305D\u3099\u3046
\u304B\u305F\u3044
\u304B\u305F\u3061
\u304B\u3099\u3061\u3087\u3046
\u304B\u3099\u3063\u304D\u3085\u3046
\u304B\u3099\u3063\u3053\u3046
\u304B\u3099\u3063\u3055\u3093
\u304B\u3099\u3063\u3057\u3087\u3046
\u304B\u306A\u3055\u3099\u308F\u3057
\u304B\u306E\u3046
\u304B\u3099\u306F\u304F
\u304B\u3075\u3099\u304B
\u304B\u307B\u3046
\u304B\u307B\u3053\u3099
\u304B\u307E\u3046
\u304B\u307E\u307B\u3099\u3053
\u304B\u3081\u308C\u304A\u3093
\u304B\u3086\u3044
\u304B\u3088\u3046\u3072\u3099
\u304B\u3089\u3044
\u304B\u308B\u3044
\u304B\u308D\u3046
\u304B\u308F\u304F
\u304B\u308F\u3089
\u304B\u3099\u3093\u304B
\u304B\u3093\u3051\u3044
\u304B\u3093\u3053\u3046
\u304B\u3093\u3057\u3083
\u304B\u3093\u305D\u3046
\u304B\u3093\u305F\u3093
\u304B\u3093\u3061
\u304B\u3099\u3093\u306F\u3099\u308B
\u304D\u3042\u3044
\u304D\u3042\u3064
\u304D\u3044\u308D
\u304D\u3099\u3044\u3093
\u304D\u3046\u3044
\u304D\u3046\u3093
\u304D\u3048\u308B
\u304D\u304A\u3046
\u304D\u304A\u304F
\u304D\u304A\u3061
\u304D\u304A\u3093
\u304D\u304B\u3044
\u304D\u304B\u304F
\u304D\u304B\u3093\u3057\u3083
\u304D\u304D\u3066
\u304D\u304F\u306F\u3099\u308A
\u304D\u304F\u3089\u3051\u3099
\u304D\u3051\u3093\u305B\u3044
\u304D\u3053\u3046
\u304D\u3053\u3048\u308B
\u304D\u3053\u304F
\u304D\u3055\u3044
\u304D\u3055\u304F
\u304D\u3055\u307E
\u304D\u3055\u3089\u304D\u3099
\u304D\u3099\u3057\u3099\u304B\u304B\u3099\u304F
\u304D\u3099\u3057\u304D
\u304D\u3099\u3057\u3099\u305F\u3044\u3051\u3093
\u304D\u3099\u3057\u3099\u306B\u3063\u3066\u3044
\u304D\u3099\u3057\u3099\u3085\u3064\u3057\u3083
\u304D\u3059\u3046
\u304D\u305B\u3044
\u304D\u305B\u304D
\u304D\u305B\u3064
\u304D\u305D\u3046
\u304D\u305D\u3099\u304F
\u304D\u305D\u3099\u3093
\u304D\u305F\u3048\u308B
\u304D\u3061\u3087\u3046
\u304D\u3064\u3048\u3093
\u304D\u3099\u3063\u3061\u308A
\u304D\u3064\u3064\u304D
\u304D\u3064\u306D
\u304D\u3066\u3044
\u304D\u3068\u3099\u3046
\u304D\u3068\u3099\u304F
\u304D\u306A\u3044
\u304D\u306A\u304B\u3099
\u304D\u306A\u3053
\u304D\u306C\u3053\u3099\u3057
\u304D\u306D\u3093
\u304D\u306E\u3046
\u304D\u306E\u3057\u305F
\u304D\u306F\u304F
\u304D\u3072\u3099\u3057\u3044
\u304D\u3072\u3093
\u304D\u3075\u304F
\u304D\u3075\u3099\u3093
\u304D\u307B\u3099\u3046
\u304D\u307B\u3093
\u304D\u307E\u308B
\u304D\u307F\u3064
\u304D\u3080\u3059\u3099\u304B\u3057\u3044
\u304D\u3081\u308B
\u304D\u3082\u305F\u3099\u3081\u3057
\u304D\u3082\u3061
\u304D\u3082\u306E
\u304D\u3083\u304F
\u304D\u3084\u304F
\u304D\u3099\u3085\u3046\u306B\u304F
\u304D\u3088\u3046
\u304D\u3087\u3046\u308A\u3085\u3046
\u304D\u3089\u3044
\u304D\u3089\u304F
\u304D\u308A\u3093
\u304D\u308C\u3044
\u304D\u308C\u3064
\u304D\u308D\u304F
\u304D\u3099\u308D\u3093
\u304D\u308F\u3081\u308B
\u304D\u3099\u3093\u3044\u308D
\u304D\u3093\u304B\u304F\u3057\u3099
\u304D\u3093\u3057\u3099\u3087
\u304D\u3093\u3088\u3046\u3072\u3099
\u304F\u3099\u3042\u3044
\u304F\u3044\u3059\u3099
\u304F\u3046\u304B\u3093
\u304F\u3046\u304D
\u304F\u3046\u304F\u3099\u3093
\u304F\u3046\u3053\u3046
\u304F\u3099\u3046\u305B\u3044
\u304F\u3046\u305D\u3046
\u304F\u3099\u3046\u305F\u3089
\u304F\u3046\u3075\u304F
\u304F\u3046\u307B\u3099
\u304F\u304B\u3093
\u304F\u304D\u3087\u3046
\u304F\u3051\u3099\u3093
\u304F\u3099\u3053\u3046
\u304F\u3055\u3044
\u304F\u3055\u304D
\u304F\u3055\u306F\u3099\u306A
\u304F\u3055\u308B
\u304F\u3057\u3083\u307F
\u304F\u3057\u3087\u3046
\u304F\u3059\u306E\u304D
\u304F\u3059\u308A\u3086\u3072\u3099
\u304F\u305B\u3051\u3099
\u304F\u305B\u3093
\u304F\u3099\u305F\u3044\u3066\u304D
\u304F\u305F\u3099\u3055\u308B
\u304F\u305F\u3072\u3099\u308C\u308B
\u304F\u3061\u3053\u307F
\u304F\u3061\u3055\u304D
\u304F\u3064\u3057\u305F
\u304F\u3099\u3063\u3059\u308A
\u304F\u3064\u308D\u304F\u3099
\u304F\u3068\u3046\u3066\u3093
\u304F\u3068\u3099\u304F
\u304F\u306A\u3093
\u304F\u306D\u304F\u306D
\u304F\u306E\u3046
\u304F\u3075\u3046
\u304F\u307F\u3042\u308F\u305B
\u304F\u307F\u305F\u3066\u308B
\u304F\u3081\u308B
\u304F\u3084\u304F\u3057\u3087
\u304F\u3089\u3059
\u304F\u3089\u3078\u3099\u308B
\u304F\u308B\u307E
\u304F\u308C\u308B
\u304F\u308D\u3046
\u304F\u308F\u3057\u3044
\u304F\u3099\u3093\u304B\u3093
\u304F\u3099\u3093\u3057\u3087\u304F
\u304F\u3099\u3093\u305F\u3044
\u304F\u3099\u3093\u3066
\u3051\u3042\u306A
\u3051\u3044\u304B\u304F
\u3051\u3044\u3051\u3093
\u3051\u3044\u3053
\u3051\u3044\u3055\u3064
\u3051\u3099\u3044\u3057\u3099\u3085\u3064
\u3051\u3044\u305F\u3044
\u3051\u3099\u3044\u306E\u3046\u3057\u3099\u3093
\u3051\u3044\u308C\u304D
\u3051\u3044\u308D
\u3051\u304A\u3068\u3059
\u3051\u304A\u308A\u3082\u306E
\u3051\u3099\u304D\u304B
\u3051\u3099\u304D\u3051\u3099\u3093
\u3051\u3099\u304D\u305F\u3099\u3093
\u3051\u3099\u304D\u3061\u3093
\u3051\u3099\u304D\u3068\u3064
\u3051\u3099\u304D\u306F
\u3051\u3099\u304D\u3084\u304F
\u3051\u3099\u3053\u3046
\u3051\u3099\u3053\u304F\u3057\u3099\u3087\u3046
\u3051\u3099\u3055\u3099\u3044
\u3051\u3055\u304D
\u3051\u3099\u3055\u3099\u3093
\u3051\u3057\u304D
\u3051\u3057\u3053\u3099\u3080
\u3051\u3057\u3087\u3046
\u3051\u3099\u3059\u3068
\u3051\u305F\u306F\u3099
\u3051\u3061\u3083\u3063\u3075\u309A
\u3051\u3061\u3089\u3059
\u3051\u3064\u3042\u3064
\u3051\u3064\u3044
\u3051\u3064\u3048\u304D
\u3051\u3063\u3053\u3093
\u3051\u3064\u3057\u3099\u3087
\u3051\u3063\u305B\u304D
\u3051\u3063\u3066\u3044
\u3051\u3064\u307E\u3064
\u3051\u3099\u3064\u3088\u3046\u3072\u3099
\u3051\u3099\u3064\u308C\u3044
\u3051\u3064\u308D\u3093
\u3051\u3099\u3068\u3099\u304F
\u3051\u3068\u306F\u3099\u3059
\u3051\u3068\u308B
\u3051\u306A\u3051\u3099
\u3051\u306A\u3059
\u3051\u306A\u307F
\u3051\u306C\u304D
\u3051\u3099\u306D\u3064
\u3051\u306D\u3093
\u3051\u306F\u3044
\u3051\u3099\u3072\u3093
\u3051\u3075\u3099\u304B\u3044
\u3051\u3099\u307B\u3099\u304F
\u3051\u307E\u308A
\u3051\u307F\u304B\u308B
\u3051\u3080\u3057
\u3051\u3080\u308A
\u3051\u3082\u306E
\u3051\u3089\u3044
\u3051\u308D\u3051\u308D
\u3051\u308F\u3057\u3044
\u3051\u3093\u3044
\u3051\u3093\u3048\u3064
\u3051\u3093\u304A
\u3051\u3093\u304B
\u3051\u3099\u3093\u304D
\u3051\u3093\u3051\u3099\u3093
\u3051\u3093\u3053\u3046
\u3051\u3093\u3055\u304F
\u3051\u3093\u3057\u3085\u3046
\u3051\u3093\u3059\u3046
\u3051\u3099\u3093\u305D\u3046
\u3051\u3093\u3061\u304F
\u3051\u3093\u3066\u3044
\u3051\u3093\u3068\u3046
\u3051\u3093\u306A\u3044
\u3051\u3093\u306B\u3093
\u3051\u3099\u3093\u3075\u3099\u3064
\u3051\u3093\u307E
\u3051\u3093\u307F\u3093
\u3051\u3093\u3081\u3044
\u3051\u3093\u3089\u3093
\u3051\u3093\u308A
\u3053\u3042\u304F\u307E
\u3053\u3044\u306C
\u3053\u3044\u3072\u3099\u3068
\u3053\u3099\u3046\u3044
\u3053\u3046\u3048\u3093
\u3053\u3046\u304A\u3093
\u3053\u3046\u304B\u3093
\u3053\u3099\u3046\u304D\u3085\u3046
\u3053\u3099\u3046\u3051\u3044
\u3053\u3046\u3053\u3046
\u3053\u3046\u3055\u3044
\u3053\u3046\u3057\u3099
\u3053\u3046\u3059\u3044
\u3053\u3099\u3046\u305B\u3044
\u3053\u3046\u305D\u304F
\u3053\u3046\u305F\u3044
\u3053\u3046\u3061\u3083
\u3053\u3046\u3064\u3046
\u3053\u3046\u3066\u3044
\u3053\u3046\u3068\u3099\u3046
\u3053\u3046\u306A\u3044
\u3053\u3046\u306F\u3044
\u3053\u3099\u3046\u307B\u3046
\u3053\u3099\u3046\u307E\u3093
\u3053\u3046\u3082\u304F
\u3053\u3046\u308A\u3064
\u3053\u3048\u308B
\u3053\u304A\u308A
\u3053\u3099\u304B\u3044
\u3053\u3099\u304B\u3099\u3064
\u3053\u3099\u304B\u3093
\u3053\u304F\u3053\u3099
\u3053\u304F\u3055\u3044
\u3053\u304F\u3068\u3046
\u3053\u304F\u306A\u3044
\u3053\u304F\u306F\u304F
\u3053\u304F\u3099\u307E
\u3053\u3051\u3044
\u3053\u3051\u308B
\u3053\u3053\u306E\u304B
\u3053\u3053\u308D
\u3053\u3055\u3081
\u3053\u3057\u3064
\u3053\u3059\u3046
\u3053\u305B\u3044
\u3053\u305B\u304D
\u3053\u305B\u3099\u3093
\u3053\u305D\u305F\u3099\u3066
\u3053\u305F\u3044
\u3053\u305F\u3048\u308B
\u3053\u305F\u3064
\u3053\u3061\u3087\u3046
\u3053\u3063\u304B
\u3053\u3064\u3053\u3064
\u3053\u3064\u306F\u3099\u3093
\u3053\u3064\u3075\u3099
\u3053\u3066\u3044
\u3053\u3066\u3093
\u3053\u3068\u304B\u3099\u3089
\u3053\u3068\u3057
\u3053\u3068\u306F\u3099
\u3053\u3068\u308A
\u3053\u306A\u3053\u3099\u306A
\u3053\u306D\u3053\u306D
\u3053\u306E\u307E\u307E
\u3053\u306E\u307F
\u3053\u306E\u3088
\u3053\u3099\u306F\u3093
\u3053\u3072\u3064\u3057\u3099
\u3053\u3075\u3046
\u3053\u3075\u3093
\u3053\u307B\u3099\u308C\u308B
\u3053\u3099\u307E\u3042\u3075\u3099\u3089
\u3053\u307E\u304B\u3044
\u3053\u3099\u307E\u3059\u308A
\u3053\u307E\u3064\u306A
\u3053\u307E\u308B
\u3053\u3080\u304D\u3099\u3053
\u3053\u3082\u3057\u3099
\u3053\u3082\u3061
\u3053\u3082\u306E
\u3053\u3082\u3093
\u3053\u3084\u304F
\u3053\u3084\u307E
\u3053\u3086\u3046
\u3053\u3086\u3072\u3099
\u3053\u3088\u3044
\u3053\u3088\u3046
\u3053\u308A\u308B
\u3053\u308C\u304F\u3057\u3087\u3093
\u3053\u308D\u3063\u3051
\u3053\u308F\u3082\u3066
\u3053\u308F\u308C\u308B
\u3053\u3093\u3044\u3093
\u3053\u3093\u304B\u3044
\u3053\u3093\u304D
\u3053\u3093\u3057\u3085\u3046
\u3053\u3093\u3059\u3044
\u3053\u3093\u305F\u3099\u3066
\u3053\u3093\u3068\u3093
\u3053\u3093\u306A\u3093
\u3053\u3093\u3072\u3099\u306B
\u3053\u3093\u307B\u309A\u3093
\u3053\u3093\u307E\u3051
\u3053\u3093\u3084
\u3053\u3093\u308C\u3044
\u3053\u3093\u308F\u304F
\u3055\u3099\u3044\u3048\u304D
\u3055\u3044\u304B\u3044
\u3055\u3044\u304D\u3093
\u3055\u3099\u3044\u3051\u3099\u3093
\u3055\u3099\u3044\u3053
\u3055\u3044\u3057\u3087
\u3055\u3044\u305B\u3044
\u3055\u3099\u3044\u305F\u304F
\u3055\u3099\u3044\u3061\u3085\u3046
\u3055\u3044\u3066\u304D
\u3055\u3099\u3044\u308A\u3087\u3046
\u3055\u3046\u306A
\u3055\u304B\u3044\u3057
\u3055\u304B\u3099\u3059
\u3055\u304B\u306A
\u3055\u304B\u307F\u3061
\u3055\u304B\u3099\u308B
\u3055\u304D\u3099\u3087\u3046
\u3055\u304F\u3057
\u3055\u304F\u3072\u3093
\u3055\u304F\u3089
\u3055\u3053\u304F
\u3055\u3053\u3064
\u3055\u3059\u3099\u304B\u308B
\u3055\u3099\u305B\u304D
\u3055\u305F\u3093
\u3055\u3064\u3048\u3044
\u3055\u3099\u3064\u304A\u3093
\u3055\u3099\u3063\u304B
\u3055\u3099\u3064\u304B\u3099\u304F
\u3055\u3063\u304D\u3087\u304F
\u3055\u3099\u3063\u3057
\u3055\u3064\u3057\u3099\u3093
\u3055\u3099\u3063\u305D\u3046
\u3055\u3064\u305F\u306F\u3099
\u3055\u3064\u307E\u3044\u3082
\u3055\u3066\u3044
\u3055\u3068\u3044\u3082
\u3055\u3068\u3046
\u3055\u3068\u304A\u3084
\u3055\u3068\u3057
\u3055\u3068\u308B
\u3055\u306E\u3046
\u3055\u306F\u3099\u304F
\u3055\u3072\u3099\u3057\u3044
\u3055\u3078\u3099\u3064
\u3055\u307B\u3046
\u3055\u307B\u3068\u3099
\u3055\u307E\u3059
\u3055\u307F\u3057\u3044
\u3055\u307F\u305F\u3099\u308C
\u3055\u3080\u3051
\u3055\u3081\u308B
\u3055\u3084\u3048\u3093\u3068\u3099\u3046
\u3055\u3086\u3046
\u3055\u3088\u3046
\u3055\u3088\u304F
\u3055\u3089\u305F\u3099
\u3055\u3099\u308B\u305D\u306F\u3099
\u3055\u308F\u3084\u304B
\u3055\u308F\u308B
\u3055\u3093\u3044\u3093
\u3055\u3093\u304B
\u3055\u3093\u304D\u3083\u304F
\u3055\u3093\u3053\u3046
\u3055\u3093\u3055\u3044
\u3055\u3099\u3093\u3057\u3087
\u3055\u3093\u3059\u3046
\u3055\u3093\u305B\u3044
\u3055\u3093\u305D
\u3055\u3093\u3061
\u3055\u3093\u307E
\u3055\u3093\u307F
\u3055\u3093\u3089\u3093
\u3057\u3042\u3044
\u3057\u3042\u3051\u3099
\u3057\u3042\u3055\u3063\u3066
\u3057\u3042\u308F\u305B
\u3057\u3044\u304F
\u3057\u3044\u3093
\u3057\u3046\u3061
\u3057\u3048\u3044
\u3057\u304A\u3051
\u3057\u304B\u3044
\u3057\u304B\u304F
\u3057\u3099\u304B\u3093
\u3057\u3053\u3099\u3068
\u3057\u3059\u3046
\u3057\u3099\u305F\u3099\u3044
\u3057\u305F\u3046\u3051
\u3057\u305F\u304D\u3099
\u3057\u305F\u3066
\u3057\u305F\u307F
\u3057\u3061\u3087\u3046
\u3057\u3061\u308A\u3093
\u3057\u3063\u304B\u308A
\u3057\u3064\u3057\u3099
\u3057\u3064\u3082\u3093
\u3057\u3066\u3044
\u3057\u3066\u304D
\u3057\u3066\u3064
\u3057\u3099\u3066\u3093
\u3057\u3099\u3068\u3099\u3046
\u3057\u306A\u304D\u3099\u308C
\u3057\u306A\u3082\u306E
\u3057\u306A\u3093
\u3057\u306D\u307E
\u3057\u306D\u3093
\u3057\u306E\u304F\u3099
\u3057\u306E\u3075\u3099
\u3057\u306F\u3044
\u3057\u306F\u3099\u304B\u308A
\u3057\u306F\u3064
\u3057\u306F\u3089\u3044
\u3057\u306F\u3093
\u3057\u3072\u3087\u3046
\u3057\u3075\u304F
\u3057\u3099\u3075\u3099\u3093
\u3057\u3078\u3044
\u3057\u307B\u3046
\u3057\u307B\u3093
\u3057\u307E\u3046
\u3057\u307E\u308B
\u3057\u307F\u3093
\u3057\u3080\u3051\u308B
\u3057\u3099\u3080\u3057\u3087
\u3057\u3081\u3044
\u3057\u3081\u308B
\u3057\u3082\u3093
\u3057\u3083\u3044\u3093
\u3057\u3083\u3046\u3093
\u3057\u3083\u304A\u3093
\u3057\u3099\u3083\u304B\u3099\u3044\u3082
\u3057\u3084\u304F\u3057\u3087
\u3057\u3083\u304F\u307B\u3046
\u3057\u3083\u3051\u3093
\u3057\u3083\u3053
\u3057\u3083\u3055\u3099\u3044
\u3057\u3083\u3057\u3093
\u3057\u3083\u305B\u3093
\u3057\u3083\u305D\u3046
\u3057\u3083\u305F\u3044
\u3057\u3083\u3061\u3087\u3046
\u3057\u3083\u3063\u304D\u3093
\u3057\u3099\u3083\u307E
\u3057\u3083\u308A\u3093
\u3057\u3083\u308C\u3044
\u3057\u3099\u3086\u3046
\u3057\u3099\u3085\u3046\u3057\u3087
\u3057\u3085\u304F\u306F\u304F
\u3057\u3099\u3085\u3057\u3093
\u3057\u3085\u3063\u305B\u304D
\u3057\u3085\u307F
\u3057\u3085\u3089\u306F\u3099
\u3057\u3099\u3085\u3093\u306F\u3099\u3093
\u3057\u3087\u3046\u304B\u3044
\u3057\u3087\u304F\u305F\u304F
\u3057\u3087\u3063\u3051\u3093
\u3057\u3087\u3068\u3099\u3046
\u3057\u3087\u3082\u3064
\u3057\u3089\u305B\u308B
\u3057\u3089\u3078\u3099\u308B
\u3057\u3093\u304B
\u3057\u3093\u3053\u3046
\u3057\u3099\u3093\u3057\u3099\u3083
\u3057\u3093\u305B\u3044\u3057\u3099
\u3057\u3093\u3061\u304F
\u3057\u3093\u308A\u3093
\u3059\u3042\u3051\u3099
\u3059\u3042\u3057
\u3059\u3042\u306A
\u3059\u3099\u3042\u3093
\u3059\u3044\u3048\u3044
\u3059\u3044\u304B
\u3059\u3044\u3068\u3046
\u3059\u3099\u3044\u3075\u3099\u3093
\u3059\u3044\u3088\u3046\u3072\u3099
\u3059\u3046\u304B\u3099\u304F
\u3059\u3046\u3057\u3099\u3064
\u3059\u3046\u305B\u3093
\u3059\u304A\u3068\u3099\u308A
\u3059\u304D\u307E
\u3059\u304F\u3046
\u3059\u304F\u306A\u3044
\u3059\u3051\u308B
\u3059\u3053\u3099\u3044
\u3059\u3053\u3057
\u3059\u3099\u3055\u3093
\u3059\u3059\u3099\u3057\u3044
\u3059\u3059\u3080
\u3059\u3059\u3081\u308B
\u3059\u3063\u304B\u308A
\u3059\u3099\u3063\u3057\u308A
\u3059\u3099\u3063\u3068
\u3059\u3066\u304D
\u3059\u3066\u308B
\u3059\u306D\u308B
\u3059\u306E\u3053
\u3059\u306F\u305F\u3099
\u3059\u306F\u3099\u3089\u3057\u3044
\u3059\u3099\u3072\u3087\u3046
\u3059\u3099\u3075\u3099\u306C\u308C
\u3059\u3075\u3099\u308A
\u3059\u3075\u308C
\u3059\u3078\u3099\u3066
\u3059\u3078\u3099\u308B
\u3059\u3099\u307B\u3046
\u3059\u307B\u3099\u3093
\u3059\u307E\u3044
\u3059\u3081\u3057
\u3059\u3082\u3046
\u3059\u3084\u304D
\u3059\u3089\u3059\u3089
\u3059\u308B\u3081
\u3059\u308C\u3061\u304B\u3099\u3046
\u3059\u308D\u3063\u3068
\u3059\u308F\u308B
\u3059\u3093\u305B\u3099\u3093
\u3059\u3093\u307B\u309A\u3046
\u305B\u3042\u3075\u3099\u3089
\u305B\u3044\u304B\u3064
\u305B\u3044\u3051\u3099\u3093
\u305B\u3044\u3057\u3099
\u305B\u3044\u3088\u3046
\u305B\u304A\u3046
\u305B\u304B\u3044\u304B\u3093
\u305B\u304D\u306B\u3093
\u305B\u304D\u3080
\u305B\u304D\u3086
\u305B\u304D\u3089\u3093\u3046\u3093
\u305B\u3051\u3093
\u305B\u3053\u3046
\u305B\u3059\u3057\u3099
\u305B\u305F\u3044
\u305B\u305F\u3051
\u305B\u3063\u304B\u304F
\u305B\u3063\u304D\u3083\u304F
\u305B\u3099\u3063\u304F
\u305B\u3063\u3051\u3093
\u305B\u3063\u3053\u3064
\u305B\u3063\u3055\u305F\u304F\u307E
\u305B\u3064\u305D\u3099\u304F
\u305B\u3064\u305F\u3099\u3093
\u305B\u3064\u3066\u3099\u3093
\u305B\u3063\u306F\u309A\u3093
\u305B\u3064\u3072\u3099
\u305B\u3064\u3075\u3099\u3093
\u305B\u3064\u3081\u3044
\u305B\u3064\u308A\u3064
\u305B\u306A\u304B
\u305B\u306E\u3072\u3099
\u305B\u306F\u306F\u3099
\u305B\u3072\u3099\u308D
\u305B\u307B\u3099\u306D
\u305B\u307E\u3044
\u305B\u307E\u308B
\u305B\u3081\u308B
\u305B\u3082\u305F\u308C
\u305B\u308A\u3075
\u305B\u3099\u3093\u3042\u304F
\u305B\u3093\u3044
\u305B\u3093\u3048\u3044
\u305B\u3093\u304B
\u305B\u3093\u304D\u3087
\u305B\u3093\u304F
\u305B\u3093\u3051\u3099\u3093
\u305B\u3099\u3093\u3053\u3099
\u305B\u3093\u3055\u3044
\u305B\u3093\u3057\u3085
\u305B\u3093\u3059\u3044
\u305B\u3093\u305B\u3044
\u305B\u3093\u305D\u3099
\u305B\u3093\u305F\u304F
\u305B\u3093\u3061\u3087\u3046
\u305B\u3093\u3066\u3044
\u305B\u3093\u3068\u3046
\u305B\u3093\u306C\u304D
\u305B\u3093\u306D\u3093
\u305B\u3093\u306F\u309A\u3044
\u305B\u3099\u3093\u3075\u3099
\u305B\u3099\u3093\u307B\u309A\u3046
\u305B\u3093\u3080
\u305B\u3093\u3081\u3093\u3057\u3099\u3087
\u305B\u3093\u3082\u3093
\u305B\u3093\u3084\u304F
\u305B\u3093\u3086\u3046
\u305B\u3093\u3088\u3046
\u305B\u3099\u3093\u3089
\u305B\u3099\u3093\u308A\u3083\u304F
\u305B\u3093\u308C\u3044
\u305B\u3093\u308D
\u305D\u3042\u304F
\u305D\u3044\u3068\u3051\u3099\u308B
\u305D\u3044\u306D
\u305D\u3046\u304B\u3099\u3093\u304D\u3087\u3046
\u305D\u3046\u304D
\u305D\u3046\u3053\u3099
\u305D\u3046\u3057\u3093
\u305D\u3046\u305F\u3099\u3093
\u305D\u3046\u306A\u3093
\u305D\u3046\u3072\u3099
\u305D\u3046\u3081\u3093
\u305D\u3046\u308A
\u305D\u3048\u3082\u306E
\u305D\u3048\u3093
\u305D\u304B\u3099\u3044
\u305D\u3051\u3099\u304D
\u305D\u3053\u3046
\u305D\u3053\u305D\u3053
\u305D\u3055\u3099\u3044
\u305D\u3057\u306A
\u305D\u305B\u3044
\u305D\u305B\u3093
\u305D\u305D\u304F\u3099
\u305D\u305F\u3099\u3066\u308B
\u305D\u3064\u3046
\u305D\u3064\u3048\u3093
\u305D\u3063\u304B\u3093
\u305D\u3064\u304D\u3099\u3087\u3046
\u305D\u3063\u3051\u3064
\u305D\u3063\u3053\u3046
\u305D\u3063\u305B\u3093
\u305D\u3063\u3068
\u305D\u3068\u304B\u3099\u308F
\u305D\u3068\u3064\u3099\u3089
\u305D\u306A\u3048\u308B
\u305D\u306A\u305F
\u305D\u3075\u307B\u3099
\u305D\u307B\u3099\u304F
\u305D\u307B\u3099\u308D
\u305D\u307E\u3064
\u305D\u307E\u308B
\u305D\u3080\u304F
\u305D\u3080\u308A\u3048
\u305D\u3081\u308B
\u305D\u3082\u305D\u3082
\u305D\u3088\u304B\u305B\u3099
\u305D\u3089\u307E\u3081
\u305D\u308D\u3046
\u305D\u3093\u304B\u3044
\u305D\u3093\u3051\u3044
\u305D\u3093\u3055\u3099\u3044
\u305D\u3093\u3057\u3064
\u305D\u3093\u305D\u3099\u304F
\u305D\u3093\u3061\u3087\u3046
\u305D\u3099\u3093\u3072\u3099
\u305D\u3099\u3093\u3075\u3099\u3093
\u305D\u3093\u307F\u3093
\u305F\u3042\u3044
\u305F\u3044\u3044\u3093
\u305F\u3044\u3046\u3093
\u305F\u3044\u3048\u304D
\u305F\u3044\u304A\u3046
\u305F\u3099\u3044\u304B\u3099\u304F
\u305F\u3044\u304D
\u305F\u3044\u304F\u3099\u3046
\u305F\u3044\u3051\u3093
\u305F\u3044\u3053
\u305F\u3044\u3055\u3099\u3044
\u305F\u3099\u3044\u3057\u3099\u3087\u3046\u3075\u3099
\u305F\u3099\u3044\u3059\u304D
\u305F\u3044\u305B\u3064
\u305F\u3044\u305D\u3046
\u305F\u3099\u3044\u305F\u3044
\u305F\u3044\u3061\u3087\u3046
\u305F\u3044\u3066\u3044
\u305F\u3099\u3044\u3068\u3099\u3053\u308D
\u305F\u3044\u306A\u3044
\u305F\u3044\u306D\u3064
\u305F\u3044\u306E\u3046
\u305F\u3044\u306F\u3093
\u305F\u3099\u3044\u3072\u3087\u3046
\u305F\u3044\u3075\u3046
\u305F\u3044\u3078\u3093
\u305F\u3044\u307B
\u305F\u3044\u307E\u3064\u306F\u3099\u306A
\u305F\u3044\u307F\u3093\u304F\u3099
\u305F\u3044\u3080
\u305F\u3044\u3081\u3093
\u305F\u3044\u3084\u304D
\u305F\u3044\u3088\u3046
\u305F\u3044\u3089
\u305F\u3044\u308A\u3087\u304F
\u305F\u3044\u308B
\u305F\u3044\u308F\u3093
\u305F\u3046\u3048
\u305F\u3048\u308B
\u305F\u304A\u3059
\u305F\u304A\u308B
\u305F\u304A\u308C\u308B
\u305F\u304B\u3044
\u305F\u304B\u306D
\u305F\u304D\u3072\u3099
\u305F\u304F\u3055\u3093
\u305F\u3053\u304F
\u305F\u3053\u3084\u304D
\u305F\u3055\u3044
\u305F\u3057\u3055\u3099\u3093
\u305F\u3099\u3057\u3099\u3083\u308C
\u305F\u3059\u3051\u308B
\u305F\u3059\u3099\u3055\u308F\u308B
\u305F\u305D\u304B\u3099\u308C
\u305F\u305F\u304B\u3046
\u305F\u305F\u304F
\u305F\u305F\u3099\u3057\u3044
\u305F\u305F\u307F
\u305F\u3061\u306F\u3099\u306A
\u305F\u3099\u3063\u304B\u3044
\u305F\u3099\u3063\u304D\u3083\u304F
\u305F\u3099\u3063\u3053
\u305F\u3099\u3063\u3057\u3085\u3064
\u305F\u3099\u3063\u305F\u3044
\u305F\u3066\u308B
\u305F\u3068\u3048\u308B
\u305F\u306A\u306F\u3099\u305F
\u305F\u306B\u3093
\u305F\u306C\u304D
\u305F\u306E\u3057\u307F
\u305F\u306F\u3064
\u305F\u3075\u3099\u3093
\u305F\u3078\u3099\u308B
\u305F\u307B\u3099\u3046
\u305F\u307E\u3053\u3099
\u305F\u307E\u308B
\u305F\u3099\u3080\u308B
\u305F\u3081\u3044\u304D
\u305F\u3081\u3059
\u305F\u3081\u308B
\u305F\u3082\u3064
\u305F\u3084\u3059\u3044
\u305F\u3088\u308B
\u305F\u3089\u3059
\u305F\u308A\u304D\u307B\u3093\u304B\u3099\u3093
\u305F\u308A\u3087\u3046
\u305F\u308A\u308B
\u305F\u308B\u3068
\u305F\u308C\u308B
\u305F\u308C\u3093\u3068
\u305F\u308D\u3063\u3068
\u305F\u308F\u3080\u308C\u308B
\u305F\u3099\u3093\u3042\u3064
\u305F\u3093\u3044
\u305F\u3093\u304A\u3093
\u305F\u3093\u304B
\u305F\u3093\u304D
\u305F\u3093\u3051\u3093
\u305F\u3093\u3053\u3099
\u305F\u3093\u3055\u3093
\u305F\u3093\u3057\u3099\u3087\u3046\u3072\u3099
\u305F\u3099\u3093\u305B\u3044
\u305F\u3093\u305D\u304F
\u305F\u3093\u305F\u3044
\u305F\u3099\u3093\u3061
\u305F\u3093\u3066\u3044
\u305F\u3093\u3068\u3046
\u305F\u3099\u3093\u306A
\u305F\u3093\u306B\u3093
\u305F\u3099\u3093\u306D\u3064
\u305F\u3093\u306E\u3046
\u305F\u3093\u3072\u309A\u3093
\u305F\u3099\u3093\u307B\u3099\u3046
\u305F\u3093\u307E\u3064
\u305F\u3093\u3081\u3044
\u305F\u3099\u3093\u308C\u3064
\u305F\u3099\u3093\u308D
\u305F\u3099\u3093\u308F
\u3061\u3042\u3044
\u3061\u3042\u3093
\u3061\u3044\u304D
\u3061\u3044\u3055\u3044
\u3061\u3048\u3093
\u3061\u304B\u3044
\u3061\u304B\u3089
\u3061\u304D\u3085\u3046
\u3061\u304D\u3093
\u3061\u3051\u3044\u3059\u3099
\u3061\u3051\u3093
\u3061\u3053\u304F
\u3061\u3055\u3044
\u3061\u3057\u304D
\u3061\u3057\u308A\u3087\u3046
\u3061\u305B\u3044
\u3061\u305D\u3046
\u3061\u305F\u3044
\u3061\u305F\u3093
\u3061\u3061\u304A\u3084
\u3061\u3064\u3057\u3099\u3087
\u3061\u3066\u304D
\u3061\u3066\u3093
\u3061\u306C\u304D
\u3061\u306C\u308A
\u3061\u306E\u3046
\u3061\u3072\u3087\u3046
\u3061\u3078\u3044\u305B\u3093
\u3061\u307B\u3046
\u3061\u307E\u305F
\u3061\u307F\u3064
\u3061\u307F\u3068\u3099\u308D
\u3061\u3081\u3044\u3068\u3099
\u3061\u3083\u3093\u3053\u306A\u3078\u3099
\u3061\u3085\u3046\u3044
\u3061\u3086\u308A\u3087\u304F
\u3061\u3087\u3046\u3057
\u3061\u3087\u3055\u304F\u3051\u3093
\u3061\u3089\u3057
\u3061\u3089\u307F
\u3061\u308A\u304B\u3099\u307F
\u3061\u308A\u3087\u3046
\u3061\u308B\u3068\u3099
\u3061\u308F\u308F
\u3061\u3093\u305F\u3044
\u3061\u3093\u3082\u304F
\u3064\u3044\u304B
\u3064\u3044\u305F\u3061
\u3064\u3046\u304B
\u3064\u3046\u3057\u3099\u3087\u3046
\u3064\u3046\u306F\u3093
\u3064\u3046\u308F
\u3064\u304B\u3046
\u3064\u304B\u308C\u308B
\u3064\u304F\u306D
\u3064\u304F\u308B
\u3064\u3051\u306D
\u3064\u3051\u308B
\u3064\u3053\u3099\u3046
\u3064\u305F\u3048\u308B
\u3064\u3064\u3099\u304F
\u3064\u3064\u3057\u3099
\u3064\u3064\u3080
\u3064\u3068\u3081\u308B
\u3064\u306A\u304B\u3099\u308B
\u3064\u306A\u307F
\u3064\u306D\u3064\u3099\u306D
\u3064\u306E\u308B
\u3064\u3075\u3099\u3059
\u3064\u307E\u3089\u306A\u3044
\u3064\u307E\u308B
\u3064\u307F\u304D
\u3064\u3081\u305F\u3044
\u3064\u3082\u308A
\u3064\u3082\u308B
\u3064\u3088\u3044
\u3064\u308B\u307B\u3099
\u3064\u308B\u307F\u304F
\u3064\u308F\u3082\u306E
\u3064\u308F\u308A
\u3066\u3042\u3057
\u3066\u3042\u3066
\u3066\u3042\u307F
\u3066\u3044\u304A\u3093
\u3066\u3044\u304B
\u3066\u3044\u304D
\u3066\u3044\u3051\u3044
\u3066\u3044\u3053\u304F
\u3066\u3044\u3055\u3064
\u3066\u3044\u3057
\u3066\u3044\u305B\u3044
\u3066\u3044\u305F\u3044
\u3066\u3044\u3068\u3099
\u3066\u3044\u306D\u3044
\u3066\u3044\u3072\u3087\u3046
\u3066\u3044\u3078\u3093
\u3066\u3044\u307B\u3099\u3046
\u3066\u3046\u3061
\u3066\u304A\u304F\u308C
\u3066\u304D\u3068\u3046
\u3066\u304F\u3072\u3099
\u3066\u3099\u3053\u307B\u3099\u3053
\u3066\u3055\u304D\u3099\u3087\u3046
\u3066\u3055\u3051\u3099
\u3066\u3059\u308A
\u3066\u305D\u3046
\u3066\u3061\u304B\u3099\u3044
\u3066\u3061\u3087\u3046
\u3066\u3064\u304B\u3099\u304F
\u3066\u3064\u3064\u3099\u304D
\u3066\u3099\u3063\u306F\u309A
\u3066\u3064\u307B\u3099\u3046
\u3066\u3064\u3084
\u3066\u3099\u306C\u304B\u3048
\u3066\u306C\u304D
\u3066\u306C\u304F\u3099\u3044
\u3066\u306E\u3072\u3089
\u3066\u306F\u3044
\u3066\u3075\u3099\u304F\u308D
\u3066\u3075\u305F\u3099
\u3066\u307B\u3068\u3099\u304D
\u3066\u307B\u3093
\u3066\u307E\u3048
\u3066\u307E\u304D\u3059\u3099\u3057
\u3066\u307F\u3057\u3099\u304B
\u3066\u307F\u3084\u3051\u3099
\u3066\u3089\u3059
\u3066\u308C\u3072\u3099
\u3066\u308F\u3051
\u3066\u308F\u305F\u3057
\u3066\u3099\u3093\u3042\u3064
\u3066\u3093\u3044\u3093
\u3066\u3093\u304B\u3044
\u3066\u3093\u304D
\u3066\u3093\u304F\u3099
\u3066\u3093\u3051\u3093
\u3066\u3093\u3053\u3099\u304F
\u3066\u3093\u3055\u3044
\u3066\u3093\u3057
\u3066\u3093\u3059\u3046
\u3066\u3099\u3093\u3061
\u3066\u3093\u3066\u304D
\u3066\u3093\u3068\u3046
\u3066\u3093\u306A\u3044
\u3066\u3093\u3075\u309A\u3089
\u3066\u3093\u307B\u3099\u3046\u305F\u3099\u3044
\u3066\u3093\u3081\u3064
\u3066\u3093\u3089\u3093\u304B\u3044
\u3066\u3099\u3093\u308A\u3087\u304F
\u3066\u3099\u3093\u308F
\u3068\u3099\u3042\u3044
\u3068\u3044\u308C
\u3068\u3099\u3046\u304B\u3093
\u3068\u3046\u304D\u3085\u3046
\u3068\u3099\u3046\u304F\u3099
\u3068\u3046\u3057
\u3068\u3046\u3080\u304D\u3099
\u3068\u304A\u3044
\u3068\u304A\u304B
\u3068\u304A\u304F
\u3068\u304A\u3059
\u3068\u304A\u308B
\u3068\u304B\u3044
\u3068\u304B\u3059
\u3068\u304D\u304A\u308A
\u3068\u304D\u3068\u3099\u304D
\u3068\u304F\u3044
\u3068\u304F\u3057\u3085\u3046
\u3068\u304F\u3066\u3093
\u3068\u304F\u306B
\u3068\u304F\u3078\u3099\u3064
\u3068\u3051\u3044
\u3068\u3051\u308B
\u3068\u3053\u3084
\u3068\u3055\u304B
\u3068\u3057\u3087\u304B\u3093
\u3068\u305D\u3046
\u3068\u305F\u3093
\u3068\u3061\u3085\u3046
\u3068\u3063\u304D\u3085\u3046
\u3068\u3063\u304F\u3093
\u3068\u3064\u305B\u3099\u3093
\u3068\u3064\u306B\u3085\u3046
\u3068\u3068\u3099\u3051\u308B
\u3068\u3068\u306E\u3048\u308B
\u3068\u306A\u3044
\u3068\u306A\u3048\u308B
\u3068\u306A\u308A
\u3068\u306E\u3055\u307E
\u3068\u306F\u3099\u3059
\u3068\u3099\u3075\u3099\u304B\u3099\u308F
\u3068\u307B\u3046
\u3068\u307E\u308B
\u3068\u3081\u308B
\u3068\u3082\u305F\u3099\u3061
\u3068\u3082\u308B
\u3068\u3099\u3088\u3046\u3072\u3099
\u3068\u3089\u3048\u308B
\u3068\u3093\u304B\u3064
\u3068\u3099\u3093\u3075\u3099\u308A
\u306A\u3044\u304B\u304F
\u306A\u3044\u3053\u3046
\u306A\u3044\u3057\u3087
\u306A\u3044\u3059
\u306A\u3044\u305B\u3093
\u306A\u3044\u305D\u3046
\u306A\u304A\u3059
\u306A\u304B\u3099\u3044
\u306A\u304F\u3059
\u306A\u3051\u3099\u308B
\u306A\u3053\u3046\u3068\u3099
\u306A\u3055\u3051
\u306A\u305F\u3066\u3099\u3053\u3053
\u306A\u3063\u3068\u3046
\u306A\u3064\u3084\u3059\u307F
\u306A\u306A\u304A\u3057
\u306A\u306B\u3053\u3099\u3068
\u306A\u306B\u3082\u306E
\u306A\u306B\u308F
\u306A\u306E\u304B
\u306A\u3075\u305F\u3099
\u306A\u307E\u3044\u304D
\u306A\u307E\u3048
\u306A\u307E\u307F
\u306A\u307F\u305F\u3099
\u306A\u3081\u3089\u304B
\u306A\u3081\u308B
\u306A\u3084\u3080
\u306A\u3089\u3046
\u306A\u3089\u3072\u3099
\u306A\u3089\u3075\u3099
\u306A\u308C\u308B
\u306A\u308F\u3068\u3072\u3099
\u306A\u308F\u306F\u3099\u308A
\u306B\u3042\u3046
\u306B\u3044\u304B\u3099\u305F
\u306B\u3046\u3051
\u306B\u304A\u3044
\u306B\u304B\u3044
\u306B\u304B\u3099\u3066
\u306B\u304D\u3072\u3099
\u306B\u304F\u3057\u307F
\u306B\u304F\u307E\u3093
\u306B\u3051\u3099\u308B
\u306B\u3055\u3093\u304B\u305F\u3093\u305D
\u306B\u3057\u304D
\u306B\u305B\u3082\u306E
\u306B\u3061\u3057\u3099\u3087\u3046
\u306B\u3061\u3088\u3046\u3072\u3099
\u306B\u3063\u304B
\u306B\u3063\u304D
\u306B\u3063\u3051\u3044
\u306B\u3063\u3053\u3046
\u306B\u3063\u3055\u3093
\u306B\u3063\u3057\u3087\u304F
\u306B\u3063\u3059\u3046
\u306B\u3063\u305B\u304D
\u306B\u3063\u3066\u3044
\u306B\u306A\u3046
\u306B\u307B\u3093
\u306B\u307E\u3081
\u306B\u3082\u3064
\u306B\u3084\u308A
\u306B\u3085\u3046\u3044\u3093
\u306B\u308A\u3093\u3057\u3083
\u306B\u308F\u3068\u308A
\u306B\u3093\u3044
\u306B\u3093\u304B
\u306B\u3093\u304D
\u306B\u3093\u3051\u3099\u3093
\u306B\u3093\u3057\u304D
\u306B\u3093\u3059\u3099\u3046
\u306B\u3093\u305D\u3046
\u306B\u3093\u305F\u3044
\u306B\u3093\u3061
\u306B\u3093\u3066\u3044
\u306B\u3093\u306B\u304F
\u306B\u3093\u3075\u309A
\u306B\u3093\u307E\u308A
\u306B\u3093\u3080
\u306B\u3093\u3081\u3044
\u306B\u3093\u3088\u3046
\u306C\u3044\u304F\u304D\u3099
\u306C\u304B\u3059
\u306C\u304F\u3099\u3044\u3068\u308B
\u306C\u304F\u3099\u3046
\u306C\u304F\u3082\u308A
\u306C\u3059\u3080
\u306C\u307E\u3048\u3072\u3099
\u306C\u3081\u308A
\u306C\u3089\u3059
\u306C\u3093\u3061\u3083\u304F
\u306D\u3042\u3051\u3099
\u306D\u3044\u304D
\u306D\u3044\u308B
\u306D\u3044\u308D
\u306D\u304F\u3099\u305B
\u306D\u304F\u305F\u3044
\u306D\u304F\u3089
\u306D\u3053\u305B\u3099
\u306D\u3053\u3080
\u306D\u3055\u3051\u3099
\u306D\u3059\u3053\u3099\u3059
\u306D\u305D\u3078\u3099\u308B
\u306D\u305F\u3099\u3093
\u306D\u3064\u3044
\u306D\u3063\u3057\u3093
\u306D\u3064\u305D\u3099\u3046
\u306D\u3063\u305F\u3044\u304D\u3099\u3087
\u306D\u3075\u3099\u305D\u304F
\u306D\u3075\u305F\u3099
\u306D\u307B\u3099\u3046
\u306D\u307B\u308A\u306F\u307B\u308A
\u306D\u307E\u304D
\u306D\u307E\u308F\u3057
\u306D\u307F\u307F
\u306D\u3080\u3044
\u306D\u3080\u305F\u3044
\u306D\u3082\u3068
\u306D\u3089\u3046
\u306D\u308F\u3055\u3099
\u306D\u3093\u3044\u308A
\u306D\u3093\u304A\u3057
\u306D\u3093\u304B\u3093
\u306D\u3093\u304D\u3093
\u306D\u3093\u304F\u3099
\u306D\u3093\u3055\u3099
\u306D\u3093\u3057
\u306D\u3093\u3061\u3083\u304F
\u306D\u3093\u3068\u3099
\u306D\u3093\u3072\u309A
\u306D\u3093\u3075\u3099\u3064
\u306D\u3093\u307E\u3064
\u306D\u3093\u308A\u3087\u3046
\u306D\u3093\u308C\u3044
\u306E\u3044\u3059\u3099
\u306E\u304A\u3064\u3099\u307E
\u306E\u304B\u3099\u3059
\u306E\u304D\u306A\u307F
\u306E\u3053\u304D\u3099\u308A
\u306E\u3053\u3059
\u306E\u3053\u308B
\u306E\u305B\u308B
\u306E\u305D\u3099\u304F
\u306E\u305D\u3099\u3080
\u306E\u305F\u307E\u3046
\u306E\u3061\u307B\u3068\u3099
\u306E\u3063\u304F
\u306E\u306F\u3099\u3059
\u306E\u306F\u3089
\u306E\u3078\u3099\u308B
\u306E\u307B\u3099\u308B
\u306E\u307F\u3082\u306E
\u306E\u3084\u307E
\u306E\u3089\u3044\u306C
\u306E\u3089\u306D\u3053
\u306E\u308A\u3082\u306E
\u306E\u308A\u3086\u304D
\u306E\u308C\u3093
\u306E\u3093\u304D
\u306F\u3099\u3042\u3044
\u306F\u3042\u304F
\u306F\u3099\u3042\u3055\u3093
\u306F\u3099\u3044\u304B
\u306F\u3099\u3044\u304F
\u306F\u3044\u3051\u3093
\u306F\u3044\u3053\u3099
\u306F\u3044\u3057\u3093
\u306F\u3044\u3059\u3044
\u306F\u3044\u305B\u3093
\u306F\u3044\u305D\u3046
\u306F\u3044\u3061
\u306F\u3099\u3044\u306F\u3099\u3044
\u306F\u3044\u308C\u3064
\u306F\u3048\u308B
\u306F\u304A\u308B
\u306F\u304B\u3044
\u306F\u3099\u304B\u308A
\u306F\u304B\u308B
\u306F\u304F\u3057\u3085
\u306F\u3051\u3093
\u306F\u3053\u3075\u3099
\u306F\u3055\u307F
\u306F\u3055\u3093
\u306F\u3057\u3053\u3099
\u306F\u3099\u3057\u3087
\u306F\u3057\u308B
\u306F\u305B\u308B
\u306F\u309A\u305D\u3053\u3093
\u306F\u305D\u3093
\u306F\u305F\u3093
\u306F\u3061\u307F\u3064
\u306F\u3064\u304A\u3093
\u306F\u3063\u304B\u304F
\u306F\u3064\u3099\u304D
\u306F\u3063\u304D\u308A
\u306F\u3063\u304F\u3064
\u306F\u3063\u3051\u3093
\u306F\u3063\u3053\u3046
\u306F\u3063\u3055\u3093
\u306F\u3063\u3057\u3093
\u306F\u3063\u305F\u3064
\u306F\u3063\u3061\u3085\u3046
\u306F\u3063\u3066\u3093
\u306F\u3063\u3072\u309A\u3087\u3046
\u306F\u3063\u307B\u309A\u3046
\u306F\u306A\u3059
\u306F\u306A\u3072\u3099
\u306F\u306B\u304B\u3080
\u306F\u3075\u3099\u3089\u3057
\u306F\u307F\u304B\u3099\u304D
\u306F\u3080\u304B\u3046
\u306F\u3081\u3064
\u306F\u3084\u3044
\u306F\u3084\u3057
\u306F\u3089\u3046
\u306F\u308D\u3046\u3043\u3093
\u306F\u308F\u3044
\u306F\u3093\u3044
\u306F\u3093\u3048\u3044
\u306F\u3093\u304A\u3093
\u306F\u3093\u304B\u304F
\u306F\u3093\u304D\u3087\u3046
\u306F\u3099\u3093\u304F\u3099\u307F
\u306F\u3093\u3053
\u306F\u3093\u3057\u3083
\u306F\u3093\u3059\u3046
\u306F\u3093\u305F\u3099\u3093
\u306F\u309A\u3093\u3061
\u306F\u309A\u3093\u3064
\u306F\u3093\u3066\u3044
\u306F\u3093\u3068\u3057
\u306F\u3093\u306E\u3046
\u306F\u3093\u306F\u309A
\u306F\u3093\u3075\u3099\u3093
\u306F\u3093\u3078\u309A\u3093
\u306F\u3093\u307B\u3099\u3046\u304D
\u306F\u3093\u3081\u3044
\u306F\u3093\u3089\u3093
\u306F\u3093\u308D\u3093
\u3072\u3044\u304D
\u3072\u3046\u3093
\u3072\u3048\u308B
\u3072\u304B\u304F
\u3072\u304B\u308A
\u3072\u304B\u308B
\u3072\u304B\u3093
\u3072\u304F\u3044
\u3072\u3051\u3064
\u3072\u3053\u3046\u304D
\u3072\u3053\u304F
\u3072\u3055\u3044
\u3072\u3055\u3057\u3075\u3099\u308A
\u3072\u3055\u3093
\u3072\u3099\u3057\u3099\u3085\u3064\u304B\u3093
\u3072\u3057\u3087
\u3072\u305D\u304B
\u3072\u305D\u3080
\u3072\u305F\u3080\u304D
\u3072\u305F\u3099\u308A
\u3072\u305F\u308B
\u3072\u3064\u304D\u3099
\u3072\u3063\u3053\u3057
\u3072\u3063\u3057
\u3072\u3064\u3057\u3099\u3085\u3072\u3093
\u3072\u3063\u3059
\u3072\u3064\u305B\u3099\u3093
\u3072\u309A\u3063\u305F\u308A
\u3072\u309A\u3063\u3061\u308A
\u3072\u3064\u3088\u3046
\u3072\u3066\u3044
\u3072\u3068\u3053\u3099\u307F
\u3072\u306A\u307E\u3064\u308A
\u3072\u306A\u3093
\u3072\u306D\u308B
\u3072\u306F\u3093
\u3072\u3072\u3099\u304F
\u3072\u3072\u3087\u3046
\u3072\u307B\u3046
\u3072\u307E\u308F\u308A
\u3072\u307E\u3093
\u3072\u307F\u3064
\u3072\u3081\u3044
\u3072\u3081\u3057\u3099\u3057
\u3072\u3084\u3051
\u3072\u3084\u3059
\u3072\u3088\u3046
\u3072\u3099\u3087\u3046\u304D
\u3072\u3089\u304B\u3099\u306A
\u3072\u3089\u304F
\u3072\u308A\u3064
\u3072\u308A\u3087\u3046
\u3072\u308B\u307E
\u3072\u308B\u3084\u3059\u307F
\u3072\u308C\u3044
\u3072\u308D\u3044
\u3072\u308D\u3046
\u3072\u308D\u304D
\u3072\u308D\u3086\u304D
\u3072\u3093\u304B\u304F
\u3072\u3093\u3051\u3064
\u3072\u3093\u3053\u3093
\u3072\u3093\u3057\u3085
\u3072\u3093\u305D\u3046
\u3072\u309A\u3093\u3061
\u3072\u3093\u306F\u309A\u3093
\u3072\u3099\u3093\u307B\u3099\u3046
\u3075\u3042\u3093
\u3075\u3044\u3046\u3061
\u3075\u3046\u3051\u3044
\u3075\u3046\u305B\u3093
\u3075\u309A\u3046\u305F\u308D\u3046
\u3075\u3046\u3068\u3046
\u3075\u3046\u3075
\u3075\u3048\u308B
\u3075\u304A\u3093
\u3075\u304B\u3044
\u3075\u304D\u3093
\u3075\u304F\u3055\u3099\u3064
\u3075\u304F\u3075\u3099\u304F\u308D
\u3075\u3053\u3046
\u3075\u3055\u3044
\u3075\u3057\u304D\u3099
\u3075\u3057\u3099\u307F
\u3075\u3059\u307E
\u3075\u305B\u3044
\u3075\u305B\u304F\u3099
\u3075\u305D\u304F
\u3075\u3099\u305F\u306B\u304F
\u3075\u305F\u3093
\u3075\u3061\u3087\u3046
\u3075\u3064\u3046
\u3075\u3064\u304B
\u3075\u3063\u304B\u3064
\u3075\u3063\u304D
\u3075\u3063\u3053\u304F
\u3075\u3099\u3068\u3099\u3046
\u3075\u3068\u308B
\u3075\u3068\u3093
\u3075\u306E\u3046
\u3075\u306F\u3044
\u3075\u3072\u3087\u3046
\u3075\u3078\u3093
\u3075\u307E\u3093
\u3075\u307F\u3093
\u3075\u3081\u3064
\u3075\u3081\u3093
\u3075\u3088\u3046
\u3075\u308A\u3053
\u3075\u308A\u308B
\u3075\u308B\u3044
\u3075\u3093\u3044\u304D
\u3075\u3099\u3093\u304B\u3099\u304F
\u3075\u3099\u3093\u304F\u3099
\u3075\u3093\u3057\u3064
\u3075\u3099\u3093\u305B\u304D
\u3075\u3093\u305D\u3046
\u3075\u3099\u3093\u307B\u309A\u3046
\u3078\u3044\u3042\u3093
\u3078\u3044\u304A\u3093
\u3078\u3044\u304B\u3099\u3044
\u3078\u3044\u304D
\u3078\u3044\u3051\u3099\u3093
\u3078\u3044\u3053\u3046
\u3078\u3044\u3055
\u3078\u3044\u3057\u3083
\u3078\u3044\u305B\u3064
\u3078\u3044\u305D
\u3078\u3044\u305F\u304F
\u3078\u3044\u3066\u3093
\u3078\u3044\u306D\u3064
\u3078\u3044\u308F
\u3078\u304D\u304B\u3099
\u3078\u3053\u3080
\u3078\u3099\u306B\u3044\u308D
\u3078\u3099\u306B\u3057\u3087\u3046\u304B\u3099
\u3078\u3089\u3059
\u3078\u3093\u304B\u3093
\u3078\u3099\u3093\u304D\u3087\u3046
\u3078\u3099\u3093\u3053\u3099\u3057
\u3078\u3093\u3055\u3044
\u3078\u3093\u305F\u3044
\u3078\u3099\u3093\u308A
\u307B\u3042\u3093
\u307B\u3044\u304F
\u307B\u3099\u3046\u304D\u3099\u3087
\u307B\u3046\u3053\u304F
\u307B\u3046\u305D\u3046
\u307B\u3046\u307B\u3046
\u307B\u3046\u3082\u3093
\u307B\u3046\u308A\u3064
\u307B\u3048\u308B
\u307B\u304A\u3093
\u307B\u304B\u3093
\u307B\u304D\u3087\u3046
\u307B\u3099\u304D\u3093
\u307B\u304F\u308D
\u307B\u3051\u3064
\u307B\u3051\u3093
\u307B\u3053\u3046
\u307B\u3053\u308B
\u307B\u3057\u3044
\u307B\u3057\u3064
\u307B\u3057\u3085
\u307B\u3057\u3087\u3046
\u307B\u305B\u3044
\u307B\u305D\u3044
\u307B\u305D\u304F
\u307B\u305F\u3066
\u307B\u305F\u308B
\u307B\u309A\u3061\u3075\u3099\u304F\u308D
\u307B\u3063\u304D\u3087\u304F
\u307B\u3063\u3055
\u307B\u3063\u305F\u3093
\u307B\u3068\u3093\u3068\u3099
\u307B\u3081\u308B
\u307B\u3093\u3044
\u307B\u3093\u304D
\u307B\u3093\u3051
\u307B\u3093\u3057\u3064
\u307B\u3093\u3084\u304F
\u307E\u3044\u306B\u3061
\u307E\u304B\u3044
\u307E\u304B\u305B\u308B
\u307E\u304B\u3099\u308B
\u307E\u3051\u308B
\u307E\u3053\u3068
\u307E\u3055\u3064
\u307E\u3057\u3099\u3081
\u307E\u3059\u304F
\u307E\u305B\u3099\u308B
\u307E\u3064\u308A
\u307E\u3068\u3081
\u307E\u306A\u3075\u3099
\u307E\u306C\u3051
\u307E\u306D\u304F
\u307E\u307B\u3046
\u307E\u3082\u308B
\u307E\u3086\u3051\u3099
\u307E\u3088\u3046
\u307E\u308D\u3084\u304B
\u307E\u308F\u3059
\u307E\u308F\u308A
\u307E\u308F\u308B
\u307E\u3093\u304B\u3099
\u307E\u3093\u304D\u3064
\u307E\u3093\u305D\u3099\u304F
\u307E\u3093\u306A\u304B
\u307F\u3044\u3089
\u307F\u3046\u3061
\u307F\u3048\u308B
\u307F\u304B\u3099\u304F
\u307F\u304B\u305F
\u307F\u304B\u3093
\u307F\u3051\u3093
\u307F\u3053\u3093
\u307F\u3057\u3099\u304B\u3044
\u307F\u3059\u3044
\u307F\u3059\u3048\u308B
\u307F\u305B\u308B
\u307F\u3063\u304B
\u307F\u3064\u304B\u308B
\u307F\u3064\u3051\u308B
\u307F\u3066\u3044
\u307F\u3068\u3081\u308B
\u307F\u306A\u3068
\u307F\u306A\u307F\u304B\u3055\u3044
\u307F\u306D\u3089\u308B
\u307F\u306E\u3046
\u307F\u306E\u304B\u3099\u3059
\u307F\u307B\u3093
\u307F\u3082\u3068
\u307F\u3084\u3051\u3099
\u307F\u3089\u3044
\u307F\u308A\u3087\u304F
\u307F\u308F\u304F
\u307F\u3093\u304B
\u307F\u3093\u305D\u3099\u304F
\u3080\u3044\u304B
\u3080\u3048\u304D
\u3080\u3048\u3093
\u3080\u304B\u3044
\u3080\u304B\u3046
\u3080\u304B\u3048
\u3080\u304B\u3057
\u3080\u304D\u3099\u3061\u3083
\u3080\u3051\u308B
\u3080\u3051\u3099\u3093
\u3080\u3055\u307B\u3099\u308B
\u3080\u3057\u3042\u3064\u3044
\u3080\u3057\u306F\u3099
\u3080\u3057\u3099\u3085\u3093
\u3080\u3057\u308D
\u3080\u3059\u3046
\u3080\u3059\u3053
\u3080\u3059\u3075\u3099
\u3080\u3059\u3081
\u3080\u305B\u308B
\u3080\u305B\u3093
\u3080\u3061\u3085\u3046
\u3080\u306A\u3057\u3044
\u3080\u306E\u3046
\u3080\u3084\u307F
\u3080\u3088\u3046
\u3080\u3089\u3055\u304D
\u3080\u308A\u3087\u3046
\u3080\u308D\u3093
\u3081\u3044\u3042\u3093
\u3081\u3044\u3046\u3093
\u3081\u3044\u3048\u3093
\u3081\u3044\u304B\u304F
\u3081\u3044\u304D\u3087\u304F
\u3081\u3044\u3055\u3044
\u3081\u3044\u3057
\u3081\u3044\u305D\u3046
\u3081\u3044\u3075\u3099\u3064
\u3081\u3044\u308C\u3044
\u3081\u3044\u308F\u304F
\u3081\u304F\u3099\u307E\u308C\u308B
\u3081\u3055\u3099\u3059
\u3081\u3057\u305F
\u3081\u3059\u3099\u3089\u3057\u3044
\u3081\u305F\u3099\u3064
\u3081\u307E\u3044
\u3081\u3084\u3059
\u3081\u3093\u304D\u3087
\u3081\u3093\u305B\u304D
\u3081\u3093\u3068\u3099\u3046
\u3082\u3046\u3057\u3042\u3051\u3099\u308B
\u3082\u3046\u3068\u3099\u3046\u3051\u3093
\u3082\u3048\u308B
\u3082\u304F\u3057
\u3082\u304F\u3066\u304D
\u3082\u304F\u3088\u3046\u3072\u3099
\u3082\u3061\u308D\u3093
\u3082\u3068\u3099\u308B
\u3082\u3089\u3046
\u3082\u3093\u304F
\u3082\u3093\u305F\u3099\u3044
\u3084\u304A\u3084
\u3084\u3051\u308B
\u3084\u3055\u3044
\u3084\u3055\u3057\u3044
\u3084\u3059\u3044
\u3084\u3059\u305F\u308D\u3046
\u3084\u3059\u307F
\u3084\u305B\u308B
\u3084\u305D\u3046
\u3084\u305F\u3044
\u3084\u3061\u3093
\u3084\u3063\u3068
\u3084\u3063\u306F\u309A\u308A
\u3084\u3075\u3099\u308B
\u3084\u3081\u308B
\u3084\u3084\u3053\u3057\u3044
\u3084\u3088\u3044
\u3084\u308F\u3089\u304B\u3044
\u3086\u3046\u304D
\u3086\u3046\u3072\u3099\u3093\u304D\u3087\u304F
\u3086\u3046\u3078\u3099
\u3086\u3046\u3081\u3044
\u3086\u3051\u3064
\u3086\u3057\u3085\u3064
\u3086\u305B\u3093
\u3086\u305D\u3046
\u3086\u305F\u304B
\u3086\u3061\u3083\u304F
\u3086\u3066\u3099\u308B
\u3086\u306B\u3085\u3046
\u3086\u3072\u3099\u308F
\u3086\u3089\u3044
\u3086\u308C\u308B
\u3088\u3046\u3044
\u3088\u3046\u304B
\u3088\u3046\u304D\u3085\u3046
\u3088\u3046\u3057\u3099
\u3088\u3046\u3059
\u3088\u3046\u3061\u3048\u3093
\u3088\u304B\u305B\u3099
\u3088\u304B\u3093
\u3088\u304D\u3093
\u3088\u304F\u305B\u3044
\u3088\u304F\u307B\u3099\u3046
\u3088\u3051\u3044
\u3088\u3053\u3099\u308C\u308B
\u3088\u3055\u3093
\u3088\u3057\u3085\u3046
\u3088\u305D\u3046
\u3088\u305D\u304F
\u3088\u3063\u304B
\u3088\u3066\u3044
\u3088\u3068\u3099\u304B\u3099\u308F\u304F
\u3088\u306D\u3064
\u3088\u3084\u304F
\u3088\u3086\u3046
\u3088\u308D\u3053\u3075\u3099
\u3088\u308D\u3057\u3044
\u3089\u3044\u3046
\u3089\u304F\u304B\u3099\u304D
\u3089\u304F\u3053\u3099
\u3089\u304F\u3055\u3064
\u3089\u304F\u305F\u3099
\u3089\u3057\u3093\u306F\u3099\u3093
\u3089\u305B\u3093
\u3089\u305D\u3099\u304F
\u3089\u305F\u3044
\u3089\u3063\u304B
\u3089\u308C\u3064
\u308A\u3048\u304D
\u308A\u304B\u3044
\u308A\u304D\u3055\u304F
\u308A\u304D\u305B\u3064
\u308A\u304F\u304F\u3099\u3093
\u308A\u304F\u3064
\u308A\u3051\u3093
\u308A\u3053\u3046
\u308A\u305B\u3044
\u308A\u305D\u3046
\u308A\u305D\u304F
\u308A\u3066\u3093
\u308A\u306D\u3093
\u308A\u3086\u3046
\u308A\u3085\u3046\u304B\u3099\u304F
\u308A\u3088\u3046
\u308A\u3087\u3046\u308A
\u308A\u3087\u304B\u3093
\u308A\u3087\u304F\u3061\u3083
\u308A\u3087\u3053\u3046
\u308A\u308A\u304F
\u308A\u308C\u304D
\u308A\u308D\u3093
\u308A\u3093\u3053\u3099
\u308B\u3044\u3051\u3044
\u308B\u3044\u3055\u3044
\u308B\u3044\u3057\u3099
\u308B\u3044\u305B\u304D
\u308B\u3059\u306F\u3099\u3093
\u308B\u308A\u304B\u3099\u308F\u3089
\u308C\u3044\u304B\u3093
\u308C\u3044\u304D\u3099
\u308C\u3044\u305B\u3044
\u308C\u3044\u305D\u3099\u3046\u3053
\u308C\u3044\u3068\u3046
\u308C\u3044\u307B\u3099\u3046
\u308C\u304D\u3057
\u308C\u304D\u305F\u3099\u3044
\u308C\u3093\u3042\u3044
\u308C\u3093\u3051\u3044
\u308C\u3093\u3053\u3093
\u308C\u3093\u3055\u3044
\u308C\u3093\u3057\u3085\u3046
\u308C\u3093\u305D\u3099\u304F
\u308C\u3093\u3089\u304F
\u308D\u3046\u304B
\u308D\u3046\u3053\u3099
\u308D\u3046\u3057\u3099\u3093
\u308D\u3046\u305D\u304F
\u308D\u304F\u304B\u3099
\u308D\u3053\u3064
\u308D\u3057\u3099\u3046\u3089
\u308D\u3057\u3085\u3064
\u308D\u305B\u3093
\u308D\u3066\u3093
\u308D\u3081\u3093
\u308D\u308C\u3064
\u308D\u3093\u304D\u3099
\u308D\u3093\u306F\u309A
\u308D\u3093\u3075\u3099\u3093
\u308D\u3093\u308A
\u308F\u304B\u3059
\u308F\u304B\u3081
\u308F\u304B\u3084\u307E
\u308F\u304B\u308C\u308B
\u308F\u3057\u3064
\u308F\u3057\u3099\u307E\u3057
\u308F\u3059\u308C\u3082\u306E
\u308F\u3089\u3046
\u308F\u308C\u308B`.split("\n");
// /home/mous/work/pimlico/alto/node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/@scure/bip39/esm/wordlists/korean.js
var wordlist6 = `\u1100\u1161\u1100\u1167\u11A8
\u1100\u1161\u1101\u1173\u11B7
\u1100\u1161\u1102\u1161\u11AB
\u1100\u1161\u1102\u1173\u11BC
\u1100\u1161\u1103\u1173\u11A8
\u1100\u1161\u1105\u1173\u110E\u1175\u11B7
\u1100\u1161\u1106\u116E\u11B7
\u1100\u1161\u1107\u1161\u11BC
\u1100\u1161\u1109\u1161\u11BC
\u1100\u1161\u1109\u1173\u11B7
\u1100\u1161\u110B\u116E\u11AB\u1103\u1166
\u1100\u1161\u110B\u1173\u11AF
\u1100\u1161\u110B\u1175\u1103\u1173
\u1100\u1161\u110B\u1175\u11B8
\u1100\u1161\u110C\u1161\u11BC
\u1100\u1161\u110C\u1165\u11BC
\u1100\u1161\u110C\u1169\u11A8
\u1100\u1161\u110C\u116E\u11A8
\u1100\u1161\u11A8\u110B\u1169
\u1100\u1161\u11A8\u110C\u1161
\u1100\u1161\u11AB\u1100\u1167\u11A8
\u1100\u1161\u11AB\u1107\u116E
\u1100\u1161\u11AB\u1109\u1165\u11B8
\u1100\u1161\u11AB\u110C\u1161\u11BC
\u1100\u1161\u11AB\u110C\u1165\u11B8
\u1100\u1161\u11AB\u1111\u1161\u11AB
\u1100\u1161\u11AF\u1103\u1173\u11BC
\u1100\u1161\u11AF\u1107\u1175
\u1100\u1161\u11AF\u1109\u1162\u11A8
\u1100\u1161\u11AF\u110C\u1173\u11BC
\u1100\u1161\u11B7\u1100\u1161\u11A8
\u1100\u1161\u11B7\u1100\u1175
\u1100\u1161\u11B7\u1109\u1169
\u1100\u1161\u11B7\u1109\u116E\u1109\u1165\u11BC
\u1100\u1161\u11B7\u110C\u1161
\u1100\u1161\u11B7\u110C\u1165\u11BC
\u1100\u1161\u11B8\u110C\u1161\u1100\u1175
\u1100\u1161\u11BC\u1102\u1161\u11B7
\u1100\u1161\u11BC\u1103\u1161\u11BC
\u1100\u1161\u11BC\u1103\u1169
\u1100\u1161\u11BC\u1105\u1167\u11A8\u1112\u1175
\u1100\u1161\u11BC\u1107\u1167\u11AB
\u1100\u1161\u11BC\u1107\u116E\u11A8
\u1100\u1161\u11BC\u1109\u1161
\u1100\u1161\u11BC\u1109\u116E\u1105\u1163\u11BC
\u1100\u1161\u11BC\u110B\u1161\u110C\u1175
\u1100\u1161\u11BC\u110B\u116F\u11AB\u1103\u1169
\u1100\u1161\u11BC\u110B\u1174
\u1100\u1161\u11BC\u110C\u1166
\u1100\u1161\u11BC\u110C\u1169
\u1100\u1161\u11C0\u110B\u1175
\u1100\u1162\u1100\u116E\u1105\u1175
\u1100\u1162\u1102\u1161\u1105\u1175
\u1100\u1162\u1107\u1161\u11BC
\u1100\u1162\u1107\u1167\u11AF
\u1100\u1162\u1109\u1165\u11AB
\u1100\u1162\u1109\u1165\u11BC
\u1100\u1162\u110B\u1175\u11AB
\u1100\u1162\u11A8\u1100\u116A\u11AB\u110C\u1165\u11A8
\u1100\u1165\u1109\u1175\u11AF
\u1100\u1165\u110B\u1162\u11A8
\u1100\u1165\u110B\u116E\u11AF
\u1100\u1165\u110C\u1175\u11BA
\u1100\u1165\u1111\u116E\u11B7
\u1100\u1165\u11A8\u110C\u1165\u11BC
\u1100\u1165\u11AB\u1100\u1161\u11BC
\u1100\u1165\u11AB\u1106\u116E\u11AF
\u1100\u1165\u11AB\u1109\u1165\u11AF
\u1100\u1165\u11AB\u110C\u1169
\u1100\u1165\u11AB\u110E\u116E\u11A8
\u1100\u1165\u11AF\u110B\u1173\u11B7
\u1100\u1165\u11B7\u1109\u1161
\u1100\u1165\u11B7\u1110\u1169
\u1100\u1166\u1109\u1175\u1111\u1161\u11AB
\u1100\u1166\u110B\u1175\u11B7
\u1100\u1167\u110B\u116E\u11AF
\u1100\u1167\u11AB\u1112\u1162
\u1100\u1167\u11AF\u1100\u116A
\u1100\u1167\u11AF\u1100\u116E\u11A8
\u1100\u1167\u11AF\u1105\u1169\u11AB
\u1100\u1167\u11AF\u1109\u1165\u11A8
\u1100\u1167\u11AF\u1109\u1173\u11BC
\u1100\u1167\u11AF\u1109\u1175\u11B7
\u1100\u1167\u11AF\u110C\u1165\u11BC
\u1100\u1167\u11AF\u1112\u1169\u11AB
\u1100\u1167\u11BC\u1100\u1168
\u1100\u1167\u11BC\u1100\u1169
\u1100\u1167\u11BC\u1100\u1175
\u1100\u1167\u11BC\u1105\u1167\u11A8
\u1100\u1167\u11BC\u1107\u1169\u11A8\u1100\u116E\u11BC
\u1100\u1167\u11BC\u1107\u1175
\u1100\u1167\u11BC\u1109\u1161\u11BC\u1103\u1169
\u1100\u1167\u11BC\u110B\u1167\u11BC
\u1100\u1167\u11BC\u110B\u116E
\u1100\u1167\u11BC\u110C\u1162\u11BC
\u1100\u1167\u11BC\u110C\u1166
\u1100\u1167\u11BC\u110C\u116E
\u1100\u1167\u11BC\u110E\u1161\u11AF
\u1100\u1167\u11BC\u110E\u1175
\u1100\u1167\u11BC\u1112\u1163\u11BC
\u1100\u1167\u11BC\u1112\u1165\u11B7
\u1100\u1168\u1100\u1169\u11A8
\u1100\u1168\u1103\u1161\u11AB
\u1100\u1168\u1105\u1161\u11AB
\u1100\u1168\u1109\u1161\u11AB
\u1100\u1168\u1109\u1169\u11A8
\u1100\u1168\u110B\u1163\u11A8
\u1100\u1168\u110C\u1165\u11AF
\u1100\u1168\u110E\u1173\u11BC
\u1100\u1168\u1112\u116C\u11A8
\u1100\u1169\u1100\u1162\u11A8
\u1100\u1169\u1100\u116E\u1105\u1167
\u1100\u1169\u1100\u116E\u11BC
\u1100\u1169\u1100\u1173\u11B8
\u1100\u1169\u1103\u1173\u11BC\u1112\u1161\u11A8\u1109\u1162\u11BC
\u1100\u1169\u1106\u116E\u1109\u1175\u11AB
\u1100\u1169\u1106\u1175\u11AB
\u1100\u1169\u110B\u1163\u11BC\u110B\u1175
\u1100\u1169\u110C\u1161\u11BC
\u1100\u1169\u110C\u1165\u11AB
\u1100\u1169\u110C\u1175\u11B8
\u1100\u1169\u110E\u116E\u11BA\u1100\u1161\u1105\u116E
\u1100\u1169\u1110\u1169\u11BC
\u1100\u1169\u1112\u1163\u11BC
\u1100\u1169\u11A8\u1109\u1175\u11A8
\u1100\u1169\u11AF\u1106\u1169\u11A8
\u1100\u1169\u11AF\u110D\u1161\u1100\u1175
\u1100\u1169\u11AF\u1111\u1173
\u1100\u1169\u11BC\u1100\u1161\u11AB
\u1100\u1169\u11BC\u1100\u1162
\u1100\u1169\u11BC\u1100\u1167\u11A8
\u1100\u1169\u11BC\u1100\u116E\u11AB
\u1100\u1169\u11BC\u1100\u1173\u11B8
\u1100\u1169\u11BC\u1100\u1175
\u1100\u1169\u11BC\u1103\u1169\u11BC
\u1100\u1169\u11BC\u1106\u116E\u110B\u116F\u11AB
\u1100\u1169\u11BC\u1107\u116E
\u1100\u1169\u11BC\u1109\u1161
\u1100\u1169\u11BC\u1109\u1175\u11A8
\u1100\u1169\u11BC\u110B\u1165\u11B8
\u1100\u1169\u11BC\u110B\u1167\u11AB
\u1100\u1169\u11BC\u110B\u116F\u11AB
\u1100\u1169\u11BC\u110C\u1161\u11BC
\u1100\u1169\u11BC\u110D\u1161
\u1100\u1169\u11BC\u110E\u1162\u11A8
\u1100\u1169\u11BC\u1110\u1169\u11BC
\u1100\u1169\u11BC\u1111\u1169
\u1100\u1169\u11BC\u1112\u1161\u11BC
\u1100\u1169\u11BC\u1112\u1172\u110B\u1175\u11AF
\u1100\u116A\u1106\u1169\u11A8
\u1100\u116A\u110B\u1175\u11AF
\u1100\u116A\u110C\u1161\u11BC
\u1100\u116A\u110C\u1165\u11BC
\u1100\u116A\u1112\u1161\u11A8
\u1100\u116A\u11AB\u1100\u1162\u11A8
\u1100\u116A\u11AB\u1100\u1168
\u1100\u116A\u11AB\u1100\u116A\u11BC
\u1100\u116A\u11AB\u1102\u1167\u11B7
\u1100\u116A\u11AB\u1105\u1161\u11B7
\u1100\u116A\u11AB\u1105\u1167\u11AB
\u1100\u116A\u11AB\u1105\u1175
\u1100\u116A\u11AB\u1109\u1173\u11B8
\u1100\u116A\u11AB\u1109\u1175\u11B7
\u1100\u116A\u11AB\u110C\u1165\u11B7
\u1100\u116A\u11AB\u110E\u1161\u11AF
\u1100\u116A\u11BC\u1100\u1167\u11BC
\u1100\u116A\u11BC\u1100\u1169
\u1100\u116A\u11BC\u110C\u1161\u11BC
\u1100\u116A\u11BC\u110C\u116E
\u1100\u116C\u1105\u1169\u110B\u116E\u11B7
\u1100\u116C\u11BC\u110C\u1161\u11BC\u1112\u1175
\u1100\u116D\u1100\u116A\u1109\u1165
\u1100\u116D\u1106\u116E\u11AB
\u1100\u116D\u1107\u1169\u11A8
\u1100\u116D\u1109\u1175\u11AF
\u1100\u116D\u110B\u1163\u11BC
\u1100\u116D\u110B\u1172\u11A8
\u1100\u116D\u110C\u1161\u11BC
\u1100\u116D\u110C\u1175\u11A8
\u1100\u116D\u1110\u1169\u11BC
\u1100\u116D\u1112\u116A\u11AB
\u1100\u116D\u1112\u116E\u11AB
\u1100\u116E\u1100\u1167\u11BC
\u1100\u116E\u1105\u1173\u11B7
\u1100\u116E\u1106\u1165\u11BC
\u1100\u116E\u1107\u1167\u11AF
\u1100\u116E\u1107\u116E\u11AB
\u1100\u116E\u1109\u1165\u11A8
\u1100\u116E\u1109\u1165\u11BC
\u1100\u116E\u1109\u1169\u11A8
\u1100\u116E\u110B\u1167\u11A8
\u1100\u116E\u110B\u1175\u11B8
\u1100\u116E\u110E\u1165\u11BC
\u1100\u116E\u110E\u1166\u110C\u1165\u11A8
\u1100\u116E\u11A8\u1100\u1161
\u1100\u116E\u11A8\u1100\u1175
\u1100\u116E\u11A8\u1102\u1162
\u1100\u116E\u11A8\u1105\u1175\u11B8
\u1100\u116E\u11A8\u1106\u116E\u11AF
\u1100\u116E\u11A8\u1106\u1175\u11AB
\u1100\u116E\u11A8\u1109\u116E
\u1100\u116E\u11A8\u110B\u1165
\u1100\u116E\u11A8\u110B\u116A\u11BC
\u1100\u116E\u11A8\u110C\u1165\u11A8
\u1100\u116E\u11A8\u110C\u1166
\u1100\u116E\u11A8\u1112\u116C
\u1100\u116E\u11AB\u1103\u1162
\u1100\u116E\u11AB\u1109\u1161
\u1100\u116E\u11AB\u110B\u1175\u11AB
\u1100\u116E\u11BC\u1100\u1173\u11A8\u110C\u1165\u11A8
\u1100\u116F\u11AB\u1105\u1175
\u1100\u116F\u11AB\u110B\u1171
\u1100\u116F\u11AB\u1110\u116E
\u1100\u1171\u1100\u116E\u11A8
\u1100\u1171\u1109\u1175\u11AB
\u1100\u1172\u110C\u1165\u11BC
\u1100\u1172\u110E\u1175\u11A8
\u1100\u1172\u11AB\u1112\u1167\u11BC
\u1100\u1173\u1102\u1161\u11AF
\u1100\u1173\u1102\u1163\u11BC
\u1100\u1173\u1102\u1173\u11AF
\u1100\u1173\u1105\u1165\u1102\u1161
\u1100\u1173\u1105\u116E\u11B8
\u1100\u1173\u1105\u1173\u11BA
\u1100\u1173\u1105\u1175\u11B7
\u1100\u1173\u110C\u1166\u1109\u1165\u110B\u1163
\u1100\u1173\u1110\u1169\u1105\u1169\u11A8
\u1100\u1173\u11A8\u1107\u1169\u11A8
\u1100\u1173\u11A8\u1112\u1175
\u1100\u1173\u11AB\u1100\u1165
\u1100\u1173\u11AB\u1100\u116D
\u1100\u1173\u11AB\u1105\u1162
\u1100\u1173\u11AB\u1105\u1169
\u1100\u1173\u11AB\u1106\u116E
\u1100\u1173\u11AB\u1107\u1169\u11AB
\u1100\u1173\u11AB\u110B\u116F\u11AB
\u1100\u1173\u11AB\u110B\u1172\u11A8
\u1100\u1173\u11AB\u110E\u1165
\u1100\u1173\u11AF\u110A\u1175
\u1100\u1173\u11AF\u110C\u1161
\u1100\u1173\u11B7\u1100\u1161\u11BC\u1109\u1161\u11AB
\u1100\u1173\u11B7\u1100\u1169
\u1100\u1173\u11B7\u1102\u1167\u11AB
\u1100\u1173\u11B7\u1106\u1166\u1103\u1161\u11AF
\u1100\u1173\u11B7\u110B\u1162\u11A8
\u1100\u1173\u11B7\u110B\u1167\u11AB
\u1100\u1173\u11B7\u110B\u116D\u110B\u1175\u11AF
\u1100\u1173\u11B7\u110C\u1175
\u1100\u1173\u11BC\u110C\u1165\u11BC\u110C\u1165\u11A8
\u1100\u1175\u1100\u1161\u11AB
\u1100\u1175\u1100\u116A\u11AB
\u1100\u1175\u1102\u1167\u11B7
\u1100\u1175\u1102\u1173\u11BC
\u1100\u1175\u1103\u1169\u11A8\u1100\u116D
\u1100\u1175\u1103\u116E\u11BC
\u1100\u1175\u1105\u1169\u11A8
\u1100\u1175\u1105\u1173\u11B7
\u1100\u1175\u1107\u1165\u11B8
\u1100\u1175\u1107\u1169\u11AB
\u1100\u1175\u1107\u116E\u11AB
\u1100\u1175\u1108\u1173\u11B7
\u1100\u1175\u1109\u116E\u11A8\u1109\u1161
\u1100\u1175\u1109\u116E\u11AF
\u1100\u1175\u110B\u1165\u11A8
\u1100\u1175\u110B\u1165\u11B8
\u1100\u1175\u110B\u1169\u11AB
\u1100\u1175\u110B\u116E\u11AB
\u1100\u1175\u110B\u116F\u11AB
\u1100\u1175\u110C\u1165\u11A8
\u1100\u1175\u110C\u116E\u11AB
\u1100\u1175\u110E\u1175\u11B7
\u1100\u1175\u1112\u1169\u11AB
\u1100\u1175\u1112\u116C\u11A8
\u1100\u1175\u11AB\u1100\u1173\u11B8
\u1100\u1175\u11AB\u110C\u1161\u11BC
\u1100\u1175\u11AF\u110B\u1175
\u1100\u1175\u11B7\u1107\u1161\u11B8
\u1100\u1175\u11B7\u110E\u1175
\u1100\u1175\u11B7\u1111\u1169\u1100\u1169\u11BC\u1112\u1161\u11BC
\u1101\u1161\u11A8\u1103\u116E\u1100\u1175
\u1101\u1161\u11B7\u1108\u1161\u11A8
\u1101\u1162\u1103\u1161\u11AF\u110B\u1173\u11B7
\u1101\u1162\u1109\u1169\u1100\u1173\u11B7
\u1101\u1165\u11B8\u110C\u1175\u11AF
\u1101\u1169\u11A8\u1103\u1162\u1100\u1175
\u1101\u1169\u11BE\u110B\u1175\u11C1
\u1102\u1161\u1103\u1173\u11AF\u110B\u1175
\u1102\u1161\u1105\u1161\u11AB\u1112\u1175
\u1102\u1161\u1106\u1165\u110C\u1175
\u1102\u1161\u1106\u116E\u11AF
\u1102\u1161\u110E\u1175\u11B7\u1107\u1161\u11AB
\u1102\u1161\u1112\u1173\u11AF
\u1102\u1161\u11A8\u110B\u1167\u11B8
\u1102\u1161\u11AB\u1107\u1161\u11BC
\u1102\u1161\u11AF\u1100\u1162
\u1102\u1161\u11AF\u110A\u1175
\u1102\u1161\u11AF\u110D\u1161
\u1102\u1161\u11B7\u1102\u1167
\u1102\u1161\u11B7\u1103\u1162\u1106\u116E\u11AB
\u1102\u1161\u11B7\u1106\u1162
\u1102\u1161\u11B7\u1109\u1161\u11AB
\u1102\u1161\u11B7\u110C\u1161
\u1102\u1161\u11B7\u1111\u1167\u11AB
\u1102\u1161\u11B7\u1112\u1161\u11A8\u1109\u1162\u11BC
\u1102\u1161\u11BC\u1107\u1175
\u1102\u1161\u11C0\u1106\u1161\u11AF
\u1102\u1162\u1102\u1167\u11AB
\u1102\u1162\u110B\u116D\u11BC
\u1102\u1162\u110B\u1175\u11AF
\u1102\u1162\u11B7\u1107\u1175
\u1102\u1162\u11B7\u1109\u1162
\u1102\u1162\u11BA\u1106\u116E\u11AF
\u1102\u1162\u11BC\u1103\u1169\u11BC
\u1102\u1162\u11BC\u1106\u1167\u11AB
\u1102\u1162\u11BC\u1107\u1161\u11BC
\u1102\u1162\u11BC\u110C\u1161\u11BC\u1100\u1169
\u1102\u1166\u11A8\u1110\u1161\u110B\u1175
\u1102\u1166\u11BA\u110D\u1162
\u1102\u1169\u1103\u1169\u11BC
\u1102\u1169\u1105\u1161\u11AB\u1109\u1162\u11A8
\u1102\u1169\u1105\u1167\u11A8
\u1102\u1169\u110B\u1175\u11AB
\u1102\u1169\u11A8\u110B\u1173\u11B7
\u1102\u1169\u11A8\u110E\u1161
\u1102\u1169\u11A8\u1112\u116A
\u1102\u1169\u11AB\u1105\u1175
\u1102\u1169\u11AB\u1106\u116E\u11AB
\u1102\u1169\u11AB\u110C\u1162\u11BC
\u1102\u1169\u11AF\u110B\u1175
\u1102\u1169\u11BC\u1100\u116E
\u1102\u1169\u11BC\u1103\u1161\u11B7
\u1102\u1169\u11BC\u1106\u1175\u11AB
\u1102\u1169\u11BC\u1107\u116E
\u1102\u1169\u11BC\u110B\u1165\u11B8
\u1102\u1169\u11BC\u110C\u1161\u11BC
\u1102\u1169\u11BC\u110E\u1169\u11AB
\u1102\u1169\u11C1\u110B\u1175
\u1102\u116E\u11AB\u1103\u1169\u11BC\u110C\u1161
\u1102\u116E\u11AB\u1106\u116E\u11AF
\u1102\u116E\u11AB\u110A\u1165\u11B8
\u1102\u1172\u110B\u116D\u11A8
\u1102\u1173\u1101\u1175\u11B7
\u1102\u1173\u11A8\u1103\u1162
\u1102\u1173\u11BC\u1103\u1169\u11BC\u110C\u1165\u11A8
\u1102\u1173\u11BC\u1105\u1167\u11A8
\u1103\u1161\u1107\u1161\u11BC
\u1103\u1161\u110B\u1163\u11BC\u1109\u1165\u11BC
\u1103\u1161\u110B\u1173\u11B7
\u1103\u1161\u110B\u1175\u110B\u1165\u1110\u1173
\u1103\u1161\u1112\u1162\u11BC
\u1103\u1161\u11AB\u1100\u1168
\u1103\u1161\u11AB\u1100\u1169\u11AF
\u1103\u1161\u11AB\u1103\u1169\u11A8
\u1103\u1161\u11AB\u1106\u1161\u11BA
\u1103\u1161\u11AB\u1109\u116E\u11AB
\u1103\u1161\u11AB\u110B\u1165
\u1103\u1161\u11AB\u110B\u1171
\u1103\u1161\u11AB\u110C\u1165\u11B7
\u1103\u1161\u11AB\u110E\u1166
\u1103\u1161\u11AB\u110E\u116E
\u1103\u1161\u11AB\u1111\u1167\u11AB
\u1103\u1161\u11AB\u1111\u116E\u11BC
\u1103\u1161\u11AF\u1100\u1163\u11AF
\u1103\u1161\u11AF\u1105\u1165
\u1103\u1161\u11AF\u1105\u1167\u11A8
\u1103\u1161\u11AF\u1105\u1175
\u1103\u1161\u11B0\u1100\u1169\u1100\u1175
\u1103\u1161\u11B7\u1103\u1161\u11BC
\u1103\u1161\u11B7\u1107\u1162
\u1103\u1161\u11B7\u110B\u116D
\u1103\u1161\u11B7\u110B\u1175\u11B7
\u1103\u1161\u11B8\u1107\u1167\u11AB
\u1103\u1161\u11B8\u110C\u1161\u11BC
\u1103\u1161\u11BC\u1100\u1173\u11AB
\u1103\u1161\u11BC\u1107\u116E\u11AB\u1100\u1161\u11AB
\u1103\u1161\u11BC\u110B\u1167\u11AB\u1112\u1175
\u1103\u1161\u11BC\u110C\u1161\u11BC
\u1103\u1162\u1100\u1172\u1106\u1169
\u1103\u1162\u1102\u1161\u11BD
\u1103\u1162\u1103\u1161\u11AB\u1112\u1175
\u1103\u1162\u1103\u1161\u11B8
\u1103\u1162\u1103\u1169\u1109\u1175
\u1103\u1162\u1105\u1163\u11A8
\u1103\u1162\u1105\u1163\u11BC
\u1103\u1162\u1105\u1172\u11A8
\u1103\u1162\u1106\u116E\u11AB
\u1103\u1162\u1107\u116E\u1107\u116E\u11AB
\u1103\u1162\u1109\u1175\u11AB
\u1103\u1162\u110B\u1173\u11BC
\u1103\u1162\u110C\u1161\u11BC
\u1103\u1162\u110C\u1165\u11AB
\u1103\u1162\u110C\u1165\u11B8
\u1103\u1162\u110C\u116E\u11BC
\u1103\u1162\u110E\u1162\u11A8
\u1103\u1162\u110E\u116E\u11AF
\u1103\u1162\u110E\u116E\u11BC
\u1103\u1162\u1110\u1169\u11BC\u1105\u1167\u11BC
\u1103\u1162\u1112\u1161\u11A8
\u1103\u1162\u1112\u1161\u11AB\u1106\u1175\u11AB\u1100\u116E\u11A8
\u1103\u1162\u1112\u1161\u11B8\u1109\u1175\u11AF
\u1103\u1162\u1112\u1167\u11BC
\u1103\u1165\u11BC\u110B\u1165\u1105\u1175
\u1103\u1166\u110B\u1175\u1110\u1173
\u1103\u1169\u1103\u1162\u110E\u1166
\u1103\u1169\u1103\u1165\u11A8
\u1103\u1169\u1103\u116E\u11A8
\u1103\u1169\u1106\u1161\u11BC
\u1103\u1169\u1109\u1165\u1100\u116A\u11AB
\u1103\u1169\u1109\u1175\u11B7
\u1103\u1169\u110B\u116E\u11B7
\u1103\u1169\u110B\u1175\u11B8
\u1103\u1169\u110C\u1161\u1100\u1175
\u1103\u1169\u110C\u1165\u1112\u1175
\u1103\u1169\u110C\u1165\u11AB
\u1103\u1169\u110C\u116E\u11BC
\u1103\u1169\u110E\u1161\u11A8
\u1103\u1169\u11A8\u1100\u1161\u11B7
\u1103\u1169\u11A8\u1105\u1175\u11B8
\u1103\u1169\u11A8\u1109\u1165
\u1103\u1169\u11A8\u110B\u1175\u11AF
\u1103\u1169\u11A8\u110E\u1161\u11BC\u110C\u1165\u11A8
\u1103\u1169\u11BC\u1112\u116A\u110E\u1162\u11A8
\u1103\u1171\u11BA\u1106\u1169\u1109\u1173\u11B8
\u1103\u1171\u11BA\u1109\u1161\u11AB
\u1104\u1161\u11AF\u110B\u1161\u110B\u1175
\u1106\u1161\u1102\u116E\u1105\u1161
\u1106\u1161\u1102\u1173\u11AF
\u1106\u1161\u1103\u1161\u11BC
\u1106\u1161\u1105\u1161\u1110\u1169\u11AB
\u1106\u1161\u1105\u1167\u11AB
\u1106\u1161\u1106\u116E\u1105\u1175
\u1106\u1161\u1109\u1161\u110C\u1175
\u1106\u1161\u110B\u1163\u11A8
\u1106\u1161\u110B\u116D\u1102\u1166\u110C\u1173
\u1106\u1161\u110B\u1173\u11AF
\u1106\u1161\u110B\u1173\u11B7
\u1106\u1161\u110B\u1175\u110F\u1173
\u1106\u1161\u110C\u116E\u11BC
\u1106\u1161\u110C\u1175\u1106\u1161\u11A8
\u1106\u1161\u110E\u1161\u11AB\u1100\u1161\u110C\u1175
\u1106\u1161\u110E\u1161\u11AF
\u1106\u1161\u1112\u1173\u11AB
\u1106\u1161\u11A8\u1100\u1165\u11AF\u1105\u1175
\u1106\u1161\u11A8\u1102\u1162
\u1106\u1161\u11A8\u1109\u1161\u11BC
\u1106\u1161\u11AB\u1102\u1161\u11B7
\u1106\u1161\u11AB\u1103\u116E
\u1106\u1161\u11AB\u1109\u1166
\u1106\u1161\u11AB\u110B\u1163\u11A8
\u1106\u1161\u11AB\u110B\u1175\u11AF
\u1106\u1161\u11AB\u110C\u1165\u11B7
\u1106\u1161\u11AB\u110C\u1169\u11A8
\u1106\u1161\u11AB\u1112\u116A
\u1106\u1161\u11AD\u110B\u1175
\u1106\u1161\u11AF\u1100\u1175
\u1106\u1161\u11AF\u110A\u1173\u11B7
\u1106\u1161\u11AF\u1110\u116E
\u1106\u1161\u11B7\u1103\u1162\u1105\u1169
\u1106\u1161\u11BC\u110B\u116F\u11AB\u1100\u1167\u11BC
\u1106\u1162\u1102\u1167\u11AB
\u1106\u1162\u1103\u1161\u11AF
\u1106\u1162\u1105\u1167\u11A8
\u1106\u1162\u1107\u1165\u11AB
\u1106\u1162\u1109\u1173\u110F\u1165\u11B7
\u1106\u1162\u110B\u1175\u11AF
\u1106\u1162\u110C\u1161\u11BC
\u1106\u1162\u11A8\u110C\u116E
\u1106\u1165\u11A8\u110B\u1175
\u1106\u1165\u11AB\u110C\u1165
\u1106\u1165\u11AB\u110C\u1175
\u1106\u1165\u11AF\u1105\u1175
\u1106\u1166\u110B\u1175\u11AF
\u1106\u1167\u1102\u1173\u1105\u1175
\u1106\u1167\u110E\u1175\u11AF
\u1106\u1167\u11AB\u1103\u1161\u11B7
\u1106\u1167\u11AF\u110E\u1175
\u1106\u1167\u11BC\u1103\u1161\u11AB
\u1106\u1167\u11BC\u1105\u1167\u11BC
\u1106\u1167\u11BC\u110B\u1168
\u1106\u1167\u11BC\u110B\u1174
\u1106\u1167\u11BC\u110C\u1165\u11AF
\u1106\u1167\u11BC\u110E\u1175\u11BC
\u1106\u1167\u11BC\u1112\u1161\u11B7
\u1106\u1169\u1100\u1173\u11B7
\u1106\u1169\u1102\u1175\u1110\u1165
\u1106\u1169\u1103\u1166\u11AF
\u1106\u1169\u1103\u1173\u11AB
\u1106\u1169\u1107\u1165\u11B7
\u1106\u1169\u1109\u1173\u11B8
\u1106\u1169\u110B\u1163\u11BC
\u1106\u1169\u110B\u1175\u11B7
\u1106\u1169\u110C\u1169\u1105\u1175
\u1106\u1169\u110C\u1175\u11B8
\u1106\u1169\u1110\u116E\u11BC\u110B\u1175
\u1106\u1169\u11A8\u1100\u1165\u11AF\u110B\u1175
\u1106\u1169\u11A8\u1105\u1169\u11A8
\u1106\u1169\u11A8\u1109\u1161
\u1106\u1169\u11A8\u1109\u1169\u1105\u1175
\u1106\u1169\u11A8\u1109\u116E\u11B7
\u1106\u1169\u11A8\u110C\u1165\u11A8
\u1106\u1169\u11A8\u1111\u116D
\u1106\u1169\u11AF\u1105\u1162
\u1106\u1169\u11B7\u1106\u1162
\u1106\u1169\u11B7\u1106\u116E\u1100\u1166
\u1106\u1169\u11B7\u1109\u1161\u11AF
\u1106\u1169\u11B7\u1109\u1169\u11A8
\u1106\u1169\u11B7\u110C\u1175\u11BA
\u1106\u1169\u11B7\u1110\u1169\u11BC
\u1106\u1169\u11B8\u1109\u1175
\u1106\u116E\u1100\u116A\u11AB\u1109\u1175\u11B7
\u1106\u116E\u1100\u116E\u11BC\u1112\u116A
\u1106\u116E\u1103\u1165\u110B\u1171
\u1106\u116E\u1103\u1165\u11B7
\u1106\u116E\u1105\u1173\u11C1
\u1106\u116E\u1109\u1173\u11AB
\u1106\u116E\u110B\u1165\u11BA
\u1106\u116E\u110B\u1167\u11A8
\u1106\u116E\u110B\u116D\u11BC
\u1106\u116E\u110C\u1169\u1100\u1165\u11AB
\u1106\u116E\u110C\u1175\u1100\u1162
\u1106\u116E\u110E\u1165\u11A8
\u1106\u116E\u11AB\u1100\u116E
\u1106\u116E\u11AB\u1103\u1173\u11A8
\u1106\u116E\u11AB\u1107\u1165\u11B8
\u1106\u116E\u11AB\u1109\u1165
\u1106\u116E\u11AB\u110C\u1166
\u1106\u116E\u11AB\u1112\u1161\u11A8
\u1106\u116E\u11AB\u1112\u116A
\u1106\u116E\u11AF\u1100\u1161
\u1106\u116E\u11AF\u1100\u1165\u11AB
\u1106\u116E\u11AF\u1100\u1167\u11AF
\u1106\u116E\u11AF\u1100\u1169\u1100\u1175
\u1106\u116E\u11AF\u1105\u1169\u11AB
\u1106\u116E\u11AF\u1105\u1175\u1112\u1161\u11A8
\u1106\u116E\u11AF\u110B\u1173\u11B7
\u1106\u116E\u11AF\u110C\u1175\u11AF
\u1106\u116E\u11AF\u110E\u1166
\u1106\u1175\u1100\u116E\u11A8
\u1106\u1175\u1103\u1175\u110B\u1165
\u1106\u1175\u1109\u1161\u110B\u1175\u11AF
\u1106\u1175\u1109\u116E\u11AF
\u1106\u1175\u110B\u1167\u11A8
\u1106\u1175\u110B\u116D\u11BC\u1109\u1175\u11AF
\u1106\u1175\u110B\u116E\u11B7
\u1106\u1175\u110B\u1175\u11AB
\u1106\u1175\u1110\u1175\u11BC
\u1106\u1175\u1112\u1169\u11AB
\u1106\u1175\u11AB\u1100\u1161\u11AB
\u1106\u1175\u11AB\u110C\u1169\u11A8
\u1106\u1175\u11AB\u110C\u116E
\u1106\u1175\u11AE\u110B\u1173\u11B7
\u1106\u1175\u11AF\u1100\u1161\u1105\u116E
\u1106\u1175\u11AF\u1105\u1175\u1106\u1175\u1110\u1165
\u1106\u1175\u11C0\u1107\u1161\u1103\u1161\u11A8
\u1107\u1161\u1100\u1161\u110C\u1175
\u1107\u1161\u1100\u116E\u1102\u1175
\u1107\u1161\u1102\u1161\u1102\u1161
\u1107\u1161\u1102\u1173\u11AF
\u1107\u1161\u1103\u1161\u11A8
\u1107\u1161\u1103\u1161\u11BA\u1100\u1161
\u1107\u1161\u1105\u1161\u11B7
\u1107\u1161\u110B\u1175\u1105\u1165\u1109\u1173
\u1107\u1161\u1110\u1161\u11BC
\u1107\u1161\u11A8\u1106\u116E\u11AF\u1100\u116A\u11AB
\u1107\u1161\u11A8\u1109\u1161
\u1107\u1161\u11A8\u1109\u116E
\u1107\u1161\u11AB\u1103\u1162
\u1107\u1161\u11AB\u1103\u1173\u1109\u1175
\u1107\u1161\u11AB\u1106\u1161\u11AF
\u1107\u1161\u11AB\u1107\u1161\u11AF
\u1107\u1161\u11AB\u1109\u1165\u11BC
\u1107\u1161\u11AB\u110B\u1173\u11BC
\u1107\u1161\u11AB\u110C\u1161\u11BC
\u1107\u1161\u11AB\u110C\u116E\u11A8
\u1107\u1161\u11AB\u110C\u1175
\u1107\u1161\u11AB\u110E\u1161\u11AB
\u1107\u1161\u11AE\u110E\u1175\u11B7
\u1107\u1161\u11AF\u1100\u1161\u1105\u1161\u11A8
\u1107\u1161\u11AF\u1100\u1165\u11AF\u110B\u1173\u11B7
\u1107\u1161\u11AF\u1100\u1167\u11AB
\u1107\u1161\u11AF\u1103\u1161\u11AF
\u1107\u1161\u11AF\u1105\u1166
\u1107\u1161\u11AF\u1106\u1169\u11A8
\u1107\u1161\u11AF\u1107\u1161\u1103\u1161\u11A8
\u1107\u1161\u11AF\u1109\u1162\u11BC
\u1107\u1161\u11AF\u110B\u1173\u11B7
\u1107\u1161\u11AF\u110C\u1161\u1100\u116E\u11A8
\u1107\u1161\u11AF\u110C\u1165\u11AB
\u1107\u1161\u11AF\u1110\u1169\u11B8
\u1107\u1161\u11AF\u1111\u116D
\u1107\u1161\u11B7\u1112\u1161\u1102\u1173\u11AF
\u1107\u1161\u11B8\u1100\u1173\u1105\u1173\u11BA
\u1107\u1161\u11B8\u1106\u1161\u11BA
\u1107\u1161\u11B8\u1109\u1161\u11BC
\u1107\u1161\u11B8\u1109\u1169\u11C0
\u1107\u1161\u11BC\u1100\u1173\u11B7
\u1107\u1161\u11BC\u1106\u1167\u11AB
\u1107\u1161\u11BC\u1106\u116E\u11AB
\u1107\u1161\u11BC\u1107\u1161\u1103\u1161\u11A8
\u1107\u1161\u11BC\u1107\u1165\u11B8
\u1107\u1161\u11BC\u1109\u1169\u11BC
\u1107\u1161\u11BC\u1109\u1175\u11A8
\u1107\u1161\u11BC\u110B\u1161\u11AB
\u1107\u1161\u11BC\u110B\u116E\u11AF
\u1107\u1161\u11BC\u110C\u1175
\u1107\u1161\u11BC\u1112\u1161\u11A8
\u1107\u1161\u11BC\u1112\u1162
\u1107\u1161\u11BC\u1112\u1163\u11BC
\u1107\u1162\u1100\u1167\u11BC
\u1107\u1162\u1101\u1169\u11B8
\u1107\u1162\u1103\u1161\u11AF
\u1107\u1162\u1103\u1173\u1106\u1175\u11AB\u1110\u1165\u11AB
\u1107\u1162\u11A8\u1103\u116E\u1109\u1161\u11AB
\u1107\u1162\u11A8\u1109\u1162\u11A8
\u1107\u1162\u11A8\u1109\u1165\u11BC
\u1107\u1162\u11A8\u110B\u1175\u11AB
\u1107\u1162\u11A8\u110C\u1166
\u1107\u1162\u11A8\u1112\u116A\u110C\u1165\u11B7
\u1107\u1165\u1105\u1173\u11BA
\u1107\u1165\u1109\u1165\u11BA
\u1107\u1165\u1110\u1173\u11AB
\u1107\u1165\u11AB\u1100\u1162
\u1107\u1165\u11AB\u110B\u1167\u11A8
\u1107\u1165\u11AB\u110C\u1175
\u1107\u1165\u11AB\u1112\u1169
\u1107\u1165\u11AF\u1100\u1173\u11B7
\u1107\u1165\u11AF\u1105\u1166
\u1107\u1165\u11AF\u110A\u1165
\u1107\u1165\u11B7\u110B\u1171
\u1107\u1165\u11B7\u110B\u1175\u11AB
\u1107\u1165\u11B7\u110C\u116C
\u1107\u1165\u11B8\u1105\u1172\u11AF
\u1107\u1165\u11B8\u110B\u116F\u11AB
\u1107\u1165\u11B8\u110C\u1165\u11A8
\u1107\u1165\u11B8\u110E\u1175\u11A8
\u1107\u1166\u110B\u1175\u110C\u1175\u11BC
\u1107\u1166\u11AF\u1110\u1173
\u1107\u1167\u11AB\u1100\u1167\u11BC
\u1107\u1167\u11AB\u1103\u1169\u11BC
\u1107\u1167\u11AB\u1106\u1167\u11BC
\u1107\u1167\u11AB\u1109\u1175\u11AB
\u1107\u1167\u11AB\u1112\u1169\u1109\u1161
\u1107\u1167\u11AB\u1112\u116A
\u1107\u1167\u11AF\u1103\u1169
\u1107\u1167\u11AF\u1106\u1167\u11BC
\u1107\u1167\u11AF\u110B\u1175\u11AF
\u1107\u1167\u11BC\u1109\u1175\u11AF
\u1107\u1167\u11BC\u110B\u1161\u1105\u1175
\u1107\u1167\u11BC\u110B\u116F\u11AB
\u1107\u1169\u1100\u116A\u11AB
\u1107\u1169\u1102\u1165\u1109\u1173
\u1107\u1169\u1105\u1161\u1109\u1162\u11A8
\u1107\u1169\u1105\u1161\u11B7
\u1107\u1169\u1105\u1173\u11B7
\u1107\u1169\u1109\u1161\u11BC
\u1107\u1169\u110B\u1161\u11AB
\u1107\u1169\u110C\u1161\u1100\u1175
\u1107\u1169\u110C\u1161\u11BC
\u1107\u1169\u110C\u1165\u11AB
\u1107\u1169\u110C\u1169\u11AB
\u1107\u1169\u1110\u1169\u11BC
\u1107\u1169\u1111\u1167\u11AB\u110C\u1165\u11A8
\u1107\u1169\u1112\u1165\u11B7
\u1107\u1169\u11A8\u1103\u1169
\u1107\u1169\u11A8\u1109\u1161
\u1107\u1169\u11A8\u1109\u116E\u11BC\u110B\u1161
\u1107\u1169\u11A8\u1109\u1173\u11B8
\u1107\u1169\u11A9\u110B\u1173\u11B7
\u1107\u1169\u11AB\u1100\u1167\u11A8\u110C\u1165\u11A8
\u1107\u1169\u11AB\u1105\u1162
\u1107\u1169\u11AB\u1107\u116E
\u1107\u1169\u11AB\u1109\u1161
\u1107\u1169\u11AB\u1109\u1165\u11BC
\u1107\u1169\u11AB\u110B\u1175\u11AB
\u1107\u1169\u11AB\u110C\u1175\u11AF
\u1107\u1169\u11AF\u1111\u1166\u11AB
\u1107\u1169\u11BC\u1109\u1161
\u1107\u1169\u11BC\u110C\u1175
\u1107\u1169\u11BC\u1110\u116E
\u1107\u116E\u1100\u1173\u11AB
\u1107\u116E\u1101\u1173\u1105\u1165\u110B\u116E\u11B7
\u1107\u116E\u1103\u1161\u11B7
\u1107\u116E\u1103\u1169\u11BC\u1109\u1161\u11AB
\u1107\u116E\u1106\u116E\u11AB
\u1107\u116E\u1107\u116E\u11AB
\u1107\u116E\u1109\u1161\u11AB
\u1107\u116E\u1109\u1161\u11BC
\u1107\u116E\u110B\u1165\u11BF
\u1107\u116E\u110B\u1175\u11AB
\u1107\u116E\u110C\u1161\u11A8\u110B\u116D\u11BC
\u1107\u116E\u110C\u1161\u11BC
\u1107\u116E\u110C\u1165\u11BC
\u1107\u116E\u110C\u1169\u11A8
\u1107\u116E\u110C\u1175\u1105\u1165\u11AB\u1112\u1175
\u1107\u116E\u110E\u1175\u11AB
\u1107\u116E\u1110\u1161\u11A8
\u1107\u116E\u1111\u116E\u11B7
\u1107\u116E\u1112\u116C\u110C\u1161\u11BC
\u1107\u116E\u11A8\u1107\u116E
\u1107\u116E\u11A8\u1112\u1161\u11AB
\u1107\u116E\u11AB\u1102\u1169
\u1107\u116E\u11AB\u1105\u1163\u11BC
\u1107\u116E\u11AB\u1105\u1175
\u1107\u116E\u11AB\u1106\u1167\u11BC
\u1107\u116E\u11AB\u1109\u1165\u11A8
\u1107\u116E\u11AB\u110B\u1163
\u1107\u116E\u11AB\u110B\u1171\u1100\u1175
\u1107\u116E\u11AB\u1111\u1175\u11AF
\u1107\u116E\u11AB\u1112\u1169\u11BC\u1109\u1162\u11A8
\u1107\u116E\u11AF\u1100\u1169\u1100\u1175
\u1107\u116E\u11AF\u1100\u116A
\u1107\u116E\u11AF\u1100\u116D
\u1107\u116E\u11AF\u1101\u1169\u11BE
\u1107\u116E\u11AF\u1106\u1161\u11AB
\u1107\u116E\u11AF\u1107\u1165\u11B8
\u1107\u116E\u11AF\u1107\u1175\u11BE
\u1107\u116E\u11AF\u110B\u1161\u11AB
\u1107\u116E\u11AF\u110B\u1175\u110B\u1175\u11A8
\u1107\u116E\u11AF\u1112\u1162\u11BC
\u1107\u1173\u1105\u1162\u11AB\u1103\u1173
\u1107\u1175\u1100\u1173\u11A8
\u1107\u1175\u1102\u1161\u11AB
\u1107\u1175\u1102\u1175\u11AF
\u1107\u1175\u1103\u116E\u11AF\u1100\u1175
\u1107\u1175\u1103\u1175\u110B\u1169
\u1107\u1175\u1105\u1169\u1109\u1169
\u1107\u1175\u1106\u1161\u11AB
\u1107\u1175\u1106\u1167\u11BC
\u1107\u1175\u1106\u1175\u11AF
\u1107\u1175\u1107\u1161\u1105\u1161\u11B7
\u1107\u1175\u1107\u1175\u11B7\u1107\u1161\u11B8
\u1107\u1175\u1109\u1161\u11BC
\u1107\u1175\u110B\u116D\u11BC
\u1107\u1175\u110B\u1172\u11AF
\u1107\u1175\u110C\u116E\u11BC
\u1107\u1175\u1110\u1161\u1106\u1175\u11AB
\u1107\u1175\u1111\u1161\u11AB
\u1107\u1175\u11AF\u1103\u1175\u11BC
\u1107\u1175\u11BA\u1106\u116E\u11AF
\u1107\u1175\u11BA\u1107\u1161\u11BC\u110B\u116E\u11AF
\u1107\u1175\u11BA\u110C\u116E\u11AF\u1100\u1175
\u1107\u1175\u11BE\u1101\u1161\u11AF
\u1108\u1161\u11AF\u1100\u1161\u11AB\u1109\u1162\u11A8
\u1108\u1161\u11AF\u1105\u1162
\u1108\u1161\u11AF\u1105\u1175
\u1109\u1161\u1100\u1165\u11AB
\u1109\u1161\u1100\u1168\u110C\u1165\u11AF
\u1109\u1161\u1102\u1161\u110B\u1175
\u1109\u1161\u1102\u1163\u11BC
\u1109\u1161\u1105\u1161\u11B7
\u1109\u1161\u1105\u1161\u11BC
\u1109\u1161\u1105\u1175\u11B8
\u1109\u1161\u1106\u1169\u1102\u1175\u11B7
\u1109\u1161\u1106\u116E\u11AF
\u1109\u1161\u1107\u1161\u11BC
\u1109\u1161\u1109\u1161\u11BC
\u1109\u1161\u1109\u1162\u11BC\u1112\u116A\u11AF
\u1109\u1161\u1109\u1165\u11AF
\u1109\u1161\u1109\u1173\u11B7
\u1109\u1161\u1109\u1175\u11AF
\u1109\u1161\u110B\u1165\u11B8
\u1109\u1161\u110B\u116D\u11BC
\u1109\u1161\u110B\u116F\u11AF
\u1109\u1161\u110C\u1161\u11BC
\u1109\u1161\u110C\u1165\u11AB
\u1109\u1161\u110C\u1175\u11AB
\u1109\u1161\u110E\u1169\u11AB
\u1109\u1161\u110E\u116E\u11AB\u1100\u1175
\u1109\u1161\u1110\u1161\u11BC
\u1109\u1161\u1110\u116E\u1105\u1175
\u1109\u1161\u1112\u1173\u11AF
\u1109\u1161\u11AB\u1100\u1175\u11AF
\u1109\u1161\u11AB\u1107\u116E\u110B\u1175\u11AB\u1100\u116A
\u1109\u1161\u11AB\u110B\u1165\u11B8
\u1109\u1161\u11AB\u110E\u1162\u11A8
\u1109\u1161\u11AF\u1105\u1175\u11B7
\u1109\u1161\u11AF\u110B\u1175\u11AB
\u1109\u1161\u11AF\u110D\u1161\u11A8
\u1109\u1161\u11B7\u1100\u1168\u1110\u1161\u11BC
\u1109\u1161\u11B7\u1100\u116E\u11A8
\u1109\u1161\u11B7\u1109\u1175\u11B8
\u1109\u1161\u11B7\u110B\u116F\u11AF
\u1109\u1161\u11B7\u110E\u1169\u11AB
\u1109\u1161\u11BC\u1100\u116A\u11AB
\u1109\u1161\u11BC\u1100\u1173\u11B7
\u1109\u1161\u11BC\u1103\u1162
\u1109\u1161\u11BC\u1105\u1172
\u1109\u1161\u11BC\u1107\u1161\u11AB\u1100\u1175
\u1109\u1161\u11BC\u1109\u1161\u11BC
\u1109\u1161\u11BC\u1109\u1175\u11A8
\u1109\u1161\u11BC\u110B\u1165\u11B8
\u1109\u1161\u11BC\u110B\u1175\u11AB
\u1109\u1161\u11BC\u110C\u1161
\u1109\u1161\u11BC\u110C\u1165\u11B7
\u1109\u1161\u11BC\u110E\u1165
\u1109\u1161\u11BC\u110E\u116E
\u1109\u1161\u11BC\u1110\u1162
\u1109\u1161\u11BC\u1111\u116D
\u1109\u1161\u11BC\u1111\u116E\u11B7
\u1109\u1161\u11BC\u1112\u116A\u11BC
\u1109\u1162\u1107\u1167\u11A8
\u1109\u1162\u11A8\u1101\u1161\u11AF
\u1109\u1162\u11A8\u110B\u1167\u11AB\u1111\u1175\u11AF
\u1109\u1162\u11BC\u1100\u1161\u11A8
\u1109\u1162\u11BC\u1106\u1167\u11BC
\u1109\u1162\u11BC\u1106\u116E\u11AF
\u1109\u1162\u11BC\u1107\u1161\u11BC\u1109\u1169\u11BC
\u1109\u1162\u11BC\u1109\u1161\u11AB
\u1109\u1162\u11BC\u1109\u1165\u11AB
\u1109\u1162\u11BC\u1109\u1175\u11AB
\u1109\u1162\u11BC\u110B\u1175\u11AF
\u1109\u1162\u11BC\u1112\u116A\u11AF
\u1109\u1165\u1105\u1161\u11B8
\u1109\u1165\u1105\u1173\u11AB
\u1109\u1165\u1106\u1167\u11BC
\u1109\u1165\u1106\u1175\u11AB
\u1109\u1165\u1107\u1175\u1109\u1173
\u1109\u1165\u110B\u1163\u11BC
\u1109\u1165\u110B\u116E\u11AF
\u1109\u1165\u110C\u1165\u11A8
\u1109\u1165\u110C\u1165\u11B7
\u1109\u1165\u110D\u1169\u11A8
\u1109\u1165\u110F\u1173\u11AF
\u1109\u1165\u11A8\u1109\u1161
\u1109\u1165\u11A8\u110B\u1172
\u1109\u1165\u11AB\u1100\u1165
\u1109\u1165\u11AB\u1106\u116E\u11AF
\u1109\u1165\u11AB\u1107\u1162
\u1109\u1165\u11AB\u1109\u1162\u11BC
\u1109\u1165\u11AB\u1109\u116E
\u1109\u1165\u11AB\u110B\u116F\u11AB
\u1109\u1165\u11AB\u110C\u1161\u11BC
\u1109\u1165\u11AB\u110C\u1165\u11AB
\u1109\u1165\u11AB\u1110\u1162\u11A8
\u1109\u1165\u11AB\u1111\u116E\u11BC\u1100\u1175
\u1109\u1165\u11AF\u1100\u1165\u110C\u1175
\u1109\u1165\u11AF\u1102\u1161\u11AF
\u1109\u1165\u11AF\u1105\u1165\u11BC\u1110\u1161\u11BC
\u1109\u1165\u11AF\u1106\u1167\u11BC
\u1109\u1165\u11AF\u1106\u116E\u11AB
\u1109\u1165\u11AF\u1109\u1161
\u1109\u1165\u11AF\u110B\u1161\u11A8\u1109\u1161\u11AB
\u1109\u1165\u11AF\u110E\u1175
\u1109\u1165\u11AF\u1110\u1161\u11BC
\u1109\u1165\u11B8\u110A\u1175
\u1109\u1165\u11BC\u1100\u1169\u11BC
\u1109\u1165\u11BC\u1103\u1161\u11BC
\u1109\u1165\u11BC\u1106\u1167\u11BC
\u1109\u1165\u11BC\u1107\u1167\u11AF
\u1109\u1165\u11BC\u110B\u1175\u11AB
\u1109\u1165\u11BC\u110C\u1161\u11BC
\u1109\u1165\u11BC\u110C\u1165\u11A8
\u1109\u1165\u11BC\u110C\u1175\u11AF
\u1109\u1165\u11BC\u1112\u1161\u11B7
\u1109\u1166\u1100\u1173\u11B7
\u1109\u1166\u1106\u1175\u1102\u1161
\u1109\u1166\u1109\u1161\u11BC
\u1109\u1166\u110B\u116F\u11AF
\u1109\u1166\u110C\u1169\u11BC\u1103\u1162\u110B\u116A\u11BC
\u1109\u1166\u1110\u1161\u11A8
\u1109\u1166\u11AB\u1110\u1165
\u1109\u1166\u11AB\u1110\u1175\u1106\u1175\u1110\u1165
\u1109\u1166\u11BA\u110D\u1162
\u1109\u1169\u1100\u1172\u1106\u1169
\u1109\u1169\u1100\u1173\u11A8\u110C\u1165\u11A8
\u1109\u1169\u1100\u1173\u11B7
\u1109\u1169\u1102\u1161\u1100\u1175
\u1109\u1169\u1102\u1167\u11AB
\u1109\u1169\u1103\u1173\u11A8
\u1109\u1169\u1106\u1161\u11BC
\u1109\u1169\u1106\u116E\u11AB
\u1109\u1169\u1109\u1165\u11AF
\u1109\u1169\u1109\u1169\u11A8
\u1109\u1169\u110B\u1161\u1100\u116A
\u1109\u1169\u110B\u116D\u11BC
\u1109\u1169\u110B\u116F\u11AB
\u1109\u1169\u110B\u1173\u11B7
\u1109\u1169\u110C\u116E\u11BC\u1112\u1175
\u1109\u1169\u110C\u1175\u1111\u116E\u11B7
\u1109\u1169\u110C\u1175\u11AF
\u1109\u1169\u1111\u116E\u11BC
\u1109\u1169\u1112\u1167\u11BC
\u1109\u1169\u11A8\u1103\u1161\u11B7
\u1109\u1169\u11A8\u1103\u1169
\u1109\u1169\u11A8\u110B\u1169\u11BA
\u1109\u1169\u11AB\u1100\u1161\u1105\u1161\u11A8
\u1109\u1169\u11AB\u1100\u1175\u11AF
\u1109\u1169\u11AB\u1102\u1167
\u1109\u1169\u11AB\u1102\u1175\u11B7
\u1109\u1169\u11AB\u1103\u1173\u11BC
\u1109\u1169\u11AB\u1106\u1169\u11A8
\u1109\u1169\u11AB\u1108\u1167\u11A8
\u1109\u1169\u11AB\u1109\u1175\u11AF
\u1109\u1169\u11AB\u110C\u1175\u11AF
\u1109\u1169\u11AB\u1110\u1169\u11B8
\u1109\u1169\u11AB\u1112\u1162
\u1109\u1169\u11AF\u110C\u1175\u11A8\u1112\u1175
\u1109\u1169\u11B7\u110A\u1175
\u1109\u1169\u11BC\u110B\u1161\u110C\u1175
\u1109\u1169\u11BC\u110B\u1175
\u1109\u1169\u11BC\u1111\u1167\u11AB
\u1109\u116C\u1100\u1169\u1100\u1175
\u1109\u116D\u1111\u1175\u11BC
\u1109\u116E\u1100\u1165\u11AB
\u1109\u116E\u1102\u1167\u11AB
\u1109\u116E\u1103\u1161\u11AB
\u1109\u116E\u1103\u1169\u11BA\u1106\u116E\u11AF
\u1109\u116E\u1103\u1169\u11BC\u110C\u1165\u11A8
\u1109\u116E\u1106\u1167\u11AB
\u1109\u116E\u1106\u1167\u11BC
\u1109\u116E\u1107\u1161\u11A8
\u1109\u116E\u1109\u1161\u11BC
\u1109\u116E\u1109\u1165\u11A8
\u1109\u116E\u1109\u116E\u11AF
\u1109\u116E\u1109\u1175\u1105\u1169
\u1109\u116E\u110B\u1165\u11B8
\u1109\u116E\u110B\u1167\u11B7
\u1109\u116E\u110B\u1167\u11BC
\u1109\u116E\u110B\u1175\u11B8
\u1109\u116E\u110C\u116E\u11AB
\u1109\u116E\u110C\u1175\u11B8
\u1109\u116E\u110E\u116E\u11AF
\u1109\u116E\u110F\u1165\u11BA
\u1109\u116E\u1111\u1175\u11AF
\u1109\u116E\u1112\u1161\u11A8
\u1109\u116E\u1112\u1165\u11B7\u1109\u1162\u11BC
\u1109\u116E\u1112\u116A\u1100\u1175
\u1109\u116E\u11A8\u1102\u1167
\u1109\u116E\u11A8\u1109\u1169
\u1109\u116E\u11A8\u110C\u1166
\u1109\u116E\u11AB\u1100\u1161\u11AB
\u1109\u116E\u11AB\u1109\u1165
\u1109\u116E\u11AB\u1109\u116E
\u1109\u116E\u11AB\u1109\u1175\u11A8\u1100\u1161\u11AB
\u1109\u116E\u11AB\u110B\u1171
\u1109\u116E\u11AE\u1100\u1161\u1105\u1161\u11A8
\u1109\u116E\u11AF\u1107\u1167\u11BC
\u1109\u116E\u11AF\u110C\u1175\u11B8
\u1109\u116E\u11BA\u110C\u1161
\u1109\u1173\u1102\u1175\u11B7
\u1109\u1173\u1106\u116E\u11AF
\u1109\u1173\u1109\u1173\u1105\u1169
\u1109\u1173\u1109\u1173\u11BC
\u1109\u1173\u110B\u1170\u1110\u1165
\u1109\u1173\u110B\u1171\u110E\u1175
\u1109\u1173\u110F\u1166\u110B\u1175\u1110\u1173
\u1109\u1173\u1110\u1172\u1103\u1175\u110B\u1169
\u1109\u1173\u1110\u1173\u1105\u1166\u1109\u1173
\u1109\u1173\u1111\u1169\u110E\u1173
\u1109\u1173\u11AF\u110D\u1165\u11A8
\u1109\u1173\u11AF\u1111\u1173\u11B7
\u1109\u1173\u11B8\u1100\u116A\u11AB
\u1109\u1173\u11B8\u1100\u1175
\u1109\u1173\u11BC\u1100\u1162\u11A8
\u1109\u1173\u11BC\u1105\u1175
\u1109\u1173\u11BC\u1107\u116E
\u1109\u1173\u11BC\u110B\u116D\u11BC\u110E\u1161
\u1109\u1173\u11BC\u110C\u1175\u11AB
\u1109\u1175\u1100\u1161\u11A8
\u1109\u1175\u1100\u1161\u11AB
\u1109\u1175\u1100\u1169\u11AF
\u1109\u1175\u1100\u1173\u11B7\u110E\u1175
\u1109\u1175\u1102\u1161\u1105\u1175\u110B\u1169
\u1109\u1175\u1103\u1162\u11A8
\u1109\u1175\u1105\u1175\u110C\u1173
\u1109\u1175\u1106\u1166\u11AB\u1110\u1173
\u1109\u1175\u1106\u1175\u11AB
\u1109\u1175\u1107\u116E\u1106\u1169
\u1109\u1175\u1109\u1165\u11AB
\u1109\u1175\u1109\u1165\u11AF
\u1109\u1175\u1109\u1173\u1110\u1166\u11B7
\u1109\u1175\u110B\u1161\u1107\u1165\u110C\u1175
\u1109\u1175\u110B\u1165\u1106\u1165\u1102\u1175
\u1109\u1175\u110B\u116F\u11AF
\u1109\u1175\u110B\u1175\u11AB
\u1109\u1175\u110B\u1175\u11AF
\u1109\u1175\u110C\u1161\u11A8
\u1109\u1175\u110C\u1161\u11BC
\u1109\u1175\u110C\u1165\u11AF
\u1109\u1175\u110C\u1165\u11B7
\u1109\u1175\u110C\u116E\u11BC
\u1109\u1175\u110C\u1173\u11AB
\u1109\u1175\u110C\u1175\u11B8
\u1109\u1175\u110E\u1165\u11BC
\u1109\u1175\u1112\u1161\u11B8
\u1109\u1175\u1112\u1165\u11B7
\u1109\u1175\u11A8\u1100\u116E
\u1109\u1175\u11A8\u1100\u1175
\u1109\u1175\u11A8\u1103\u1161\u11BC
\u1109\u1175\u11A8\u1105\u1163\u11BC
\u1109\u1175\u11A8\u1105\u116D\u1111\u116E\u11B7
\u1109\u1175\u11A8\u1106\u116E\u11AF
\u1109\u1175\u11A8\u1108\u1161\u11BC
\u1109\u1175\u11A8\u1109\u1161
\u1109\u1175\u11A8\u1109\u1162\u11BC\u1112\u116A\u11AF
\u1109\u1175\u11A8\u110E\u1169
\u1109\u1175\u11A8\u1110\u1161\u11A8
\u1109\u1175\u11A8\u1111\u116E\u11B7
\u1109\u1175\u11AB\u1100\u1169
\u1109\u1175\u11AB\u1100\u1172
\u1109\u1175\u11AB\u1102\u1167\u11B7
\u1109\u1175\u11AB\u1106\u116E\u11AB
\u1109\u1175\u11AB\u1107\u1161\u11AF
\u1109\u1175\u11AB\u1107\u1175
\u1109\u1175\u11AB\u1109\u1161
\u1109\u1175\u11AB\u1109\u1166
\u1109\u1175\u11AB\u110B\u116D\u11BC
\u1109\u1175\u11AB\u110C\u1166\u1111\u116E\u11B7
\u1109\u1175\u11AB\u110E\u1165\u11BC
\u1109\u1175\u11AB\u110E\u1166
\u1109\u1175\u11AB\u1112\u116A
\u1109\u1175\u11AF\u1100\u1161\u11B7
\u1109\u1175\u11AF\u1102\u1162
\u1109\u1175\u11AF\u1105\u1167\u11A8
\u1109\u1175\u11AF\u1105\u1168
\u1109\u1175\u11AF\u1106\u1161\u11BC
\u1109\u1175\u11AF\u1109\u116E
\u1109\u1175\u11AF\u1109\u1173\u11B8
\u1109\u1175\u11AF\u1109\u1175
\u1109\u1175\u11AF\u110C\u1161\u11BC
\u1109\u1175\u11AF\u110C\u1165\u11BC
\u1109\u1175\u11AF\u110C\u1175\u11AF\u110C\u1165\u11A8
\u1109\u1175\u11AF\u110E\u1165\u11AB
\u1109\u1175\u11AF\u110E\u1166
\u1109\u1175\u11AF\u110F\u1165\u11BA
\u1109\u1175\u11AF\u1110\u1162
\u1109\u1175\u11AF\u1111\u1162
\u1109\u1175\u11AF\u1112\u1165\u11B7
\u1109\u1175\u11AF\u1112\u1167\u11AB
\u1109\u1175\u11B7\u1105\u1175
\u1109\u1175\u11B7\u1107\u116E\u1105\u1173\u11B7
\u1109\u1175\u11B7\u1109\u1161
\u1109\u1175\u11B7\u110C\u1161\u11BC
\u1109\u1175\u11B7\u110C\u1165\u11BC
\u1109\u1175\u11B7\u1111\u1161\u11AB
\u110A\u1161\u11BC\u1103\u116E\u11BC\u110B\u1175
\u110A\u1175\u1105\u1173\u11B7
\u110A\u1175\u110B\u1161\u11BA
\u110B\u1161\u1100\u1161\u110A\u1175
\u110B\u1161\u1102\u1161\u110B\u116E\u11AB\u1109\u1165
\u110B\u1161\u1103\u1173\u1102\u1175\u11B7
\u110B\u1161\u1103\u1173\u11AF
\u110B\u1161\u1109\u1171\u110B\u116E\u11B7
\u110B\u1161\u1109\u1173\u1111\u1161\u11AF\u1110\u1173
\u110B\u1161\u1109\u1175\u110B\u1161
\u110B\u1161\u110B\u116E\u11AF\u1105\u1165
\u110B\u1161\u110C\u1165\u110A\u1175
\u110B\u1161\u110C\u116E\u11B7\u1106\u1161
\u110B\u1161\u110C\u1175\u11A8
\u110B\u1161\u110E\u1175\u11B7
\u110B\u1161\u1111\u1161\u1110\u1173
\u110B\u1161\u1111\u1173\u1105\u1175\u110F\u1161
\u110B\u1161\u1111\u1173\u11B7
\u110B\u1161\u1112\u1169\u11B8
\u110B\u1161\u1112\u1173\u11AB
\u110B\u1161\u11A8\u1100\u1175
\u110B\u1161\u11A8\u1106\u1169\u11BC
\u110B\u1161\u11A8\u1109\u116E
\u110B\u1161\u11AB\u1100\u1162
\u110B\u1161\u11AB\u1100\u1167\u11BC
\u110B\u1161\u11AB\u1100\u116A
\u110B\u1161\u11AB\u1102\u1162
\u110B\u1161\u11AB\u1102\u1167\u11BC
\u110B\u1161\u11AB\u1103\u1169\u11BC
\u110B\u1161\u11AB\u1107\u1161\u11BC
\u110B\u1161\u11AB\u1107\u116E
\u110B\u1161\u11AB\u110C\u116E
\u110B\u1161\u11AF\u1105\u116E\u1106\u1175\u1102\u1172\u11B7
\u110B\u1161\u11AF\u110F\u1169\u110B\u1169\u11AF
\u110B\u1161\u11B7\u1109\u1175
\u110B\u1161\u11B7\u110F\u1165\u11BA
\u110B\u1161\u11B8\u1105\u1167\u11A8
\u110B\u1161\u11C1\u1102\u1161\u11AF
\u110B\u1161\u11C1\u1106\u116E\u11AB
\u110B\u1162\u110B\u1175\u11AB
\u110B\u1162\u110C\u1165\u11BC
\u110B\u1162\u11A8\u1109\u116E
\u110B\u1162\u11AF\u1107\u1165\u11B7
\u110B\u1163\u1100\u1161\u11AB
\u110B\u1163\u1103\u1161\u11AB
\u110B\u1163\u110B\u1169\u11BC
\u110B\u1163\u11A8\u1100\u1161\u11AB
\u110B\u1163\u11A8\u1100\u116E\u11A8
\u110B\u1163\u11A8\u1109\u1169\u11A8
\u110B\u1163\u11A8\u1109\u116E
\u110B\u1163\u11A8\u110C\u1165\u11B7
\u110B\u1163\u11A8\u1111\u116E\u11B7
\u110B\u1163\u11A8\u1112\u1169\u11AB\u1102\u1167
\u110B\u1163\u11BC\u1102\u1167\u11B7
\u110B\u1163\u11BC\u1105\u1167\u11A8
\u110B\u1163\u11BC\u1106\u1161\u11AF
\u110B\u1163\u11BC\u1107\u1162\u110E\u116E
\u110B\u1163\u11BC\u110C\u116E
\u110B\u1163\u11BC\u1111\u1161
\u110B\u1165\u1103\u116E\u11B7
\u110B\u1165\u1105\u1167\u110B\u116E\u11B7
\u110B\u1165\u1105\u1173\u11AB
\u110B\u1165\u110C\u1166\u11BA\u1107\u1161\u11B7
\u110B\u1165\u110D\u1162\u11BB\u1103\u1173\u11AB
\u110B\u1165\u110D\u1165\u1103\u1161\u1100\u1161
\u110B\u1165\u110D\u1165\u11AB\u110C\u1175
\u110B\u1165\u11AB\u1102\u1175
\u110B\u1165\u11AB\u1103\u1165\u11A8
\u110B\u1165\u11AB\u1105\u1169\u11AB
\u110B\u1165\u11AB\u110B\u1165
\u110B\u1165\u11AF\u1100\u116E\u11AF
\u110B\u1165\u11AF\u1105\u1173\u11AB
\u110B\u1165\u11AF\u110B\u1173\u11B7
\u110B\u1165\u11AF\u1111\u1175\u11BA
\u110B\u1165\u11B7\u1106\u1161
\u110B\u1165\u11B8\u1106\u116E
\u110B\u1165\u11B8\u110C\u1169\u11BC
\u110B\u1165\u11B8\u110E\u1166
\u110B\u1165\u11BC\u1103\u1165\u11BC\u110B\u1175
\u110B\u1165\u11BC\u1106\u1161\u11BC
\u110B\u1165\u11BC\u1110\u1165\u1105\u1175
\u110B\u1165\u11BD\u1100\u1173\u110C\u1166
\u110B\u1166\u1102\u1165\u110C\u1175
\u110B\u1166\u110B\u1165\u110F\u1165\u11AB
\u110B\u1166\u11AB\u110C\u1175\u11AB
\u110B\u1167\u1100\u1165\u11AB
\u110B\u1167\u1100\u1169\u1109\u1162\u11BC
\u110B\u1167\u1100\u116A\u11AB
\u110B\u1167\u1100\u116E\u11AB
\u110B\u1167\u1100\u116F\u11AB
\u110B\u1167\u1103\u1162\u1109\u1162\u11BC
\u110B\u1167\u1103\u1165\u11B2
\u110B\u1167\u1103\u1169\u11BC\u1109\u1162\u11BC
\u110B\u1167\u1103\u1173\u11AB
\u110B\u1167\u1105\u1169\u11AB
\u110B\u1167\u1105\u1173\u11B7
\u110B\u1167\u1109\u1165\u11BA
\u110B\u1167\u1109\u1165\u11BC
\u110B\u1167\u110B\u116A\u11BC
\u110B\u1167\u110B\u1175\u11AB
\u110B\u1167\u110C\u1165\u11AB\u1112\u1175
\u110B\u1167\u110C\u1175\u11A8\u110B\u116F\u11AB
\u110B\u1167\u1112\u1161\u11A8\u1109\u1162\u11BC
\u110B\u1167\u1112\u1162\u11BC
\u110B\u1167\u11A8\u1109\u1161
\u110B\u1167\u11A8\u1109\u1175
\u110B\u1167\u11A8\u1112\u1161\u11AF
\u110B\u1167\u11AB\u1100\u1167\u11AF
\u110B\u1167\u11AB\u1100\u116E
\u110B\u1167\u11AB\u1100\u1173\u11A8
\u110B\u1167\u11AB\u1100\u1175
\u110B\u1167\u11AB\u1105\u1161\u11A8
\u110B\u1167\u11AB\u1109\u1165\u11AF
\u110B\u1167\u11AB\u1109\u1166
\u110B\u1167\u11AB\u1109\u1169\u11A8
\u110B\u1167\u11AB\u1109\u1173\u11B8
\u110B\u1167\u11AB\u110B\u1162
\u110B\u1167\u11AB\u110B\u1168\u110B\u1175\u11AB
\u110B\u1167\u11AB\u110B\u1175\u11AB
\u110B\u1167\u11AB\u110C\u1161\u11BC
\u110B\u1167\u11AB\u110C\u116E
\u110B\u1167\u11AB\u110E\u116E\u11AF
\u110B\u1167\u11AB\u1111\u1175\u11AF
\u110B\u1167\u11AB\u1112\u1161\u11B8
\u110B\u1167\u11AB\u1112\u1172
\u110B\u1167\u11AF\u1100\u1175
\u110B\u1167\u11AF\u1106\u1162
\u110B\u1167\u11AF\u1109\u116C
\u110B\u1167\u11AF\u1109\u1175\u11B7\u1112\u1175
\u110B\u1167\u11AF\u110C\u1165\u11BC
\u110B\u1167\u11AF\u110E\u1161
\u110B\u1167\u11AF\u1112\u1173\u11AF
\u110B\u1167\u11B7\u1105\u1167
\u110B\u1167\u11B8\u1109\u1165
\u110B\u1167\u11BC\u1100\u116E\u11A8
\u110B\u1167\u11BC\u1102\u1161\u11B7
\u110B\u1167\u11BC\u1109\u1161\u11BC
\u110B\u1167\u11BC\u110B\u1163\u11BC
\u110B\u1167\u11BC\u110B\u1167\u11A8
\u110B\u1167\u11BC\u110B\u116E\u11BC
\u110B\u1167\u11BC\u110B\u116F\u11AB\u1112\u1175
\u110B\u1167\u11BC\u1112\u1161
\u110B\u1167\u11BC\u1112\u1163\u11BC
\u110B\u1167\u11BC\u1112\u1169\u11AB
\u110B\u1167\u11BC\u1112\u116A
\u110B\u1167\u11C1\u1100\u116E\u1105\u1175
\u110B\u1167\u11C1\u1107\u1161\u11BC
\u110B\u1167\u11C1\u110C\u1175\u11B8
\u110B\u1168\u1100\u1161\u11B7
\u110B\u1168\u1100\u1173\u11B7
\u110B\u1168\u1107\u1161\u11BC
\u110B\u1168\u1109\u1161\u11AB
\u110B\u1168\u1109\u1161\u11BC
\u110B\u1168\u1109\u1165\u11AB
\u110B\u1168\u1109\u116E\u11AF
\u110B\u1168\u1109\u1173\u11B8
\u110B\u1168\u1109\u1175\u11A8\u110C\u1161\u11BC
\u110B\u1168\u110B\u1163\u11A8
\u110B\u1168\u110C\u1165\u11AB
\u110B\u1168\u110C\u1165\u11AF
\u110B\u1168\u110C\u1165\u11BC
\u110B\u1168\u110F\u1165\u11AB\u1103\u1162
\u110B\u1168\u11BA\u1102\u1161\u11AF
\u110B\u1169\u1102\u1173\u11AF
\u110B\u1169\u1105\u1161\u11A8
\u110B\u1169\u1105\u1162\u11BA\u1103\u1169\u11BC\u110B\u1161\u11AB
\u110B\u1169\u1105\u1166\u11AB\u110C\u1175
\u110B\u1169\u1105\u1169\u110C\u1175
\u110B\u1169\u1105\u1173\u11AB\u1107\u1161\u11AF
\u110B\u1169\u1107\u1173\u11AB
\u110B\u1169\u1109\u1175\u11B8
\u110B\u1169\u110B\u1167\u11B7
\u110B\u1169\u110B\u116F\u11AF
\u110B\u1169\u110C\u1165\u11AB
\u110B\u1169\u110C\u1175\u11A8
\u110B\u1169\u110C\u1175\u11BC\u110B\u1165
\u110B\u1169\u1111\u1166\u1105\u1161
\u110B\u1169\u1111\u1175\u1109\u1173\u1110\u1166\u11AF
\u110B\u1169\u1112\u1175\u1105\u1167
\u110B\u1169\u11A8\u1109\u1161\u11BC
\u110B\u1169\u11A8\u1109\u116E\u1109\u116E
\u110B\u1169\u11AB\u1100\u1161\u11BD
\u110B\u1169\u11AB\u1105\u1161\u110B\u1175\u11AB
\u110B\u1169\u11AB\u1106\u1169\u11B7
\u110B\u1169\u11AB\u110C\u1169\u11BC\u110B\u1175\u11AF
\u110B\u1169\u11AB\u1110\u1169\u11BC
\u110B\u1169\u11AF\u1100\u1161\u110B\u1173\u11AF
\u110B\u1169\u11AF\u1105\u1175\u11B7\u1111\u1175\u11A8
\u110B\u1169\u11AF\u1112\u1162
\u110B\u1169\u11BA\u110E\u1161\u1105\u1175\u11B7
\u110B\u116A\u110B\u1175\u1109\u1167\u110E\u1173
\u110B\u116A\u110B\u1175\u11AB
\u110B\u116A\u11AB\u1109\u1165\u11BC
\u110B\u116A\u11AB\u110C\u1165\u11AB
\u110B\u116A\u11BC\u1107\u1175
\u110B\u116A\u11BC\u110C\u1161
\u110B\u116B\u1102\u1163\u1112\u1161\u1106\u1167\u11AB
\u110B\u116B\u11AB\u110C\u1175
\u110B\u116C\u1100\u1161\u11BA\u110C\u1175\u11B8
\u110B\u116C\u1100\u116E\u11A8
\u110B\u116C\u1105\u1169\u110B\u116E\u11B7
\u110B\u116C\u1109\u1161\u11B7\u110E\u1169\u11AB
\u110B\u116C\u110E\u116E\u11AF
\u110B\u116C\u110E\u1175\u11B7
\u110B\u116C\u1112\u1161\u11AF\u1106\u1165\u1102\u1175
\u110B\u116C\u11AB\u1107\u1161\u11AF
\u110B\u116C\u11AB\u1109\u1169\u11AB
\u110B\u116C\u11AB\u110D\u1169\u11A8
\u110B\u116D\u1100\u1173\u11B7
\u110B\u116D\u110B\u1175\u11AF
\u110B\u116D\u110C\u1173\u11B7
\u110B\u116D\u110E\u1165\u11BC
\u110B\u116D\u11BC\u1100\u1175
\u110B\u116D\u11BC\u1109\u1165
\u110B\u116D\u11BC\u110B\u1165
\u110B\u116E\u1109\u1161\u11AB
\u110B\u116E\u1109\u1165\u11AB
\u110B\u116E\u1109\u1173\u11BC
\u110B\u116E\u110B\u1167\u11AB\u1112\u1175
\u110B\u116E\u110C\u1165\u11BC
\u110B\u116E\u110E\u1166\u1100\u116E\u11A8
\u110B\u116E\u1111\u1167\u11AB
\u110B\u116E\u11AB\u1103\u1169\u11BC
\u110B\u116E\u11AB\u1106\u1167\u11BC
\u110B\u116E\u11AB\u1107\u1161\u11AB
\u110B\u116E\u11AB\u110C\u1165\u11AB
\u110B\u116E\u11AB\u1112\u1162\u11BC
\u110B\u116E\u11AF\u1109\u1161\u11AB
\u110B\u116E\u11AF\u110B\u1173\u11B7
\u110B\u116E\u11B7\u110C\u1175\u11A8\u110B\u1175\u11B7
\u110B\u116E\u11BA\u110B\u1165\u1105\u1173\u11AB
\u110B\u116E\u11BA\u110B\u1173\u11B7
\u110B\u116F\u1102\u1161\u11A8
\u110B\u116F\u11AB\u1100\u1169
\u110B\u116F\u11AB\u1105\u1162
\u110B\u116F\u11AB\u1109\u1165
\u110B\u116F\u11AB\u1109\u116E\u11BC\u110B\u1175
\u110B\u116F\u11AB\u110B\u1175\u11AB
\u110B\u116F\u11AB\u110C\u1161\u11BC
\u110B\u116F\u11AB\u1111\u1175\u1109\u1173
\u110B\u116F\u11AF\u1100\u1173\u11B8
\u110B\u116F\u11AF\u1103\u1173\u110F\u1165\u11B8
\u110B\u116F\u11AF\u1109\u1166
\u110B\u116F\u11AF\u110B\u116D\u110B\u1175\u11AF
\u110B\u1170\u110B\u1175\u1110\u1165
\u110B\u1171\u1107\u1161\u11AB
\u110B\u1171\u1107\u1165\u11B8
\u110B\u1171\u1109\u1165\u11BC
\u110B\u1171\u110B\u116F\u11AB
\u110B\u1171\u1112\u1165\u11B7
\u110B\u1171\u1112\u1167\u11B8
\u110B\u1171\u11BA\u1109\u1161\u1105\u1161\u11B7
\u110B\u1172\u1102\u1161\u11AB\u1112\u1175
\u110B\u1172\u1105\u1165\u11B8
\u110B\u1172\u1106\u1167\u11BC
\u110B\u1172\u1106\u116E\u11AF
\u110B\u1172\u1109\u1161\u11AB
\u110B\u1172\u110C\u1165\u11A8
\u110B\u1172\u110E\u1175\u110B\u116F\u11AB
\u110B\u1172\u1112\u1161\u11A8
\u110B\u1172\u1112\u1162\u11BC
\u110B\u1172\u1112\u1167\u11BC
\u110B\u1172\u11A8\u1100\u116E\u11AB
\u110B\u1172\u11A8\u1109\u1161\u11BC
\u110B\u1172\u11A8\u1109\u1175\u11B8
\u110B\u1172\u11A8\u110E\u1166
\u110B\u1173\u11AB\u1112\u1162\u11BC
\u110B\u1173\u11B7\u1105\u1167\u11A8
\u110B\u1173\u11B7\u1105\u116D
\u110B\u1173\u11B7\u1107\u1161\u11AB
\u110B\u1173\u11B7\u1109\u1165\u11BC
\u110B\u1173\u11B7\u1109\u1175\u11A8
\u110B\u1173\u11B7\u110B\u1161\u11A8
\u110B\u1173\u11B7\u110C\u116E
\u110B\u1174\u1100\u1167\u11AB
\u110B\u1174\u1102\u1169\u11AB
\u110B\u1174\u1106\u116E\u11AB
\u110B\u1174\u1107\u1169\u11A8
\u110B\u1174\u1109\u1175\u11A8
\u110B\u1174\u1109\u1175\u11B7
\u110B\u1174\u110B\u116C\u1105\u1169
\u110B\u1174\u110B\u116D\u11A8
\u110B\u1174\u110B\u116F\u11AB
\u110B\u1174\u1112\u1161\u11A8
\u110B\u1175\u1100\u1165\u11BA
\u110B\u1175\u1100\u1169\u11BA
\u110B\u1175\u1102\u1167\u11B7
\u110B\u1175\u1102\u1169\u11B7
\u110B\u1175\u1103\u1161\u11AF
\u110B\u1175\u1103\u1162\u1105\u1169
\u110B\u1175\u1103\u1169\u11BC
\u110B\u1175\u1105\u1165\u11C2\u1100\u1166
\u110B\u1175\u1105\u1167\u11A8\u1109\u1165
\u110B\u1175\u1105\u1169\u11AB\u110C\u1165\u11A8
\u110B\u1175\u1105\u1173\u11B7
\u110B\u1175\u1106\u1175\u11AB
\u110B\u1175\u1107\u1161\u11AF\u1109\u1169
\u110B\u1175\u1107\u1167\u11AF
\u110B\u1175\u1107\u116E\u11AF
\u110B\u1175\u1108\u1161\u11AF
\u110B\u1175\u1109\u1161\u11BC
\u110B\u1175\u1109\u1165\u11BC
\u110B\u1175\u1109\u1173\u11AF
\u110B\u1175\u110B\u1163\u1100\u1175
\u110B\u1175\u110B\u116D\u11BC
\u110B\u1175\u110B\u116E\u11BA
\u110B\u1175\u110B\u116F\u11AF
\u110B\u1175\u110B\u1173\u11A8\u1100\u1169
\u110B\u1175\u110B\u1175\u11A8
\u110B\u1175\u110C\u1165\u11AB
\u110B\u1175\u110C\u116E\u11BC
\u110B\u1175\u1110\u1173\u11AE\u1102\u1161\u11AF
\u110B\u1175\u1110\u1173\u11AF
\u110B\u1175\u1112\u1169\u11AB
\u110B\u1175\u11AB\u1100\u1161\u11AB
\u110B\u1175\u11AB\u1100\u1167\u11A8
\u110B\u1175\u11AB\u1100\u1169\u11BC
\u110B\u1175\u11AB\u1100\u116E
\u110B\u1175\u11AB\u1100\u1173\u11AB
\u110B\u1175\u11AB\u1100\u1175
\u110B\u1175\u11AB\u1103\u1169
\u110B\u1175\u11AB\u1105\u1172
\u110B\u1175\u11AB\u1106\u116E\u11AF
\u110B\u1175\u11AB\u1109\u1162\u11BC
\u110B\u1175\u11AB\u1109\u116B
\u110B\u1175\u11AB\u110B\u1167\u11AB
\u110B\u1175\u11AB\u110B\u116F\u11AB
\u110B\u1175\u11AB\u110C\u1162
\u110B\u1175\u11AB\u110C\u1169\u11BC
\u110B\u1175\u11AB\u110E\u1165\u11AB
\u110B\u1175\u11AB\u110E\u1166
\u110B\u1175\u11AB\u1110\u1165\u1102\u1166\u11BA
\u110B\u1175\u11AB\u1112\u1161
\u110B\u1175\u11AB\u1112\u1167\u11BC
\u110B\u1175\u11AF\u1100\u1169\u11B8
\u110B\u1175\u11AF\u1100\u1175
\u110B\u1175\u11AF\u1103\u1161\u11AB
\u110B\u1175\u11AF\u1103\u1162
\u110B\u1175\u11AF\u1103\u1173\u11BC
\u110B\u1175\u11AF\u1107\u1161\u11AB
\u110B\u1175\u11AF\u1107\u1169\u11AB
\u110B\u1175\u11AF\u1107\u116E
\u110B\u1175\u11AF\u1109\u1161\u11BC
\u110B\u1175\u11AF\u1109\u1162\u11BC
\u110B\u1175\u11AF\u1109\u1169\u11AB
\u110B\u1175\u11AF\u110B\u116D\u110B\u1175\u11AF
\u110B\u1175\u11AF\u110B\u116F\u11AF
\u110B\u1175\u11AF\u110C\u1165\u11BC
\u110B\u1175\u11AF\u110C\u1169\u11BC
\u110B\u1175\u11AF\u110C\u116E\u110B\u1175\u11AF
\u110B\u1175\u11AF\u110D\u1175\u11A8
\u110B\u1175\u11AF\u110E\u1166
\u110B\u1175\u11AF\u110E\u1175
\u110B\u1175\u11AF\u1112\u1162\u11BC
\u110B\u1175\u11AF\u1112\u116C\u110B\u116D\u11BC
\u110B\u1175\u11B7\u1100\u1173\u11B7
\u110B\u1175\u11B7\u1106\u116E
\u110B\u1175\u11B8\u1103\u1162
\u110B\u1175\u11B8\u1105\u1167\u11A8
\u110B\u1175\u11B8\u1106\u1161\u11BA
\u110B\u1175\u11B8\u1109\u1161
\u110B\u1175\u11B8\u1109\u116E\u11AF
\u110B\u1175\u11B8\u1109\u1175
\u110B\u1175\u11B8\u110B\u116F\u11AB
\u110B\u1175\u11B8\u110C\u1161\u11BC
\u110B\u1175\u11B8\u1112\u1161\u11A8
\u110C\u1161\u1100\u1161\u110B\u116D\u11BC
\u110C\u1161\u1100\u1167\u11A8
\u110C\u1161\u1100\u1173\u11A8
\u110C\u1161\u1103\u1169\u11BC
\u110C\u1161\u1105\u1161\u11BC
\u110C\u1161\u1107\u116E\u1109\u1175\u11B7
\u110C\u1161\u1109\u1175\u11A8
\u110C\u1161\u1109\u1175\u11AB
\u110C\u1161\u110B\u1167\u11AB
\u110C\u1161\u110B\u116F\u11AB
\u110C\u1161\u110B\u1172\u11AF
\u110C\u1161\u110C\u1165\u11AB\u1100\u1165
\u110C\u1161\u110C\u1165\u11BC
\u110C\u1161\u110C\u1169\u11AB\u1109\u1175\u11B7
\u110C\u1161\u1111\u1161\u11AB
\u110C\u1161\u11A8\u1100\u1161
\u110C\u1161\u11A8\u1102\u1167\u11AB
\u110C\u1161\u11A8\u1109\u1165\u11BC
\u110C\u1161\u11A8\u110B\u1165\u11B8
\u110C\u1161\u11A8\u110B\u116D\u11BC
\u110C\u1161\u11A8\u110B\u1173\u11AB\u1104\u1161\u11AF
\u110C\u1161\u11A8\u1111\u116E\u11B7
\u110C\u1161\u11AB\u1103\u1175
\u110C\u1161\u11AB\u1104\u1173\u11A8
\u110C\u1161\u11AB\u110E\u1175
\u110C\u1161\u11AF\u1106\u1169\u11BA
\u110C\u1161\u11B7\u1101\u1161\u11AB
\u110C\u1161\u11B7\u1109\u116E\u1112\u1161\u11B7
\u110C\u1161\u11B7\u1109\u1175
\u110C\u1161\u11B7\u110B\u1169\u11BA
\u110C\u1161\u11B7\u110C\u1161\u1105\u1175
\u110C\u1161\u11B8\u110C\u1175
\u110C\u1161\u11BC\u1100\u116A\u11AB
\u110C\u1161\u11BC\u1100\u116E\u11AB
\u110C\u1161\u11BC\u1100\u1175\u1100\u1161\u11AB
\u110C\u1161\u11BC\u1105\u1162
\u110C\u1161\u11BC\u1105\u1168
\u110C\u1161\u11BC\u1105\u1173
\u110C\u1161\u11BC\u1106\u1161
\u110C\u1161\u11BC\u1106\u1167\u11AB
\u110C\u1161\u11BC\u1106\u1169
\u110C\u1161\u11BC\u1106\u1175
\u110C\u1161\u11BC\u1107\u1175
\u110C\u1161\u11BC\u1109\u1161
\u110C\u1161\u11BC\u1109\u1169
\u110C\u1161\u11BC\u1109\u1175\u11A8
\u110C\u1161\u11BC\u110B\u1162\u110B\u1175\u11AB
\u110C\u1161\u11BC\u110B\u1175\u11AB
\u110C\u1161\u11BC\u110C\u1165\u11B7
\u110C\u1161\u11BC\u110E\u1161
\u110C\u1161\u11BC\u1112\u1161\u11A8\u1100\u1173\u11B7
\u110C\u1162\u1102\u1173\u11BC
\u110C\u1162\u1108\u1161\u11AF\u1105\u1175
\u110C\u1162\u1109\u1161\u11AB
\u110C\u1162\u1109\u1162\u11BC
\u110C\u1162\u110C\u1161\u11A8\u1102\u1167\u11AB
\u110C\u1162\u110C\u1165\u11BC
\u110C\u1162\u110E\u1162\u1100\u1175
\u110C\u1162\u1111\u1161\u11AB
\u110C\u1162\u1112\u1161\u11A8
\u110C\u1162\u1112\u116A\u11AF\u110B\u116D\u11BC
\u110C\u1165\u1100\u1165\u11BA
\u110C\u1165\u1100\u1169\u1105\u1175
\u110C\u1165\u1100\u1169\u11BA
\u110C\u1165\u1102\u1167\u11A8
\u110C\u1165\u1105\u1165\u11AB
\u110C\u1165\u1105\u1165\u11C2\u1100\u1166
\u110C\u1165\u1107\u1165\u11AB
\u110C\u1165\u110B\u116E\u11AF
\u110C\u1165\u110C\u1165\u11AF\u1105\u1169
\u110C\u1165\u110E\u116E\u11A8
\u110C\u1165\u11A8\u1100\u1173\u11A8
\u110C\u1165\u11A8\u1103\u1161\u11BC\u1112\u1175
\u110C\u1165\u11A8\u1109\u1165\u11BC
\u110C\u1165\u11A8\u110B\u116D\u11BC
\u110C\u1165\u11A8\u110B\u1173\u11BC
\u110C\u1165\u11AB\u1100\u1162
\u110C\u1165\u11AB\u1100\u1169\u11BC
\u110C\u1165\u11AB\u1100\u1175
\u110C\u1165\u11AB\u1103\u1161\u11AF
\u110C\u1165\u11AB\u1105\u1161\u1103\u1169
\u110C\u1165\u11AB\u1106\u1161\u11BC
\u110C\u1165\u11AB\u1106\u116E\u11AB
\u110C\u1165\u11AB\u1107\u1161\u11AB
\u110C\u1165\u11AB\u1107\u116E
\u110C\u1165\u11AB\u1109\u1166
\u110C\u1165\u11AB\u1109\u1175
\u110C\u1165\u11AB\u110B\u116D\u11BC
\u110C\u1165\u11AB\u110C\u1161
\u110C\u1165\u11AB\u110C\u1162\u11BC
\u110C\u1165\u11AB\u110C\u116E
\u110C\u1165\u11AB\u110E\u1165\u11AF
\u110C\u1165\u11AB\u110E\u1166
\u110C\u1165\u11AB\u1110\u1169\u11BC
\u110C\u1165\u11AB\u1112\u1167
\u110C\u1165\u11AB\u1112\u116E
\u110C\u1165\u11AF\u1103\u1162
\u110C\u1165\u11AF\u1106\u1161\u11BC
\u110C\u1165\u11AF\u1107\u1161\u11AB
\u110C\u1165\u11AF\u110B\u1163\u11A8
\u110C\u1165\u11AF\u110E\u1161
\u110C\u1165\u11B7\u1100\u1165\u11B7
\u110C\u1165\u11B7\u1109\u116E
\u110C\u1165\u11B7\u1109\u1175\u11B7
\u110C\u1165\u11B7\u110B\u116F\u11AB
\u110C\u1165\u11B7\u110C\u1165\u11B7
\u110C\u1165\u11B7\u110E\u1161
\u110C\u1165\u11B8\u1100\u1173\u11AB
\u110C\u1165\u11B8\u1109\u1175
\u110C\u1165\u11B8\u110E\u1169\u11A8
\u110C\u1165\u11BA\u1100\u1161\u1105\u1161\u11A8
\u110C\u1165\u11BC\u1100\u1165\u110C\u1161\u11BC
\u110C\u1165\u11BC\u1103\u1169
\u110C\u1165\u11BC\u1105\u1172\u110C\u1161\u11BC
\u110C\u1165\u11BC\u1105\u1175
\u110C\u1165\u11BC\u1106\u1161\u11AF
\u110C\u1165\u11BC\u1106\u1167\u11AB
\u110C\u1165\u11BC\u1106\u116E\u11AB
\u110C\u1165\u11BC\u1107\u1161\u11AB\u1103\u1162
\u110C\u1165\u11BC\u1107\u1169
\u110C\u1165\u11BC\u1107\u116E
\u110C\u1165\u11BC\u1107\u1175
\u110C\u1165\u11BC\u1109\u1161\u11BC
\u110C\u1165\u11BC\u1109\u1165\u11BC
\u110C\u1165\u11BC\u110B\u1169
\u110C\u1165\u11BC\u110B\u116F\u11AB
\u110C\u1165\u11BC\u110C\u1161\u11BC
\u110C\u1165\u11BC\u110C\u1175
\u110C\u1165\u11BC\u110E\u1175
\u110C\u1165\u11BC\u1112\u116A\u11A8\u1112\u1175
\u110C\u1166\u1100\u1169\u11BC
\u110C\u1166\u1100\u116A\u110C\u1165\u11B7
\u110C\u1166\u1103\u1162\u1105\u1169
\u110C\u1166\u1106\u1169\u11A8
\u110C\u1166\u1107\u1161\u11AF
\u110C\u1166\u1107\u1165\u11B8
\u110C\u1166\u1109\u1161\u11BA\u1102\u1161\u11AF
\u110C\u1166\u110B\u1161\u11AB
\u110C\u1166\u110B\u1175\u11AF
\u110C\u1166\u110C\u1161\u11A8
\u110C\u1166\u110C\u116E\u1103\u1169
\u110C\u1166\u110E\u116E\u11AF
\u110C\u1166\u1111\u116E\u11B7
\u110C\u1166\u1112\u1161\u11AB
\u110C\u1169\u1100\u1161\u11A8
\u110C\u1169\u1100\u1165\u11AB
\u110C\u1169\u1100\u1173\u11B7
\u110C\u1169\u1100\u1175\u11BC
\u110C\u1169\u1106\u1167\u11BC
\u110C\u1169\u1106\u1175\u1105\u116D
\u110C\u1169\u1109\u1161\u11BC
\u110C\u1169\u1109\u1165\u11AB
\u110C\u1169\u110B\u116D\u11BC\u1112\u1175
\u110C\u1169\u110C\u1165\u11AF
\u110C\u1169\u110C\u1165\u11BC
\u110C\u1169\u110C\u1175\u11A8
\u110C\u1169\u11AB\u1103\u1162\u11BA\u1106\u1161\u11AF
\u110C\u1169\u11AB\u110C\u1162
\u110C\u1169\u11AF\u110B\u1165\u11B8
\u110C\u1169\u11AF\u110B\u1173\u11B7
\u110C\u1169\u11BC\u1100\u116D
\u110C\u1169\u11BC\u1105\u1169
\u110C\u1169\u11BC\u1105\u1172
\u110C\u1169\u11BC\u1109\u1169\u1105\u1175
\u110C\u1169\u11BC\u110B\u1165\u11B8\u110B\u116F\u11AB
\u110C\u1169\u11BC\u110C\u1169\u11BC
\u110C\u1169\u11BC\u1112\u1161\u11B8
\u110C\u116A\u1109\u1165\u11A8
\u110C\u116C\u110B\u1175\u11AB
\u110C\u116E\u1100\u116A\u11AB\u110C\u1165\u11A8
\u110C\u116E\u1105\u1173\u11B7
\u110C\u116E\u1106\u1161\u11AF
\u110C\u116E\u1106\u1165\u1102\u1175
\u110C\u116E\u1106\u1165\u11A8
\u110C\u116E\u1106\u116E\u11AB
\u110C\u116E\u1106\u1175\u11AB
\u110C\u116E\u1107\u1161\u11BC
\u110C\u116E\u1107\u1167\u11AB
\u110C\u116E\u1109\u1175\u11A8
\u110C\u116E\u110B\u1175\u11AB
\u110C\u116E\u110B\u1175\u11AF
\u110C\u116E\u110C\u1161\u11BC
\u110C\u116E\u110C\u1165\u11AB\u110C\u1161
\u110C\u116E\u1110\u1162\u11A8
\u110C\u116E\u11AB\u1107\u1175
\u110C\u116E\u11AF\u1100\u1165\u1105\u1175
\u110C\u116E\u11AF\u1100\u1175
\u110C\u116E\u11AF\u1106\u116E\u1102\u1174
\u110C\u116E\u11BC\u1100\u1161\u11AB
\u110C\u116E\u11BC\u1100\u1168\u1107\u1161\u11BC\u1109\u1169\u11BC
\u110C\u116E\u11BC\u1100\u116E\u11A8
\u110C\u116E\u11BC\u1102\u1167\u11AB
\u110C\u116E\u11BC\u1103\u1161\u11AB
\u110C\u116E\u11BC\u1103\u1169\u11A8
\u110C\u116E\u11BC\u1107\u1161\u11AB
\u110C\u116E\u11BC\u1107\u116E
\u110C\u116E\u11BC\u1109\u1166
\u110C\u116E\u11BC\u1109\u1169\u1100\u1175\u110B\u1165\u11B8
\u110C\u116E\u11BC\u1109\u116E\u11AB
\u110C\u116E\u11BC\u110B\u1161\u11BC
\u110C\u116E\u11BC\u110B\u116D
\u110C\u116E\u11BC\u1112\u1161\u11A8\u1100\u116D
\u110C\u1173\u11A8\u1109\u1165\u11A8
\u110C\u1173\u11A8\u1109\u1175
\u110C\u1173\u11AF\u1100\u1165\u110B\u116E\u11B7
\u110C\u1173\u11BC\u1100\u1161
\u110C\u1173\u11BC\u1100\u1165
\u110C\u1173\u11BC\u1100\u116F\u11AB
\u110C\u1173\u11BC\u1109\u1161\u11BC
\u110C\u1173\u11BC\u1109\u1166
\u110C\u1175\u1100\u1161\u11A8
\u110C\u1175\u1100\u1161\u11B8
\u110C\u1175\u1100\u1167\u11BC
\u110C\u1175\u1100\u1173\u11A8\u1112\u1175
\u110C\u1175\u1100\u1173\u11B7
\u110C\u1175\u1100\u1173\u11B8
\u110C\u1175\u1102\u1173\u11BC
\u110C\u1175\u1105\u1173\u11B7\u1100\u1175\u11AF
\u110C\u1175\u1105\u1175\u1109\u1161\u11AB
\u110C\u1175\u1107\u1161\u11BC
\u110C\u1175\u1107\u116E\u11BC
\u110C\u1175\u1109\u1175\u11A8
\u110C\u1175\u110B\u1167\u11A8
\u110C\u1175\u110B\u116E\u1100\u1162
\u110C\u1175\u110B\u116F\u11AB
\u110C\u1175\u110C\u1165\u11A8
\u110C\u1175\u110C\u1165\u11B7
\u110C\u1175\u110C\u1175\u11AB
\u110C\u1175\u110E\u116E\u11AF
\u110C\u1175\u11A8\u1109\u1165\u11AB
\u110C\u1175\u11A8\u110B\u1165\u11B8
\u110C\u1175\u11A8\u110B\u116F\u11AB
\u110C\u1175\u11A8\u110C\u1161\u11BC
\u110C\u1175\u11AB\u1100\u1173\u11B8
\u110C\u1175\u11AB\u1103\u1169\u11BC
\u110C\u1175\u11AB\u1105\u1169
\u110C\u1175\u11AB\u1105\u116D
\u110C\u1175\u11AB\u1105\u1175
\u110C\u1175\u11AB\u110D\u1161
\u110C\u1175\u11AB\u110E\u1161\u11AF
\u110C\u1175\u11AB\u110E\u116E\u11AF
\u110C\u1175\u11AB\u1110\u1169\u11BC
\u110C\u1175\u11AB\u1112\u1162\u11BC
\u110C\u1175\u11AF\u1106\u116E\u11AB
\u110C\u1175\u11AF\u1107\u1167\u11BC
\u110C\u1175\u11AF\u1109\u1165
\u110C\u1175\u11B7\u110C\u1161\u11A8
\u110C\u1175\u11B8\u1103\u1161\u11AB
\u110C\u1175\u11B8\u110B\u1161\u11AB
\u110C\u1175\u11B8\u110C\u116E\u11BC
\u110D\u1161\u110C\u1173\u11BC
\u110D\u1175\u1101\u1165\u1100\u1175
\u110E\u1161\u1102\u1161\u11B7
\u110E\u1161\u1105\u1161\u1105\u1175
\u110E\u1161\u1105\u1163\u11BC
\u110E\u1161\u1105\u1175\u11B7
\u110E\u1161\u1107\u1167\u11AF
\u110E\u1161\u1109\u1165\u11AB
\u110E\u1161\u110E\u1173\u11B7
\u110E\u1161\u11A8\u1100\u1161\u11A8
\u110E\u1161\u11AB\u1106\u116E\u11AF
\u110E\u1161\u11AB\u1109\u1165\u11BC
\u110E\u1161\u11B7\u1100\u1161
\u110E\u1161\u11B7\u1100\u1175\u1105\u1173\u11B7
\u110E\u1161\u11B7\u1109\u1162
\u110E\u1161\u11B7\u1109\u1165\u11A8
\u110E\u1161\u11B7\u110B\u1167
\u110E\u1161\u11B7\u110B\u116C
\u110E\u1161\u11B7\u110C\u1169
\u110E\u1161\u11BA\u110C\u1161\u11AB
\u110E\u1161\u11BC\u1100\u1161
\u110E\u1161\u11BC\u1100\u1169
\u110E\u1161\u11BC\u1100\u116E
\u110E\u1161\u11BC\u1106\u116E\u11AB
\u110E\u1161\u11BC\u1107\u1161\u11A9
\u110E\u1161\u11BC\u110C\u1161\u11A8
\u110E\u1161\u11BC\u110C\u1169
\u110E\u1162\u1102\u1165\u11AF
\u110E\u1162\u110C\u1165\u11B7
\u110E\u1162\u11A8\u1100\u1161\u1107\u1161\u11BC
\u110E\u1162\u11A8\u1107\u1161\u11BC
\u110E\u1162\u11A8\u1109\u1161\u11BC
\u110E\u1162\u11A8\u110B\u1175\u11B7
\u110E\u1162\u11B7\u1111\u1175\u110B\u1165\u11AB
\u110E\u1165\u1107\u1165\u11AF
\u110E\u1165\u110B\u1173\u11B7
\u110E\u1165\u11AB\u1100\u116E\u11A8
\u110E\u1165\u11AB\u1103\u116E\u11BC
\u110E\u1165\u11AB\u110C\u1161\u11BC
\u110E\u1165\u11AB\u110C\u1162
\u110E\u1165\u11AB\u110E\u1165\u11AB\u1112\u1175
\u110E\u1165\u11AF\u1103\u1169
\u110E\u1165\u11AF\u110C\u1165\u1112\u1175
\u110E\u1165\u11AF\u1112\u1161\u11A8
\u110E\u1165\u11BA\u1102\u1161\u11AF
\u110E\u1165\u11BA\u110D\u1162
\u110E\u1165\u11BC\u1102\u1167\u11AB
\u110E\u1165\u11BC\u1107\u1161\u110C\u1175
\u110E\u1165\u11BC\u1109\u1169
\u110E\u1165\u11BC\u110E\u116E\u11AB
\u110E\u1166\u1100\u1168
\u110E\u1166\u1105\u1167\u11A8
\u110E\u1166\u110B\u1169\u11AB
\u110E\u1166\u110B\u1172\u11A8
\u110E\u1166\u110C\u116E\u11BC
\u110E\u1166\u1112\u1165\u11B7
\u110E\u1169\u1103\u1173\u11BC\u1112\u1161\u11A8\u1109\u1162\u11BC
\u110E\u1169\u1107\u1161\u11AB
\u110E\u1169\u1107\u1161\u11B8
\u110E\u1169\u1109\u1161\u11BC\u1112\u116A
\u110E\u1169\u1109\u116E\u11AB
\u110E\u1169\u110B\u1167\u1105\u1173\u11B7
\u110E\u1169\u110B\u116F\u11AB
\u110E\u1169\u110C\u1165\u1102\u1167\u11A8
\u110E\u1169\u110C\u1165\u11B7
\u110E\u1169\u110E\u1165\u11BC
\u110E\u1169\u110F\u1169\u11AF\u1105\u1175\u11BA
\u110E\u1169\u11BA\u1107\u116E\u11AF
\u110E\u1169\u11BC\u1100\u1161\u11A8
\u110E\u1169\u11BC\u1105\u1175
\u110E\u1169\u11BC\u110C\u1161\u11BC
\u110E\u116A\u11AF\u110B\u1167\u11BC
\u110E\u116C\u1100\u1173\u11AB
\u110E\u116C\u1109\u1161\u11BC
\u110E\u116C\u1109\u1165\u11AB
\u110E\u116C\u1109\u1175\u11AB
\u110E\u116C\u110B\u1161\u11A8
\u110E\u116C\u110C\u1169\u11BC
\u110E\u116E\u1109\u1165\u11A8
\u110E\u116E\u110B\u1165\u11A8
\u110E\u116E\u110C\u1175\u11AB
\u110E\u116E\u110E\u1165\u11AB
\u110E\u116E\u110E\u1173\u11A8
\u110E\u116E\u11A8\u1100\u116E
\u110E\u116E\u11A8\u1109\u1169
\u110E\u116E\u11A8\u110C\u1166
\u110E\u116E\u11A8\u1112\u1161
\u110E\u116E\u11AF\u1100\u1173\u11AB
\u110E\u116E\u11AF\u1107\u1161\u11AF
\u110E\u116E\u11AF\u1109\u1161\u11AB
\u110E\u116E\u11AF\u1109\u1175\u11AB
\u110E\u116E\u11AF\u110B\u1167\u11AB
\u110E\u116E\u11AF\u110B\u1175\u11B8
\u110E\u116E\u11AF\u110C\u1161\u11BC
\u110E\u116E\u11AF\u1111\u1161\u11AB
\u110E\u116E\u11BC\u1100\u1167\u11A8
\u110E\u116E\u11BC\u1100\u1169
\u110E\u116E\u11BC\u1103\u1169\u11AF
\u110E\u116E\u11BC\u1107\u116E\u11AB\u1112\u1175
\u110E\u116E\u11BC\u110E\u1165\u11BC\u1103\u1169
\u110E\u1171\u110B\u1165\u11B8
\u110E\u1171\u110C\u1175\u11A8
\u110E\u1171\u1112\u1163\u11BC
\u110E\u1175\u110B\u1163\u11A8
\u110E\u1175\u11AB\u1100\u116E
\u110E\u1175\u11AB\u110E\u1165\u11A8
\u110E\u1175\u11AF\u1109\u1175\u11B8
\u110E\u1175\u11AF\u110B\u116F\u11AF
\u110E\u1175\u11AF\u1111\u1161\u11AB
\u110E\u1175\u11B7\u1103\u1162
\u110E\u1175\u11B7\u1106\u116E\u11A8
\u110E\u1175\u11B7\u1109\u1175\u11AF
\u110E\u1175\u11BA\u1109\u1169\u11AF
\u110E\u1175\u11BC\u110E\u1161\u11AB
\u110F\u1161\u1106\u1166\u1105\u1161
\u110F\u1161\u110B\u116E\u11AB\u1110\u1165
\u110F\u1161\u11AF\u1100\u116E\u11A8\u1109\u116E
\u110F\u1162\u1105\u1175\u11A8\u1110\u1165
\u110F\u1162\u11B7\u1111\u1165\u1109\u1173
\u110F\u1162\u11B7\u1111\u1166\u110B\u1175\u11AB
\u110F\u1165\u1110\u1173\u11AB
\u110F\u1165\u11AB\u1103\u1175\u1109\u1167\u11AB
\u110F\u1165\u11AF\u1105\u1165
\u110F\u1165\u11B7\u1111\u1172\u1110\u1165
\u110F\u1169\u1101\u1175\u1105\u1175
\u110F\u1169\u1106\u1175\u1103\u1175
\u110F\u1169\u11AB\u1109\u1165\u1110\u1173
\u110F\u1169\u11AF\u1105\u1161
\u110F\u1169\u11B7\u1111\u1173\u11AF\u1105\u1166\u11A8\u1109\u1173
\u110F\u1169\u11BC\u1102\u1161\u1106\u116E\u11AF
\u110F\u116B\u1100\u1161\u11B7
\u110F\u116E\u1103\u1166\u1110\u1161
\u110F\u1173\u1105\u1175\u11B7
\u110F\u1173\u11AB\u1100\u1175\u11AF
\u110F\u1173\u11AB\u1104\u1161\u11AF
\u110F\u1173\u11AB\u1109\u1169\u1105\u1175
\u110F\u1173\u11AB\u110B\u1161\u1103\u1173\u11AF
\u110F\u1173\u11AB\u110B\u1165\u1106\u1165\u1102\u1175
\u110F\u1173\u11AB\u110B\u1175\u11AF
\u110F\u1173\u11AB\u110C\u1165\u11AF
\u110F\u1173\u11AF\u1105\u1162\u1109\u1175\u11A8
\u110F\u1173\u11AF\u1105\u1165\u11B8
\u110F\u1175\u11AF\u1105\u1169
\u1110\u1161\u110B\u1175\u11B8
\u1110\u1161\u110C\u1161\u1100\u1175
\u1110\u1161\u11A8\u1100\u116E
\u1110\u1161\u11A8\u110C\u1161
\u1110\u1161\u11AB\u1109\u1162\u11BC
\u1110\u1162\u1100\u116F\u11AB\u1103\u1169
\u1110\u1162\u110B\u1163\u11BC
\u1110\u1162\u1111\u116E\u11BC
\u1110\u1162\u11A8\u1109\u1175
\u1110\u1162\u11AF\u1105\u1165\u11AB\u1110\u1173
\u1110\u1165\u1102\u1165\u11AF
\u1110\u1165\u1106\u1175\u1102\u1165\u11AF
\u1110\u1166\u1102\u1175\u1109\u1173
\u1110\u1166\u1109\u1173\u1110\u1173
\u1110\u1166\u110B\u1175\u1107\u1173\u11AF
\u1110\u1166\u11AF\u1105\u1166\u1107\u1175\u110C\u1165\u11AB
\u1110\u1169\u1105\u1169\u11AB
\u1110\u1169\u1106\u1161\u1110\u1169
\u1110\u1169\u110B\u116D\u110B\u1175\u11AF
\u1110\u1169\u11BC\u1100\u1168
\u1110\u1169\u11BC\u1100\u116A
\u1110\u1169\u11BC\u1105\u1169
\u1110\u1169\u11BC\u1109\u1175\u11AB
\u1110\u1169\u11BC\u110B\u1167\u11A8
\u1110\u1169\u11BC\u110B\u1175\u11AF
\u1110\u1169\u11BC\u110C\u1161\u11BC
\u1110\u1169\u11BC\u110C\u1166
\u1110\u1169\u11BC\u110C\u1173\u11BC
\u1110\u1169\u11BC\u1112\u1161\u11B8
\u1110\u1169\u11BC\u1112\u116A
\u1110\u116C\u1100\u1173\u11AB
\u1110\u116C\u110B\u116F\u11AB
\u1110\u116C\u110C\u1175\u11A8\u1100\u1173\u11B7
\u1110\u1171\u1100\u1175\u11B7
\u1110\u1173\u1105\u1165\u11A8
\u1110\u1173\u11A8\u1100\u1173\u11B8
\u1110\u1173\u11A8\u1107\u1167\u11AF
\u1110\u1173\u11A8\u1109\u1165\u11BC
\u1110\u1173\u11A8\u1109\u116E
\u1110\u1173\u11A8\u110C\u1175\u11BC
\u1110\u1173\u11A8\u1112\u1175
\u1110\u1173\u11AB\u1110\u1173\u11AB\u1112\u1175
\u1110\u1175\u1109\u1167\u110E\u1173
\u1111\u1161\u1105\u1161\u11AB\u1109\u1162\u11A8
\u1111\u1161\u110B\u1175\u11AF
\u1111\u1161\u110E\u116E\u11AF\u1109\u1169
\u1111\u1161\u11AB\u1100\u1167\u11AF
\u1111\u1161\u11AB\u1103\u1161\u11AB
\u1111\u1161\u11AB\u1106\u1162
\u1111\u1161\u11AB\u1109\u1161
\u1111\u1161\u11AF\u1109\u1175\u11B8
\u1111\u1161\u11AF\u110B\u116F\u11AF
\u1111\u1161\u11B8\u1109\u1169\u11BC
\u1111\u1162\u1109\u1167\u11AB
\u1111\u1162\u11A8\u1109\u1173
\u1111\u1162\u11A8\u1109\u1175\u1106\u1175\u11AF\u1105\u1175
\u1111\u1162\u11AB\u1110\u1175
\u1111\u1165\u1109\u1166\u11AB\u1110\u1173
\u1111\u1166\u110B\u1175\u11AB\u1110\u1173
\u1111\u1167\u11AB\u1100\u1167\u11AB
\u1111\u1167\u11AB\u110B\u1174
\u1111\u1167\u11AB\u110C\u1175
\u1111\u1167\u11AB\u1112\u1175
\u1111\u1167\u11BC\u1100\u1161
\u1111\u1167\u11BC\u1100\u1172\u11AB
\u1111\u1167\u11BC\u1109\u1162\u11BC
\u1111\u1167\u11BC\u1109\u1169
\u1111\u1167\u11BC\u110B\u1163\u11BC
\u1111\u1167\u11BC\u110B\u1175\u11AF
\u1111\u1167\u11BC\u1112\u116A
\u1111\u1169\u1109\u1173\u1110\u1165
\u1111\u1169\u110B\u1175\u11AB\u1110\u1173
\u1111\u1169\u110C\u1161\u11BC
\u1111\u1169\u1112\u1161\u11B7
\u1111\u116D\u1106\u1167\u11AB
\u1111\u116D\u110C\u1165\u11BC
\u1111\u116D\u110C\u116E\u11AB
\u1111\u116D\u1112\u1167\u11AB
\u1111\u116E\u11B7\u1106\u1169\u11A8
\u1111\u116E\u11B7\u110C\u1175\u11AF
\u1111\u116E\u11BC\u1100\u1167\u11BC
\u1111\u116E\u11BC\u1109\u1169\u11A8
\u1111\u116E\u11BC\u1109\u1173\u11B8
\u1111\u1173\u1105\u1161\u11BC\u1109\u1173
\u1111\u1173\u1105\u1175\u11AB\u1110\u1165
\u1111\u1173\u11AF\u1105\u1161\u1109\u1173\u1110\u1175\u11A8
\u1111\u1175\u1100\u1169\u11AB
\u1111\u1175\u1106\u1161\u11BC
\u1111\u1175\u110B\u1161\u1102\u1169
\u1111\u1175\u11AF\u1105\u1173\u11B7
\u1111\u1175\u11AF\u1109\u116E
\u1111\u1175\u11AF\u110B\u116D
\u1111\u1175\u11AF\u110C\u1161
\u1111\u1175\u11AF\u1110\u1169\u11BC
\u1111\u1175\u11BC\u1100\u1168
\u1112\u1161\u1102\u1173\u1102\u1175\u11B7
\u1112\u1161\u1102\u1173\u11AF
\u1112\u1161\u1103\u1173\u110B\u1170\u110B\u1165
\u1112\u1161\u1105\u116E\u11BA\u1107\u1161\u11B7
\u1112\u1161\u1107\u1161\u11AB\u1100\u1175
\u1112\u1161\u1109\u116E\u11A8\u110C\u1175\u11B8
\u1112\u1161\u1109\u116E\u11AB
\u1112\u1161\u110B\u1167\u1110\u1173\u11AB
\u1112\u1161\u110C\u1175\u1106\u1161\u11AB
\u1112\u1161\u110E\u1165\u11AB
\u1112\u1161\u1111\u116E\u11B7
\u1112\u1161\u1111\u1175\u11AF
\u1112\u1161\u11A8\u1100\u116A
\u1112\u1161\u11A8\u1100\u116D
\u1112\u1161\u11A8\u1100\u1173\u11B8
\u1112\u1161\u11A8\u1100\u1175
\u1112\u1161\u11A8\u1102\u1167\u11AB
\u1112\u1161\u11A8\u1105\u1167\u11A8
\u1112\u1161\u11A8\u1107\u1165\u11AB
\u1112\u1161\u11A8\u1107\u116E\u1106\u1169
\u1112\u1161\u11A8\u1107\u1175
\u1112\u1161\u11A8\u1109\u1162\u11BC
\u1112\u1161\u11A8\u1109\u116E\u11AF
\u1112\u1161\u11A8\u1109\u1173\u11B8
\u1112\u1161\u11A8\u110B\u116D\u11BC\u1111\u116E\u11B7
\u1112\u1161\u11A8\u110B\u116F\u11AB
\u1112\u1161\u11A8\u110B\u1171
\u1112\u1161\u11A8\u110C\u1161
\u1112\u1161\u11A8\u110C\u1165\u11B7
\u1112\u1161\u11AB\u1100\u1168
\u1112\u1161\u11AB\u1100\u1173\u11AF
\u1112\u1161\u11AB\u1101\u1165\u1107\u1165\u11AB\u110B\u1166
\u1112\u1161\u11AB\u1102\u1161\u11BD
\u1112\u1161\u11AB\u1102\u116E\u11AB
\u1112\u1161\u11AB\u1103\u1169\u11BC\u110B\u1161\u11AB
\u1112\u1161\u11AB\u1104\u1162
\u1112\u1161\u11AB\u1105\u1161\u1109\u1161\u11AB
\u1112\u1161\u11AB\u1106\u1161\u1103\u1175
\u1112\u1161\u11AB\u1106\u116E\u11AB
\u1112\u1161\u11AB\u1107\u1165\u11AB
\u1112\u1161\u11AB\u1107\u1169\u11A8
\u1112\u1161\u11AB\u1109\u1175\u11A8
\u1112\u1161\u11AB\u110B\u1167\u1105\u1173\u11B7
\u1112\u1161\u11AB\u110D\u1169\u11A8
\u1112\u1161\u11AF\u1106\u1165\u1102\u1175
\u1112\u1161\u11AF\u110B\u1161\u1107\u1165\u110C\u1175
\u1112\u1161\u11AF\u110B\u1175\u11AB
\u1112\u1161\u11B7\u1101\u1166
\u1112\u1161\u11B7\u1107\u116E\u1105\u1169
\u1112\u1161\u11B8\u1100\u1167\u11A8
\u1112\u1161\u11B8\u1105\u1175\u110C\u1165\u11A8
\u1112\u1161\u11BC\u1100\u1169\u11BC
\u1112\u1161\u11BC\u1100\u116E
\u1112\u1161\u11BC\u1109\u1161\u11BC
\u1112\u1161\u11BC\u110B\u1174
\u1112\u1162\u1100\u1167\u11AF
\u1112\u1162\u1100\u116E\u11AB
\u1112\u1162\u1103\u1161\u11B8
\u1112\u1162\u1103\u1161\u11BC
\u1112\u1162\u1106\u116E\u11AF
\u1112\u1162\u1109\u1165\u11A8
\u1112\u1162\u1109\u1165\u11AF
\u1112\u1162\u1109\u116E\u110B\u116D\u11A8\u110C\u1161\u11BC
\u1112\u1162\u110B\u1161\u11AB
\u1112\u1162\u11A8\u1109\u1175\u11B7
\u1112\u1162\u11AB\u1103\u1173\u1107\u1162\u11A8
\u1112\u1162\u11B7\u1107\u1165\u1100\u1165
\u1112\u1162\u11BA\u1107\u1167\u11C0
\u1112\u1162\u11BA\u1109\u1161\u11AF
\u1112\u1162\u11BC\u1103\u1169\u11BC
\u1112\u1162\u11BC\u1107\u1169\u11A8
\u1112\u1162\u11BC\u1109\u1161
\u1112\u1162\u11BC\u110B\u116E\u11AB
\u1112\u1162\u11BC\u110B\u1171
\u1112\u1163\u11BC\u1100\u1175
\u1112\u1163\u11BC\u1109\u1161\u11BC
\u1112\u1163\u11BC\u1109\u116E
\u1112\u1165\u1105\u1161\u11A8
\u1112\u1165\u110B\u116D\u11BC
\u1112\u1166\u11AF\u1100\u1175
\u1112\u1167\u11AB\u1100\u116A\u11AB
\u1112\u1167\u11AB\u1100\u1173\u11B7
\u1112\u1167\u11AB\u1103\u1162
\u1112\u1167\u11AB\u1109\u1161\u11BC
\u1112\u1167\u11AB\u1109\u1175\u11AF
\u1112\u1167\u11AB\u110C\u1161\u11BC
\u1112\u1167\u11AB\u110C\u1162
\u1112\u1167\u11AB\u110C\u1175
\u1112\u1167\u11AF\u110B\u1162\u11A8
\u1112\u1167\u11B8\u1105\u1167\u11A8
\u1112\u1167\u11BC\u1107\u116E
\u1112\u1167\u11BC\u1109\u1161
\u1112\u1167\u11BC\u1109\u116E
\u1112\u1167\u11BC\u1109\u1175\u11A8
\u1112\u1167\u11BC\u110C\u1166
\u1112\u1167\u11BC\u1110\u1162
\u1112\u1167\u11BC\u1111\u1167\u11AB
\u1112\u1168\u1110\u1162\u11A8
\u1112\u1169\u1100\u1175\u1109\u1175\u11B7
\u1112\u1169\u1102\u1161\u11B7
\u1112\u1169\u1105\u1161\u11BC\u110B\u1175
\u1112\u1169\u1107\u1161\u11A8
\u1112\u1169\u1110\u1166\u11AF
\u1112\u1169\u1112\u1173\u11B8
\u1112\u1169\u11A8\u1109\u1175
\u1112\u1169\u11AF\u1105\u1169
\u1112\u1169\u11B7\u1111\u1166\u110B\u1175\u110C\u1175
\u1112\u1169\u11BC\u1107\u1169
\u1112\u1169\u11BC\u1109\u116E
\u1112\u1169\u11BC\u110E\u1161
\u1112\u116A\u1106\u1167\u11AB
\u1112\u116A\u1107\u116E\u11AB
\u1112\u116A\u1109\u1161\u11AF
\u1112\u116A\u110B\u116D\u110B\u1175\u11AF
\u1112\u116A\u110C\u1161\u11BC
\u1112\u116A\u1112\u1161\u11A8
\u1112\u116A\u11A8\u1107\u1169
\u1112\u116A\u11A8\u110B\u1175\u11AB
\u1112\u116A\u11A8\u110C\u1161\u11BC
\u1112\u116A\u11A8\u110C\u1165\u11BC
\u1112\u116A\u11AB\u1100\u1161\u11B8
\u1112\u116A\u11AB\u1100\u1167\u11BC
\u1112\u116A\u11AB\u110B\u1167\u11BC
\u1112\u116A\u11AB\u110B\u1172\u11AF
\u1112\u116A\u11AB\u110C\u1161
\u1112\u116A\u11AF\u1100\u1175
\u1112\u116A\u11AF\u1103\u1169\u11BC
\u1112\u116A\u11AF\u1107\u1161\u11AF\u1112\u1175
\u1112\u116A\u11AF\u110B\u116D\u11BC
\u1112\u116A\u11AF\u110D\u1161\u11A8
\u1112\u116C\u1100\u1167\u11AB
\u1112\u116C\u1100\u116A\u11AB
\u1112\u116C\u1107\u1169\u11A8
\u1112\u116C\u1109\u1162\u11A8
\u1112\u116C\u110B\u116F\u11AB
\u1112\u116C\u110C\u1161\u11BC
\u1112\u116C\u110C\u1165\u11AB
\u1112\u116C\u11BA\u1109\u116E
\u1112\u116C\u11BC\u1103\u1161\u11AB\u1107\u1169\u1103\u1169
\u1112\u116D\u110B\u1172\u11AF\u110C\u1165\u11A8
\u1112\u116E\u1107\u1161\u11AB
\u1112\u116E\u110E\u116E\u11BA\u1100\u1161\u1105\u116E
\u1112\u116E\u11AB\u1105\u1167\u11AB
\u1112\u116F\u11AF\u110A\u1175\u11AB
\u1112\u1172\u1109\u1175\u11A8
\u1112\u1172\u110B\u1175\u11AF
\u1112\u1172\u11BC\u1102\u1162
\u1112\u1173\u1105\u1173\u11B7
\u1112\u1173\u11A8\u1107\u1162\u11A8
\u1112\u1173\u11A8\u110B\u1175\u11AB
\u1112\u1173\u11AB\u110C\u1165\u11A8
\u1112\u1173\u11AB\u1112\u1175
\u1112\u1173\u11BC\u1106\u1175
\u1112\u1173\u11BC\u1107\u116E\u11AB
\u1112\u1174\u1100\u1169\u11A8
\u1112\u1174\u1106\u1161\u11BC
\u1112\u1174\u1109\u1162\u11BC
\u1112\u1174\u11AB\u1109\u1162\u11A8
\u1112\u1175\u11B7\u1101\u1165\u11BA`.split("\n");
// /home/mous/work/pimlico/alto/node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/@scure/bip39/esm/wordlists/simplified-chinese.js
var wordlist7 = `\u7684
\u4E00
\u662F
\u5728
\u4E0D
\u4E86
\u6709
\u548C
\u4EBA
\u8FD9
\u4E2D
\u5927
\u4E3A
\u4E0A
\u4E2A
\u56FD
\u6211
\u4EE5
\u8981
\u4ED6
\u65F6
\u6765
\u7528
\u4EEC
\u751F
\u5230
\u4F5C
\u5730
\u4E8E
\u51FA
\u5C31
\u5206
\u5BF9
\u6210
\u4F1A
\u53EF
\u4E3B
\u53D1
\u5E74
\u52A8
\u540C
\u5DE5
\u4E5F
\u80FD
\u4E0B
\u8FC7
\u5B50
\u8BF4
\u4EA7
\u79CD
\u9762
\u800C
\u65B9
\u540E
\u591A
\u5B9A
\u884C
\u5B66
\u6CD5
\u6240
\u6C11
\u5F97
\u7ECF
\u5341
\u4E09
\u4E4B
\u8FDB
\u7740
\u7B49
\u90E8
\u5EA6
\u5BB6
\u7535
\u529B
\u91CC
\u5982
\u6C34
\u5316
\u9AD8
\u81EA
\u4E8C
\u7406
\u8D77
\u5C0F
\u7269
\u73B0
\u5B9E
\u52A0
\u91CF
\u90FD
\u4E24
\u4F53
\u5236
\u673A
\u5F53
\u4F7F
\u70B9
\u4ECE
\u4E1A
\u672C
\u53BB
\u628A
\u6027
\u597D
\u5E94
\u5F00
\u5B83
\u5408
\u8FD8
\u56E0
\u7531
\u5176
\u4E9B
\u7136
\u524D
\u5916
\u5929
\u653F
\u56DB
\u65E5
\u90A3
\u793E
\u4E49
\u4E8B
\u5E73
\u5F62
\u76F8
\u5168
\u8868
\u95F4
\u6837
\u4E0E
\u5173
\u5404
\u91CD
\u65B0
\u7EBF
\u5185
\u6570
\u6B63
\u5FC3
\u53CD
\u4F60
\u660E
\u770B
\u539F
\u53C8
\u4E48
\u5229
\u6BD4
\u6216
\u4F46
\u8D28
\u6C14
\u7B2C
\u5411
\u9053
\u547D
\u6B64
\u53D8
\u6761
\u53EA
\u6CA1
\u7ED3
\u89E3
\u95EE
\u610F
\u5EFA
\u6708
\u516C
\u65E0
\u7CFB
\u519B
\u5F88
\u60C5
\u8005
\u6700
\u7ACB
\u4EE3
\u60F3
\u5DF2
\u901A
\u5E76
\u63D0
\u76F4
\u9898
\u515A
\u7A0B
\u5C55
\u4E94
\u679C
\u6599
\u8C61
\u5458
\u9769
\u4F4D
\u5165
\u5E38
\u6587
\u603B
\u6B21
\u54C1
\u5F0F
\u6D3B
\u8BBE
\u53CA
\u7BA1
\u7279
\u4EF6
\u957F
\u6C42
\u8001
\u5934
\u57FA
\u8D44
\u8FB9
\u6D41
\u8DEF
\u7EA7
\u5C11
\u56FE
\u5C71
\u7EDF
\u63A5
\u77E5
\u8F83
\u5C06
\u7EC4
\u89C1
\u8BA1
\u522B
\u5979
\u624B
\u89D2
\u671F
\u6839
\u8BBA
\u8FD0
\u519C
\u6307
\u51E0
\u4E5D
\u533A
\u5F3A
\u653E
\u51B3
\u897F
\u88AB
\u5E72
\u505A
\u5FC5
\u6218
\u5148
\u56DE
\u5219
\u4EFB
\u53D6
\u636E
\u5904
\u961F
\u5357
\u7ED9
\u8272
\u5149
\u95E8
\u5373
\u4FDD
\u6CBB
\u5317
\u9020
\u767E
\u89C4
\u70ED
\u9886
\u4E03
\u6D77
\u53E3
\u4E1C
\u5BFC
\u5668
\u538B
\u5FD7
\u4E16
\u91D1
\u589E
\u4E89
\u6D4E
\u9636
\u6CB9
\u601D
\u672F
\u6781
\u4EA4
\u53D7
\u8054
\u4EC0
\u8BA4
\u516D
\u5171
\u6743
\u6536
\u8BC1
\u6539
\u6E05
\u7F8E
\u518D
\u91C7
\u8F6C
\u66F4
\u5355
\u98CE
\u5207
\u6253
\u767D
\u6559
\u901F
\u82B1
\u5E26
\u5B89
\u573A
\u8EAB
\u8F66
\u4F8B
\u771F
\u52A1
\u5177
\u4E07
\u6BCF
\u76EE
\u81F3
\u8FBE
\u8D70
\u79EF
\u793A
\u8BAE
\u58F0
\u62A5
\u6597
\u5B8C
\u7C7B
\u516B
\u79BB
\u534E
\u540D
\u786E
\u624D
\u79D1
\u5F20
\u4FE1
\u9A6C
\u8282
\u8BDD
\u7C73
\u6574
\u7A7A
\u5143
\u51B5
\u4ECA
\u96C6
\u6E29
\u4F20
\u571F
\u8BB8
\u6B65
\u7FA4
\u5E7F
\u77F3
\u8BB0
\u9700
\u6BB5
\u7814
\u754C
\u62C9
\u6797
\u5F8B
\u53EB
\u4E14
\u7A76
\u89C2
\u8D8A
\u7EC7
\u88C5
\u5F71
\u7B97
\u4F4E
\u6301
\u97F3
\u4F17
\u4E66
\u5E03
\u590D
\u5BB9
\u513F
\u987B
\u9645
\u5546
\u975E
\u9A8C
\u8FDE
\u65AD
\u6DF1
\u96BE
\u8FD1
\u77FF
\u5343
\u5468
\u59D4
\u7D20
\u6280
\u5907
\u534A
\u529E
\u9752
\u7701
\u5217
\u4E60
\u54CD
\u7EA6
\u652F
\u822C
\u53F2
\u611F
\u52B3
\u4FBF
\u56E2
\u5F80
\u9178
\u5386
\u5E02
\u514B
\u4F55
\u9664
\u6D88
\u6784
\u5E9C
\u79F0
\u592A
\u51C6
\u7CBE
\u503C
\u53F7
\u7387
\u65CF
\u7EF4
\u5212
\u9009
\u6807
\u5199
\u5B58
\u5019
\u6BDB
\u4EB2
\u5FEB
\u6548
\u65AF
\u9662
\u67E5
\u6C5F
\u578B
\u773C
\u738B
\u6309
\u683C
\u517B
\u6613
\u7F6E
\u6D3E
\u5C42
\u7247
\u59CB
\u5374
\u4E13
\u72B6
\u80B2
\u5382
\u4EAC
\u8BC6
\u9002
\u5C5E
\u5706
\u5305
\u706B
\u4F4F
\u8C03
\u6EE1
\u53BF
\u5C40
\u7167
\u53C2
\u7EA2
\u7EC6
\u5F15
\u542C
\u8BE5
\u94C1
\u4EF7
\u4E25
\u9996
\u5E95
\u6DB2
\u5B98
\u5FB7
\u968F
\u75C5
\u82CF
\u5931
\u5C14
\u6B7B
\u8BB2
\u914D
\u5973
\u9EC4
\u63A8
\u663E
\u8C08
\u7F6A
\u795E
\u827A
\u5462
\u5E2D
\u542B
\u4F01
\u671B
\u5BC6
\u6279
\u8425
\u9879
\u9632
\u4E3E
\u7403
\u82F1
\u6C27
\u52BF
\u544A
\u674E
\u53F0
\u843D
\u6728
\u5E2E
\u8F6E
\u7834
\u4E9A
\u5E08
\u56F4
\u6CE8
\u8FDC
\u5B57
\u6750
\u6392
\u4F9B
\u6CB3
\u6001
\u5C01
\u53E6
\u65BD
\u51CF
\u6811
\u6EB6
\u600E
\u6B62
\u6848
\u8A00
\u58EB
\u5747
\u6B66
\u56FA
\u53F6
\u9C7C
\u6CE2
\u89C6
\u4EC5
\u8D39
\u7D27
\u7231
\u5DE6
\u7AE0
\u65E9
\u671D
\u5BB3
\u7EED
\u8F7B
\u670D
\u8BD5
\u98DF
\u5145
\u5175
\u6E90
\u5224
\u62A4
\u53F8
\u8DB3
\u67D0
\u7EC3
\u5DEE
\u81F4
\u677F
\u7530
\u964D
\u9ED1
\u72AF
\u8D1F
\u51FB
\u8303
\u7EE7
\u5174
\u4F3C
\u4F59
\u575A
\u66F2
\u8F93
\u4FEE
\u6545
\u57CE
\u592B
\u591F
\u9001
\u7B14
\u8239
\u5360
\u53F3
\u8D22
\u5403
\u5BCC
\u6625
\u804C
\u89C9
\u6C49
\u753B
\u529F
\u5DF4
\u8DDF
\u867D
\u6742
\u98DE
\u68C0
\u5438
\u52A9
\u5347
\u9633
\u4E92
\u521D
\u521B
\u6297
\u8003
\u6295
\u574F
\u7B56
\u53E4
\u5F84
\u6362
\u672A
\u8DD1
\u7559
\u94A2
\u66FE
\u7AEF
\u8D23
\u7AD9
\u7B80
\u8FF0
\u94B1
\u526F
\u5C3D
\u5E1D
\u5C04
\u8349
\u51B2
\u627F
\u72EC
\u4EE4
\u9650
\u963F
\u5BA3
\u73AF
\u53CC
\u8BF7
\u8D85
\u5FAE
\u8BA9
\u63A7
\u5DDE
\u826F
\u8F74
\u627E
\u5426
\u7EAA
\u76CA
\u4F9D
\u4F18
\u9876
\u7840
\u8F7D
\u5012
\u623F
\u7A81
\u5750
\u7C89
\u654C
\u7565
\u5BA2
\u8881
\u51B7
\u80DC
\u7EDD
\u6790
\u5757
\u5242
\u6D4B
\u4E1D
\u534F
\u8BC9
\u5FF5
\u9648
\u4ECD
\u7F57
\u76D0
\u53CB
\u6D0B
\u9519
\u82E6
\u591C
\u5211
\u79FB
\u9891
\u9010
\u9760
\u6DF7
\u6BCD
\u77ED
\u76AE
\u7EC8
\u805A
\u6C7D
\u6751
\u4E91
\u54EA
\u65E2
\u8DDD
\u536B
\u505C
\u70C8
\u592E
\u5BDF
\u70E7
\u8FC5
\u5883
\u82E5
\u5370
\u6D32
\u523B
\u62EC
\u6FC0
\u5B54
\u641E
\u751A
\u5BA4
\u5F85
\u6838
\u6821
\u6563
\u4FB5
\u5427
\u7532
\u6E38
\u4E45
\u83DC
\u5473
\u65E7
\u6A21
\u6E56
\u8D27
\u635F
\u9884
\u963B
\u6BEB
\u666E
\u7A33
\u4E59
\u5988
\u690D
\u606F
\u6269
\u94F6
\u8BED
\u6325
\u9152
\u5B88
\u62FF
\u5E8F
\u7EB8
\u533B
\u7F3A
\u96E8
\u5417
\u9488
\u5218
\u554A
\u6025
\u5531
\u8BEF
\u8BAD
\u613F
\u5BA1
\u9644
\u83B7
\u8336
\u9C9C
\u7CAE
\u65A4
\u5B69
\u8131
\u786B
\u80A5
\u5584
\u9F99
\u6F14
\u7236
\u6E10
\u8840
\u6B22
\u68B0
\u638C
\u6B4C
\u6C99
\u521A
\u653B
\u8C13
\u76FE
\u8BA8
\u665A
\u7C92
\u4E71
\u71C3
\u77DB
\u4E4E
\u6740
\u836F
\u5B81
\u9C81
\u8D35
\u949F
\u7164
\u8BFB
\u73ED
\u4F2F
\u9999
\u4ECB
\u8FEB
\u53E5
\u4E30
\u57F9
\u63E1
\u5170
\u62C5
\u5F26
\u86CB
\u6C89
\u5047
\u7A7F
\u6267
\u7B54
\u4E50
\u8C01
\u987A
\u70DF
\u7F29
\u5F81
\u8138
\u559C
\u677E
\u811A
\u56F0
\u5F02
\u514D
\u80CC
\u661F
\u798F
\u4E70
\u67D3
\u4E95
\u6982
\u6162
\u6015
\u78C1
\u500D
\u7956
\u7687
\u4FC3
\u9759
\u8865
\u8BC4
\u7FFB
\u8089
\u8DF5
\u5C3C
\u8863
\u5BBD
\u626C
\u68C9
\u5E0C
\u4F24
\u64CD
\u5782
\u79CB
\u5B9C
\u6C22
\u5957
\u7763
\u632F
\u67B6
\u4EAE
\u672B
\u5BAA
\u5E86
\u7F16
\u725B
\u89E6
\u6620
\u96F7
\u9500
\u8BD7
\u5EA7
\u5C45
\u6293
\u88C2
\u80DE
\u547C
\u5A18
\u666F
\u5A01
\u7EFF
\u6676
\u539A
\u76DF
\u8861
\u9E21
\u5B59
\u5EF6
\u5371
\u80F6
\u5C4B
\u4E61
\u4E34
\u9646
\u987E
\u6389
\u5440
\u706F
\u5C81
\u63AA
\u675F
\u8010
\u5267
\u7389
\u8D75
\u8DF3
\u54E5
\u5B63
\u8BFE
\u51EF
\u80E1
\u989D
\u6B3E
\u7ECD
\u5377
\u9F50
\u4F1F
\u84B8
\u6B96
\u6C38
\u5B97
\u82D7
\u5DDD
\u7089
\u5CA9
\u5F31
\u96F6
\u6768
\u594F
\u6CBF
\u9732
\u6746
\u63A2
\u6ED1
\u9547
\u996D
\u6D53
\u822A
\u6000
\u8D76
\u5E93
\u593A
\u4F0A
\u7075
\u7A0E
\u9014
\u706D
\u8D5B
\u5F52
\u53EC
\u9F13
\u64AD
\u76D8
\u88C1
\u9669
\u5EB7
\u552F
\u5F55
\u83CC
\u7EAF
\u501F
\u7CD6
\u76D6
\u6A2A
\u7B26
\u79C1
\u52AA
\u5802
\u57DF
\u67AA
\u6DA6
\u5E45
\u54C8
\u7ADF
\u719F
\u866B
\u6CFD
\u8111
\u58E4
\u78B3
\u6B27
\u904D
\u4FA7
\u5BE8
\u6562
\u5F7B
\u8651
\u659C
\u8584
\u5EAD
\u7EB3
\u5F39
\u9972
\u4F38
\u6298
\u9EA6
\u6E7F
\u6697
\u8377
\u74E6
\u585E
\u5E8A
\u7B51
\u6076
\u6237
\u8BBF
\u5854
\u5947
\u900F
\u6881
\u5200
\u65CB
\u8FF9
\u5361
\u6C2F
\u9047
\u4EFD
\u6BD2
\u6CE5
\u9000
\u6D17
\u6446
\u7070
\u5F69
\u5356
\u8017
\u590F
\u62E9
\u5FD9
\u94DC
\u732E
\u786C
\u4E88
\u7E41
\u5708
\u96EA
\u51FD
\u4EA6
\u62BD
\u7BC7
\u9635
\u9634
\u4E01
\u5C3A
\u8FFD
\u5806
\u96C4
\u8FCE
\u6CDB
\u7238
\u697C
\u907F
\u8C0B
\u5428
\u91CE
\u732A
\u65D7
\u7D2F
\u504F
\u5178
\u9986
\u7D22
\u79E6
\u8102
\u6F6E
\u7237
\u8C46
\u5FFD
\u6258
\u60CA
\u5851
\u9057
\u6108
\u6731
\u66FF
\u7EA4
\u7C97
\u503E
\u5C1A
\u75DB
\u695A
\u8C22
\u594B
\u8D2D
\u78E8
\u541B
\u6C60
\u65C1
\u788E
\u9AA8
\u76D1
\u6355
\u5F1F
\u66B4
\u5272
\u8D2F
\u6B8A
\u91CA
\u8BCD
\u4EA1
\u58C1
\u987F
\u5B9D
\u5348
\u5C18
\u95FB
\u63ED
\u70AE
\u6B8B
\u51AC
\u6865
\u5987
\u8B66
\u7EFC
\u62DB
\u5434
\u4ED8
\u6D6E
\u906D
\u5F90
\u60A8
\u6447
\u8C37
\u8D5E
\u7BB1
\u9694
\u8BA2
\u7537
\u5439
\u56ED
\u7EB7
\u5510
\u8D25
\u5B8B
\u73BB
\u5DE8
\u8015
\u5766
\u8363
\u95ED
\u6E7E
\u952E
\u51E1
\u9A7B
\u9505
\u6551
\u6069
\u5265
\u51DD
\u78B1
\u9F7F
\u622A
\u70BC
\u9EBB
\u7EBA
\u7981
\u5E9F
\u76DB
\u7248
\u7F13
\u51C0
\u775B
\u660C
\u5A5A
\u6D89
\u7B52
\u5634
\u63D2
\u5CB8
\u6717
\u5E84
\u8857
\u85CF
\u59D1
\u8D38
\u8150
\u5974
\u5566
\u60EF
\u4E58
\u4F19
\u6062
\u5300
\u7EB1
\u624E
\u8FA9
\u8033
\u5F6A
\u81E3
\u4EBF
\u7483
\u62B5
\u8109
\u79C0
\u8428
\u4FC4
\u7F51
\u821E
\u5E97
\u55B7
\u7EB5
\u5BF8
\u6C57
\u6302
\u6D2A
\u8D3A
\u95EA
\u67EC
\u7206
\u70EF
\u6D25
\u7A3B
\u5899
\u8F6F
\u52C7
\u50CF
\u6EDA
\u5398
\u8499
\u82B3
\u80AF
\u5761
\u67F1
\u8361
\u817F
\u4EEA
\u65C5
\u5C3E
\u8F67
\u51B0
\u8D21
\u767B
\u9ECE
\u524A
\u94BB
\u52D2
\u9003
\u969C
\u6C28
\u90ED
\u5CF0
\u5E01
\u6E2F
\u4F0F
\u8F68
\u4EA9
\u6BD5
\u64E6
\u83AB
\u523A
\u6D6A
\u79D8
\u63F4
\u682A
\u5065
\u552E
\u80A1
\u5C9B
\u7518
\u6CE1
\u7761
\u7AE5
\u94F8
\u6C64
\u9600
\u4F11
\u6C47
\u820D
\u7267
\u7ED5
\u70B8
\u54F2
\u78F7
\u7EE9
\u670B
\u6DE1
\u5C16
\u542F
\u9677
\u67F4
\u5448
\u5F92
\u989C
\u6CEA
\u7A0D
\u5FD8
\u6CF5
\u84DD
\u62D6
\u6D1E
\u6388
\u955C
\u8F9B
\u58EE
\u950B
\u8D2B
\u865A
\u5F2F
\u6469
\u6CF0
\u5E7C
\u5EF7
\u5C0A
\u7A97
\u7EB2
\u5F04
\u96B6
\u7591
\u6C0F
\u5BAB
\u59D0
\u9707
\u745E
\u602A
\u5C24
\u7434
\u5FAA
\u63CF
\u819C
\u8FDD
\u5939
\u8170
\u7F18
\u73E0
\u7A77
\u68EE
\u679D
\u7AF9
\u6C9F
\u50AC
\u7EF3
\u5FC6
\u90A6
\u5269
\u5E78
\u6D46
\u680F
\u62E5
\u7259
\u8D2E
\u793C
\u6EE4
\u94A0
\u7EB9
\u7F62
\u62CD
\u54B1
\u558A
\u8896
\u57C3
\u52E4
\u7F5A
\u7126
\u6F5C
\u4F0D
\u58A8
\u6B32
\u7F1D
\u59D3
\u520A
\u9971
\u4EFF
\u5956
\u94DD
\u9B3C
\u4E3D
\u8DE8
\u9ED8
\u6316
\u94FE
\u626B
\u559D
\u888B
\u70AD
\u6C61
\u5E55
\u8BF8
\u5F27
\u52B1
\u6885
\u5976
\u6D01
\u707E
\u821F
\u9274
\u82EF
\u8BBC
\u62B1
\u6BC1
\u61C2
\u5BD2
\u667A
\u57D4
\u5BC4
\u5C4A
\u8DC3
\u6E21
\u6311
\u4E39
\u8270
\u8D1D
\u78B0
\u62D4
\u7239
\u6234
\u7801
\u68A6
\u82BD
\u7194
\u8D64
\u6E14
\u54ED
\u656C
\u9897
\u5954
\u94C5
\u4EF2
\u864E
\u7A00
\u59B9
\u4E4F
\u73CD
\u7533
\u684C
\u9075
\u5141
\u9686
\u87BA
\u4ED3
\u9B4F
\u9510
\u6653
\u6C2E
\u517C
\u9690
\u788D
\u8D6B
\u62E8
\u5FE0
\u8083
\u7F38
\u7275
\u62A2
\u535A
\u5DE7
\u58F3
\u5144
\u675C
\u8BAF
\u8BDA
\u78A7
\u7965
\u67EF
\u9875
\u5DE1
\u77E9
\u60B2
\u704C
\u9F84
\u4F26
\u7968
\u5BFB
\u6842
\u94FA
\u5723
\u6050
\u6070
\u90D1
\u8DA3
\u62AC
\u8352
\u817E
\u8D34
\u67D4
\u6EF4
\u731B
\u9614
\u8F86
\u59BB
\u586B
\u64A4
\u50A8
\u7B7E
\u95F9
\u6270
\u7D2B
\u7802
\u9012
\u620F
\u540A
\u9676
\u4F10
\u5582
\u7597
\u74F6
\u5A46
\u629A
\u81C2
\u6478
\u5FCD
\u867E
\u8721
\u90BB
\u80F8
\u5DE9
\u6324
\u5076
\u5F03
\u69FD
\u52B2
\u4E73
\u9093
\u5409
\u4EC1
\u70C2
\u7816
\u79DF
\u4E4C
\u8230
\u4F34
\u74DC
\u6D45
\u4E19
\u6682
\u71E5
\u6A61
\u67F3
\u8FF7
\u6696
\u724C
\u79E7
\u80C6
\u8BE6
\u7C27
\u8E0F
\u74F7
\u8C31
\u5446
\u5BBE
\u7CCA
\u6D1B
\u8F89
\u6124
\u7ADE
\u9699
\u6012
\u7C98
\u4E43
\u7EEA
\u80A9
\u7C4D
\u654F
\u6D82
\u7199
\u7686
\u4FA6
\u60AC
\u6398
\u4EAB
\u7EA0
\u9192
\u72C2
\u9501
\u6DC0
\u6068
\u7272
\u9738
\u722C
\u8D4F
\u9006
\u73A9
\u9675
\u795D
\u79D2
\u6D59
\u8C8C
\u5F79
\u5F7C
\u6089
\u9E2D
\u8D8B
\u51E4
\u6668
\u755C
\u8F88
\u79E9
\u5375
\u7F72
\u68AF
\u708E
\u6EE9
\u68CB
\u9A71
\u7B5B
\u5CE1
\u5192
\u5565
\u5BFF
\u8BD1
\u6D78
\u6CC9
\u5E3D
\u8FDF
\u7845
\u7586
\u8D37
\u6F0F
\u7A3F
\u51A0
\u5AE9
\u80C1
\u82AF
\u7262
\u53DB
\u8680
\u5965
\u9E23
\u5CAD
\u7F8A
\u51ED
\u4E32
\u5858
\u7ED8
\u9175
\u878D
\u76C6
\u9521
\u5E99
\u7B79
\u51BB
\u8F85
\u6444
\u88AD
\u7B4B
\u62D2
\u50DA
\u65F1
\u94BE
\u9E1F
\u6F06
\u6C88
\u7709
\u758F
\u6DFB
\u68D2
\u7A57
\u785D
\u97E9
\u903C
\u626D
\u4FA8
\u51C9
\u633A
\u7897
\u683D
\u7092
\u676F
\u60A3
\u998F
\u529D
\u8C6A
\u8FBD
\u52C3
\u9E3F
\u65E6
\u540F
\u62DC
\u72D7
\u57CB
\u8F8A
\u63A9
\u996E
\u642C
\u9A82
\u8F9E
\u52FE
\u6263
\u4F30
\u848B
\u7ED2
\u96FE
\u4E08
\u6735
\u59C6
\u62DF
\u5B87
\u8F91
\u9655
\u96D5
\u507F
\u84C4
\u5D07
\u526A
\u5021
\u5385
\u54AC
\u9A76
\u85AF
\u5237
\u65A5
\u756A
\u8D4B
\u5949
\u4F5B
\u6D47
\u6F2B
\u66FC
\u6247
\u9499
\u6843
\u6276
\u4ED4
\u8FD4
\u4FD7
\u4E8F
\u8154
\u978B
\u68F1
\u8986
\u6846
\u6084
\u53D4
\u649E
\u9A97
\u52D8
\u65FA
\u6CB8
\u5B64
\u5410
\u5B5F
\u6E20
\u5C48
\u75BE
\u5999
\u60DC
\u4EF0
\u72E0
\u80C0
\u8C10
\u629B
\u9709
\u6851
\u5C97
\u561B
\u8870
\u76D7
\u6E17
\u810F
\u8D56
\u6D8C
\u751C
\u66F9
\u9605
\u808C
\u54E9
\u5389
\u70C3
\u7EAC
\u6BC5
\u6628
\u4F2A
\u75C7
\u716E
\u53F9
\u9489
\u642D
\u830E
\u7B3C
\u9177
\u5077
\u5F13
\u9525
\u6052
\u6770
\u5751
\u9F3B
\u7FFC
\u7EB6
\u53D9
\u72F1
\u902E
\u7F50
\u7EDC
\u68DA
\u6291
\u81A8
\u852C
\u5BFA
\u9AA4
\u7A46
\u51B6
\u67AF
\u518C
\u5C38
\u51F8
\u7EC5
\u576F
\u727A
\u7130
\u8F70
\u6B23
\u664B
\u7626
\u5FA1
\u952D
\u9526
\u4E27
\u65EC
\u953B
\u5784
\u641C
\u6251
\u9080
\u4EAD
\u916F
\u8FC8
\u8212
\u8106
\u9176
\u95F2
\u5FE7
\u915A
\u987D
\u7FBD
\u6DA8
\u5378
\u4ED7
\u966A
\u8F9F
\u60E9
\u676D
\u59DA
\u809A
\u6349
\u98D8
\u6F02
\u6606
\u6B3A
\u543E
\u90CE
\u70F7
\u6C41
\u5475
\u9970
\u8427
\u96C5
\u90AE
\u8FC1
\u71D5
\u6492
\u59FB
\u8D74
\u5BB4
\u70E6
\u503A
\u5E10
\u6591
\u94C3
\u65E8
\u9187
\u8463
\u997C
\u96CF
\u59FF
\u62CC
\u5085
\u8179
\u59A5
\u63C9
\u8D24
\u62C6
\u6B6A
\u8461
\u80FA
\u4E22
\u6D69
\u5FBD
\u6602
\u57AB
\u6321
\u89C8
\u8D2A
\u6170
\u7F34
\u6C6A
\u614C
\u51AF
\u8BFA
\u59DC
\u8C0A
\u51F6
\u52A3
\u8BEC
\u8000
\u660F
\u8EBA
\u76C8
\u9A91
\u4E54
\u6EAA
\u4E1B
\u5362
\u62B9
\u95F7
\u54A8
\u522E
\u9A7E
\u7F06
\u609F
\u6458
\u94D2
\u63B7
\u9887
\u5E7B
\u67C4
\u60E0
\u60E8
\u4F73
\u4EC7
\u814A
\u7A9D
\u6DA4
\u5251
\u77A7
\u5821
\u6CFC
\u8471
\u7F69
\u970D
\u635E
\u80CE
\u82CD
\u6EE8
\u4FE9
\u6345
\u6E58
\u780D
\u971E
\u90B5
\u8404
\u75AF
\u6DEE
\u9042
\u718A
\u7CAA
\u70D8
\u5BBF
\u6863
\u6208
\u9A73
\u5AC2
\u88D5
\u5F99
\u7BAD
\u6350
\u80A0
\u6491
\u6652
\u8FA8
\u6BBF
\u83B2
\u644A
\u6405
\u9171
\u5C4F
\u75AB
\u54C0
\u8521
\u5835
\u6CAB
\u76B1
\u7545
\u53E0
\u9601
\u83B1
\u6572
\u8F96
\u94A9
\u75D5
\u575D
\u5DF7
\u997F
\u7978
\u4E18
\u7384
\u6E9C
\u66F0
\u903B
\u5F6D
\u5C1D
\u537F
\u59A8
\u8247
\u541E
\u97E6
\u6028
\u77EE
\u6B47`.split("\n");
// /home/mous/work/pimlico/alto/node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/@scure/bip39/esm/wordlists/spanish.js
var wordlist8 = `a\u0301baco
abdomen
abeja
abierto
abogado
abono
aborto
abrazo
abrir
abuelo
abuso
acabar
academia
acceso
accio\u0301n
aceite
acelga
acento
aceptar
a\u0301cido
aclarar
acne\u0301
acoger
acoso
activo
acto
actriz
actuar
acudir
acuerdo
acusar
adicto
admitir
adoptar
adorno
aduana
adulto
ae\u0301reo
afectar
aficio\u0301n
afinar
afirmar
a\u0301gil
agitar
agoni\u0301a
agosto
agotar
agregar
agrio
agua
agudo
a\u0301guila
aguja
ahogo
ahorro
aire
aislar
ajedrez
ajeno
ajuste
alacra\u0301n
alambre
alarma
alba
a\u0301lbum
alcalde
aldea
alegre
alejar
alerta
aleta
alfiler
alga
algodo\u0301n
aliado
aliento
alivio
alma
almeja
almi\u0301bar
altar
alteza
altivo
alto
altura
alumno
alzar
amable
amante
amapola
amargo
amasar
a\u0301mbar
a\u0301mbito
ameno
amigo
amistad
amor
amparo
amplio
ancho
anciano
ancla
andar
ande\u0301n
anemia
a\u0301ngulo
anillo
a\u0301nimo
ani\u0301s
anotar
antena
antiguo
antojo
anual
anular
anuncio
an\u0303adir
an\u0303ejo
an\u0303o
apagar
aparato
apetito
apio
aplicar
apodo
aporte
apoyo
aprender
aprobar
apuesta
apuro
arado
aran\u0303a
arar
a\u0301rbitro
a\u0301rbol
arbusto
archivo
arco
arder
ardilla
arduo
a\u0301rea
a\u0301rido
aries
armoni\u0301a
arne\u0301s
aroma
arpa
arpo\u0301n
arreglo
arroz
arruga
arte
artista
asa
asado
asalto
ascenso
asegurar
aseo
asesor
asiento
asilo
asistir
asno
asombro
a\u0301spero
astilla
astro
astuto
asumir
asunto
atajo
ataque
atar
atento
ateo
a\u0301tico
atleta
a\u0301tomo
atraer
atroz
atu\u0301n
audaz
audio
auge
aula
aumento
ausente
autor
aval
avance
avaro
ave
avellana
avena
avestruz
avio\u0301n
aviso
ayer
ayuda
ayuno
azafra\u0301n
azar
azote
azu\u0301car
azufre
azul
baba
babor
bache
bahi\u0301a
baile
bajar
balanza
balco\u0301n
balde
bambu\u0301
banco
banda
ban\u0303o
barba
barco
barniz
barro
ba\u0301scula
basto\u0301n
basura
batalla
bateri\u0301a
batir
batuta
bau\u0301l
bazar
bebe\u0301
bebida
bello
besar
beso
bestia
bicho
bien
bingo
blanco
bloque
blusa
boa
bobina
bobo
boca
bocina
boda
bodega
boina
bola
bolero
bolsa
bomba
bondad
bonito
bono
bonsa\u0301i
borde
borrar
bosque
bote
boti\u0301n
bo\u0301veda
bozal
bravo
brazo
brecha
breve
brillo
brinco
brisa
broca
broma
bronce
brote
bruja
brusco
bruto
buceo
bucle
bueno
buey
bufanda
bufo\u0301n
bu\u0301ho
buitre
bulto
burbuja
burla
burro
buscar
butaca
buzo\u0301n
caballo
cabeza
cabina
cabra
cacao
cada\u0301ver
cadena
caer
cafe\u0301
cai\u0301da
caima\u0301n
caja
cajo\u0301n
cal
calamar
calcio
caldo
calidad
calle
calma
calor
calvo
cama
cambio
camello
camino
campo
ca\u0301ncer
candil
canela
canguro
canica
canto
can\u0303a
can\u0303o\u0301n
caoba
caos
capaz
capita\u0301n
capote
captar
capucha
cara
carbo\u0301n
ca\u0301rcel
careta
carga
carin\u0303o
carne
carpeta
carro
carta
casa
casco
casero
caspa
castor
catorce
catre
caudal
causa
cazo
cebolla
ceder
cedro
celda
ce\u0301lebre
celoso
ce\u0301lula
cemento
ceniza
centro
cerca
cerdo
cereza
cero
cerrar
certeza
ce\u0301sped
cetro
chacal
chaleco
champu\u0301
chancla
chapa
charla
chico
chiste
chivo
choque
choza
chuleta
chupar
ciclo\u0301n
ciego
cielo
cien
cierto
cifra
cigarro
cima
cinco
cine
cinta
cipre\u0301s
circo
ciruela
cisne
cita
ciudad
clamor
clan
claro
clase
clave
cliente
clima
cli\u0301nica
cobre
coccio\u0301n
cochino
cocina
coco
co\u0301digo
codo
cofre
coger
cohete
coji\u0301n
cojo
cola
colcha
colegio
colgar
colina
collar
colmo
columna
combate
comer
comida
co\u0301modo
compra
conde
conejo
conga
conocer
consejo
contar
copa
copia
corazo\u0301n
corbata
corcho
cordo\u0301n
corona
correr
coser
cosmos
costa
cra\u0301neo
cra\u0301ter
crear
crecer
crei\u0301do
crema
cri\u0301a
crimen
cripta
crisis
cromo
cro\u0301nica
croqueta
crudo
cruz
cuadro
cuarto
cuatro
cubo
cubrir
cuchara
cuello
cuento
cuerda
cuesta
cueva
cuidar
culebra
culpa
culto
cumbre
cumplir
cuna
cuneta
cuota
cupo\u0301n
cu\u0301pula
curar
curioso
curso
curva
cutis
dama
danza
dar
dardo
da\u0301til
deber
de\u0301bil
de\u0301cada
decir
dedo
defensa
definir
dejar
delfi\u0301n
delgado
delito
demora
denso
dental
deporte
derecho
derrota
desayuno
deseo
desfile
desnudo
destino
desvi\u0301o
detalle
detener
deuda
di\u0301a
diablo
diadema
diamante
diana
diario
dibujo
dictar
diente
dieta
diez
difi\u0301cil
digno
dilema
diluir
dinero
directo
dirigir
disco
disen\u0303o
disfraz
diva
divino
doble
doce
dolor
domingo
don
donar
dorado
dormir
dorso
dos
dosis
drago\u0301n
droga
ducha
duda
duelo
duen\u0303o
dulce
du\u0301o
duque
durar
dureza
duro
e\u0301bano
ebrio
echar
eco
ecuador
edad
edicio\u0301n
edificio
editor
educar
efecto
eficaz
eje
ejemplo
elefante
elegir
elemento
elevar
elipse
e\u0301lite
elixir
elogio
eludir
embudo
emitir
emocio\u0301n
empate
empen\u0303o
empleo
empresa
enano
encargo
enchufe
enci\u0301a
enemigo
enero
enfado
enfermo
engan\u0303o
enigma
enlace
enorme
enredo
ensayo
ensen\u0303ar
entero
entrar
envase
envi\u0301o
e\u0301poca
equipo
erizo
escala
escena
escolar
escribir
escudo
esencia
esfera
esfuerzo
espada
espejo
espi\u0301a
esposa
espuma
esqui\u0301
estar
este
estilo
estufa
etapa
eterno
e\u0301tica
etnia
evadir
evaluar
evento
evitar
exacto
examen
exceso
excusa
exento
exigir
exilio
existir
e\u0301xito
experto
explicar
exponer
extremo
fa\u0301brica
fa\u0301bula
fachada
fa\u0301cil
factor
faena
faja
falda
fallo
falso
faltar
fama
familia
famoso
farao\u0301n
farmacia
farol
farsa
fase
fatiga
fauna
favor
fax
febrero
fecha
feliz
feo
feria
feroz
fe\u0301rtil
fervor
festi\u0301n
fiable
fianza
fiar
fibra
ficcio\u0301n
ficha
fideo
fiebre
fiel
fiera
fiesta
figura
fijar
fijo
fila
filete
filial
filtro
fin
finca
fingir
finito
firma
flaco
flauta
flecha
flor
flota
fluir
flujo
flu\u0301or
fobia
foca
fogata
fogo\u0301n
folio
folleto
fondo
forma
forro
fortuna
forzar
fosa
foto
fracaso
fra\u0301gil
franja
frase
fraude
frei\u0301r
freno
fresa
fri\u0301o
frito
fruta
fuego
fuente
fuerza
fuga
fumar
funcio\u0301n
funda
furgo\u0301n
furia
fusil
fu\u0301tbol
futuro
gacela
gafas
gaita
gajo
gala
galeri\u0301a
gallo
gamba
ganar
gancho
ganga
ganso
garaje
garza
gasolina
gastar
gato
gavila\u0301n
gemelo
gemir
gen
ge\u0301nero
genio
gente
geranio
gerente
germen
gesto
gigante
gimnasio
girar
giro
glaciar
globo
gloria
gol
golfo
goloso
golpe
goma
gordo
gorila
gorra
gota
goteo
gozar
grada
gra\u0301fico
grano
grasa
gratis
grave
grieta
grillo
gripe
gris
grito
grosor
gru\u0301a
grueso
grumo
grupo
guante
guapo
guardia
guerra
gui\u0301a
guin\u0303o
guion
guiso
guitarra
gusano
gustar
haber
ha\u0301bil
hablar
hacer
hacha
hada
hallar
hamaca
harina
haz
hazan\u0303a
hebilla
hebra
hecho
helado
helio
hembra
herir
hermano
he\u0301roe
hervir
hielo
hierro
hi\u0301gado
higiene
hijo
himno
historia
hocico
hogar
hoguera
hoja
hombre
hongo
honor
honra
hora
hormiga
horno
hostil
hoyo
hueco
huelga
huerta
hueso
huevo
huida
huir
humano
hu\u0301medo
humilde
humo
hundir
huraca\u0301n
hurto
icono
ideal
idioma
i\u0301dolo
iglesia
iglu\u0301
igual
ilegal
ilusio\u0301n
imagen
ima\u0301n
imitar
impar
imperio
imponer
impulso
incapaz
i\u0301ndice
inerte
infiel
informe
ingenio
inicio
inmenso
inmune
innato
insecto
instante
intere\u0301s
i\u0301ntimo
intuir
inu\u0301til
invierno
ira
iris
ironi\u0301a
isla
islote
jabali\u0301
jabo\u0301n
jamo\u0301n
jarabe
jardi\u0301n
jarra
jaula
jazmi\u0301n
jefe
jeringa
jinete
jornada
joroba
joven
joya
juerga
jueves
juez
jugador
jugo
juguete
juicio
junco
jungla
junio
juntar
ju\u0301piter
jurar
justo
juvenil
juzgar
kilo
koala
labio
lacio
lacra
lado
ladro\u0301n
lagarto
la\u0301grima
laguna
laico
lamer
la\u0301mina
la\u0301mpara
lana
lancha
langosta
lanza
la\u0301piz
largo
larva
la\u0301stima
lata
la\u0301tex
latir
laurel
lavar
lazo
leal
leccio\u0301n
leche
lector
leer
legio\u0301n
legumbre
lejano
lengua
lento
len\u0303a
leo\u0301n
leopardo
lesio\u0301n
letal
letra
leve
leyenda
libertad
libro
licor
li\u0301der
lidiar
lienzo
liga
ligero
lima
li\u0301mite
limo\u0301n
limpio
lince
lindo
li\u0301nea
lingote
lino
linterna
li\u0301quido
liso
lista
litera
litio
litro
llaga
llama
llanto
llave
llegar
llenar
llevar
llorar
llover
lluvia
lobo
locio\u0301n
loco
locura
lo\u0301gica
logro
lombriz
lomo
lonja
lote
lucha
lucir
lugar
lujo
luna
lunes
lupa
lustro
luto
luz
maceta
macho
madera
madre
maduro
maestro
mafia
magia
mago
mai\u0301z
maldad
maleta
malla
malo
mama\u0301
mambo
mamut
manco
mando
manejar
manga
maniqui\u0301
manjar
mano
manso
manta
man\u0303ana
mapa
ma\u0301quina
mar
marco
marea
marfil
margen
marido
ma\u0301rmol
marro\u0301n
martes
marzo
masa
ma\u0301scara
masivo
matar
materia
matiz
matriz
ma\u0301ximo
mayor
mazorca
mecha
medalla
medio
me\u0301dula
mejilla
mejor
melena
melo\u0301n
memoria
menor
mensaje
mente
menu\u0301
mercado
merengue
me\u0301rito
mes
meso\u0301n
meta
meter
me\u0301todo
metro
mezcla
miedo
miel
miembro
miga
mil
milagro
militar
millo\u0301n
mimo
mina
minero
mi\u0301nimo
minuto
miope
mirar
misa
miseria
misil
mismo
mitad
mito
mochila
mocio\u0301n
moda
modelo
moho
mojar
molde
moler
molino
momento
momia
monarca
moneda
monja
monto
mon\u0303o
morada
morder
moreno
morir
morro
morsa
mortal
mosca
mostrar
motivo
mover
mo\u0301vil
mozo
mucho
mudar
mueble
muela
muerte
muestra
mugre
mujer
mula
muleta
multa
mundo
mun\u0303eca
mural
muro
mu\u0301sculo
museo
musgo
mu\u0301sica
muslo
na\u0301car
nacio\u0301n
nadar
naipe
naranja
nariz
narrar
nasal
natal
nativo
natural
na\u0301usea
naval
nave
navidad
necio
ne\u0301ctar
negar
negocio
negro
neo\u0301n
nervio
neto
neutro
nevar
nevera
nicho
nido
niebla
nieto
nin\u0303ez
nin\u0303o
ni\u0301tido
nivel
nobleza
noche
no\u0301mina
noria
norma
norte
nota
noticia
novato
novela
novio
nube
nuca
nu\u0301cleo
nudillo
nudo
nuera
nueve
nuez
nulo
nu\u0301mero
nutria
oasis
obeso
obispo
objeto
obra
obrero
observar
obtener
obvio
oca
ocaso
oce\u0301ano
ochenta
ocho
ocio
ocre
octavo
octubre
oculto
ocupar
ocurrir
odiar
odio
odisea
oeste
ofensa
oferta
oficio
ofrecer
ogro
oi\u0301do
oi\u0301r
ojo
ola
oleada
olfato
olivo
olla
olmo
olor
olvido
ombligo
onda
onza
opaco
opcio\u0301n
o\u0301pera
opinar
oponer
optar
o\u0301ptica
opuesto
oracio\u0301n
orador
oral
o\u0301rbita
orca
orden
oreja
o\u0301rgano
orgi\u0301a
orgullo
oriente
origen
orilla
oro
orquesta
oruga
osadi\u0301a
oscuro
osezno
oso
ostra
oton\u0303o
otro
oveja
o\u0301vulo
o\u0301xido
oxi\u0301geno
oyente
ozono
pacto
padre
paella
pa\u0301gina
pago
pai\u0301s
pa\u0301jaro
palabra
palco
paleta
pa\u0301lido
palma
paloma
palpar
pan
panal
pa\u0301nico
pantera
pan\u0303uelo
papa\u0301
papel
papilla
paquete
parar
parcela
pared
parir
paro
pa\u0301rpado
parque
pa\u0301rrafo
parte
pasar
paseo
pasio\u0301n
paso
pasta
pata
patio
patria
pausa
pauta
pavo
payaso
peato\u0301n
pecado
pecera
pecho
pedal
pedir
pegar
peine
pelar
peldan\u0303o
pelea
peligro
pellejo
pelo
peluca
pena
pensar
pen\u0303o\u0301n
peo\u0301n
peor
pepino
pequen\u0303o
pera
percha
perder
pereza
perfil
perico
perla
permiso
perro
persona
pesa
pesca
pe\u0301simo
pestan\u0303a
pe\u0301talo
petro\u0301leo
pez
pezun\u0303a
picar
picho\u0301n
pie
piedra
pierna
pieza
pijama
pilar
piloto
pimienta
pino
pintor
pinza
pin\u0303a
piojo
pipa
pirata
pisar
piscina
piso
pista
pito\u0301n
pizca
placa
plan
plata
playa
plaza
pleito
pleno
plomo
pluma
plural
pobre
poco
poder
podio
poema
poesi\u0301a
poeta
polen
polici\u0301a
pollo
polvo
pomada
pomelo
pomo
pompa
poner
porcio\u0301n
portal
posada
poseer
posible
poste
potencia
potro
pozo
prado
precoz
pregunta
premio
prensa
preso
previo
primo
pri\u0301ncipe
prisio\u0301n
privar
proa
probar
proceso
producto
proeza
profesor
programa
prole
promesa
pronto
propio
pro\u0301ximo
prueba
pu\u0301blico
puchero
pudor
pueblo
puerta
puesto
pulga
pulir
pulmo\u0301n
pulpo
pulso
puma
punto
pun\u0303al
pun\u0303o
pupa
pupila
pure\u0301
quedar
queja
quemar
querer
queso
quieto
qui\u0301mica
quince
quitar
ra\u0301bano
rabia
rabo
racio\u0301n
radical
rai\u0301z
rama
rampa
rancho
rango
rapaz
ra\u0301pido
rapto
rasgo
raspa
rato
rayo
raza
razo\u0301n
reaccio\u0301n
realidad
reban\u0303o
rebote
recaer
receta
rechazo
recoger
recreo
recto
recurso
red
redondo
reducir
reflejo
reforma
refra\u0301n
refugio
regalo
regir
regla
regreso
rehe\u0301n
reino
rei\u0301r
reja
relato
relevo
relieve
relleno
reloj
remar
remedio
remo
rencor
rendir
renta
reparto
repetir
reposo
reptil
res
rescate
resina
respeto
resto
resumen
retiro
retorno
retrato
reunir
reve\u0301s
revista
rey
rezar
rico
riego
rienda
riesgo
rifa
ri\u0301gido
rigor
rinco\u0301n
rin\u0303o\u0301n
ri\u0301o
riqueza
risa
ritmo
rito
rizo
roble
roce
rociar
rodar
rodeo
rodilla
roer
rojizo
rojo
romero
romper
ron
ronco
ronda
ropa
ropero
rosa
rosca
rostro
rotar
rubi\u0301
rubor
rudo
rueda
rugir
ruido
ruina
ruleta
rulo
rumbo
rumor
ruptura
ruta
rutina
sa\u0301bado
saber
sabio
sable
sacar
sagaz
sagrado
sala
saldo
salero
salir
salmo\u0301n
salo\u0301n
salsa
salto
salud
salvar
samba
sancio\u0301n
sandi\u0301a
sanear
sangre
sanidad
sano
santo
sapo
saque
sardina
sarte\u0301n
sastre
sata\u0301n
sauna
saxofo\u0301n
seccio\u0301n
seco
secreto
secta
sed
seguir
seis
sello
selva
semana
semilla
senda
sensor
sen\u0303al
sen\u0303or
separar
sepia
sequi\u0301a
ser
serie
sermo\u0301n
servir
sesenta
sesio\u0301n
seta
setenta
severo
sexo
sexto
sidra
siesta
siete
siglo
signo
si\u0301laba
silbar
silencio
silla
si\u0301mbolo
simio
sirena
sistema
sitio
situar
sobre
socio
sodio
sol
solapa
soldado
soledad
so\u0301lido
soltar
solucio\u0301n
sombra
sondeo
sonido
sonoro
sonrisa
sopa
soplar
soporte
sordo
sorpresa
sorteo
soste\u0301n
so\u0301tano
suave
subir
suceso
sudor
suegra
suelo
suen\u0303o
suerte
sufrir
sujeto
sulta\u0301n
sumar
superar
suplir
suponer
supremo
sur
surco
suren\u0303o
surgir
susto
sutil
tabaco
tabique
tabla
tabu\u0301
taco
tacto
tajo
talar
talco
talento
talla
talo\u0301n
taman\u0303o
tambor
tango
tanque
tapa
tapete
tapia
tapo\u0301n
taquilla
tarde
tarea
tarifa
tarjeta
tarot
tarro
tarta
tatuaje
tauro
taza
tazo\u0301n
teatro
techo
tecla
te\u0301cnica
tejado
tejer
tejido
tela
tele\u0301fono
tema
temor
templo
tenaz
tender
tener
tenis
tenso
teori\u0301a
terapia
terco
te\u0301rmino
ternura
terror
tesis
tesoro
testigo
tetera
texto
tez
tibio
tiburo\u0301n
tiempo
tienda
tierra
tieso
tigre
tijera
tilde
timbre
ti\u0301mido
timo
tinta
ti\u0301o
ti\u0301pico
tipo
tira
tiro\u0301n
tita\u0301n
ti\u0301tere
ti\u0301tulo
tiza
toalla
tobillo
tocar
tocino
todo
toga
toldo
tomar
tono
tonto
topar
tope
toque
to\u0301rax
torero
tormenta
torneo
toro
torpedo
torre
torso
tortuga
tos
tosco
toser
to\u0301xico
trabajo
tractor
traer
tra\u0301fico
trago
traje
tramo
trance
trato
trauma
trazar
tre\u0301bol
tregua
treinta
tren
trepar
tres
tribu
trigo
tripa
triste
triunfo
trofeo
trompa
tronco
tropa
trote
trozo
truco
trueno
trufa
tuberi\u0301a
tubo
tuerto
tumba
tumor
tu\u0301nel
tu\u0301nica
turbina
turismo
turno
tutor
ubicar
u\u0301lcera
umbral
unidad
unir
universo
uno
untar
un\u0303a
urbano
urbe
urgente
urna
usar
usuario
u\u0301til
utopi\u0301a
uva
vaca
vaci\u0301o
vacuna
vagar
vago
vaina
vajilla
vale
va\u0301lido
valle
valor
va\u0301lvula
vampiro
vara
variar
varo\u0301n
vaso
vecino
vector
vehi\u0301culo
veinte
vejez
vela
velero
veloz
vena
vencer
venda
veneno
vengar
venir
venta
venus
ver
verano
verbo
verde
vereda
verja
verso
verter
vi\u0301a
viaje
vibrar
vicio
vi\u0301ctima
vida
vi\u0301deo
vidrio
viejo
viernes
vigor
vil
villa
vinagre
vino
vin\u0303edo
violi\u0301n
viral
virgo
virtud
visor
vi\u0301spera
vista
vitamina
viudo
vivaz
vivero
vivir
vivo
volca\u0301n
volumen
volver
voraz
votar
voto
voz
vuelo
vulgar
yacer
yate
yegua
yema
yerno
yeso
yodo
yoga
yogur
zafiro
zanja
zapato
zarza
zona
zorro
zumo
zurdo`.split("\n");
// /home/mous/work/pimlico/alto/node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/@scure/bip39/esm/wordlists/traditional-chinese.js
var wordlist9 = `\u7684
\u4E00
\u662F
\u5728
\u4E0D
\u4E86
\u6709
\u548C
\u4EBA
\u9019
\u4E2D
\u5927
\u70BA
\u4E0A
\u500B
\u570B
\u6211
\u4EE5
\u8981
\u4ED6
\u6642
\u4F86
\u7528
\u5011
\u751F
\u5230
\u4F5C
\u5730
\u65BC
\u51FA
\u5C31
\u5206
\u5C0D
\u6210
\u6703
\u53EF
\u4E3B
\u767C
\u5E74
\u52D5
\u540C
\u5DE5
\u4E5F
\u80FD
\u4E0B
\u904E
\u5B50
\u8AAA
\u7522
\u7A2E
\u9762
\u800C
\u65B9
\u5F8C
\u591A
\u5B9A
\u884C
\u5B78
\u6CD5
\u6240
\u6C11
\u5F97
\u7D93
\u5341
\u4E09
\u4E4B
\u9032
\u8457
\u7B49
\u90E8
\u5EA6
\u5BB6
\u96FB
\u529B
\u88E1
\u5982
\u6C34
\u5316
\u9AD8
\u81EA
\u4E8C
\u7406
\u8D77
\u5C0F
\u7269
\u73FE
\u5BE6
\u52A0
\u91CF
\u90FD
\u5169
\u9AD4
\u5236
\u6A5F
\u7576
\u4F7F
\u9EDE
\u5F9E
\u696D
\u672C
\u53BB
\u628A
\u6027
\u597D
\u61C9
\u958B
\u5B83
\u5408
\u9084
\u56E0
\u7531
\u5176
\u4E9B
\u7136
\u524D
\u5916
\u5929
\u653F
\u56DB
\u65E5
\u90A3
\u793E
\u7FA9
\u4E8B
\u5E73
\u5F62
\u76F8
\u5168
\u8868
\u9593
\u6A23
\u8207
\u95DC
\u5404
\u91CD
\u65B0
\u7DDA
\u5167
\u6578
\u6B63
\u5FC3
\u53CD
\u4F60
\u660E
\u770B
\u539F
\u53C8
\u9EBC
\u5229
\u6BD4
\u6216
\u4F46
\u8CEA
\u6C23
\u7B2C
\u5411
\u9053
\u547D
\u6B64
\u8B8A
\u689D
\u53EA
\u6C92
\u7D50
\u89E3
\u554F
\u610F
\u5EFA
\u6708
\u516C
\u7121
\u7CFB
\u8ECD
\u5F88
\u60C5
\u8005
\u6700
\u7ACB
\u4EE3
\u60F3
\u5DF2
\u901A
\u4E26
\u63D0
\u76F4
\u984C
\u9EE8
\u7A0B
\u5C55
\u4E94
\u679C
\u6599
\u8C61
\u54E1
\u9769
\u4F4D
\u5165
\u5E38
\u6587
\u7E3D
\u6B21
\u54C1
\u5F0F
\u6D3B
\u8A2D
\u53CA
\u7BA1
\u7279
\u4EF6
\u9577
\u6C42
\u8001
\u982D
\u57FA
\u8CC7
\u908A
\u6D41
\u8DEF
\u7D1A
\u5C11
\u5716
\u5C71
\u7D71
\u63A5
\u77E5
\u8F03
\u5C07
\u7D44
\u898B
\u8A08
\u5225
\u5979
\u624B
\u89D2
\u671F
\u6839
\u8AD6
\u904B
\u8FB2
\u6307
\u5E7E
\u4E5D
\u5340
\u5F37
\u653E
\u6C7A
\u897F
\u88AB
\u5E79
\u505A
\u5FC5
\u6230
\u5148
\u56DE
\u5247
\u4EFB
\u53D6
\u64DA
\u8655
\u968A
\u5357
\u7D66
\u8272
\u5149
\u9580
\u5373
\u4FDD
\u6CBB
\u5317
\u9020
\u767E
\u898F
\u71B1
\u9818
\u4E03
\u6D77
\u53E3
\u6771
\u5C0E
\u5668
\u58D3
\u5FD7
\u4E16
\u91D1
\u589E
\u722D
\u6FDF
\u968E
\u6CB9
\u601D
\u8853
\u6975
\u4EA4
\u53D7
\u806F
\u4EC0
\u8A8D
\u516D
\u5171
\u6B0A
\u6536
\u8B49
\u6539
\u6E05
\u7F8E
\u518D
\u63A1
\u8F49
\u66F4
\u55AE
\u98A8
\u5207
\u6253
\u767D
\u6559
\u901F
\u82B1
\u5E36
\u5B89
\u5834
\u8EAB
\u8ECA
\u4F8B
\u771F
\u52D9
\u5177
\u842C
\u6BCF
\u76EE
\u81F3
\u9054
\u8D70
\u7A4D
\u793A
\u8B70
\u8072
\u5831
\u9B25
\u5B8C
\u985E
\u516B
\u96E2
\u83EF
\u540D
\u78BA
\u624D
\u79D1
\u5F35
\u4FE1
\u99AC
\u7BC0
\u8A71
\u7C73
\u6574
\u7A7A
\u5143
\u6CC1
\u4ECA
\u96C6
\u6EAB
\u50B3
\u571F
\u8A31
\u6B65
\u7FA4
\u5EE3
\u77F3
\u8A18
\u9700
\u6BB5
\u7814
\u754C
\u62C9
\u6797
\u5F8B
\u53EB
\u4E14
\u7A76
\u89C0
\u8D8A
\u7E54
\u88DD
\u5F71
\u7B97
\u4F4E
\u6301
\u97F3
\u773E
\u66F8
\u5E03
\u590D
\u5BB9
\u5152
\u9808
\u969B
\u5546
\u975E
\u9A57
\u9023
\u65B7
\u6DF1
\u96E3
\u8FD1
\u7926
\u5343
\u9031
\u59D4
\u7D20
\u6280
\u5099
\u534A
\u8FA6
\u9752
\u7701
\u5217
\u7FD2
\u97FF
\u7D04
\u652F
\u822C
\u53F2
\u611F
\u52DE
\u4FBF
\u5718
\u5F80
\u9178
\u6B77
\u5E02
\u514B
\u4F55
\u9664
\u6D88
\u69CB
\u5E9C
\u7A31
\u592A
\u6E96
\u7CBE
\u503C
\u865F
\u7387
\u65CF
\u7DAD
\u5283
\u9078
\u6A19
\u5BEB
\u5B58
\u5019
\u6BDB
\u89AA
\u5FEB
\u6548
\u65AF
\u9662
\u67E5
\u6C5F
\u578B
\u773C
\u738B
\u6309
\u683C
\u990A
\u6613
\u7F6E
\u6D3E
\u5C64
\u7247
\u59CB
\u537B
\u5C08
\u72C0
\u80B2
\u5EE0
\u4EAC
\u8B58
\u9069
\u5C6C
\u5713
\u5305
\u706B
\u4F4F
\u8ABF
\u6EFF
\u7E23
\u5C40
\u7167
\u53C3
\u7D05
\u7D30
\u5F15
\u807D
\u8A72
\u9435
\u50F9
\u56B4
\u9996
\u5E95
\u6DB2
\u5B98
\u5FB7
\u96A8
\u75C5
\u8607
\u5931
\u723E
\u6B7B
\u8B1B
\u914D
\u5973
\u9EC3
\u63A8
\u986F
\u8AC7
\u7F6A
\u795E
\u85DD
\u5462
\u5E2D
\u542B
\u4F01
\u671B
\u5BC6
\u6279
\u71DF
\u9805
\u9632
\u8209
\u7403
\u82F1
\u6C27
\u52E2
\u544A
\u674E
\u53F0
\u843D
\u6728
\u5E6B
\u8F2A
\u7834
\u4E9E
\u5E2B
\u570D
\u6CE8
\u9060
\u5B57
\u6750
\u6392
\u4F9B
\u6CB3
\u614B
\u5C01
\u53E6
\u65BD
\u6E1B
\u6A39
\u6EB6
\u600E
\u6B62
\u6848
\u8A00
\u58EB
\u5747
\u6B66
\u56FA
\u8449
\u9B5A
\u6CE2
\u8996
\u50C5
\u8CBB
\u7DCA
\u611B
\u5DE6
\u7AE0
\u65E9
\u671D
\u5BB3
\u7E8C
\u8F15
\u670D
\u8A66
\u98DF
\u5145
\u5175
\u6E90
\u5224
\u8B77
\u53F8
\u8DB3
\u67D0
\u7DF4
\u5DEE
\u81F4
\u677F
\u7530
\u964D
\u9ED1
\u72AF
\u8CA0
\u64CA
\u8303
\u7E7C
\u8208
\u4F3C
\u9918
\u5805
\u66F2
\u8F38
\u4FEE
\u6545
\u57CE
\u592B
\u5920
\u9001
\u7B46
\u8239
\u4F54
\u53F3
\u8CA1
\u5403
\u5BCC
\u6625
\u8077
\u89BA
\u6F22
\u756B
\u529F
\u5DF4
\u8DDF
\u96D6
\u96DC
\u98DB
\u6AA2
\u5438
\u52A9
\u6607
\u967D
\u4E92
\u521D
\u5275
\u6297
\u8003
\u6295
\u58DE
\u7B56
\u53E4
\u5F91
\u63DB
\u672A
\u8DD1
\u7559
\u92FC
\u66FE
\u7AEF
\u8CAC
\u7AD9
\u7C21
\u8FF0
\u9322
\u526F
\u76E1
\u5E1D
\u5C04
\u8349
\u885D
\u627F
\u7368
\u4EE4
\u9650
\u963F
\u5BA3
\u74B0
\u96D9
\u8ACB
\u8D85
\u5FAE
\u8B93
\u63A7
\u5DDE
\u826F
\u8EF8
\u627E
\u5426
\u7D00
\u76CA
\u4F9D
\u512A
\u9802
\u790E
\u8F09
\u5012
\u623F
\u7A81
\u5750
\u7C89
\u6575
\u7565
\u5BA2
\u8881
\u51B7
\u52DD
\u7D55
\u6790
\u584A
\u5291
\u6E2C
\u7D72
\u5354
\u8A34
\u5FF5
\u9673
\u4ECD
\u7F85
\u9E7D
\u53CB
\u6D0B
\u932F
\u82E6
\u591C
\u5211
\u79FB
\u983B
\u9010
\u9760
\u6DF7
\u6BCD
\u77ED
\u76AE
\u7D42
\u805A
\u6C7D
\u6751
\u96F2
\u54EA
\u65E2
\u8DDD
\u885B
\u505C
\u70C8
\u592E
\u5BDF
\u71D2
\u8FC5
\u5883
\u82E5
\u5370
\u6D32
\u523B
\u62EC
\u6FC0
\u5B54
\u641E
\u751A
\u5BA4
\u5F85
\u6838
\u6821
\u6563
\u4FB5
\u5427
\u7532
\u904A
\u4E45
\u83DC
\u5473
\u820A
\u6A21
\u6E56
\u8CA8
\u640D
\u9810
\u963B
\u6BEB
\u666E
\u7A69
\u4E59
\u5ABD
\u690D
\u606F
\u64F4
\u9280
\u8A9E
\u63EE
\u9152
\u5B88
\u62FF
\u5E8F
\u7D19
\u91AB
\u7F3A
\u96E8
\u55CE
\u91DD
\u5289
\u554A
\u6025
\u5531
\u8AA4
\u8A13
\u9858
\u5BE9
\u9644
\u7372
\u8336
\u9BAE
\u7CE7
\u65A4
\u5B69
\u812B
\u786B
\u80A5
\u5584
\u9F8D
\u6F14
\u7236
\u6F38
\u8840
\u6B61
\u68B0
\u638C
\u6B4C
\u6C99
\u525B
\u653B
\u8B02
\u76FE
\u8A0E
\u665A
\u7C92
\u4E82
\u71C3
\u77DB
\u4E4E
\u6BBA
\u85E5
\u5BE7
\u9B6F
\u8CB4
\u9418
\u7164
\u8B80
\u73ED
\u4F2F
\u9999
\u4ECB
\u8FEB
\u53E5
\u8C50
\u57F9
\u63E1
\u862D
\u64D4
\u5F26
\u86CB
\u6C89
\u5047
\u7A7F
\u57F7
\u7B54
\u6A02
\u8AB0
\u9806
\u7159
\u7E2E
\u5FB5
\u81C9
\u559C
\u677E
\u8173
\u56F0
\u7570
\u514D
\u80CC
\u661F
\u798F
\u8CB7
\u67D3
\u4E95
\u6982
\u6162
\u6015
\u78C1
\u500D
\u7956
\u7687
\u4FC3
\u975C
\u88DC
\u8A55
\u7FFB
\u8089
\u8E10
\u5C3C
\u8863
\u5BEC
\u63DA
\u68C9
\u5E0C
\u50B7
\u64CD
\u5782
\u79CB
\u5B9C
\u6C2B
\u5957
\u7763
\u632F
\u67B6
\u4EAE
\u672B
\u61B2
\u6176
\u7DE8
\u725B
\u89F8
\u6620
\u96F7
\u92B7
\u8A69
\u5EA7
\u5C45
\u6293
\u88C2
\u80DE
\u547C
\u5A18
\u666F
\u5A01
\u7DA0
\u6676
\u539A
\u76DF
\u8861
\u96DE
\u5B6B
\u5EF6
\u5371
\u81A0
\u5C4B
\u9109
\u81E8
\u9678
\u9867
\u6389
\u5440
\u71C8
\u6B72
\u63AA
\u675F
\u8010
\u5287
\u7389
\u8D99
\u8DF3
\u54E5
\u5B63
\u8AB2
\u51F1
\u80E1
\u984D
\u6B3E
\u7D39
\u5377
\u9F4A
\u5049
\u84B8
\u6B96
\u6C38
\u5B97
\u82D7
\u5DDD
\u7210
\u5CA9
\u5F31
\u96F6
\u694A
\u594F
\u6CBF
\u9732
\u687F
\u63A2
\u6ED1
\u93AE
\u98EF
\u6FC3
\u822A
\u61F7
\u8D95
\u5EAB
\u596A
\u4F0A
\u9748
\u7A05
\u9014
\u6EC5
\u8CFD
\u6B78
\u53EC
\u9F13
\u64AD
\u76E4
\u88C1
\u96AA
\u5EB7
\u552F
\u9304
\u83CC
\u7D14
\u501F
\u7CD6
\u84CB
\u6A6B
\u7B26
\u79C1
\u52AA
\u5802
\u57DF
\u69CD
\u6F64
\u5E45
\u54C8
\u7ADF
\u719F
\u87F2
\u6FA4
\u8166
\u58E4
\u78B3
\u6B50
\u904D
\u5074
\u5BE8
\u6562
\u5FB9
\u616E
\u659C
\u8584
\u5EAD
\u7D0D
\u5F48
\u98FC
\u4F38
\u6298
\u9EA5
\u6FD5
\u6697
\u8377
\u74E6
\u585E
\u5E8A
\u7BC9
\u60E1
\u6236
\u8A2A
\u5854
\u5947
\u900F
\u6881
\u5200
\u65CB
\u8DE1
\u5361
\u6C2F
\u9047
\u4EFD
\u6BD2
\u6CE5
\u9000
\u6D17
\u64FA
\u7070
\u5F69
\u8CE3
\u8017
\u590F
\u64C7
\u5FD9
\u9285
\u737B
\u786C
\u4E88
\u7E41
\u5708
\u96EA
\u51FD
\u4EA6
\u62BD
\u7BC7
\u9663
\u9670
\u4E01
\u5C3A
\u8FFD
\u5806
\u96C4
\u8FCE
\u6CDB
\u7238
\u6A13
\u907F
\u8B00
\u5678
\u91CE
\u8C6C
\u65D7
\u7D2F
\u504F
\u5178
\u9928
\u7D22
\u79E6
\u8102
\u6F6E
\u723A
\u8C46
\u5FFD
\u6258
\u9A5A
\u5851
\u907A
\u6108
\u6731
\u66FF
\u7E96
\u7C97
\u50BE
\u5C1A
\u75DB
\u695A
\u8B1D
\u596E
\u8CFC
\u78E8
\u541B
\u6C60
\u65C1
\u788E
\u9AA8
\u76E3
\u6355
\u5F1F
\u66B4
\u5272
\u8CAB
\u6B8A
\u91CB
\u8A5E
\u4EA1
\u58C1
\u9813
\u5BF6
\u5348
\u5875
\u805E
\u63ED
\u70AE
\u6B98
\u51AC
\u6A4B
\u5A66
\u8B66
\u7D9C
\u62DB
\u5433
\u4ED8
\u6D6E
\u906D
\u5F90
\u60A8
\u6416
\u8C37
\u8D0A
\u7BB1
\u9694
\u8A02
\u7537
\u5439
\u5712
\u7D1B
\u5510
\u6557
\u5B8B
\u73BB
\u5DE8
\u8015
\u5766
\u69AE
\u9589
\u7063
\u9375
\u51E1
\u99D0
\u934B
\u6551
\u6069
\u525D
\u51DD
\u9E7C
\u9F52
\u622A
\u7149
\u9EBB
\u7D21
\u7981
\u5EE2
\u76DB
\u7248
\u7DE9
\u6DE8
\u775B
\u660C
\u5A5A
\u6D89
\u7B52
\u5634
\u63D2
\u5CB8
\u6717
\u838A
\u8857
\u85CF
\u59D1
\u8CBF
\u8150
\u5974
\u5566
\u6163
\u4E58
\u5925
\u6062
\u52FB
\u7D17
\u624E
\u8FAF
\u8033
\u5F6A
\u81E3
\u5104
\u7483
\u62B5
\u8108
\u79C0
\u85A9
\u4FC4
\u7DB2
\u821E
\u5E97
\u5674
\u7E31
\u5BF8
\u6C57
\u639B
\u6D2A
\u8CC0
\u9583
\u67EC
\u7206
\u70EF
\u6D25
\u7A3B
\u7246
\u8EDF
\u52C7
\u50CF
\u6EFE
\u5398
\u8499
\u82B3
\u80AF
\u5761
\u67F1
\u76EA
\u817F
\u5100
\u65C5
\u5C3E
\u8ECB
\u51B0
\u8CA2
\u767B
\u9ECE
\u524A
\u947D
\u52D2
\u9003
\u969C
\u6C28
\u90ED
\u5CF0
\u5E63
\u6E2F
\u4F0F
\u8ECC
\u755D
\u7562
\u64E6
\u83AB
\u523A
\u6D6A
\u79D8
\u63F4
\u682A
\u5065
\u552E
\u80A1
\u5CF6
\u7518
\u6CE1
\u7761
\u7AE5
\u9444
\u6E6F
\u95A5
\u4F11
\u532F
\u820D
\u7267
\u7E5E
\u70B8
\u54F2
\u78F7
\u7E3E
\u670B
\u6DE1
\u5C16
\u555F
\u9677
\u67F4
\u5448
\u5F92
\u984F
\u6DDA
\u7A0D
\u5FD8
\u6CF5
\u85CD
\u62D6
\u6D1E
\u6388
\u93E1
\u8F9B
\u58EF
\u92D2
\u8CA7
\u865B
\u5F4E
\u6469
\u6CF0
\u5E7C
\u5EF7
\u5C0A
\u7A97
\u7DB1
\u5F04
\u96B8
\u7591
\u6C0F
\u5BAE
\u59D0
\u9707
\u745E
\u602A
\u5C24
\u7434
\u5FAA
\u63CF
\u819C
\u9055
\u593E
\u8170
\u7DE3
\u73E0
\u7AAE
\u68EE
\u679D
\u7AF9
\u6E9D
\u50AC
\u7E69
\u61B6
\u90A6
\u5269
\u5E78
\u6F3F
\u6B04
\u64C1
\u7259
\u8CAF
\u79AE
\u6FFE
\u9209
\u7D0B
\u7F77
\u62CD
\u54B1
\u558A
\u8896
\u57C3
\u52E4
\u7F70
\u7126
\u6F5B
\u4F0D
\u58A8
\u6B32
\u7E2B
\u59D3
\u520A
\u98FD
\u4EFF
\u734E
\u92C1
\u9B3C
\u9E97
\u8DE8
\u9ED8
\u6316
\u93C8
\u6383
\u559D
\u888B
\u70AD
\u6C61
\u5E55
\u8AF8
\u5F27
\u52F5
\u6885
\u5976
\u6F54
\u707D
\u821F
\u9451
\u82EF
\u8A1F
\u62B1
\u6BC0
\u61C2
\u5BD2
\u667A
\u57D4
\u5BC4
\u5C46
\u8E8D
\u6E21
\u6311
\u4E39
\u8271
\u8C9D
\u78B0
\u62D4
\u7239
\u6234
\u78BC
\u5922
\u82BD
\u7194
\u8D64
\u6F01
\u54ED
\u656C
\u9846
\u5954
\u925B
\u4EF2
\u864E
\u7A00
\u59B9
\u4E4F
\u73CD
\u7533
\u684C
\u9075
\u5141
\u9686
\u87BA
\u5009
\u9B4F
\u92B3
\u66C9
\u6C2E
\u517C
\u96B1
\u7919
\u8D6B
\u64A5
\u5FE0
\u8085
\u7F38
\u727D
\u6436
\u535A
\u5DE7
\u6BBC
\u5144
\u675C
\u8A0A
\u8AA0
\u78A7
\u7965
\u67EF
\u9801
\u5DE1
\u77E9
\u60B2
\u704C
\u9F61
\u502B
\u7968
\u5C0B
\u6842
\u92EA
\u8056
\u6050
\u6070
\u912D
\u8DA3
\u62AC
\u8352
\u9A30
\u8CBC
\u67D4
\u6EF4
\u731B
\u95CA
\u8F1B
\u59BB
\u586B
\u64A4
\u5132
\u7C3D
\u9B27
\u64FE
\u7D2B
\u7802
\u905E
\u6232
\u540A
\u9676
\u4F10
\u9935
\u7642
\u74F6
\u5A46
\u64AB
\u81C2
\u6478
\u5FCD
\u8766
\u881F
\u9130
\u80F8
\u978F
\u64E0
\u5076
\u68C4
\u69FD
\u52C1
\u4E73
\u9127
\u5409
\u4EC1
\u721B
\u78DA
\u79DF
\u70CF
\u8266
\u4F34
\u74DC
\u6DFA
\u4E19
\u66AB
\u71E5
\u6A61
\u67F3
\u8FF7
\u6696
\u724C
\u79E7
\u81BD
\u8A73
\u7C27
\u8E0F
\u74F7
\u8B5C
\u5446
\u8CD3
\u7CCA
\u6D1B
\u8F1D
\u61A4
\u7AF6
\u9699
\u6012
\u7C98
\u4E43
\u7DD2
\u80A9
\u7C4D
\u654F
\u5857
\u7199
\u7686
\u5075
\u61F8
\u6398
\u4EAB
\u7CFE
\u9192
\u72C2
\u9396
\u6DC0
\u6068
\u7272
\u9738
\u722C
\u8CDE
\u9006
\u73A9
\u9675
\u795D
\u79D2
\u6D59
\u8C8C
\u5F79
\u5F7C
\u6089
\u9D28
\u8DA8
\u9CF3
\u6668
\u755C
\u8F29
\u79E9
\u5375
\u7F72
\u68AF
\u708E
\u7058
\u68CB
\u9A45
\u7BE9
\u5CFD
\u5192
\u5565
\u58FD
\u8B6F
\u6D78
\u6CC9
\u5E3D
\u9072
\u77FD
\u7586
\u8CB8
\u6F0F
\u7A3F
\u51A0
\u5AE9
\u8105
\u82AF
\u7262
\u53DB
\u8755
\u5967
\u9CF4
\u5DBA
\u7F8A
\u6191
\u4E32
\u5858
\u7E6A
\u9175
\u878D
\u76C6
\u932B
\u5EDF
\u7C4C
\u51CD
\u8F14
\u651D
\u8972
\u7B4B
\u62D2
\u50DA
\u65F1
\u9240
\u9CE5
\u6F06
\u6C88
\u7709
\u758F
\u6DFB
\u68D2
\u7A57
\u785D
\u97D3
\u903C
\u626D
\u50D1
\u6DBC
\u633A
\u7897
\u683D
\u7092
\u676F
\u60A3
\u993E
\u52F8
\u8C6A
\u907C
\u52C3
\u9D3B
\u65E6
\u540F
\u62DC
\u72D7
\u57CB
\u8F25
\u63A9
\u98F2
\u642C
\u7F75
\u8FAD
\u52FE
\u6263
\u4F30
\u8523
\u7D68
\u9727
\u4E08
\u6735
\u59C6
\u64EC
\u5B87
\u8F2F
\u965D
\u96D5
\u511F
\u84C4
\u5D07
\u526A
\u5021
\u5EF3
\u54AC
\u99DB
\u85AF
\u5237
\u65A5
\u756A
\u8CE6
\u5949
\u4F5B
\u6F86
\u6F2B
\u66FC
\u6247
\u9223
\u6843
\u6276
\u4ED4
\u8FD4
\u4FD7
\u8667
\u8154
\u978B
\u68F1
\u8986
\u6846
\u6084
\u53D4
\u649E
\u9A19
\u52D8
\u65FA
\u6CB8
\u5B64
\u5410
\u5B5F
\u6E20
\u5C48
\u75BE
\u5999
\u60DC
\u4EF0
\u72E0
\u8139
\u8AE7
\u62CB
\u9EF4
\u6851
\u5D17
\u561B
\u8870
\u76DC
\u6EF2
\u81DF
\u8CF4
\u6E67
\u751C
\u66F9
\u95B1
\u808C
\u54E9
\u53B2
\u70F4
\u7DEF
\u6BC5
\u6628
\u507D
\u75C7
\u716E
\u5606
\u91D8
\u642D
\u8396
\u7C60
\u9177
\u5077
\u5F13
\u9310
\u6046
\u5091
\u5751
\u9F3B
\u7FFC
\u7DB8
\u6558
\u7344
\u902E
\u7F50
\u7D61
\u68DA
\u6291
\u81A8
\u852C
\u5BFA
\u9A5F
\u7A46
\u51B6
\u67AF
\u518A
\u5C4D
\u51F8
\u7D33
\u576F
\u72A7
\u7130
\u8F5F
\u6B23
\u6649
\u7626
\u79A6
\u9320
\u9326
\u55AA
\u65EC
\u935B
\u58DF
\u641C
\u64B2
\u9080
\u4EAD
\u916F
\u9081
\u8212
\u8106
\u9176
\u9592
\u6182
\u915A
\u9811
\u7FBD
\u6F32
\u5378
\u4ED7
\u966A
\u95E2
\u61F2
\u676D
\u59DA
\u809A
\u6349
\u98C4
\u6F02
\u6606
\u6B3A
\u543E
\u90CE
\u70F7
\u6C41
\u5475
\u98FE
\u856D
\u96C5
\u90F5
\u9077
\u71D5
\u6492
\u59FB
\u8D74
\u5BB4
\u7169
\u50B5
\u5E33
\u6591
\u9234
\u65E8
\u9187
\u8463
\u9905
\u96DB
\u59FF
\u62CC
\u5085
\u8179
\u59A5
\u63C9
\u8CE2
\u62C6
\u6B6A
\u8461
\u80FA
\u4E1F
\u6D69
\u5FBD
\u6602
\u588A
\u64CB
\u89BD
\u8CAA
\u6170
\u7E73
\u6C6A
\u614C
\u99AE
\u8AFE
\u59DC
\u8ABC
\u5147
\u52A3
\u8AA3
\u8000
\u660F
\u8EBA
\u76C8
\u9A0E
\u55AC
\u6EAA
\u53E2
\u76E7
\u62B9
\u60B6
\u8AEE
\u522E
\u99D5
\u7E9C
\u609F
\u6458
\u927A
\u64F2
\u9817
\u5E7B
\u67C4
\u60E0
\u6158
\u4F73
\u4EC7
\u81D8
\u7AA9
\u6ECC
\u528D
\u77A7
\u5821
\u6F51
\u8525
\u7F69
\u970D
\u6488
\u80CE
\u84BC
\u6FF1
\u5006
\u6345
\u6E58
\u780D
\u971E
\u90B5
\u8404
\u760B
\u6DEE
\u9042
\u718A
\u7CDE
\u70D8
\u5BBF
\u6A94
\u6208
\u99C1
\u5AC2
\u88D5
\u5F99
\u7BAD
\u6350
\u8178
\u6490
\u66EC
\u8FA8
\u6BBF
\u84EE
\u6524
\u652A
\u91AC
\u5C4F
\u75AB
\u54C0
\u8521
\u5835
\u6CAB
\u76BA
\u66A2
\u758A
\u95A3
\u840A
\u6572
\u8F44
\u9264
\u75D5
\u58E9
\u5DF7
\u9913
\u798D
\u4E18
\u7384
\u6E9C
\u66F0
\u908F
\u5F6D
\u5617
\u537F
\u59A8
\u8247
\u541E
\u97CB
\u6028
\u77EE
\u6B47`.split("\n");
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/accounts/privateKeyToAccount.js
init_secp256k1();
init_toHex();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/accounts/toAccount.js
init_address();
init_isAddress();
function toAccount(source) {
  if (typeof source === "string") {
    if (!isAddress(source))
      throw new InvalidAddressError({ address: source });
    return {
      address: source,
      type: "json-rpc"
    };
  }
  if (!isAddress(source.address))
    throw new InvalidAddressError({ address: source.address });
  return {
    address: source.address,
    signMessage: source.signMessage,
    signTransaction: source.signTransaction,
    signTypedData: source.signTypedData,
    source: "custom",
    type: "local"
  };
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/accounts/utils/sign.js
init_secp256k1();
init_toHex();
async function sign({ hash: hash4, privateKey }) {
  const { r, s, recovery } = secp256k1.sign(hash4.slice(2), privateKey.slice(2));
  return {
    r: toHex2(r),
    s: toHex2(s),
    v: recovery ? 28n : 27n
  };
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/accounts/utils/signMessage.js
async function signMessage3({ message, privateKey }) {
  const signature = await sign({ hash: hashMessage(message), privateKey });
  return signatureToHex(signature);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/accounts/utils/signTransaction.js
init_keccak256();
async function signTransaction3({ privateKey, transaction: transaction14, serializer = serializeTransaction }) {
  const signature = await sign({
    hash: keccak256(serializer(transaction14)),
    privateKey
  });
  return serializer(transaction14, signature);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/accounts/utils/signTypedData.js
async function signTypedData3({ privateKey, ...typedData3 }) {
  const signature = await sign({
    hash: hashTypedData(typedData3),
    privateKey
  });
  return signatureToHex(signature);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/accounts/privateKeyToAccount.js
function privateKeyToAccount(privateKey) {
  const publicKey = toHex2(secp256k1.getPublicKey(privateKey.slice(2), false));
  const address9 = publicKeyToAddress(publicKey);
  const account7 = toAccount({
    address: address9,
    async signMessage({ message }) {
      return signMessage3({ message, privateKey });
    },
    async signTransaction(transaction14, { serializer } = {}) {
      return signTransaction3({ privateKey, transaction: transaction14, serializer });
    },
    async signTypedData(typedData3) {
      return signTypedData3({ ...typedData3, privateKey });
    }
  });
  return {
    ...account7,
    publicKey,
    source: "privateKey"
  };
}
// cli/config/bundler.ts
var logLevel = z.enum(["trace", "debug", "info", "warn", "error", "fatal"]);
var bundlerArgsSchema = z.object({
  entryPoint: addressSchema,
  entryPointSimulationsAddress: addressSchema.optional(),
  networkName: z.string(),
  signerPrivateKeys: z.union([
    z.array(hexData32Schema).transform((vals) => vals.map((val) => privateKeyToAccount(val))),
    z.string().regex(/^0x(?:[0-9a-f]{2}){32}(?:,0x(?:[0-9a-f]{2}){32})*$/).transform((val) => val.split(",").map((val2) => privateKeyToAccount(val2)))
  ]),
  signerPrivateKeysExtra: z.union([
    z.array(hexData32Schema).transform((vals) => vals.map((val) => privateKeyToAccount(val))),
    z.string().regex(/^0x(?:[0-9a-f]{2}){32}(?:,0x(?:[0-9a-f]{2}){32})*$/).transform((val) => val.split(",").map((val2) => privateKeyToAccount(val2)))
  ]).optional(),
  utilityPrivateKey: hexData32Schema.transform((val) => privateKeyToAccount(val)),
  maxSigners: z.number().int().min(0).optional(),
  rpcUrl: z.string().url(),
  executionRpcUrl: z.string().url().optional(),
  bundleBulkerAddress: addressSchema.optional(),
  perOpInflatorAddress: addressSchema.optional(),
  minBalance: z.string().transform((val) => BigInt(val)),
  refillInterval: z.number().int().min(0),
  requestTimeout: z.number().int().min(0).optional(),
  minStake: z.number().int().min(0),
  minUnstakeDelay: z.number().int().min(0),
  maxBundleWaitTime: z.number().int().min(0),
  maxBundleSize: z.number().int().min(0),
  port: z.number().int().min(0),
  pollingInterval: z.number().int().min(0),
  environment: z.enum(["production", "staging", "development"]),
  logLevel,
  publicClientLogLevel: logLevel.optional(),
  walletClientLogLevel: logLevel.optional(),
  rpcLogLevel: logLevel.optional(),
  mempoolLogLevel: logLevel.optional(),
  executorLogLevel: logLevel.optional(),
  reputationManagerLogLevel: logLevel.optional(),
  nonceQueuerLogLevel: logLevel.optional(),
  logEnvironment: z.enum(["production", "development"]),
  bundleMode: z.enum(["auto", "manual"]),
  bundlerFrequency: z.number().int().min(0),
  flushStuckTransactionsDuringStartup: z.boolean(),
  safeMode: z.boolean(),
  disableExpirationCheck: z.boolean(),
  tenderlyEnabled: z.boolean().optional(),
  minimumGasPricePercent: z.number().int().min(0),
  apiVersion: z.enum(["v1", "v2"]),
  noEip1559Support: z.boolean(),
  noEthCallOverrideSupport: z.boolean(),
  balanceOverrideEnabled: z.boolean(),
  useUserOperationGasLimitsForSubmission: z.boolean(),
  customGasLimitForEstimation: z.string().transform((val) => BigInt(val)).optional(),
  rpcMaxBlockRange: z.number().int().min(0).optional(),
  dangerousSkipUserOperationValidation: z.boolean().optional(),
  entryPointVersion: z.enum(["0.6", "0.7"]),
  gasPriceTimeValidityInSeconds: z.number().int().min(0)
});
// utils/logger.ts
var import_pino = __toESM(require_pino(), 1);
var bigintToJson = function(_key, value) {
  if (typeof value === "bigint") {
    return toHex2(value);
  }
  return value;
};
var logLevel2 = function(label) {
  return {
    level: label
  };
};
var stringifyWithCircularHandling = function(obj, replacer) {
  const cache = new Set;
  return JSON.stringify(obj, (key, value) => {
    if (typeof value === "object" && value !== null) {
      if (cache.has(value)) {
        return;
      }
      cache.add(value);
    }
    return replacer ? replacer(key, value) : value;
  });
};
var customSerializer = (input) => {
  const output2 = {};
  for (const key in input) {
    if (Object.prototype.hasOwnProperty.call(input, key)) {
      const value = input[key];
      if (typeof value === "object" && value !== null) {
        output2[key] = JSON.parse(stringifyWithCircularHandling(value, bigintToJson));
      } else {
        output2[key] = bigintToJson(key, value);
      }
    }
  }
  return output2;
};
var initDebugLogger = (level = "debug") => {
  const l = import_pino.default({
    transport: {
      target: "pino-pretty",
      options: {
        colorize: true
      }
    },
    formatters: {
      level: logLevel2,
      log: customSerializer
    }
  });
  l.level = level;
  return l;
};
var initProductionLogger = (level) => {
  const l = import_pino.default({
    base: undefined,
    formatters: {
      level: logLevel2,
      log: customSerializer
    }
  });
  l.level = level;
  return l;
};
// /home/mous/work/pimlico/alto/src/node_modules/prom-client/index.js
var $register = require_registry().globalRegistry;
var $Registry = require_registry();
var $contentType = require_registry().globalRegistry.contentType;
var $validateMetricName = require_validation().validateMetricName;
var $Counter = require_counter();
var $Gauge = require_gauge();
var $Histogram = require_histogram();
var $Summary = require_summary();
var $Pushgateway = require_pushgateway();
var $linearBuckets = require_bucketGenerators().linearBuckets;
var $exponentialBuckets = require_bucketGenerators().exponentialBuckets;
var $collectDefaultMetrics = require_defaultMetrics();
var $aggregators = require_metricAggregators().aggregators;
var $AggregatorRegistry = require_cluster();

// utils/metrics.ts
function createMetrics(registry, register = true) {
  $collectDefaultMetrics({ register: registry });
  const registers = register ? [registry] : [];
  const httpRequests = new $Counter({
    name: "alto_requests_total",
    help: "Total number of requests",
    labelNames: [
      "route",
      "network",
      "chainId",
      "rpc_method",
      "rpc_status",
      "code",
      "method"
    ],
    registers
  });
  const httpRequestsDuration = new $Histogram({
    name: "alto_requests_duration_seconds",
    help: "Duration of requests in seconds",
    labelNames: [
      "route",
      "network",
      "chainId",
      "rpc_method",
      "rpc_status",
      "code",
      "method",
      "api_version"
    ],
    registers
  });
  const userOperationsInMempool = new $Gauge({
    name: "alto_user_operations_in_mempool_count",
    help: "Number of user operations in mempool",
    labelNames: ["network", "chainId", "status"],
    registers
  });
  const walletsAvailable = new $Gauge({
    name: "alto_executor_wallets_available_count",
    help: "Number of available executor wallets used to bundle",
    labelNames: [],
    registers
  });
  const walletsTotal = new $Gauge({
    name: "alto_executor_wallets_total_count",
    help: "Number of total executor wallets used to bundle",
    labelNames: [],
    registers
  });
  const userOperationsOnChain = new $Counter({
    name: "alto_user_operations_on_chain_total",
    help: "Number of user operations on-chain by status",
    labelNames: ["status"],
    registers
  });
  const userOperationsSubmitted = new $Counter({
    name: "alto_user_operations_submitted_total",
    help: "Number of user operations bundles submitted on-chain",
    labelNames: ["status"],
    registers
  });
  const bundlesIncluded = new $Counter({
    name: "alto_bundles_included_total",
    help: "Number of user operations bundles included on-chain",
    labelNames: [],
    registers
  });
  const bundlesSubmitted = new $Counter({
    name: "alto_bundles_submitted_total",
    help: "Number of user operations bundles submitted on-chain",
    labelNames: ["status"],
    registers
  });
  const userOperationsReceived = new $Counter({
    name: "alto_user_operations_received_total",
    help: "Number of user operations received",
    labelNames: ["status", "type"],
    registers
  });
  const userOperationsValidationSuccess = new $Counter({
    name: "alto_user_operations_validation_success_total",
    help: "Number of user operations successfully validated",
    labelNames: [],
    registers
  });
  const userOperationsValidationFailure = new $Counter({
    name: "alto_user_operations_validation_failure_total",
    help: "Number of user operations failed to validate",
    labelNames: [],
    registers
  });
  const userOperationInclusionDuration = new $Histogram({
    name: "alto_user_operation_inclusion_duration_seconds",
    help: "Duration of user operation inclusion from first submission to inclusion on-chain",
    labelNames: [],
    registers,
    buckets: [
      0.5,
      1,
      2,
      4,
      6,
      8,
      10,
      12,
      14,
      16,
      18,
      20,
      25,
      30,
      40,
      50,
      60,
      120,
      180,
      240,
      300,
      600,
      900,
      1200
    ]
  });
  const verificationGasLimitEstimationTime = new $Histogram({
    name: "alto_verification_gas_limit_estimation_time_seconds",
    help: "Total duration of verification gas limit estimation",
    labelNames: [],
    registers,
    buckets: [0.1, 0.2, 0.3, 0.5, 1, 1.5, 2, 2.5, 3, 4, 5]
  });
  const verificationGasLimitEstimationCount = new $Histogram({
    name: "alto_verification_gas_limit_estimation_count",
    help: "Number of verification gas limit estimation calls",
    labelNames: [],
    registers,
    buckets: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  });
  const replacedTransactions = new $Counter({
    name: "alto_replaced_transactions_total",
    help: "Number of replaced transactions",
    labelNames: ["reason", "status"],
    registers
  });
  const userOperationsResubmitted = new $Counter({
    name: "alto_user_operations_resubmitted_total",
    help: "Number of user operations resubmitted",
    labelNames: [],
    registers
  });
  return {
    httpRequests,
    httpRequestsDuration,
    userOperationsInMempool,
    walletsAvailable,
    walletsTotal,
    userOperationsOnChain,
    userOperationsSubmitted,
    bundlesIncluded,
    bundlesSubmitted,
    userOperationsReceived,
    userOperationsValidationSuccess,
    userOperationsValidationFailure,
    userOperationInclusionDuration,
    verificationGasLimitEstimationTime,
    verificationGasLimitEstimationCount,
    replacedTransactions,
    userOperationsResubmitted
  };
}
// utils/bigInt.ts
var minBigInt = (a, b) => {
  return a < b ? a : b;
};
var maxBigInt = (a, b) => {
  return a > b ? a : b;
};
// entrypoint-0.7/types/contracts/BundleBulker.ts
var BundleBulkerAbi2 = [
  {
    type: "fallback",
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "ENTRY_POINT",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "idToInflator",
    inputs: [
      {
        name: "",
        type: "uint32",
        internalType: "uint32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract IInflator"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "inflate",
    inputs: [
      {
        name: "compressed",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [
      {
        name: "ops",
        type: "tuple[]",
        internalType: "struct UserOperation[]",
        components: [
          {
            name: "sender",
            type: "address",
            internalType: "address"
          },
          {
            name: "nonce",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "initCode",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "callData",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "callGasLimit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "verificationGasLimit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "maxFeePerGas",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "paymasterAndData",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "signature",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "beneficiary",
        type: "address",
        internalType: "address payable"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "inflatorToID",
    inputs: [
      {
        name: "",
        type: "address",
        internalType: "contract IInflator"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint32",
        internalType: "uint32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "registerInflator",
    inputs: [
      {
        name: "inflatorId",
        type: "uint32",
        internalType: "uint32"
      },
      {
        name: "inflator",
        type: "address",
        internalType: "contract IInflator"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  }
];
// entrypoint-0.7/types/contracts/EntryPoint.ts
var EntryPointAbi2 = [
  {
    inputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "bytes",
        name: "ret",
        type: "bytes"
      }
    ],
    name: "DelegateAndRevert",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "opIndex",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "reason",
        type: "string"
      }
    ],
    name: "FailedOp",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "opIndex",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "reason",
        type: "string"
      },
      {
        internalType: "bytes",
        name: "inner",
        type: "bytes"
      }
    ],
    name: "FailedOpWithRevert",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "returnData",
        type: "bytes"
      }
    ],
    name: "PostOpReverted",
    type: "error"
  },
  {
    inputs: [],
    name: "ReentrancyGuardReentrantCall",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "SenderAddressResult",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "aggregator",
        type: "address"
      }
    ],
    name: "SignatureValidationFailed",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "factory",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "paymaster",
        type: "address"
      }
    ],
    name: "AccountDeployed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [],
    name: "BeforeExecution",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalDeposit",
        type: "uint256"
      }
    ],
    name: "Deposited",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "PostOpRevertReason",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "aggregator",
        type: "address"
      }
    ],
    name: "SignatureAggregatorChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalStaked",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "unstakeDelaySec",
        type: "uint256"
      }
    ],
    name: "StakeLocked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "withdrawTime",
        type: "uint256"
      }
    ],
    name: "StakeUnlocked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "StakeWithdrawn",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "paymaster",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "actualGasCost",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "actualGasUsed",
        type: "uint256"
      }
    ],
    name: "UserOperationEvent",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "UserOperationRevertReason",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Withdrawn",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "unstakeDelaySec",
        type: "uint32"
      }
    ],
    name: "addStake",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "delegateAndRevert",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "depositTo",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "deposits",
    outputs: [
      {
        internalType: "uint256",
        name: "deposit",
        type: "uint256"
      },
      {
        internalType: "bool",
        name: "staked",
        type: "bool"
      },
      {
        internalType: "uint112",
        name: "stake",
        type: "uint112"
      },
      {
        internalType: "uint32",
        name: "unstakeDelaySec",
        type: "uint32"
      },
      {
        internalType: "uint48",
        name: "withdrawTime",
        type: "uint48"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "getDepositInfo",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "deposit",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "staked",
            type: "bool"
          },
          {
            internalType: "uint112",
            name: "stake",
            type: "uint112"
          },
          {
            internalType: "uint32",
            name: "unstakeDelaySec",
            type: "uint32"
          },
          {
            internalType: "uint48",
            name: "withdrawTime",
            type: "uint48"
          }
        ],
        internalType: "struct IStakeManager.DepositInfo",
        name: "info",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "uint192",
        name: "key",
        type: "uint192"
      }
    ],
    name: "getNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "initCode",
        type: "bytes"
      }
    ],
    name: "getSenderAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "gasFees",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct PackedUserOperation",
        name: "userOp",
        type: "tuple"
      }
    ],
    name: "getUserOpHash",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "bytes32",
                name: "accountGasLimits",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "gasFees",
                type: "bytes32"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct PackedUserOperation[]",
            name: "userOps",
            type: "tuple[]"
          },
          {
            internalType: "contract IAggregator",
            name: "aggregator",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct IEntryPoint.UserOpsPerAggregator[]",
        name: "opsPerAggregator",
        type: "tuple[]"
      },
      {
        internalType: "address payable",
        name: "beneficiary",
        type: "address"
      }
    ],
    name: "handleAggregatedOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "gasFees",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct PackedUserOperation[]",
        name: "ops",
        type: "tuple[]"
      },
      {
        internalType: "address payable",
        name: "beneficiary",
        type: "address"
      }
    ],
    name: "handleOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint192",
        name: "key",
        type: "uint192"
      }
    ],
    name: "incrementNonce",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "callData",
        type: "bytes"
      },
      {
        components: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "paymasterVerificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "paymasterPostOpGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "paymaster",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              }
            ],
            internalType: "struct EntryPoint.MemoryUserOp",
            name: "mUserOp",
            type: "tuple"
          },
          {
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "prefund",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "contextOffset",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "preOpGas",
            type: "uint256"
          }
        ],
        internalType: "struct EntryPoint.UserOpInfo",
        name: "opInfo",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "context",
        type: "bytes"
      }
    ],
    name: "innerHandleOp",
    outputs: [
      {
        internalType: "uint256",
        name: "actualGasCost",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint192",
        name: "",
        type: "uint192"
      }
    ],
    name: "nonceSequenceNumber",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "unlockStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address payable",
        name: "withdrawAddress",
        type: "address"
      }
    ],
    name: "withdrawStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address payable",
        name: "withdrawAddress",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "withdrawAmount",
        type: "uint256"
      }
    ],
    name: "withdrawTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];
// entrypoint-0.7/types/contracts/IPaymaster.ts
var PaymasterAbi2 = [
  {
    inputs: [
      {
        internalType: "enum IPaymaster.PostOpMode",
        name: "mode",
        type: "uint8"
      },
      {
        internalType: "bytes",
        name: "context",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "actualGasCost",
        type: "uint256"
      }
    ],
    name: "postOp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "callGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxFeePerGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct UserOperation",
        name: "userOp",
        type: "tuple"
      },
      {
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "maxCost",
        type: "uint256"
      }
    ],
    name: "validatePaymasterUserOp",
    outputs: [
      {
        internalType: "bytes",
        name: "context",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "validationData",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
// entrypoint-0.7/types/contracts/IOpInflator.ts
var IOpInflatorAbi2 = [
  {
    type: "function",
    name: "inflate",
    inputs: [
      {
        name: "compressed",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [
      {
        name: "op",
        type: "tuple",
        internalType: "struct UserOperation",
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "gasFees",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ]
      }
    ],
    stateMutability: "view"
  }
];
// entrypoint-0.7/types/contracts/PerOpInflator.ts
var PerOpInfaltorAbi2 = [
  {
    type: "constructor",
    inputs: [
      {
        name: "_owner",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "beneficiary",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address payable"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "idToInflator",
    inputs: [
      {
        name: "",
        type: "uint32",
        internalType: "uint32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract IOpInflator"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "inflate",
    inputs: [
      {
        name: "compressed",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple[]",
        internalType: "struct UserOperation[]",
        components: [
          {
            name: "sender",
            type: "address",
            internalType: "address"
          },
          {
            name: "nonce",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "initCode",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "callData",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "callGasLimit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "verificationGasLimit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "maxFeePerGas",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "paymasterAndData",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "signature",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "",
        type: "address",
        internalType: "address payable"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "inflatorToID",
    inputs: [
      {
        name: "",
        type: "address",
        internalType: "contract IOpInflator"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint32",
        internalType: "uint32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "owner",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "registerOpInflator",
    inputs: [
      {
        name: "inflatorId",
        type: "uint32",
        internalType: "uint32"
      },
      {
        name: "inflator",
        type: "address",
        internalType: "contract IOpInflator"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "renounceOwnership",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setBeneficiary",
    inputs: [
      {
        name: "_beneficiary",
        type: "address",
        internalType: "address payable"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "transferOwnership",
    inputs: [
      {
        name: "newOwner",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "event",
    name: "OwnershipTransferred",
    inputs: [
      {
        name: "previousOwner",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "newOwner",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  }
];
// entrypoint-0.7/types/contracts/SenderCreator.ts
var SenderCreatorAbi2 = [
  {
    inputs: [
      {
        internalType: "bytes",
        name: "initCode",
        type: "bytes"
      }
    ],
    name: "createSender",
    outputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
// entrypoint-0.7/types/contracts/CodeHashGetter.ts
var CodeHashGetterAbi2 = [
  {
    inputs: [
      {
        internalType: "address[]",
        name: "addresses",
        type: "address[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "hash",
        type: "bytes32"
      }
    ],
    name: "CodeHashesResult",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "addresses",
        type: "address[]"
      }
    ],
    name: "getCodeHashes",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var CodeHashGetterBytecode2 = "0x608060405234801561001057600080fd5b506040516102b03803806102b083398101604081905261002f9161016a565b6100388161005d565b60405163091cd00560e01b815260040161005491815260200190565b60405180910390fd5b60008082516001600160401b0381111561007957610079610138565b6040519080825280602002602001820160405280156100a2578160200160208202803683370190505b50905060005b8351811015610104578381815181106100c3576100c361022e565b60200260200101516001600160a01b03163f8282815181106100e7576100e761022e565b6020908102919091010152806100fc81610244565b9150506100a8565b50600081604051602001610118919061026b565b60408051601f198184030181529190528051602090910120949350505050565b634e487b7160e01b600052604160045260246000fd5b80516001600160a01b038116811461016557600080fd5b919050565b6000602080838503121561017d57600080fd5b82516001600160401b038082111561019457600080fd5b818501915085601f8301126101a857600080fd5b8151818111156101ba576101ba610138565b8060051b604051601f19603f830116810181811085821117156101df576101df610138565b6040529182528482019250838101850191888311156101fd57600080fd5b938501935b82851015610222576102138561014e565b84529385019392850192610202565b98975050505050505050565b634e487b7160e01b600052603260045260246000fd5b60006001820161026457634e487b7160e01b600052601160045260246000fd5b5060010190565b6020808252825182820181905260009190848201906040850190845b818110156102a357835183529284019291840191600101610287565b5090969550505050505056fe";
// entrypoint-0.7/types/contracts/EntryPointSimulations.ts
var EntryPointSimulationsAbi2 = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "bytes",
        name: "ret",
        type: "bytes"
      }
    ],
    name: "DelegateAndRevert",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "opIndex",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "reason",
        type: "string"
      }
    ],
    name: "FailedOp",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "opIndex",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "reason",
        type: "string"
      },
      {
        internalType: "bytes",
        name: "inner",
        type: "bytes"
      }
    ],
    name: "FailedOpWithRevert",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "returnData",
        type: "bytes"
      }
    ],
    name: "PostOpReverted",
    type: "error"
  },
  {
    inputs: [],
    name: "ReentrancyGuardReentrantCall",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "SenderAddressResult",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "aggregator",
        type: "address"
      }
    ],
    name: "SignatureValidationFailed",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "targetSuccess",
        type: "bool"
      },
      {
        internalType: "bytes",
        name: "targetResult",
        type: "bytes"
      }
    ],
    name: "TargetCallResult",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "factory",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "paymaster",
        type: "address"
      }
    ],
    name: "AccountDeployed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [],
    name: "BeforeExecution",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalDeposit",
        type: "uint256"
      }
    ],
    name: "Deposited",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "PostOpRevertReason",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "aggregator",
        type: "address"
      }
    ],
    name: "SignatureAggregatorChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalStaked",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "unstakeDelaySec",
        type: "uint256"
      }
    ],
    name: "StakeLocked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "withdrawTime",
        type: "uint256"
      }
    ],
    name: "StakeUnlocked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "StakeWithdrawn",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "paymaster",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "actualGasCost",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "actualGasUsed",
        type: "uint256"
      }
    ],
    name: "UserOperationEvent",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      }
    ],
    name: "UserOperationPrefundTooLow",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "UserOperationRevertReason",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Withdrawn",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "unstakeDelaySec",
        type: "uint32"
      }
    ],
    name: "addStake",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "delegateAndRevert",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "depositTo",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "deposits",
    outputs: [
      {
        internalType: "uint256",
        name: "deposit",
        type: "uint256"
      },
      {
        internalType: "bool",
        name: "staked",
        type: "bool"
      },
      {
        internalType: "uint112",
        name: "stake",
        type: "uint112"
      },
      {
        internalType: "uint32",
        name: "unstakeDelaySec",
        type: "uint32"
      },
      {
        internalType: "uint48",
        name: "withdrawTime",
        type: "uint48"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "getDepositInfo",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "deposit",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "staked",
            type: "bool"
          },
          {
            internalType: "uint112",
            name: "stake",
            type: "uint112"
          },
          {
            internalType: "uint32",
            name: "unstakeDelaySec",
            type: "uint32"
          },
          {
            internalType: "uint48",
            name: "withdrawTime",
            type: "uint48"
          }
        ],
        internalType: "struct IStakeManager.DepositInfo",
        name: "info",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "uint192",
        name: "key",
        type: "uint192"
      }
    ],
    name: "getNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "initCode",
        type: "bytes"
      }
    ],
    name: "getSenderAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "gasFees",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct PackedUserOperation",
        name: "userOp",
        type: "tuple"
      }
    ],
    name: "getUserOpHash",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "bytes32",
                name: "accountGasLimits",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "gasFees",
                type: "bytes32"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct PackedUserOperation[]",
            name: "userOps",
            type: "tuple[]"
          },
          {
            internalType: "contract IAggregator",
            name: "aggregator",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct IEntryPoint.UserOpsPerAggregator[]",
        name: "opsPerAggregator",
        type: "tuple[]"
      },
      {
        internalType: "address payable",
        name: "beneficiary",
        type: "address"
      }
    ],
    name: "handleAggregatedOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "gasFees",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct PackedUserOperation[]",
        name: "ops",
        type: "tuple[]"
      },
      {
        internalType: "address payable",
        name: "beneficiary",
        type: "address"
      }
    ],
    name: "handleOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint192",
        name: "key",
        type: "uint192"
      }
    ],
    name: "incrementNonce",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "callData",
        type: "bytes"
      },
      {
        components: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "paymasterVerificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "paymasterPostOpGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "paymaster",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              }
            ],
            internalType: "struct EntryPoint.MemoryUserOp",
            name: "mUserOp",
            type: "tuple"
          },
          {
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "prefund",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "contextOffset",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "preOpGas",
            type: "uint256"
          }
        ],
        internalType: "struct EntryPoint.UserOpInfo",
        name: "opInfo",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "context",
        type: "bytes"
      }
    ],
    name: "innerHandleOp",
    outputs: [
      {
        internalType: "uint256",
        name: "actualGasCost",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint192",
        name: "",
        type: "uint192"
      }
    ],
    name: "nonceSequenceNumber",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "gasFees",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct PackedUserOperation",
        name: "op",
        type: "tuple"
      },
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "targetCallData",
        type: "bytes"
      }
    ],
    name: "simulateCallData",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "gasFees",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct PackedUserOperation",
        name: "op",
        type: "tuple"
      }
    ],
    name: "simulateHandleOp",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "preOpGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "paid",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "accountValidationData",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "paymasterValidationData",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "targetSuccess",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "targetResult",
            type: "bytes"
          }
        ],
        internalType: "struct IEntryPointSimulations.ExecutionResult",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "gasFees",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct PackedUserOperation",
        name: "userOp",
        type: "tuple"
      }
    ],
    name: "simulateValidation",
    outputs: [
      {
        components: [
          {
            components: [
              {
                internalType: "uint256",
                name: "preOpGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "prefund",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "accountValidationData",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "paymasterValidationData",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterContext",
                type: "bytes"
              }
            ],
            internalType: "struct IEntryPoint.ReturnInfo",
            name: "returnInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "senderInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "factoryInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "paymasterInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "address",
                name: "aggregator",
                type: "address"
              },
              {
                components: [
                  {
                    internalType: "uint256",
                    name: "stake",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "unstakeDelaySec",
                    type: "uint256"
                  }
                ],
                internalType: "struct IStakeManager.StakeInfo",
                name: "stakeInfo",
                type: "tuple"
              }
            ],
            internalType: "struct IEntryPoint.AggregatorStakeInfo",
            name: "aggregatorInfo",
            type: "tuple"
          }
        ],
        internalType: "struct IEntryPointSimulations.ValidationResult",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "unlockStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address payable",
        name: "withdrawAddress",
        type: "address"
      }
    ],
    name: "withdrawStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address payable",
        name: "withdrawAddress",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "withdrawAmount",
        type: "uint256"
      }
    ],
    name: "withdrawTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];
// entrypoint-0.7/types/contracts/PimlicoEntryPointSimulations.ts
var PimlicoEntryPointSimulationsAbi = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "address payable",
        name: "ep",
        type: "address"
      },
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "simulateEntryPoint",
    outputs: [
      {
        internalType: "bytes[]",
        name: "",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var PimlicoEntryPointSimulationsBytecode = "0x60806040526040516100109061005f565b604051809103906000f08015801561002c573d6000803e3d6000fd5b50600080546001600160a01b0319166001600160a01b039290921691909117905534801561005957600080fd5b5061006c565b6153c8806105d683390190565b61055b8061007b6000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063c18f522614610030575b600080fd5b61004361003e36600461023a565b610059565b6040516100509190610403565b60405180910390f35b606060008251600161006b9190610485565b67ffffffffffffffff811115610083576100836101bc565b6040519080825280602002602001820160405280156100b657816020015b60608152602001906001900390816100a15790505b50905060005b83518110156101b25760608573ffffffffffffffffffffffffffffffffffffffff1663850aaf6260008054906101000a900473ffffffffffffffffffffffffffffffffffffffff16878581518110610116576101166104bf565b60200260200101516040518363ffffffff1660e01b815260040161013b9291906104ee565b600060405180830381600087803b15801561015557600080fd5b505af1925050508015610166575060015b61018b573d604051602082018101604052818152816000602083013e915061018b9050565b8083838151811061019e5761019e6104bf565b6020908102919091010152506001016100bc565b5090505b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715610232576102326101bc565b604052919050565b600080604080848603121561024e57600080fd5b833573ffffffffffffffffffffffffffffffffffffffff8116811461027257600080fd5b925060208481013567ffffffffffffffff8082111561029057600080fd5b8187019150601f88601f8401126102a657600080fd5b8235828111156102b8576102b86101bc565b8060051b6102c78682016101eb565b918252848101860191868101908c8411156102e157600080fd5b87870192505b8383101561038c578235868111156102ff5760008081fd5b8701603f81018e136103115760008081fd5b8881013587811115610325576103256101bc565b6103548a7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe089840116016101eb565b8181528f8c8385010111156103695760008081fd5b818c84018c83013760009181018b019190915283525091870191908701906102e7565b8099505050505050505050509250929050565b6000815180845260005b818110156103c5576020818501810151868301820152016103a9565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b600060208083016020845280855180835260408601915060408160051b87010192506020870160005b82811015610478577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc088860301845261046685835161039f565b9450928501929085019060010161042c565b5092979650505050505050565b808201808211156101b6577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b73ffffffffffffffffffffffffffffffffffffffff8316815260406020820152600061051d604083018461039f565b94935050505056fea2646970667358221220eeb9aca990134adf0a85230089406f5dd50171f3e00b1113b75843586c06007764736f6c6343000817003360a060405260405162000012906200009d565b604051809103906000f0801580156200002f573d6000803e3d6000fd5b506001600160a01b0390811660805260408051808201825260008082528251808401909352808352602080840191825282018390529051600380546001600160a01b031916919094161790925551600455516005553480156200009157600080fd5b506001600255620000ab565b610233806200519583390190565b6080516150d1620000c4600039600050506150d16000f3fe60806040526004361061016d5760003560e01c806370a08231116100cb578063bb9fe6bf1161007f578063c5f996e611610059578063c5f996e6146105b9578063dbed18e0146105d9578063fc7e286d146105f957600080fd5b8063bb9fe6bf14610557578063c23a5cea1461056c578063c3bce0091461058c57600080fd5b8063850aaf62116100b0578063850aaf62146105045780639b249f6914610524578063b760faf91461054457600080fd5b806370a08231146104a1578063765e827f146104e457600080fd5b8063205c28781161012257806335567e1a1161010757806335567e1a146102905780635287ce12146103255780635895273b1461047457600080fd5b8063205c28781461025057806322cdde4c1461027057600080fd5b80630396cb60116101535780630396cb60146101e55780630bd28e3b146101f85780631b2e01b81461021857600080fd5b806242dc531461018257806301ffc9a7146101b557600080fd5b3661017d5761017b336106cb565b005b600080fd5b34801561018e57600080fd5b506101a261019d36600461420a565b6106ec565b6040519081526020015b60405180910390f35b3480156101c157600080fd5b506101d56101d03660046142ca565b6108b5565b60405190151581526020016101ac565b61017b6101f336600461430c565b610a32565b34801561020457600080fd5b5061017b61021336600461435a565b610dc8565b34801561022457600080fd5b506101a2610233366004614375565b600160209081526000928352604080842090915290825290205481565b34801561025c57600080fd5b5061017b61026b3660046143aa565b610e10565b34801561027c57600080fd5b506101a261028b3660046143ef565b610fba565b34801561029c57600080fd5b506101a26102ab366004614375565b73ffffffffffffffffffffffffffffffffffffffff8216600090815260016020908152604080832077ffffffffffffffffffffffffffffffffffffffffffffffff8516845290915290819020549082901b7fffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000161792915050565b34801561033157600080fd5b50610412610340366004614424565b6040805160a0810182526000808252602082018190529181018290526060810182905260808101919091525073ffffffffffffffffffffffffffffffffffffffff1660009081526020818152604091829020825160a0810184528154815260019091015460ff811615159282019290925261010082046dffffffffffffffffffffffffffff16928101929092526f01000000000000000000000000000000810463ffffffff166060830152730100000000000000000000000000000000000000900465ffffffffffff16608082015290565b6040516101ac9190600060a082019050825182526020830151151560208301526dffffffffffffffffffffffffffff604084015116604083015263ffffffff606084015116606083015265ffffffffffff608084015116608083015292915050565b34801561048057600080fd5b5061049461048f3660046143ef565b610ffc565b6040516101ac91906144af565b3480156104ad57600080fd5b506101a26104bc366004614424565b73ffffffffffffffffffffffffffffffffffffffff1660009081526020819052604090205490565b3480156104f057600080fd5b5061017b6104ff366004614543565b6110f1565b34801561051057600080fd5b5061017b61051f36600461459a565b61126e565b34801561053057600080fd5b5061017b61053f3660046145ef565b611313565b61017b610552366004614424565b6106cb565b34801561056357600080fd5b5061017b6113fe565b34801561057857600080fd5b5061017b610587366004614424565b6115de565b34801561059857600080fd5b506105ac6105a73660046143ef565b6118cb565b6040516101ac9190614631565b3480156105c557600080fd5b5061017b6105d4366004614711565b611bcf565b3480156105e557600080fd5b5061017b6105f4366004614543565b611cb5565b34801561060557600080fd5b50610681610614366004614424565b6000602081905290815260409020805460019091015460ff81169061010081046dffffffffffffffffffffffffffff16906f01000000000000000000000000000000810463ffffffff1690730100000000000000000000000000000000000000900465ffffffffffff1685565b6040805195865293151560208601526dffffffffffffffffffffffffffff9092169284019290925263ffffffff909116606083015265ffffffffffff16608082015260a0016101ac565b60015b60058110156106df576001016106ce565b6106e882612161565b5050565b6000805a9050333014610760576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f4141393220696e7465726e616c2063616c6c206f6e6c7900000000000000000060448201526064015b60405180910390fd5b8451606081015160a082015181016127100160405a603f028161078557610785614773565b0410156107b6577fdeaddead0000000000000000000000000000000000000000000000000000000060005260206000fd5b8751600090156108575760006107d3846000015160008c866121b7565b9050806108555760006107e76108006121cf565b80519091501561084f57846000015173ffffffffffffffffffffffffffffffffffffffff168a602001517f1c4fada7374c0a9ee8841fc38afe82932dc0f8e69012e927f061a8bae611a2018760200151846040516108469291906147a2565b60405180910390a35b60019250505b505b600088608001515a86030190506108a7828a8a8a8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508792506121fb915050565b9a9950505050505050505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f60fc6b6e00000000000000000000000000000000000000000000000000000000148061094857507fffffffff0000000000000000000000000000000000000000000000000000000082167f915074d800000000000000000000000000000000000000000000000000000000145b8061099457507fffffffff0000000000000000000000000000000000000000000000000000000082167fcf28ef9700000000000000000000000000000000000000000000000000000000145b806109e057507fffffffff0000000000000000000000000000000000000000000000000000000082167f3e84f02100000000000000000000000000000000000000000000000000000000145b80610a2c57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b92915050565b33600090815260208190526040902063ffffffff8216610aae576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f6d757374207370656369667920756e7374616b652064656c61790000000000006044820152606401610757565b600181015463ffffffff6f0100000000000000000000000000000090910481169083161015610b39576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f63616e6e6f7420646563726561736520756e7374616b652074696d65000000006044820152606401610757565b6001810154600090610b6190349061010090046dffffffffffffffffffffffffffff166147ea565b905060008111610bcd576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f6e6f207374616b652073706563696669656400000000000000000000000000006044820152606401610757565b6dffffffffffffffffffffffffffff811115610c45576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f7374616b65206f766572666c6f770000000000000000000000000000000000006044820152606401610757565b6040805160a08101825283548152600160208083018281526dffffffffffffffffffffffffffff86811685870190815263ffffffff8a811660608801818152600060808a0181815233808352828a52918c90209a518b55965199909801805494519151965165ffffffffffff16730100000000000000000000000000000000000000027fffffffffffffff000000000000ffffffffffffffffffffffffffffffffffffff979094166f0100000000000000000000000000000002969096167fffffffffffffff00000000000000000000ffffffffffffffffffffffffffffff91909516610100027fffffffffffffffffffffffffffffffffff0000000000000000000000000000ff991515999099167fffffffffffffffffffffffffffffffffff00000000000000000000000000000090941693909317979097179190911691909117179055835185815290810192909252917fa5ae833d0bb1dcd632d98a8b70973e8516812898e19bf27b70071ebc8dc52c01910160405180910390a2505050565b33600090815260016020908152604080832077ffffffffffffffffffffffffffffffffffffffffffffffff851684529091528120805491610e08836147fd565b919050555050565b3360009081526020819052604090208054821115610e8a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f576974686472617720616d6f756e7420746f6f206c61726765000000000000006044820152606401610757565b8054610e97908390614835565b81556040805173ffffffffffffffffffffffffffffffffffffffff851681526020810184905233917fd1c19fbcd4551a5edfb66d43d2e337c04837afda3482b42bdf569a8fccdae5fb910160405180910390a260008373ffffffffffffffffffffffffffffffffffffffff168360405160006040518083038185875af1925050503d8060008114610f44576040519150601f19603f3d011682016040523d82523d6000602084013e610f49565b606091505b5050905080610fb4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f6661696c656420746f20776974686472617700000000000000000000000000006044820152606401610757565b50505050565b6000610fc582612423565b6040805160208101929092523090820152466060820152608001604051602081830303815290604052805190602001209050919050565b6110376040518060c0016040528060008152602001600081526020016000815260200160008152602001600015158152602001606081525090565b61103f61243c565b611047613dfc565b6110508361247d565b60008061105f600086856125f0565b9150915060006110716000878661284f565b90506040518060c00160405280856080015181526020018281526020018481526020018381526020016000151581526020016040518060400160405280600281526020017f30780000000000000000000000000000000000000000000000000000000000008152508152509450505050506110ec6001600255565b919050565b6110f961243c565b8160008167ffffffffffffffff81111561111557611115613fa8565b60405190808252806020026020018201604052801561114e57816020015b61113b613dfc565b8152602001906001900390816111335790505b50905060005b828110156111c757600082828151811061117057611170614848565b602002602001015190506000806111ab848a8a8781811061119357611193614848565b90506020028101906111a59190614877565b856125f0565b915091506111bc8483836000612c25565b505050600101611154565b506040516000907fbb47ee3e183a558b1a2ff0874b079f3fc5478b7454eacf2bfc5af2ff5878f972908290a160005b83811015611251576112458188888481811061121457611214614848565b90506020028101906112269190614877565b85848151811061123857611238614848565b602002602001015161284f565b909101906001016111f6565b5061125c8482612e7a565b5050506112696001600255565b505050565b6000808473ffffffffffffffffffffffffffffffffffffffff1684846040516112989291906148b5565b600060405180830381855af49150503d80600081146112d3576040519150601f19603f3d011682016040523d82523d6000602084013e6112d8565b606091505b509150915081816040517f994105540000000000000000000000000000000000000000000000000000000081526004016107579291906148c5565b600061133460065473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff1663570e1a3684846040518363ffffffff1660e01b815260040161136e929190614929565b6020604051808303816000875af115801561138d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113b1919061493d565b6040517f6ca7b80600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82166004820152909150602401610757565b336000908152602081905260408120600181015490916f0100000000000000000000000000000090910463ffffffff169003611496576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6e6f74207374616b6564000000000000000000000000000000000000000000006044820152606401610757565b600181015460ff16611504576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f616c726561647920756e7374616b696e670000000000000000000000000000006044820152606401610757565b600181015460009061152f906f01000000000000000000000000000000900463ffffffff164261495a565b6001830180547fffffffffffffff000000000000ffffffffffffffffffffffffffffffffffff001673010000000000000000000000000000000000000065ffffffffffff84169081027fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00169190911790915560405190815290915033907ffa9b3c14cc825c412c9ed81b3ba365a5b459439403f18829e572ed53a4180f0a906020015b60405180910390a25050565b336000908152602081905260409020600181015461010090046dffffffffffffffffffffffffffff168061166e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f4e6f207374616b6520746f2077697468647261770000000000000000000000006044820152606401610757565b6001820154730100000000000000000000000000000000000000900465ffffffffffff166116f8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f6d7573742063616c6c20756e6c6f636b5374616b6528292066697273740000006044820152606401610757565b60018201544273010000000000000000000000000000000000000090910465ffffffffffff161115611786576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601b60248201527f5374616b65207769746864726177616c206973206e6f742064756500000000006044820152606401610757565b6001820180547fffffffffffffff000000000000000000000000000000000000000000000000ff1690556040805173ffffffffffffffffffffffffffffffffffffffff851681526020810183905233917fb7c918e0e249f999e965cafeb6c664271b3f4317d296461500e71da39f0cbda3910160405180910390a260008373ffffffffffffffffffffffffffffffffffffffff168260405160006040518083038185875af1925050503d806000811461185b576040519150601f19603f3d011682016040523d82523d6000602084013e611860565b606091505b5050905080610fb4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f6661696c656420746f207769746864726177207374616b6500000000000000006044820152606401610757565b6118d3613eae565b6118db613dfc565b6118e48361247d565b6000806118f3600086856125f0565b845160e001516040805180820182526000808252602080830182815273ffffffffffffffffffffffffffffffffffffffff95861683528282528483206001908101546dffffffffffffffffffffffffffff6101008083048216885263ffffffff6f010000000000000000000000000000009384900481169095528e51518951808b018b5288815280880189815291909b1688528787528988209094015490810490911689520490911690528351808501909452818452830152939550919350903660006119c360408b018b614980565b9092509050600060148210156119da5760006119f5565b6119e86014600084866149e5565b6119f191614a0f565b60601c5b6040805180820182526000808252602080830182815273ffffffffffffffffffffffffffffffffffffffff86168352908290529290206001015461010081046dffffffffffffffffffffffffffff1682526f01000000000000000000000000000000900463ffffffff169091529091509350505050600085905060006040518060a001604052808960800151815260200189604001518152602001888152602001878152602001611aa78a6060015190565b905260408051808201825260035473ffffffffffffffffffffffffffffffffffffffff908116825282518084019093526004548352600554602084810191909152820192909252919250831615801590611b18575060018373ffffffffffffffffffffffffffffffffffffffff1614155b15611b9c5760408051808201825273ffffffffffffffffffffffffffffffffffffffff851680825282518084018452600080825260208083018281529382528181529490206001015461010081046dffffffffffffffffffffffffffff1682526f01000000000000000000000000000000900463ffffffff16909152909182015290505b6040805160a081018252928352602083019590955293810192909252506060810192909252608082015295945050505050565b611bd7613dfc565b611be08561247d565b611bec600086836125f0565b5060009050606073ffffffffffffffffffffffffffffffffffffffff861615611c7f578573ffffffffffffffffffffffffffffffffffffffff168585604051611c369291906148b5565b6000604051808303816000865af19150503d8060008114611c73576040519150601f19603f3d011682016040523d82523d6000602084013e611c78565b606091505b5090925090505b81816040517fd12c41340000000000000000000000000000000000000000000000000000000081526004016107579291906148c5565b611cbd61243c565b816000805b82811015611eaf5736868683818110611cdd57611cdd614848565b9050602002810190611cef9190614a57565b9050366000611cfe8380614a8b565b90925090506000611d156040850160208601614424565b90507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff73ffffffffffffffffffffffffffffffffffffffff821601611db6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f4141393620696e76616c69642061676772656761746f720000000000000000006044820152606401610757565b73ffffffffffffffffffffffffffffffffffffffff811615611e935773ffffffffffffffffffffffffffffffffffffffff8116632dd811338484611dfd6040890189614980565b6040518563ffffffff1660e01b8152600401611e1c9493929190614c43565b60006040518083038186803b158015611e3457600080fd5b505afa925050508015611e45575060015b611e93576040517f86a9f75000000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82166004820152602401610757565b611e9d82876147ea565b95505060019093019250611cc2915050565b5060008167ffffffffffffffff811115611ecb57611ecb613fa8565b604051908082528060200260200182016040528015611f0457816020015b611ef1613dfc565b815260200190600190039081611ee95790505b5090506000805b84811015611fe15736888883818110611f2657611f26614848565b9050602002810190611f389190614a57565b9050366000611f478380614a8b565b90925090506000611f5e6040850160208601614424565b90508160005b81811015611fcf576000898981518110611f8057611f80614848565b60200260200101519050600080611fa38b89898781811061119357611193614848565b91509150611fb384838389612c25565b8a611fbd816147fd565b9b505060019093019250611f64915050565b505060019094019350611f0b92505050565b506040517fbb47ee3e183a558b1a2ff0874b079f3fc5478b7454eacf2bfc5af2ff5878f97290600090a150600080805b8581101561211c573689898381811061202c5761202c614848565b905060200281019061203e9190614a57565b90506120506040820160208301614424565b73ffffffffffffffffffffffffffffffffffffffff167f575ff3acadd5ab348fe1855e217e0f3678f8d767d7494c9f9fefbee2e17cca4d60405160405180910390a236600061209f8380614a8b565b90925090508060005b8181101561210b576120ea888585848181106120c6576120c6614848565b90506020028101906120d89190614877565b8b8b8151811061123857611238614848565b6120f490886147ea565b965087612100816147fd565b9850506001016120a8565b505060019093019250612011915050565b506040516000907f575ff3acadd5ab348fe1855e217e0f3678f8d767d7494c9f9fefbee2e17cca4d908290a26121528682612e7a565b50505050506112696001600255565b600061216d8234612fc1565b90508173ffffffffffffffffffffffffffffffffffffffff167f2da466a7b24304f47e87fa2e1e5a81b9831ce54fec19055ce277ca2f39ba42c4826040516115d291815260200190565b6000806000845160208601878987f195945050505050565b60603d828111156121dd5750815b604051602082018101604052818152816000602083013e9392505050565b6000805a85519091506000908161221182613001565b60e083015190915073ffffffffffffffffffffffffffffffffffffffff811661223d5782519350612338565b80935060008851111561233857868202955060028a600281111561226357612263614cfa565b146123385760a08301516040517f7c627b2100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff831691637c627b21916122c5908e908d908c908990600401614d29565b600060405180830381600088803b1580156122df57600080fd5b5087f1935050505080156122f1575060015b6123385760006123026108006121cf565b9050806040517fad7954bc0000000000000000000000000000000000000000000000000000000081526004016107579190614d8c565b5a60a0840151606085015160808c01519288039990990198019088038082111561236b576064600a828403020498909801975b505060408901518783029650868110156123e05760028b600281111561239357612393614cfa565b036123b6578096506123a48a613033565b6123b18a6000898b61308f565b612415565b7fdeadaa510000000000000000000000000000000000000000000000000000000060005260206000fd5b8681036123ed8682612fc1565b506000808d600281111561240357612403614cfa565b1490506124128c828b8d61308f565b50505b505050505050949350505050565b600061242e82613117565b805190602001209050919050565b6002805403612477576040517f3ee5aeb500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60028055565b61257d6040517fd69400000000000000000000000000000000000000000000000000000000000060208201527fffffffffffffffffffffffffffffffffffffffff0000000000000000000000003060601b1660228201527f01000000000000000000000000000000000000000000000000000000000000006036820152600090603701604080518083037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe00181529190528051602090910120600680547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff90921691909117905550565b60006125ae61258f6040840184614980565b61259c6020860186614424565b6125a960e0870187614980565b6131dc565b905080516000146106e8576000816040517f220266b60000000000000000000000000000000000000000000000000000000081526004016107579291906147a2565b60008060005a845190915061260586826132c5565b61260e86610fba565b6020860152604081015161012082015161010083015160a08401516080850151606086015160c0870151861717171717176effffffffffffffffffffffffffffff8111156126b8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f41413934206761732076616c756573206f766572666c6f7700000000000000006044820152606401610757565b60006126e78460c081015160a08201516080830151606084015160408501516101009095015194010101010290565b90506126f68a8a8a8487613410565b965061270a84600001518560200151613651565b61277957896040517f220266b6000000000000000000000000000000000000000000000000000000008152600401610757918152604060208201819052601a908201527f4141323520696e76616c6964206163636f756e74206e6f6e6365000000000000606082015260800190565b825a860311156127ee57896040517f220266b6000000000000000000000000000000000000000000000000000000008152600401610757918152604060208201819052601e908201527f41413236206f76657220766572696669636174696f6e4761734c696d69740000606082015260800190565b60e084015160609073ffffffffffffffffffffffffffffffffffffffff16156128225761281d8b8b8b856136ac565b975090505b604089018290528060608a015260a08a01355a870301896080018181525050505050505050935093915050565b6000805a90506000612862846060015190565b604051909150600090368261287a60608a018a614980565b915091506060600082600381111561289157843591505b507f72288ed1000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008216016129d15760008b8b602001516040516024016128f4929190614d9f565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f8dd7712f000000000000000000000000000000000000000000000000000000001790525190915030906242dc53906129879084908f908d90602401614e85565b604051602081830303815290604052915060e01b6020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050925050612a48565b3073ffffffffffffffffffffffffffffffffffffffff166242dc5385858d8b604051602401612a039493929190614ec5565b604051602081830303815290604052915060e01b6020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff838183161783525050505091505b602060008351602085016000305af19550600051985084604052505050505080612c1b5760003d80602003612a835760206000803e60005191505b507fdeaddead000000000000000000000000000000000000000000000000000000008103612b1657876040517f220266b6000000000000000000000000000000000000000000000000000000008152600401610757918152604060208201819052600f908201527f41413935206f7574206f66206761730000000000000000000000000000000000606082015260800190565b7fdeadaa51000000000000000000000000000000000000000000000000000000008103612b8057600086608001515a612b4f9087614835565b612b5991906147ea565b6040880151909150612b6a88613033565b612b77886000838561308f565b9550612c199050565b8551805160208089015192015173ffffffffffffffffffffffffffffffffffffffff90911691907ff62676f440ff169a3a9afdbf812e89e7f95975ee8e5c31214ffdef631c5f479290612bd46108006121cf565b604051612be29291906147a2565b60405180910390a3600086608001515a612bfc9087614835565b612c0691906147ea565b9050612c1560028886846121fb565b9550505b505b5050509392505050565b600080612c3185613903565b915091508173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614612cd357856040517f220266b60000000000000000000000000000000000000000000000000000000081526004016107579181526040602082018190526014908201527f41413234207369676e6174757265206572726f72000000000000000000000000606082015260800190565b8015612d4457856040517f220266b60000000000000000000000000000000000000000000000000000000081526004016107579181526040602082018190526017908201527f414132322065787069726564206f72206e6f7420647565000000000000000000606082015260800190565b6000612d4f85613903565b9250905073ffffffffffffffffffffffffffffffffffffffff811615612dda57866040517f220266b60000000000000000000000000000000000000000000000000000000081526004016107579181526040602082018190526014908201527f41413334207369676e6174757265206572726f72000000000000000000000000606082015260800190565b8115612e7157866040517f220266b60000000000000000000000000000000000000000000000000000000081526004016107579181526040602082018190526021908201527f41413332207061796d61737465722065787069726564206f72206e6f7420647560608201527f6500000000000000000000000000000000000000000000000000000000000000608082015260a00190565b50505050505050565b73ffffffffffffffffffffffffffffffffffffffff8216612ef7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f4141393020696e76616c69642062656e656669636961727900000000000000006044820152606401610757565b60008273ffffffffffffffffffffffffffffffffffffffff168260405160006040518083038185875af1925050503d8060008114612f51576040519150601f19603f3d011682016040523d82523d6000602084013e612f56565b606091505b5050905080611269576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f41413931206661696c65642073656e6420746f2062656e6566696369617279006044820152606401610757565b73ffffffffffffffffffffffffffffffffffffffff8216600090815260208190526040812080548290612ff59085906147ea565b91829055509392505050565b6101008101516101208201516000919080820361301f575092915050565b61302b82488301613956565b949350505050565b805180516020808401519281015160405190815273ffffffffffffffffffffffffffffffffffffffff90921692917f67b4fa9642f42120bf031f3051d1824b0fe25627945b27b8a6a65d5761d5482e910160405180910390a350565b835160e0810151815160208088015193015160405173ffffffffffffffffffffffffffffffffffffffff9384169492909316927f49628fd1471006c1482da88028e9ce4dbb080b815c9b0344d39e5a8e6ec1419f916131099189908990899093845291151560208401526040830152606082015260800190565b60405180910390a450505050565b60608135602083013560006131376131326040870187614980565b61396e565b9050600061314b6131326060880188614980565b9050608086013560a087013560c0880135600061316e61313260e08c018c614980565b6040805173ffffffffffffffffffffffffffffffffffffffff9a909a1660208b015289810198909852606089019690965250608087019390935260a086019190915260c085015260e08401526101008084019190915281518084039091018152610120909201905292915050565b606084158015613201575073ffffffffffffffffffffffffffffffffffffffff84163b155b15613240575060408051808201909152601981527f41413230206163636f756e74206e6f74206465706c6f7965640000000000000060208201526132bc565b601482106132ab57600061325760148285876149e5565b61326091614a0f565b60601c9050803b6000036132a957505060408051808201909152601b81527f41413330207061796d6173746572206e6f74206465706c6f796564000000000060208201526132bc565b505b506040805160208101909152600081525b95945050505050565b6132d26020830183614424565b73ffffffffffffffffffffffffffffffffffffffff168152602082810135908201526fffffffffffffffffffffffffffffffff6080808401358281166060850152811c604084015260a084013560c0808501919091528401359182166101008401521c61012082015236600061334b60e0850185614980565b909250905080156133f55760348110156133c1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f4141393320696e76616c6964207061796d6173746572416e64446174610000006044820152606401610757565b6133cb8282613981565b60a0860152608085015273ffffffffffffffffffffffffffffffffffffffff1660e0840152610fb4565b600060e084018190526080840181905260a084015250505050565b825180516000919061342f888761342a60408b018b614980565b6139f2565b60e0820151600073ffffffffffffffffffffffffffffffffffffffff821661348d5773ffffffffffffffffffffffffffffffffffffffff831660009081526020819052604090205487811161348657808803613489565b60005b9150505b60208801516040517f19822f7c00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8516916319822f7c9189916134e9918e91908790600401614efc565b60206040518083038160008887f193505050508015613543575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261354091810190614f21565b60015b61358757896135536108006121cf565b6040517f65c8fd4d000000000000000000000000000000000000000000000000000000008152600401610757929190614f3a565b945073ffffffffffffffffffffffffffffffffffffffff82166136445773ffffffffffffffffffffffffffffffffffffffff8316600090815260208190526040902080548089111561363e578b6040517f220266b60000000000000000000000000000000000000000000000000000000081526004016107579181526040602082018190526017908201527f41413231206469646e2774207061792070726566756e64000000000000000000606082015260800190565b88900390555b5050505095945050505050565b73ffffffffffffffffffffffffffffffffffffffff8216600090815260016020908152604080832084821c808552925282208054849167ffffffffffffffff831691908561369e836147fd565b909155501495945050505050565b60606000805a855160e081015173ffffffffffffffffffffffffffffffffffffffff81166000908152602081905260409020805493945091929091908781101561375b578a6040517f220266b6000000000000000000000000000000000000000000000000000000008152600401610757918152604060208201819052601e908201527f41413331207061796d6173746572206465706f73697420746f6f206c6f770000606082015260800190565b87810382600001819055506000846080015190508373ffffffffffffffffffffffffffffffffffffffff166352b7512c828d8d602001518d6040518563ffffffff1660e01b81526004016137b193929190614efc565b60006040518083038160008887f19350505050801561381057506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820160405261380d9190810190614f87565b60015b613854578b6138206108006121cf565b6040517f65c8fd4d000000000000000000000000000000000000000000000000000000008152600401610757929190615008565b9098509650805a870311156138f4578b6040517f220266b60000000000000000000000000000000000000000000000000000000081526004016107579181526040602082018190526027908201527f41413336206f766572207061796d6173746572566572696669636174696f6e4760608201527f61734c696d697400000000000000000000000000000000000000000000000000608082015260a00190565b50505050505094509492505050565b6000808260000361391957506000928392509050565b600061392484613d7e565b9050806040015165ffffffffffff1642118061394b5750806020015165ffffffffffff1642105b905194909350915050565b60008183106139655781613967565b825b9392505050565b6000604051828085833790209392505050565b6000808061399260148286886149e5565b61399b91614a0f565b60601c6139ac6024601487896149e5565b6139b591615055565b60801c6139c660346024888a6149e5565b6139cf91615055565b9194506fffffffffffffffffffffffffffffffff16925060801c90509250925092565b8015610fb45782515173ffffffffffffffffffffffffffffffffffffffff81163b15613a8357846040517f220266b6000000000000000000000000000000000000000000000000000000008152600401610757918152604060208201819052601f908201527f414131302073656e64657220616c726561647920636f6e737472756374656400606082015260800190565b6000613aa460065473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff1663570e1a3686600001516040015186866040518463ffffffff1660e01b8152600401613ae7929190614929565b60206040518083038160008887f1158015613b06573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190613b2b919061493d565b905073ffffffffffffffffffffffffffffffffffffffff8116613bb357856040517f220266b6000000000000000000000000000000000000000000000000000000008152600401610757918152604060208201819052601b908201527f4141313320696e6974436f6465206661696c6564206f72204f4f470000000000606082015260800190565b8173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614613c5057856040517f220266b600000000000000000000000000000000000000000000000000000000815260040161075791815260406020808301829052908201527f4141313420696e6974436f6465206d7573742072657475726e2073656e646572606082015260800190565b8073ffffffffffffffffffffffffffffffffffffffff163b600003613cd957856040517f220266b600000000000000000000000000000000000000000000000000000000815260040161075791815260406020808301829052908201527f4141313520696e6974436f6465206d757374206372656174652073656e646572606082015260800190565b6000613ce860148286886149e5565b613cf191614a0f565b60601c90508273ffffffffffffffffffffffffffffffffffffffff1686602001517fd51a9c61267aa6196961883ecf5ff2da6619c37dac0fa92122513fb32c032d2d83896000015160e00151604051613d6d92919073ffffffffffffffffffffffffffffffffffffffff92831681529116602082015260400190565b60405180910390a350505050505050565b60408051606081018252600080825260208201819052918101919091528160a081901c65ffffffffffff8116600003613dba575065ffffffffffff5b6040805160608101825273ffffffffffffffffffffffffffffffffffffffff909316835260d09490941c602083015265ffffffffffff16928101929092525090565b6040518060a00160405280613e89604051806101400160405280600073ffffffffffffffffffffffffffffffffffffffff168152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160008152602001600081525090565b8152602001600080191681526020016000815260200160008152602001600081525090565b6040518060a00160405280613eeb6040518060a0016040528060008152602001600081526020016000815260200160008152602001606081525090565b8152602001613f0d604051806040016040528060008152602001600081525090565b8152602001613f2f604051806040016040528060008152602001600081525090565b8152602001613f51604051806040016040528060008152602001600081525090565b8152602001613f5e613f63565b905290565b6040518060400160405280600073ffffffffffffffffffffffffffffffffffffffff168152602001613f5e604051806040016040528060008152602001600081525090565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405160a0810167ffffffffffffffff81118282101715613ffa57613ffa613fa8565b60405290565b604051610140810167ffffffffffffffff81118282101715613ffa57613ffa613fa8565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff8111828210171561406b5761406b613fa8565b604052919050565b600067ffffffffffffffff82111561408d5761408d613fa8565b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b73ffffffffffffffffffffffffffffffffffffffff811681146140db57600080fd5b50565b80356110ec816140b9565b60008183036101c08112156140fd57600080fd5b614105613fd7565b91506101408082121561411757600080fd5b61411f614000565b915061412a846140de565b82526020840135602083015260408401356040830152606084013560608301526080840135608083015260a084013560a083015260c084013560c083015261417460e085016140de565b60e0830152610100848101359083015261012080850135908301529082528201356020820152610160820135604082015261018082013560608201526101a0909101356080820152919050565b60008083601f8401126141d357600080fd5b50813567ffffffffffffffff8111156141eb57600080fd5b60208301915083602082850101111561420357600080fd5b9250929050565b600080600080610200858703121561422157600080fd5b843567ffffffffffffffff8082111561423957600080fd5b818701915087601f83011261424d57600080fd5b813561426061425b82614073565b614024565b81815289602083860101111561427557600080fd5b81602085016020830137600060208383010152809750505061429a88602089016140e9565b94506101e08701359150808211156142b157600080fd5b506142be878288016141c1565b95989497509550505050565b6000602082840312156142dc57600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461396757600080fd5b60006020828403121561431e57600080fd5b813563ffffffff8116811461396757600080fd5b803577ffffffffffffffffffffffffffffffffffffffffffffffff811681146110ec57600080fd5b60006020828403121561436c57600080fd5b61396782614332565b6000806040838503121561438857600080fd5b8235614393816140b9565b91506143a160208401614332565b90509250929050565b600080604083850312156143bd57600080fd5b82356143c8816140b9565b946020939093013593505050565b600061012082840312156143e957600080fd5b50919050565b60006020828403121561440157600080fd5b813567ffffffffffffffff81111561441857600080fd5b61302b848285016143d6565b60006020828403121561443657600080fd5b8135613967816140b9565b60005b8381101561445c578181015183820152602001614444565b50506000910152565b6000815180845261447d816020860160208601614441565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b60208152815160208201526020820151604082015260408201516060820152606082015160808201526080820151151560a0820152600060a083015160c08084015261302b60e0840182614465565b60008083601f84011261451057600080fd5b50813567ffffffffffffffff81111561452857600080fd5b6020830191508360208260051b850101111561420357600080fd5b60008060006040848603121561455857600080fd5b833567ffffffffffffffff81111561456f57600080fd5b61457b868287016144fe565b909450925050602084013561458f816140b9565b809150509250925092565b6000806000604084860312156145af57600080fd5b83356145ba816140b9565b9250602084013567ffffffffffffffff8111156145d657600080fd5b6145e2868287016141c1565b9497909650939450505050565b6000806020838503121561460257600080fd5b823567ffffffffffffffff81111561461957600080fd5b614625858286016141c1565b90969095509350505050565b602080825282516101408383015280516101608401529081015161018083015260408101516101a083015260608101516101c08301526080015160a06101e0830152600090614684610200840182614465565b905060208401516146a2604085018280518252602090810151910152565b506040840151805160808581019190915260209182015160a08601526060860151805160c087015282015160e0860152850151805173ffffffffffffffffffffffffffffffffffffffff1661010086015280820151805161012087015290910151610140850152509392505050565b6000806000806060858703121561472757600080fd5b843567ffffffffffffffff8082111561473f57600080fd5b61474b888389016143d6565b95506020870135915061475d826140b9565b909350604086013590808211156142b157600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b82815260406020820152600061302b6040830184614465565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b80820180821115610a2c57610a2c6147bb565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361482e5761482e6147bb565b5060010190565b81810381811115610a2c57610a2c6147bb565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600082357ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee18336030181126148ab57600080fd5b9190910192915050565b8183823760009101908152919050565b821515815260406020820152600061302b6040830184614465565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b60208152600061302b6020830184866148e0565b60006020828403121561494f57600080fd5b8151613967816140b9565b65ffffffffffff818116838216019080821115614979576149796147bb565b5092915050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18436030181126149b557600080fd5b83018035915067ffffffffffffffff8211156149d057600080fd5b60200191503681900382131561420357600080fd5b600080858511156149f557600080fd5b83861115614a0257600080fd5b5050820193919092039150565b7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000008135818116916014851015614a4f5780818660140360031b1b83161692505b505092915050565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa18336030181126148ab57600080fd5b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112614ac057600080fd5b83018035915067ffffffffffffffff821115614adb57600080fd5b6020019150600581901b360382131561420357600080fd5b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112614b2857600080fd5b830160208101925035905067ffffffffffffffff811115614b4857600080fd5b80360382131561420357600080fd5b6000610120614b8384614b69856140de565b73ffffffffffffffffffffffffffffffffffffffff169052565b60208301356020850152614b9a6040840184614af3565b826040870152614bad83870182846148e0565b92505050614bbe6060840184614af3565b8583036060870152614bd18382846148e0565b925050506080830135608085015260a083013560a085015260c083013560c0850152614c0060e0840184614af3565b85830360e0870152614c138382846148e0565b92505050610100614c2681850185614af3565b86840383880152614c388482846148e0565b979650505050505050565b6040808252810184905260006060600586901b830181019083018783805b89811015614ce3577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa087860301845282357ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee18c3603018112614cc1578283fd5b614ccd868d8301614b57565b9550506020938401939290920191600101614c61565b505050508281036020840152614c388185876148e0565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b600060038610614d62577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b85825260806020830152614d796080830186614465565b6040830194909452506060015292915050565b6020815260006139676020830184614465565b604081526000614db26040830185614b57565b90508260208301529392505050565b8051805173ffffffffffffffffffffffffffffffffffffffff1683526020810151602084015260408101516040840152606081015160608401526080810151608084015260a081015160a084015260c081015160c084015260e0810151614e4060e085018273ffffffffffffffffffffffffffffffffffffffff169052565b5061010081810151908401526101209081015190830152602081015161014083015260408101516101608301526060810151610180830152608001516101a090910152565b6000610200808352614e9981840187614465565b9050614ea86020840186614dc1565b8281036101e0840152614ebb8185614465565b9695505050505050565b6000610200808352614eda81840187896148e0565b9050614ee96020840186614dc1565b8281036101e0840152614c388185614465565b606081526000614f0f6060830186614b57565b60208301949094525060400152919050565b600060208284031215614f3357600080fd5b5051919050565b82815260606020820152600d60608201527f4141323320726576657274656400000000000000000000000000000000000000608082015260a06040820152600061302b60a0830184614465565b60008060408385031215614f9a57600080fd5b825167ffffffffffffffff811115614fb157600080fd5b8301601f81018513614fc257600080fd5b8051614fd061425b82614073565b818152866020838501011115614fe557600080fd5b614ff6826020830160208601614441565b60209590950151949694955050505050565b82815260606020820152600d60608201527f4141333320726576657274656400000000000000000000000000000000000000608082015260a06040820152600061302b60a0830184614465565b7fffffffffffffffffffffffffffffffff000000000000000000000000000000008135818116916010851015614a4f5760109490940360031b84901b169092169291505056fea264697066735822122022e02178dc569768380168e9e3ea80c02f334e22212a424c7e3d8b24376c948964736f6c63430008170033608060405234801561001057600080fd5b50610213806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063570e1a3614610030575b600080fd5b61004361003e3660046100f9565b61006c565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b60008061007c601482858761016b565b61008591610195565b60601c90506000610099846014818861016b565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092018290525084519495509360209350849250905082850182875af190506000519350806100f057600093505b50505092915050565b6000806020838503121561010c57600080fd5b823567ffffffffffffffff8082111561012457600080fd5b818501915085601f83011261013857600080fd5b81358181111561014757600080fd5b86602082850101111561015957600080fd5b60209290920196919550909350505050565b6000808585111561017b57600080fd5b8386111561018857600080fd5b5050820193919092039150565b7fffffffffffffffffffffffffffffffffffffffff00000000000000000000000081358181169160148510156101d55780818660140360031b1b83161692505b50509291505056fea2646970667358221220f4eeea3c52e568afe7af0cb6d22e9eba322f25189228e2d96485c8f1d485112464736f6c63430008170033";
// entrypoint-0.7/types/gasPrice.ts
var gasPrice4 = z.object({
  maxFee: z.union([z.number(), z.string()]).transform((val) => parseGwei(`${val}`)),
  maxPriorityFee: z.union([z.number(), z.string()]).transform((val) => parseGwei(`${val}`))
}).transform((val) => {
  return {
    maxFeePerGas: val.maxFee,
    maxPriorityFeePerGas: val.maxPriorityFee
  };
});
var gasStationResult2 = z.object({
  safeLow: gasPrice4,
  standard: gasPrice4,
  fast: gasPrice4
});
// entrypoint-0.7/types/mempool.ts
var deriveUserOperation2 = (op) => {
  return isCompressedType2(op) ? op.inflatedOp : op;
};
var isCompressedType2 = (op) => {
  return "compressedCalldata" in op;
};
var SubmissionStatus2;
(function(SubmissionStatus3) {
  SubmissionStatus3["NotSubmitted"] = "not_submitted";
  SubmissionStatus3["Rejected"] = "rejected";
  SubmissionStatus3["Submitted"] = "submitted";
  SubmissionStatus3["Included"] = "included";
})(SubmissionStatus2 || (SubmissionStatus2 = {}));
// entrypoint-0.7/types/utils.ts
var ValidationErrors2;
(function(ValidationErrors3) {
  ValidationErrors3[ValidationErrors3["InvalidRequest"] = -32601] = "InvalidRequest";
  ValidationErrors3[ValidationErrors3["InvalidFields"] = -32602] = "InvalidFields";
  ValidationErrors3[ValidationErrors3["SimulateValidation"] = -32500] = "SimulateValidation";
  ValidationErrors3[ValidationErrors3["SimulatePaymasterValidation"] = -32501] = "SimulatePaymasterValidation";
  ValidationErrors3[ValidationErrors3["OpcodeValidation"] = -32502] = "OpcodeValidation";
  ValidationErrors3[ValidationErrors3["ExpiresShortly"] = -32503] = "ExpiresShortly";
  ValidationErrors3[ValidationErrors3["Reputation"] = -32504] = "Reputation";
  ValidationErrors3[ValidationErrors3["InsufficientStake"] = -32505] = "InsufficientStake";
  ValidationErrors3[ValidationErrors3["UnsupportedSignatureAggregator"] = -32506] = "UnsupportedSignatureAggregator";
  ValidationErrors3[ValidationErrors3["InvalidSignature"] = -32507] = "InvalidSignature";
})(ValidationErrors2 || (ValidationErrors2 = {}));
var ExecutionErrors2;
(function(ExecutionErrors3) {
  ExecutionErrors3[ExecutionErrors3["UserOperationReverted"] = -32521] = "UserOperationReverted";
})(ExecutionErrors2 || (ExecutionErrors2 = {}));

class RpcError3 extends Error {
  code;
  data;
  constructor(msg, code, data3 = undefined) {
    super(msg);
    this.code = code;
    this.data = data3;
  }
}
// entrypoint-0.7/types/schemas.ts
var hexDataPattern2 = /^0x[0-9A-Fa-f]*$/;
var addressPattern2 = /^0x[0-9,a-f,A-F]{40}$/;
var hexData32Pattern2 = /^0x([0-9a-fA-F][0-9a-fA-F]){0,32}$/;
var addressSchema2 = z.string().regex(addressPattern2, { message: "not a valid hex address" }).transform((val) => getAddress(val));
var hexNumberSchema2 = z.string().regex(hexDataPattern2).or(z.number()).or(z.bigint()).transform((val) => BigInt(val));
var hexDataSchema2 = z.string().regex(hexDataPattern2, { message: "not valid hex data" }).transform((val) => val);
var hexData32Schema2 = z.string().regex(hexData32Pattern2, { message: "not valid 32-byte hex data" }).transform((val) => val);
var unPackedUserOperationSchema = z.object({
  sender: addressSchema2,
  nonce: hexNumberSchema2,
  factory: addressSchema2.nullable().optional().transform((val) => val ?? null),
  factoryData: hexDataSchema2.nullable().optional().transform((val) => val ?? null),
  callData: hexDataSchema2,
  callGasLimit: hexNumberSchema2,
  verificationGasLimit: hexNumberSchema2,
  preVerificationGas: hexNumberSchema2,
  maxFeePerGas: hexNumberSchema2,
  maxPriorityFeePerGas: hexNumberSchema2,
  paymaster: addressSchema2.nullable().optional().transform((val) => val ?? null),
  paymasterVerificationGasLimit: hexNumberSchema2.nullable().optional().transform((val) => val ?? null),
  paymasterPostOpGasLimit: hexNumberSchema2.nullable().optional().transform((val) => val ?? null),
  paymasterData: hexDataSchema2.nullable().optional().transform((val) => val ?? null),
  signature: hexDataSchema2
}).strict().transform((val) => val);
var partialUnPackedUserOperationSchema = z.object({
  sender: addressSchema2,
  nonce: hexNumberSchema2,
  factory: addressSchema2.nullable().optional().transform((val) => val ?? null),
  factoryData: hexDataSchema2.nullable().optional().transform((val) => val ?? null),
  callData: hexDataSchema2,
  callGasLimit: hexNumberSchema2.default(1n),
  verificationGasLimit: hexNumberSchema2.default(1n),
  preVerificationGas: hexNumberSchema2.default(1n),
  maxFeePerGas: hexNumberSchema2.default(1n),
  maxPriorityFeePerGas: hexNumberSchema2.default(1n),
  paymaster: addressSchema2.nullable().optional().transform((val) => val ?? null),
  paymasterVerificationGasLimit: hexNumberSchema2.nullable().optional().transform((val) => val ?? null),
  paymasterPostOpGasLimit: hexNumberSchema2.nullable().optional().transform((val) => val ?? null),
  paymasterData: hexDataSchema2.nullable().optional().transform((val) => val ?? null),
  signature: hexDataSchema2
}).strict().transform((val) => val);
var packerUserOperationSchema = z.object({
  sender: addressSchema2,
  nonce: hexNumberSchema2,
  initCode: hexDataSchema2,
  callData: hexDataSchema2,
  accountGasLimits: hexData32Schema2,
  preVerificationGas: hexNumberSchema2,
  gasFees: hexData32Schema2,
  paymasterAndData: hexDataSchema2,
  signature: hexDataSchema2
}).strict().transform((val) => val);
var jsonRpcSchema2 = z.object({
  jsonrpc: z.literal("2.0"),
  id: z.number(),
  method: z.string(),
  params: z.array(z.unknown()).optional().transform((val) => val ?? [])
}).strict();
var jsonRpcResultSchema2 = z.object({
  jsonrpc: z.literal("2.0"),
  id: z.number(),
  result: z.unknown()
}).strict();
var chainIdRequestSchema2 = z.object({
  method: z.literal("eth_chainId"),
  params: z.tuple([])
});
var supportedEntryPointsRequestSchema2 = z.object({
  method: z.literal("eth_supportedEntryPoints"),
  params: z.tuple([])
});
var stateOverridesSchema2 = z.record(addressSchema2, z.object({
  balance: hexNumberSchema2.optional(),
  nonce: hexNumberSchema2.optional(),
  code: hexDataSchema2.optional(),
  state: z.unknown().optional(),
  stateDiff: z.unknown().optional()
}));
var estimateUserOperationGasRequestSchema2 = z.object({
  method: z.literal("eth_estimateUserOperationGas"),
  params: z.union([
    z.tuple([partialUnPackedUserOperationSchema, addressSchema2]),
    z.tuple([
      partialUnPackedUserOperationSchema,
      addressSchema2,
      stateOverridesSchema2
    ])
  ])
});
var sendUserOperationRequestSchema2 = z.object({
  method: z.literal("eth_sendUserOperation"),
  params: z.tuple([unPackedUserOperationSchema, addressSchema2])
});
var getUserOperationByHashRequestSchema2 = z.object({
  method: z.literal("eth_getUserOperationByHash"),
  params: z.tuple([
    z.string().regex(hexData32Pattern2, { message: "Missing/invalid userOpHash" }).transform((val) => val)
  ])
});
var getUserOperationReceiptRequestSchema2 = z.object({
  method: z.literal("eth_getUserOperationReceipt"),
  params: z.tuple([
    z.string().regex(hexData32Pattern2, { message: "Missing/invalid userOpHash" }).transform((val) => val)
  ])
});
var bundlerClearStateRequestSchema2 = z.object({
  method: z.literal("debug_bundler_clearState"),
  params: z.tuple([])
});
var bundlerClearMempoolRequestSchema2 = z.object({
  method: z.literal("debug_bundler_clearMempool"),
  params: z.tuple([])
});
var bundlerDumpMempoolRequestSchema2 = z.object({
  method: z.literal("debug_bundler_dumpMempool"),
  params: z.tuple([addressSchema2])
});
var bundlerSendBundleNowRequestSchema2 = z.object({
  method: z.literal("debug_bundler_sendBundleNow"),
  params: z.tuple([])
});
var bundlerSetBundlingModeRequestSchema2 = z.object({
  method: z.literal("debug_bundler_setBundlingMode"),
  params: z.tuple([z.enum(["manual", "auto"])])
});
var bundlerSetReputationsRequestSchema2 = z.object({
  method: z.literal("debug_bundler_setReputation"),
  params: z.tuple([
    z.array(z.object({
      address: addressSchema2,
      opsSeen: hexNumberSchema2,
      opsIncluded: hexNumberSchema2
    })),
    addressSchema2
  ])
});
var bundlerDumpReputationsRequestSchema2 = z.object({
  method: z.literal("debug_bundler_dumpReputation"),
  params: z.tuple([addressSchema2])
});
var pimlicoGetStakeStatusRequestSchema2 = z.object({
  method: z.literal("debug_bundler_getStakeStatus"),
  params: z.tuple([addressSchema2, addressSchema2])
});
var pimlicoGetUserOperationStatusRequestSchema2 = z.object({
  method: z.literal("pimlico_getUserOperationStatus"),
  params: z.tuple([hexData32Schema2])
});
var pimlicoGetUserOperationGasPriceRequestSchema2 = z.object({
  method: z.literal("pimlico_getUserOperationGasPrice"),
  params: z.tuple([])
});
var pimlicoSendCompressedUserOperationRequestSchema2 = z.object({
  method: z.literal("pimlico_sendCompressedUserOperation"),
  params: z.tuple([hexDataSchema2, addressSchema2, addressSchema2])
});
var bundlerRequestSchema2 = z.discriminatedUnion("method", [
  chainIdRequestSchema2,
  supportedEntryPointsRequestSchema2,
  estimateUserOperationGasRequestSchema2,
  sendUserOperationRequestSchema2,
  getUserOperationByHashRequestSchema2,
  getUserOperationReceiptRequestSchema2,
  bundlerClearStateRequestSchema2,
  bundlerClearMempoolRequestSchema2,
  bundlerDumpMempoolRequestSchema2,
  bundlerSendBundleNowRequestSchema2,
  bundlerSetBundlingModeRequestSchema2,
  bundlerSetReputationsRequestSchema2,
  bundlerDumpReputationsRequestSchema2,
  pimlicoGetStakeStatusRequestSchema2,
  pimlicoGetUserOperationStatusRequestSchema2,
  pimlicoGetUserOperationGasPriceRequestSchema2,
  pimlicoSendCompressedUserOperationRequestSchema2
]);
var chainIdResponseSchema2 = z.object({
  method: z.literal("eth_chainId"),
  result: hexNumberSchema2
});
var supportedEntryPointsResponseSchema2 = z.object({
  method: z.literal("eth_supportedEntryPoints"),
  result: z.array(addressSchema2)
});
var estimateUserOperationGasResponseSchema2 = z.object({
  method: z.literal("eth_estimateUserOperationGas"),
  result: z.object({
    callGasLimit: hexNumberSchema2,
    preVerificationGas: hexNumberSchema2,
    verificationGasLimit: hexNumberSchema2,
    paymasterVerificationGasLimit: hexNumberSchema2.optional(),
    paymasterPostOpGasLimit: hexNumberSchema2.optional()
  })
});
var sendUserOperationResponseSchema2 = z.object({
  method: z.literal("eth_sendUserOperation"),
  result: hexData32Schema2
});
var getUserOperationByHashResponseSchema2 = z.object({
  method: z.literal("eth_getUserOperationByHash"),
  result: z.object({
    userOperation: unPackedUserOperationSchema,
    entryPoint: addressSchema2,
    blockNumber: hexNumberSchema2,
    blockHash: hexData32Schema2,
    transactionHash: hexData32Schema2
  }).or(z.null())
});
var logSchema2 = z.object({
  logIndex: hexNumberSchema2,
  transactionIndex: hexNumberSchema2,
  transactionHash: hexData32Schema2,
  blockHash: hexData32Schema2,
  blockNumber: hexNumberSchema2,
  address: addressSchema2,
  data: hexDataSchema2,
  topics: z.array(hexData32Schema2)
});
var receiptSchema2 = z.object({
  transactionHash: hexData32Schema2,
  transactionIndex: hexNumberSchema2,
  blockHash: hexData32Schema2,
  blockNumber: hexNumberSchema2,
  from: addressSchema2,
  to: addressSchema2.or(z.null()),
  cumulativeGasUsed: hexNumberSchema2,
  gasUsed: hexNumberSchema2,
  contractAddress: addressSchema2.or(z.null()),
  logs: z.array(logSchema2),
  logsBloom: z.string().regex(/^0x[0-9a-f]{512}$/),
  status: hexNumberSchema2.or(z.null()),
  effectiveGasPrice: hexNumberSchema2
});
var getUserOperationReceiptResponseSchema2 = z.object({
  method: z.literal("eth_getUserOperationReceipt"),
  result: z.object({
    userOpHash: hexData32Schema2,
    sender: addressSchema2,
    nonce: hexNumberSchema2,
    actualGasCost: hexNumberSchema2,
    actualGasUsed: hexNumberSchema2,
    success: z.boolean(),
    logs: z.array(logSchema2),
    receipt: receiptSchema2
  }).or(z.null())
});
var bundlerClearStateResponseSchema2 = z.object({
  method: z.literal("debug_bundler_clearState"),
  result: z.literal("ok")
});
var bundlerClearMempoolResponseSchema2 = z.object({
  method: z.literal("debug_bundler_clearMempool"),
  result: z.literal("ok")
});
var bundlerDumpMempoolResponseSchema2 = z.object({
  method: z.literal("debug_bundler_dumpMempool"),
  result: z.array(unPackedUserOperationSchema)
});
var bundlerGetStakeStatusResponseSchema2 = z.object({
  method: z.literal("debug_bundler_getStakeStatus"),
  result: z.object({
    stakeInfo: z.object({
      addr: z.string(),
      stake: z.string().or(z.number()).or(z.bigint()).transform((val) => Number(val).toString()),
      unstakeDelaySec: z.string().or(z.number()).or(z.bigint()).transform((val) => Number(val).toString())
    }),
    isStaked: z.boolean()
  })
});
var bundlerSendBundleNowResponseSchema2 = z.object({
  method: z.literal("debug_bundler_sendBundleNow"),
  result: hexData32Schema2
});
var bundlerSetBundlingModeResponseSchema2 = z.object({
  method: z.literal("debug_bundler_setBundlingMode"),
  result: z.literal("ok")
});
var bundlerSetReputationsResponseSchema2 = z.object({
  method: z.literal("debug_bundler_setReputation"),
  result: z.literal("ok")
});
var bundlerDumpReputationsResponseSchema2 = z.object({
  method: z.literal("debug_bundler_dumpReputation"),
  result: z.array(z.object({
    address: addressSchema2,
    opsSeen: hexNumberSchema2,
    opsIncluded: hexNumberSchema2,
    status: hexNumberSchema2.optional()
  }))
});
var userOperationStatus2 = z.object({
  status: z.enum([
    "not_found",
    "not_submitted",
    "submitted",
    "rejected",
    "reverted",
    "included",
    "failed"
  ]),
  transactionHash: hexData32Schema2.or(z.null())
});
var pimlicoGetUserOperationStatusResponseSchema2 = z.object({
  method: z.literal("pimlico_getUserOperationStatus"),
  result: userOperationStatus2
});
var gasPriceSchema2 = z.object({
  slow: z.object({
    maxFeePerGas: z.bigint(),
    maxPriorityFeePerGas: z.bigint()
  }),
  standard: z.object({
    maxFeePerGas: z.bigint(),
    maxPriorityFeePerGas: z.bigint()
  }),
  fast: z.object({
    maxFeePerGas: z.bigint(),
    maxPriorityFeePerGas: z.bigint()
  })
});
var pimlicoGetUserOperationGasPriceResponseSchema2 = z.object({
  method: z.literal("pimlico_getUserOperationGasPrice"),
  result: gasPriceSchema2
});
var pimlicoSendCompressedUserOperationResponseSchema2 = z.object({
  method: z.literal("pimlico_sendCompressedUserOperation"),
  result: hexData32Schema2
});
var bundlerResponseSchema2 = z.discriminatedUnion("method", [
  chainIdResponseSchema2,
  supportedEntryPointsResponseSchema2,
  estimateUserOperationGasResponseSchema2,
  sendUserOperationResponseSchema2,
  getUserOperationByHashResponseSchema2,
  getUserOperationReceiptResponseSchema2,
  bundlerClearStateResponseSchema2,
  bundlerClearMempoolResponseSchema2,
  bundlerDumpMempoolResponseSchema2,
  bundlerGetStakeStatusResponseSchema2,
  bundlerSendBundleNowResponseSchema2,
  bundlerSetBundlingModeResponseSchema2,
  bundlerSetReputationsResponseSchema2,
  bundlerDumpReputationsResponseSchema2,
  pimlicoGetUserOperationStatusResponseSchema2,
  pimlicoGetUserOperationGasPriceResponseSchema2,
  pimlicoSendCompressedUserOperationResponseSchema2
]);

// entrypoint-0.7/types/validation.ts
var hexPattern2 = /^0x[0-9a-f]*$/;
var signatureValidationFailedSchema2 = z.tuple([addressSchema2]).transform((val) => {
  return { aggregator: val[0] };
});
var signatureValidationFailedErrorSchema2 = z.object({
  args: signatureValidationFailedSchema2,
  errorName: z.literal("SignatureValidationFailed")
});
var senderAddressResultSchema2 = z.tuple([addressSchema2]).transform((val) => {
  return {
    sender: val[0]
  };
});
var senderAddressResultErrorSchema2 = z.object({
  args: senderAddressResultSchema2,
  errorName: z.literal("SenderAddressResult")
});
var failedOpSchema2 = z.tuple([z.bigint(), z.string()]).transform((val) => {
  return { opIndex: val[0], reason: val[1] };
});
var failedOpErrorSchema2 = z.object({
  args: failedOpSchema2,
  errorName: z.literal("FailedOp")
});
var executionResultSchema2 = z.tuple([
  z.bigint(),
  z.bigint(),
  z.bigint(),
  z.bigint(),
  z.boolean(),
  z.string().regex(hexPattern2)
]).transform((val) => {
  return {
    preOpGas: val[0],
    paid: val[1],
    validationData: val[2],
    paymasterValidationData: val[3],
    targetSuccess: val[4],
    targetResult: val[5]
  };
});
var executionResultErrorSchema2 = z.object({
  args: executionResultSchema2,
  errorName: z.literal("ExecutionResult")
});
var stakeInfoSchema2 = z.object({
  addr: z.string().optional(),
  stake: z.bigint(),
  unstakeDelaySec: z.bigint()
});
var validationResultSchema2 = z.tuple([
  z.object({
    preOpGas: z.bigint(),
    prefund: z.bigint(),
    accountValidationData: z.bigint(),
    paymasterValidationData: z.bigint(),
    accountSigFailed: z.boolean().optional(),
    paymasterSigFailed: z.boolean().optional(),
    validAfter: z.number().optional(),
    validUntil: z.number().optional(),
    paymasterContext: z.string().regex(hexPattern2).transform((val) => val)
  }),
  stakeInfoSchema2,
  stakeInfoSchema2.optional(),
  stakeInfoSchema2.optional()
]).transform((val) => {
  return {
    returnInfo: val[0],
    senderInfo: val[1],
    factoryInfo: val[2],
    paymasterInfo: val[3]
  };
});
var validationResultErrorSchema2 = z.object({
  args: validationResultSchema2,
  errorName: z.literal("ValidationResult")
});
var validationResultWithAggregationSchema2 = z.tuple([
  z.object({
    preOpGas: z.bigint(),
    prefund: z.bigint(),
    accountValidationData: z.bigint(),
    paymasterValidationData: z.bigint(),
    accountSigFailed: z.boolean().optional(),
    paymasterSigFailed: z.boolean().optional(),
    validAfter: z.number().optional(),
    validUntil: z.number().optional(),
    paymasterContext: z.string().regex(hexPattern2).transform((val) => val)
  }),
  stakeInfoSchema2,
  stakeInfoSchema2.optional(),
  stakeInfoSchema2.optional(),
  z.object({
    aggregator: addressSchema2,
    stakeInfo: stakeInfoSchema2
  }).optional()
]).transform((val) => {
  return {
    returnInfo: val[0],
    senderInfo: val[1],
    factoryInfo: val[2],
    paymasterInfo: val[3],
    aggregatorInfo: val[4]
  };
});
var validationResultWithAggregationErrorSchema2 = z.object({
  args: validationResultWithAggregationSchema2,
  errorName: z.literal("ValidationResultWithAggregation")
});
var entryPointErrorsSchema2 = z.discriminatedUnion("errorName", [
  validationResultErrorSchema2,
  executionResultErrorSchema2,
  failedOpErrorSchema2,
  senderAddressResultErrorSchema2,
  signatureValidationFailedErrorSchema2,
  validationResultWithAggregationErrorSchema2
]);
var errorCauseSchema2 = z.object({
  name: z.literal("ContractFunctionRevertedError"),
  data: entryPointErrorsSchema2
});
var vmExecutionError2 = z.object({
  name: z.literal("CallExecutionError"),
  cause: z.object({
    name: z.literal("RpcRequestError"),
    cause: z.object({
      data: z.string().transform((val) => {
        const errorHexData = val.split("Reverted ")[1];
        if (errorHexData === "0x") {
          throw new RpcError3(`User operation reverted on-chain with unknown error (some chains don't return revert reason) ${val}`);
        }
        const errorResult = decodeErrorResult({
          abi: EntryPointAbi2,
          data: errorHexData
        });
        return entryPointErrorsSchema2.parse(errorResult);
      })
    })
  })
});
var entryPointExecutionErrorSchema2 = z.object({
  name: z.literal("ContractFunctionExecutionError"),
  cause: z.discriminatedUnion("name", [
    errorCauseSchema2,
    vmExecutionError2
  ])
}).transform((val) => {
  if (val.cause.name === "CallExecutionError") {
    return val.cause.cause.cause.data;
  }
  return val.cause.data;
});
// utils/gasPriceManager.ts
var sentry = __toESM(require_cjs4(), 1);

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/arbitrum.js
var arbitrum = defineChain({
  id: 42161,
  name: "Arbitrum One",
  network: "arbitrum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://arb-mainnet.g.alchemy.com/v2"],
      webSocket: ["wss://arb-mainnet.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://arbitrum-mainnet.infura.io/v3"],
      webSocket: ["wss://arbitrum-mainnet.infura.io/ws/v3"]
    },
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    },
    public: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    etherscan: { name: "Arbiscan", url: "https://arbiscan.io" },
    default: { name: "Arbiscan", url: "https://arbiscan.io" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/arbitrumGoerli.js
var arbitrumGoerli = defineChain({
  id: 421613,
  name: "Arbitrum Goerli",
  network: "arbitrum-goerli",
  nativeCurrency: {
    name: "Arbitrum Goerli Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    alchemy: {
      http: ["https://arb-goerli.g.alchemy.com/v2"],
      webSocket: ["wss://arb-goerli.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://arbitrum-goerli.infura.io/v3"],
      webSocket: ["wss://arbitrum-goerli.infura.io/ws/v3"]
    },
    default: {
      http: ["https://goerli-rollup.arbitrum.io/rpc"]
    },
    public: {
      http: ["https://goerli-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    etherscan: { name: "Arbiscan", url: "https://goerli.arbiscan.io" },
    default: { name: "Arbiscan", url: "https://goerli.arbiscan.io" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 88114
    }
  },
  testnet: true
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/arbitrumNova.js
var arbitrumNova = defineChain({
  id: 42170,
  name: "Arbitrum Nova",
  network: "arbitrum-nova",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    blast: {
      http: ["https://arbitrum-nova.public.blastapi.io"],
      webSocket: ["wss://arbitrum-nova.public.blastapi.io"]
    },
    default: {
      http: ["https://nova.arbitrum.io/rpc"]
    },
    public: {
      http: ["https://nova.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    etherscan: { name: "Arbiscan", url: "https://nova.arbiscan.io" },
    blockScout: {
      name: "BlockScout",
      url: "https://nova-explorer.arbitrum.io/"
    },
    default: { name: "Arbiscan", url: "https://nova.arbiscan.io" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1746963
    }
  }
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/arbitrumSepolia.js
var arbitrumSepolia = defineChain({
  id: 421614,
  name: "Arbitrum Sepolia",
  network: "arbitrum-sepolia",
  nativeCurrency: {
    name: "Arbitrum Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    alchemy: {
      http: ["https://arb-sepolia.g.alchemy.com/v2"],
      webSocket: ["wss://arb-sepolia.g.alchemy.com/v2"]
    },
    default: {
      http: ["https://sepolia-rollup.arbitrum.io/rpc"]
    },
    public: {
      http: ["https://sepolia-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    etherscan: { name: "Arbiscan", url: "https://sepolia.arbiscan.io" },
    default: { name: "Arbiscan", url: "https://sepolia.arbiscan.io" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 81930
    }
  },
  testnet: true
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/avalanche.js
var avalanche = defineChain({
  id: 43114,
  name: "Avalanche",
  network: "avalanche",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax.network/ext/bc/C/rpc"] },
    public: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    etherscan: { name: "SnowTrace", url: "https://snowtrace.io" },
    default: { name: "SnowTrace", url: "https://snowtrace.io" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11907934
    }
  }
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/optimism/formatters.js
init_fromHex();
var formattersOptimism = {
  block: defineBlock({
    format(args) {
      const transactions = args.transactions?.map((transaction15) => {
        if (typeof transaction15 === "string")
          return transaction15;
        const formatted = formatTransaction(transaction15);
        if (formatted.typeHex === "0x7e") {
          formatted.isSystemTx = transaction15.isSystemTx;
          formatted.mint = transaction15.mint ? hexToBigInt(transaction15.mint) : undefined;
          formatted.sourceHash = transaction15.sourceHash;
          formatted.type = "deposit";
        }
        return formatted;
      });
      return {
        transactions,
        stateRoot: args.stateRoot
      };
    }
  }),
  transaction: defineTransaction({
    format(args) {
      const transaction15 = {};
      if (args.type === "0x7e") {
        transaction15.isSystemTx = args.isSystemTx;
        transaction15.mint = args.mint ? hexToBigInt(args.mint) : undefined;
        transaction15.sourceHash = args.sourceHash;
        transaction15.type = "deposit";
      }
      return transaction15;
    }
  }),
  transactionReceipt: defineTransactionReceipt({
    format(args) {
      return {
        l1GasPrice: args.l1GasPrice ? hexToBigInt(args.l1GasPrice) : null,
        l1GasUsed: args.l1GasUsed ? hexToBigInt(args.l1GasUsed) : null,
        l1Fee: args.l1Fee ? hexToBigInt(args.l1Fee) : null,
        l1FeeScalar: args.l1FeeScalar ? Number(args.l1FeeScalar) : null
      };
    }
  })
};

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/base.js
var base29 = defineChain({
  id: 8453,
  network: "base",
  name: "Base",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://base-mainnet.g.alchemy.com/v2"],
      webSocket: ["wss://base-mainnet.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://base-mainnet.infura.io/v3"],
      webSocket: ["wss://base-mainnet.infura.io/ws/v3"]
    },
    default: {
      http: ["https://mainnet.base.org"]
    },
    public: {
      http: ["https://mainnet.base.org"]
    }
  },
  blockExplorers: {
    blockscout: {
      name: "Basescout",
      url: "https://base.blockscout.com"
    },
    default: {
      name: "Basescan",
      url: "https://basescan.org"
    },
    etherscan: {
      name: "Basescan",
      url: "https://basescan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 5022
    }
  }
}, {
  formatters: formattersOptimism
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/baseGoerli.js
var baseGoerli = defineChain({
  id: 84531,
  network: "base-goerli",
  name: "Base Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://base-goerli.g.alchemy.com/v2"],
      webSocket: ["wss://base-goerli.g.alchemy.com/v2"]
    },
    default: {
      http: ["https://goerli.base.org"]
    },
    public: {
      http: ["https://goerli.base.org"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "Basescan",
      url: "https://goerli.basescan.org"
    },
    default: {
      name: "Basescan",
      url: "https://goerli.basescan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1376988
    }
  },
  testnet: true,
  sourceId: 5
}, {
  formatters: formattersOptimism
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/baseSepolia.js
var baseSepolia = defineChain({
  id: 84532,
  network: "base-sepolia",
  name: "Base Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://base-sepolia.g.alchemy.com/v2"],
      webSocket: ["wss://base-sepolia.g.alchemy.com/v2"]
    },
    default: {
      http: ["https://sepolia.base.org"]
    },
    public: {
      http: ["https://sepolia.base.org"]
    }
  },
  blockExplorers: {
    blockscout: {
      name: "Blockscout",
      url: "https://base-sepolia.blockscout.com"
    },
    default: {
      name: "Blockscout",
      url: "https://base-sepolia.blockscout.com"
    }
  },
  testnet: true,
  sourceId: 11155111
}, {
  formatters: formattersOptimism
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/celo/formatters.js
init_fromHex();
init_toHex();
init_transactionRequest();

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/celo/utils.js
init_trim();
function isEmpty(value) {
  return value === 0 || value === 0n || value === undefined || value === null || value === "0" || value === "" || typeof value === "string" && (trim(value).toLowerCase() === "0x" || trim(value).toLowerCase() === "0x00");
}
function isPresent(value) {
  return !isEmpty(value);
}
function isEIP1559(transaction15) {
  return isPresent(transaction15.maxFeePerGas) && isPresent(transaction15.maxPriorityFeePerGas);
}
function isCIP42(transaction15) {
  if (transaction15.type === "cip42") {
    return true;
  }
  return isEIP1559(transaction15) && (isPresent(transaction15.feeCurrency) || isPresent(transaction15.gatewayFeeRecipient) || isPresent(transaction15.gatewayFee));
}
function isCIP64(transaction15) {
  if (transaction15.type === "cip64") {
    return true;
  }
  return isEIP1559(transaction15) && isPresent(transaction15.feeCurrency) && isEmpty(transaction15.gatewayFee) && isEmpty(transaction15.gatewayFeeRecipient);
}

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/celo/formatters.js
var formattersCelo = {
  block: defineBlock({
    exclude: ["difficulty", "gasLimit", "mixHash", "nonce", "uncles"],
    format(args) {
      const transactions = args.transactions?.map((transaction16) => {
        if (typeof transaction16 === "string")
          return transaction16;
        return {
          ...formatTransaction(transaction16),
          feeCurrency: transaction16.feeCurrency,
          ...transaction16.type !== "0x7b" ? {
            gatewayFee: transaction16.gatewayFee ? hexToBigInt(transaction16.gatewayFee) : null,
            gatewayFeeRecipient: transaction16.gatewayFeeRecipient || null
          } : {}
        };
      });
      return {
        randomness: args.randomness,
        transactions
      };
    }
  }),
  transaction: defineTransaction({
    format(args) {
      const transaction16 = { feeCurrency: args.feeCurrency };
      if (args.type === "0x7b")
        transaction16.type = "cip64";
      else {
        if (args.type === "0x7c")
          transaction16.type = "cip42";
        transaction16.gatewayFee = args.gatewayFee ? hexToBigInt(args.gatewayFee) : null;
        transaction16.gatewayFeeRecipient = args.gatewayFeeRecipient;
      }
      return transaction16;
    }
  }),
  transactionRequest: defineTransactionRequest({
    format(args) {
      const request5 = {
        feeCurrency: args.feeCurrency
      };
      if (isCIP64(args))
        request5.type = "0x7b";
      else {
        if (isCIP42(args))
          request5.type = "0x7c";
        request5.gatewayFee = typeof args.gatewayFee !== "undefined" ? numberToHex(args.gatewayFee) : undefined;
        request5.gatewayFeeRecipient = args.gatewayFeeRecipient;
      }
      return request5;
    }
  })
};

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/celo/serializers.js
init_address();
init_base();
init_chain();
init_node();
init_isAddress();
init_concat();
init_trim();
init_toHex();
var serializeTransactionCIP42 = function(transaction16, signature) {
  assertTransactionCIP42(transaction16);
  const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, feeCurrency, gatewayFeeRecipient, gatewayFee, data: data3 } = transaction16;
  const serializedTransaction = [
    toHex2(chainId),
    nonce ? toHex2(nonce) : "0x",
    maxPriorityFeePerGas ? toHex2(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex2(maxFeePerGas) : "0x",
    gas ? toHex2(gas) : "0x",
    feeCurrency ?? "0x",
    gatewayFeeRecipient ?? "0x",
    gatewayFee ? toHex2(gatewayFee) : "0x",
    to ?? "0x",
    value ? toHex2(value) : "0x",
    data3 ?? "0x",
    serializeAccessList(accessList)
  ];
  if (signature) {
    serializedTransaction.push(signature.v === 27n ? "0x" : toHex2(1), trim(signature.r), trim(signature.s));
  }
  return concatHex([
    "0x7c",
    toRlp(serializedTransaction)
  ]);
};
var serializeTransactionCIP64 = function(transaction16, signature) {
  assertTransactionCIP64(transaction16);
  const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, feeCurrency, data: data3 } = transaction16;
  const serializedTransaction = [
    toHex2(chainId),
    nonce ? toHex2(nonce) : "0x",
    maxPriorityFeePerGas ? toHex2(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex2(maxFeePerGas) : "0x",
    gas ? toHex2(gas) : "0x",
    to ?? "0x",
    value ? toHex2(value) : "0x",
    data3 ?? "0x",
    serializeAccessList(accessList),
    feeCurrency
  ];
  if (signature) {
    serializedTransaction.push(signature.v === 27n ? "0x" : toHex2(1), trim(signature.r), trim(signature.s));
  }
  return concatHex([
    "0x7b",
    toRlp(serializedTransaction)
  ]);
};
function assertTransactionCIP42(transaction16) {
  const { chainId, maxPriorityFeePerGas, gasPrice: gasPrice7, maxFeePerGas, to, feeCurrency, gatewayFee, gatewayFeeRecipient } = transaction16;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (gasPrice7)
    throw new BaseError("`gasPrice` is not a valid CIP-42 Transaction attribute.");
  if (isPresent(maxFeePerGas) && maxFeePerGas > MAX_MAX_FEE_PER_GAS)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (isPresent(maxPriorityFeePerGas) && isPresent(maxFeePerGas) && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
  if (isPresent(gatewayFee) && isEmpty(gatewayFeeRecipient) || isPresent(gatewayFeeRecipient) && isEmpty(gatewayFee)) {
    throw new BaseError("`gatewayFee` and `gatewayFeeRecipient` must be provided together.");
  }
  if (isPresent(feeCurrency) && !isAddress(feeCurrency)) {
    throw new BaseError("`feeCurrency` MUST be a token address for CIP-42 transactions.");
  }
  if (isPresent(gatewayFeeRecipient) && !isAddress(gatewayFeeRecipient)) {
    throw new InvalidAddressError(gatewayFeeRecipient);
  }
  if (isEmpty(feeCurrency) && isEmpty(gatewayFeeRecipient)) {
    throw new BaseError("Either `feeCurrency` or `gatewayFeeRecipient` must be provided for CIP-42 transactions.");
  }
}
function assertTransactionCIP64(transaction16) {
  const { chainId, maxPriorityFeePerGas, gasPrice: gasPrice7, maxFeePerGas, to, feeCurrency } = transaction16;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (gasPrice7)
    throw new BaseError("`gasPrice` is not a valid CIP-64 Transaction attribute.");
  if (isPresent(maxFeePerGas) && maxFeePerGas > MAX_MAX_FEE_PER_GAS)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (isPresent(maxPriorityFeePerGas) && isPresent(maxFeePerGas) && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
  if (isPresent(feeCurrency) && !isAddress(feeCurrency)) {
    throw new BaseError("`feeCurrency` MUST be a token address for CIP-64 transactions.");
  }
  if (isEmpty(feeCurrency)) {
    throw new BaseError("`feeCurrency` must be provided for CIP-64 transactions.");
  }
}
var serializeTransactionCelo = (tx, signature) => {
  if (isCIP64(tx))
    return serializeTransactionCIP64(tx, signature);
  if (isCIP42(tx))
    return serializeTransactionCIP42(tx, signature);
  return serializeTransaction(tx, signature);
};
var serializersCelo = {
  transaction: serializeTransactionCelo
};
var MAX_MAX_FEE_PER_GAS = 2n ** 256n - 1n;

// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/celo.js
var celo = defineChain({
  id: 42220,
  name: "Celo",
  network: "celo",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "CELO"
  },
  rpcUrls: {
    default: { http: ["https://forno.celo.org"] },
    infura: {
      http: ["https://celo-mainnet.infura.io/v3"]
    },
    public: {
      http: ["https://forno.celo.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Celo Explorer",
      url: "https://explorer.celo.org/mainnet"
    },
    etherscan: { name: "CeloScan", url: "https://celoscan.io" }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 13112599
    }
  },
  testnet: false
}, {
  formatters: formattersCelo,
  serializers: serializersCelo
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/celoAlfajores.js
var celoAlfajores = defineChain({
  id: 44787,
  name: "Alfajores",
  network: "celo-alfajores",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "A-CELO"
  },
  rpcUrls: {
    default: {
      http: ["https://alfajores-forno.celo-testnet.org"]
    },
    infura: {
      http: ["https://celo-alfajores.infura.io/v3"]
    },
    public: {
      http: ["https://alfajores-forno.celo-testnet.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Celo Explorer",
      url: "https://explorer.celo.org/alfajores"
    },
    etherscan: { name: "CeloScan", url: "https://alfajores.celoscan.io/" }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 14569001
    }
  },
  testnet: true
}, {
  formatters: formattersCelo,
  serializers: serializersCelo
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/celoCannoli.js
var celoCannoli = defineChain({
  id: 17323,
  name: "Cannoli",
  network: "celo-cannoli",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "C-CELO"
  },
  rpcUrls: {
    default: {
      http: ["https://forno.cannoli.celo-testnet.org"]
    },
    public: {
      http: ["https://forno.cannoli.celo-testnet.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Celo Explorer",
      url: "https://explorer.celo.org/cannoli"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5Acb0aa8BF4E8Ff0d882Ee187140713C12BF9718",
      blockCreated: 87429
    }
  },
  testnet: true
}, {
  formatters: formattersCelo,
  serializers: serializersCelo
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/dfk.js
var dfk = defineChain({
  id: 53935,
  name: "DFK Chain",
  network: "dfk",
  nativeCurrency: {
    decimals: 18,
    name: "Jewel",
    symbol: "JEWEL"
  },
  rpcUrls: {
    default: {
      http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
    },
    public: {
      http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "DFKSubnetScan",
      url: "https://subnets.avax.network/defi-kingdoms"
    },
    default: {
      name: "DFKSubnetScan",
      url: "https://subnets.avax.network/defi-kingdoms"
    }
  }
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/mainnet.js
var mainnet = defineChain({
  id: 1,
  network: "homestead",
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://eth-mainnet.g.alchemy.com/v2"],
      webSocket: ["wss://eth-mainnet.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://mainnet.infura.io/v3"],
      webSocket: ["wss://mainnet.infura.io/ws/v3"]
    },
    default: {
      http: ["https://cloudflare-eth.com"]
    },
    public: {
      http: ["https://cloudflare-eth.com"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "Etherscan",
      url: "https://etherscan.io"
    },
    default: {
      name: "Etherscan",
      url: "https://etherscan.io"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xc0497E381f536Be9ce14B0dD3817cBcAe57d2F62",
      blockCreated: 16966585
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/mantle.js
var mantle = defineChain({
  id: 5000,
  name: "Mantle",
  network: "mantle",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.mantle.xyz"] },
    public: { http: ["https://rpc.mantle.xyz"] }
  },
  blockExplorers: {
    etherscan: {
      name: "Mantle Explorer",
      url: "https://explorer.mantle.xyz"
    },
    default: {
      name: "Mantle Explorer",
      url: "https://explorer.mantle.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 304717
    }
  }
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/optimism.js
var optimism = defineChain({
  id: 10,
  name: "OP Mainnet",
  network: "optimism",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://opt-mainnet.g.alchemy.com/v2"],
      webSocket: ["wss://opt-mainnet.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://optimism-mainnet.infura.io/v3"],
      webSocket: ["wss://optimism-mainnet.infura.io/ws/v3"]
    },
    default: {
      http: ["https://mainnet.optimism.io"]
    },
    public: {
      http: ["https://mainnet.optimism.io"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "Etherscan",
      url: "https://optimistic.etherscan.io"
    },
    default: {
      name: "Optimism Explorer",
      url: "https://explorer.optimism.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4286263
    }
  }
}, {
  formatters: formattersOptimism
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/optimismGoerli.js
var optimismGoerli = defineChain({
  id: 420,
  name: "Optimism Goerli",
  network: "optimism-goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://opt-goerli.g.alchemy.com/v2"],
      webSocket: ["wss://opt-goerli.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://optimism-goerli.infura.io/v3"],
      webSocket: ["wss://optimism-goerli.infura.io/ws/v3"]
    },
    default: {
      http: ["https://goerli.optimism.io"]
    },
    public: {
      http: ["https://goerli.optimism.io"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "Etherscan",
      url: "https://goerli-optimism.etherscan.io"
    },
    default: {
      name: "Etherscan",
      url: "https://goerli-optimism.etherscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 49461
    }
  },
  testnet: true
}, {
  formatters: formattersOptimism
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/optimismSepolia.js
var optimismSepolia = defineChain({
  id: 11155420,
  name: "Optimism Sepolia",
  network: "optimism-sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://opt-sepolia.g.alchemy.com/v2"],
      webSocket: ["wss://opt-sepolia.g.alchemy.com/v2"]
    },
    default: {
      http: ["https://sepolia.optimism.io"]
    },
    public: {
      http: ["https://sepolia.optimism.io"]
    }
  },
  blockExplorers: {
    blockscout: {
      name: "Blockscout",
      url: "https://optimism-sepolia.blockscout.com"
    },
    default: {
      name: "Blockscout",
      url: "https://optimism-sepolia.blockscout.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1620204
    }
  },
  testnet: true
}, {
  formatters: formattersOptimism
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/opBNB.js
var opBNB = defineChain({
  id: 204,
  name: "opBNB",
  network: "opBNB Mainnet",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    public: { http: ["https://opbnb-mainnet-rpc.bnbchain.org"] },
    default: { http: ["https://opbnb-mainnet-rpc.bnbchain.org"] }
  },
  blockExplorers: {
    default: { name: "opbnbscan", url: "https://mainnet.opbnbscan.com" }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 512881
    }
  }
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/opBNBTestnet.js
var opBNBTestnet = defineChain({
  id: 5611,
  name: "opBNB Testnet",
  network: "opBNB Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tBNB",
    symbol: "tBNB"
  },
  rpcUrls: {
    public: { http: ["https://opbnb-testnet-rpc.bnbchain.org"] },
    default: { http: ["https://opbnb-testnet-rpc.bnbchain.org"] }
  },
  blockExplorers: {
    default: { name: "opbnbscan", url: "https://testnet.opbnbscan.com" }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3705108
    }
  },
  testnet: true
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/polygon.js
var polygon = defineChain({
  id: 137,
  name: "Polygon",
  network: "matic",
  nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://polygon-mainnet.g.alchemy.com/v2"],
      webSocket: ["wss://polygon-mainnet.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://polygon-mainnet.infura.io/v3"],
      webSocket: ["wss://polygon-mainnet.infura.io/ws/v3"]
    },
    default: {
      http: ["https://polygon-rpc.com"]
    },
    public: {
      http: ["https://polygon-rpc.com"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "PolygonScan",
      url: "https://polygonscan.com"
    },
    default: {
      name: "PolygonScan",
      url: "https://polygonscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  }
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/polygonMumbai.js
var polygonMumbai = defineChain({
  id: 80001,
  name: "Polygon Mumbai",
  network: "maticmum",
  nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://polygon-mumbai.g.alchemy.com/v2"],
      webSocket: ["wss://polygon-mumbai.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://polygon-mumbai.infura.io/v3"],
      webSocket: ["wss://polygon-mumbai.infura.io/ws/v3"]
    },
    default: {
      http: ["https://rpc.ankr.com/polygon_mumbai"]
    },
    public: {
      http: ["https://rpc.ankr.com/polygon_mumbai"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "PolygonScan",
      url: "https://mumbai.polygonscan.com"
    },
    default: {
      name: "PolygonScan",
      url: "https://mumbai.polygonscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  },
  testnet: true
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/scroll.js
var scroll = defineChain({
  id: 534352,
  name: "Scroll",
  network: "scroll",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.scroll.io"],
      webSocket: ["wss://wss-rpc.scroll.io/ws"]
    },
    public: {
      http: ["https://rpc.scroll.io"],
      webSocket: ["wss://wss-rpc.scroll.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Scrollscan",
      url: "https://scrollscan.com"
    },
    blockscout: {
      name: "Blockscout",
      url: "https://blockscout.scroll.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14
    }
  },
  testnet: false
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/scrollSepolia.js
var scrollSepolia = defineChain({
  id: 534351,
  name: "Scroll Sepolia",
  network: "scroll-sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.scroll.io"]
    },
    public: {
      http: ["https://sepolia-rpc.scroll.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia-blockscout.scroll.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 9473
    }
  },
  testnet: true
});
// ../node_modules/.pnpm/viem@1.21.4_typescript@5.3.3_zod@3.22.4/node_modules/viem/_esm/chains/definitions/sepolia.js
var sepolia = defineChain({
  id: 11155111,
  network: "sepolia",
  name: "Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "SEP", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://eth-sepolia.g.alchemy.com/v2"],
      webSocket: ["wss://eth-sepolia.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://sepolia.infura.io/v3"],
      webSocket: ["wss://sepolia.infura.io/ws/v3"]
    },
    default: {
      http: ["https://rpc.sepolia.org"]
    },
    public: {
      http: ["https://rpc.sepolia.org"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "Etherscan",
      url: "https://sepolia.etherscan.io"
    },
    default: {
      name: "Etherscan",
      url: "https://sepolia.etherscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 751532
    },
    ensRegistry: { address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
    ensUniversalResolver: {
      address: "0x21B000Fd62a880b2125A61e36a284BB757b76025",
      blockCreated: 3914906
    }
  },
  testnet: true
});
// utils/gasPriceManager.ts
var getGasStationUrl = function(chainId) {
  switch (chainId) {
    case ChainId.Polygon:
      return "https://gasstation.polygon.technology/v2";
    case ChainId.Mumbai:
      return "https://gasstation-testnet.polygon.technology/v2";
  }
};
var ChainId;
(function(ChainId2) {
  ChainId2[ChainId2["Goerli"] = 5] = "Goerli";
  ChainId2[ChainId2["Polygon"] = 137] = "Polygon";
  ChainId2[ChainId2["Mumbai"] = 80001] = "Mumbai";
  ChainId2[ChainId2["LineaTestnet"] = 59140] = "LineaTestnet";
  ChainId2[ChainId2["Linea"] = 59144] = "Linea";
})(ChainId || (ChainId = {}));
var MIN_POLYGON_GAS_PRICE = parseGwei("31");
var MIN_MUMBAI_GAS_PRICE = parseGwei("1");

class GasPriceManager {
  chain;
  publicClient;
  noEip1559Support;
  logger;
  queueMaxFeePerGas = [];
  queueMaxPriorityFeePerGas = [];
  maxQueueSize;
  constructor(chain6, publicClient, noEip1559Support, logger2, gasPriceTimeValidityInSeconds = 10) {
    this.maxQueueSize = gasPriceTimeValidityInSeconds;
    this.chain = chain6;
    this.publicClient = publicClient;
    this.noEip1559Support = noEip1559Support;
    this.logger = logger2;
  }
  getDefaultGasFee(chainId) {
    switch (chainId) {
      case ChainId.Polygon:
        return MIN_POLYGON_GAS_PRICE;
      case ChainId.Mumbai:
        return MIN_MUMBAI_GAS_PRICE;
      default:
        return 0n;
    }
  }
  async getPolygonGasPriceParameters() {
    const gasStationUrl = getGasStationUrl(this.chain.id);
    try {
      const data3 = await (await fetch(gasStationUrl)).json();
      const parsedData = gasStationResult2.parse(data3);
      return parsedData.fast;
    } catch (e) {
      this.logger.error({ error: e }, "failed to get gas price from gas station, using default");
      return null;
    }
  }
  getBumpAmount(chainId) {
    if (chainId === sepolia.id) {
      return 120n;
    }
    if (chainId === celo.id) {
      return 150n;
    }
    if (chainId === arbitrum.id || chainId === scroll.id || chainId === scrollSepolia.id || chainId === arbitrumGoerli.id || chainId === mainnet.id || chainId === mantle.id || chainId === 22222 || chainId === sepolia.id || chainId === base29.id || chainId === dfk.id || chainId === celoAlfajores.id || chainId === celoCannoli.id || chainId === avalanche.id) {
      return 111n;
    }
    return 100n;
  }
  bumpTheGasPrice(gasPriceParameters) {
    const bumpAmount = this.getBumpAmount(this.chain.id);
    const maxPriorityFeePerGas = maxBigInt(gasPriceParameters.maxPriorityFeePerGas, this.getDefaultGasFee(this.chain.id));
    const maxFeePerGas = maxBigInt(gasPriceParameters.maxFeePerGas, maxPriorityFeePerGas);
    const result = {
      maxFeePerGas: maxFeePerGas * bumpAmount / 100n,
      maxPriorityFeePerGas: maxPriorityFeePerGas * bumpAmount / 100n
    };
    if (this.chain.id === celo.id || this.chain.id === celoAlfajores.id || this.chain.id === celoCannoli.id) {
      const maxFee = maxBigInt(result.maxFeePerGas, result.maxPriorityFeePerGas);
      return {
        maxFeePerGas: maxFee,
        maxPriorityFeePerGas: maxFee
      };
    }
    if (this.chain.id === dfk.id) {
      const maxFeePerGas2 = maxBigInt(5000000000n, result.maxFeePerGas);
      const maxPriorityFeePerGas2 = maxBigInt(5000000000n, result.maxPriorityFeePerGas);
      return {
        maxFeePerGas: maxFeePerGas2,
        maxPriorityFeePerGas: maxPriorityFeePerGas2
      };
    }
    if (this.chain.id === avalanche.id) {
      const maxFeePerGas2 = maxBigInt(parseGwei("1.5"), result.maxFeePerGas);
      const maxPriorityFeePerGas2 = maxBigInt(parseGwei("1.5"), result.maxPriorityFeePerGas);
      return {
        maxFeePerGas: maxFeePerGas2,
        maxPriorityFeePerGas: maxPriorityFeePerGas2
      };
    }
    return result;
  }
  async getFallBackMaxPriorityFeePerGas(publicClient, gasPrice7) {
    const feeHistory2 = await publicClient.getFeeHistory({
      blockCount: 10,
      rewardPercentiles: [20],
      blockTag: "latest"
    });
    if (feeHistory2.reward === undefined || feeHistory2.reward === null) {
      return gasPrice7;
    }
    const feeAverage = feeHistory2.reward.reduce((acc, cur) => cur[0] + acc, 0n) / 10n;
    return minBigInt(feeAverage, gasPrice7);
  }
  async getNextBaseFee(publicClient) {
    const block7 = await publicClient.getBlock({
      blockTag: "latest"
    });
    const currentBaseFeePerGas = block7.baseFeePerGas || await publicClient.getGasPrice();
    const currentGasUsed = block7.gasUsed;
    const gasTarget = block7.gasLimit / 2n;
    if (currentGasUsed === gasTarget) {
      return currentBaseFeePerGas;
    }
    if (currentGasUsed > gasTarget) {
      const gasUsedDelta2 = currentGasUsed - gasTarget;
      const baseFeePerGasDelta2 = maxBigInt(currentBaseFeePerGas * gasUsedDelta2 / gasTarget / 8n, 1n);
      return currentBaseFeePerGas + baseFeePerGasDelta2;
    }
    const gasUsedDelta = currentGasUsed - gasTarget;
    const baseFeePerGasDelta = currentBaseFeePerGas * gasUsedDelta / gasTarget / 8n;
    return currentBaseFeePerGas - baseFeePerGasDelta;
  }
  async getNoEip1559SupportGasPrice() {
    let gasPrice7;
    try {
      const gasInfo = await this.publicClient.estimateFeesPerGas({
        chain: this.chain,
        type: "legacy"
      });
      gasPrice7 = gasInfo.gasPrice;
    } catch (e) {
      sentry.captureException(e);
      this.logger.error("failed to fetch legacy gasPrices from estimateFeesPerGas", { error: e });
      gasPrice7 = undefined;
    }
    if (gasPrice7 === undefined) {
      this.logger.warn("gasPrice is undefined, using fallback value");
      try {
        gasPrice7 = await this.publicClient.getGasPrice();
      } catch (e) {
        this.logger.error("failed to get fallback gasPrice");
        sentry.captureException(e);
        throw e;
      }
    }
    return {
      maxFeePerGas: gasPrice7,
      maxPriorityFeePerGas: gasPrice7
    };
  }
  async estimateGasPrice() {
    let maxFeePerGas;
    let maxPriorityFeePerGas;
    try {
      const fees = await this.publicClient.estimateFeesPerGas({
        chain: this.chain
      });
      maxFeePerGas = fees.maxFeePerGas;
      maxPriorityFeePerGas = fees.maxPriorityFeePerGas;
    } catch (e) {
      sentry.captureException(e);
      this.logger.error("failed to fetch eip-1559 gasPrices from estimateFeesPerGas", { error: e });
      maxFeePerGas = undefined;
      maxPriorityFeePerGas = undefined;
    }
    if (maxPriorityFeePerGas === undefined) {
      this.logger.warn("maxPriorityFeePerGas is undefined, using fallback value");
      try {
        maxPriorityFeePerGas = await this.getFallBackMaxPriorityFeePerGas(this.publicClient, maxFeePerGas ?? 0n);
      } catch (e) {
        this.logger.error("failed to get fallback maxPriorityFeePerGas");
        sentry.captureException(e);
        throw e;
      }
    }
    if (maxFeePerGas === undefined) {
      this.logger.warn("maxFeePerGas is undefined, using fallback value");
      try {
        maxFeePerGas = await this.getNextBaseFee(this.publicClient) + maxPriorityFeePerGas;
      } catch (e) {
        this.logger.error("failed to get fallback maxFeePerGas");
        sentry.captureException(e);
        throw e;
      }
    }
    if (maxPriorityFeePerGas === 0n) {
      maxPriorityFeePerGas = maxFeePerGas / 200n;
    }
    return { maxFeePerGas, maxPriorityFeePerGas };
  }
  saveMaxFeePerGas(gasPrice7, timestamp) {
    const queue = this.queueMaxFeePerGas;
    const last = queue.length > 0 ? queue[queue.length - 1] : null;
    if (!last || timestamp - last.timestamp >= 1000) {
      if (queue.length >= this.maxQueueSize) {
        queue.shift();
      }
      queue.push({ maxFeePerGas: gasPrice7, timestamp });
    } else if (gasPrice7 < last.maxFeePerGas) {
      last.maxFeePerGas = gasPrice7;
      last.timestamp = timestamp;
    }
  }
  saveMaxPriorityFeePerGas(gasPrice7, timestamp) {
    const queue = this.queueMaxPriorityFeePerGas;
    const last = queue.length > 0 ? queue[queue.length - 1] : null;
    if (!last || timestamp - last.timestamp >= 1000) {
      if (queue.length >= this.maxQueueSize) {
        queue.shift();
      }
      queue.push({ maxPriorityFeePerGas: gasPrice7, timestamp });
    } else if (gasPrice7 < last.maxPriorityFeePerGas) {
      last.maxPriorityFeePerGas = gasPrice7;
      last.timestamp = timestamp;
    }
  }
  saveGasPrice(gasPrice7, timestamp) {
    return new Promise((resolve5) => {
      this.saveMaxFeePerGas(gasPrice7.maxFeePerGas, timestamp);
      this.saveMaxPriorityFeePerGas(gasPrice7.maxPriorityFeePerGas, timestamp);
      resolve5();
    });
  }
  async innerGetGasPrice() {
    let maxFeePerGas = 0n;
    let maxPriorityFeePerGas = 0n;
    if (this.chain.id === polygon.id || this.chain.id === polygonMumbai.id) {
      const polygonEstimate = await this.getPolygonGasPriceParameters();
      if (polygonEstimate) {
        const gasPrice8 = this.bumpTheGasPrice({
          maxFeePerGas: polygonEstimate.maxFeePerGas,
          maxPriorityFeePerGas: polygonEstimate.maxPriorityFeePerGas
        });
        return {
          maxFeePerGas: maxBigInt(gasPrice8.maxFeePerGas, maxFeePerGas),
          maxPriorityFeePerGas: maxBigInt(gasPrice8.maxPriorityFeePerGas, maxPriorityFeePerGas)
        };
      }
    }
    if (this.noEip1559Support) {
      const gasPrice8 = this.bumpTheGasPrice(await this.getNoEip1559SupportGasPrice());
      return {
        maxFeePerGas: maxBigInt(gasPrice8.maxFeePerGas, maxFeePerGas),
        maxPriorityFeePerGas: maxBigInt(gasPrice8.maxPriorityFeePerGas, maxPriorityFeePerGas)
      };
    }
    const estimatedPrice = await this.estimateGasPrice();
    maxFeePerGas = estimatedPrice.maxFeePerGas;
    maxPriorityFeePerGas = estimatedPrice.maxPriorityFeePerGas;
    const gasPrice7 = this.bumpTheGasPrice({
      maxFeePerGas,
      maxPriorityFeePerGas
    });
    return {
      maxFeePerGas: maxBigInt(gasPrice7.maxFeePerGas, maxFeePerGas),
      maxPriorityFeePerGas: maxBigInt(gasPrice7.maxPriorityFeePerGas, maxPriorityFeePerGas)
    };
  }
  async getGasPrice() {
    const gasPrice7 = await this.innerGetGasPrice();
    this.saveGasPrice({
      maxFeePerGas: gasPrice7.maxFeePerGas,
      maxPriorityFeePerGas: gasPrice7.maxPriorityFeePerGas
    }, Date.now());
    return gasPrice7;
  }
  async getMinMaxFeePerGas() {
    if (this.queueMaxFeePerGas.length === 0) {
      await this.getGasPrice();
    }
    return this.queueMaxFeePerGas.reduce((acc, cur) => minBigInt(cur.maxFeePerGas, acc), this.queueMaxFeePerGas[0].maxFeePerGas);
  }
  async getMinMaxPriorityFeePerGas() {
    if (this.queueMaxPriorityFeePerGas.length === 0) {
      await this.getGasPrice();
    }
    return this.queueMaxPriorityFeePerGas.reduce((acc, cur) => minBigInt(cur.maxPriorityFeePerGas, acc), this.queueMaxPriorityFeePerGas[0].maxPriorityFeePerGas);
  }
  async validateGasPrice(gasPrice7) {
    const lowestMaxFeePerGas = await this.getMinMaxFeePerGas();
    const lowestMaxPriorityFeePerGas = await this.getMinMaxPriorityFeePerGas();
    if (gasPrice7.maxFeePerGas < lowestMaxFeePerGas) {
      throw new RpcError3(`maxFeePerGas must be at least ${lowestMaxFeePerGas} (current maxFeePerGas: ${gasPrice7.maxFeePerGas}) - use pimlico_getUserOperationGasPrice to get the current gas price`);
    }
    if (gasPrice7.maxPriorityFeePerGas < lowestMaxPriorityFeePerGas) {
      throw new RpcError3(`maxPriorityFeePerGas must be at least ${lowestMaxPriorityFeePerGas} (current maxPriorityFeePerGas: ${gasPrice7.maxPriorityFeePerGas}) - use pimlico_getUserOperationGasPrice to get the current gas price`);
    }
  }
}

// utils/index.ts
var import_pino2 = __toESM(require_pino(), 1);

// cli/handler.ts
var import_zod_validation_error6 = __toESM(require_cjs5(), 1);

// cli/customTransport.ts
function customTransport(url_, config) {
  const {
    fetchOptions,
    key = "http",
    name = "HTTP JSON-RPC",
    retryDelay,
    logger: logger3
  } = config;
  return ({ chain: chain6, retryCount: retryCount_, timeout: timeout_ }) => {
    const retryCount = config.retryCount ?? retryCount_;
    const timeout = timeout_ ?? config.timeout ?? 1e4;
    const url = url_ || chain6?.rpcUrls.default.http[0];
    if (!url) {
      throw new UrlRequiredError;
    }
    return createTransport({
      key,
      name,
      async request({ method, params }) {
        const body = { method, params };
        const fn = async (body2) => {
          return [
            await rpc4.http(url, {
              body: body2,
              fetchOptions,
              timeout
            })
          ];
        };
        const [{ error, result }] = await fn(body);
        if (error) {
          logger3.error({
            error,
            body
          }, "Received error response");
          throw new RpcRequestError({
            body,
            error,
            url
          });
        }
        logger3.info({ body, result }, "Received response");
        return result;
      },
      retryCount,
      retryDelay,
      timeout,
      type: "http"
    }, {
      fetchOptions,
      url
    });
  };
}
// entrypoint-0.6/utils/validation.ts
function packUserOp(op) {
  return encodeAbiParameters([
    {
      internalType: "address",
      name: "sender",
      type: "address"
    },
    {
      internalType: "uint256",
      name: "nonce",
      type: "uint256"
    },
    {
      internalType: "bytes",
      name: "initCode",
      type: "bytes"
    },
    {
      internalType: "bytes",
      name: "callData",
      type: "bytes"
    },
    {
      internalType: "uint256",
      name: "callGasLimit",
      type: "uint256"
    },
    {
      internalType: "uint256",
      name: "verificationGasLimit",
      type: "uint256"
    },
    {
      internalType: "uint256",
      name: "preVerificationGas",
      type: "uint256"
    },
    {
      internalType: "uint256",
      name: "maxFeePerGas",
      type: "uint256"
    },
    {
      internalType: "uint256",
      name: "maxPriorityFeePerGas",
      type: "uint256"
    },
    {
      internalType: "bytes",
      name: "paymasterAndData",
      type: "bytes"
    },
    {
      internalType: "bytes",
      name: "signature",
      type: "bytes"
    }
  ], [
    op.sender,
    BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"),
    op.initCode,
    op.callData,
    BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"),
    BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"),
    BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"),
    BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"),
    BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"),
    bytesToHex(new Uint8Array(op.paymasterAndData.length).fill(255)),
    bytesToHex(new Uint8Array(op.signature.length).fill(255))
  ]);
}
async function calcPreVerificationGas(publicClient, userOperation, entryPoint, chainId, overheads) {
  let preVerificationGas = calcDefaultPreVerificationGas(userOperation, overheads);
  if (chainId === 59140 || chainId === 59142) {
    preVerificationGas *= 2n;
  } else if (chainId === optimism.id || chainId === optimismSepolia.id || chainId === optimismGoerli.id || chainId === base29.id || chainId === baseGoerli.id || chainId === baseSepolia.id || chainId === opBNB.id || chainId === opBNBTestnet.id || chainId === 957) {
    preVerificationGas = await calcOptimismPreVerificationGas(publicClient, userOperation, entryPoint, preVerificationGas);
  } else if (chainId === arbitrum.id || chainId === arbitrumNova.id || chainId === arbitrumSepolia.id) {
    preVerificationGas = await calcArbitrumPreVerificationGas(publicClient, userOperation, entryPoint, preVerificationGas);
  }
  return preVerificationGas;
}
async function calcVerificationGasAndCallGasLimit(publicClient, userOperation, executionResult, chainId) {
  const verificationGasLimit = (executionResult.preOpGas - userOperation.preVerificationGas) * 3n / 2n;
  let gasPrice7;
  if (userOperation.maxPriorityFeePerGas === userOperation.maxFeePerGas) {
    gasPrice7 = userOperation.maxFeePerGas;
  } else {
    const blockBaseFee = (await publicClient.getBlock()).baseFeePerGas;
    gasPrice7 = userOperation.maxFeePerGas < (blockBaseFee ?? 0n) + userOperation.maxPriorityFeePerGas ? userOperation.maxFeePerGas : userOperation.maxPriorityFeePerGas + (blockBaseFee ?? 0n);
  }
  const calculatedCallGasLimit = executionResult.paid / gasPrice7 - executionResult.preOpGas + 21000n + 50000n;
  let callGasLimit = calculatedCallGasLimit > 9000n ? calculatedCallGasLimit : 9000n;
  if (chainId === baseGoerli.id || chainId === baseSepolia.id || chainId === base29.id) {
    callGasLimit = 110n * callGasLimit / 100n;
  }
  return [verificationGasLimit, callGasLimit];
}
function calcDefaultPreVerificationGas(userOperation, overheads) {
  const ov = { ...DefaultGasOverheads, ...overheads ?? {} };
  const p = { ...userOperation };
  p.preVerificationGas;
  p.signature = p.signature === "0x" ? toHex2(Buffer.alloc(ov.sigSize, 1)) : p.signature;
  const packed = toBytes2(packUserOp(p));
  const lengthInWord = (packed.length + 31) / 32;
  const callDataCost = packed.map((x) => x === 0 ? ov.zeroByte : ov.nonZeroByte).reduce((sum, x) => sum + x);
  const ret2 = Math.round(callDataCost + ov.fixed / ov.bundleSize + ov.perUserOp + ov.perUserOpWord * lengthInWord);
  return BigInt(ret2);
}
async function calcOptimismPreVerificationGas(publicClient, op, entryPoint, staticFee) {
  const randomDataUserOp = {
    ...op
  };
  const selector = getFunctionSelector(EntryPointAbi[27]);
  const paramData = encodeAbiParameters(EntryPointAbi[27].inputs, [
    [randomDataUserOp],
    entryPoint
  ]);
  const data3 = concat([selector, paramData]);
  const latestBlock = await publicClient.getBlock();
  if (latestBlock.baseFeePerGas === null) {
    throw new RpcError2("block does not have baseFeePerGas");
  }
  const serializedTx = serializeTransaction({
    to: entryPoint,
    chainId: publicClient.chain.id,
    nonce: 999999,
    gasLimit: maxUint64,
    gasPrice: maxUint64,
    data: data3
  }, {
    r: "0x123451234512345123451234512345123451234512345123451234512345",
    s: "0x123451234512345123451234512345123451234512345123451234512345",
    v: 28n
  });
  const opGasPriceOracle = getContract({
    abi: getL1FeeAbi,
    address: "0x420000000000000000000000000000000000000F",
    publicClient
  });
  const { result: l1Fee } = await opGasPriceOracle.simulate.getL1Fee([
    serializedTx
  ]);
  const l2MaxFee = op.maxFeePerGas;
  const l2PriorityFee = latestBlock.baseFeePerGas + op.maxPriorityFeePerGas;
  const l2price = l2MaxFee < l2PriorityFee ? l2MaxFee : l2PriorityFee;
  return staticFee + l1Fee / l2price;
}
async function calcArbitrumPreVerificationGas(publicClient, op, entryPoint, staticFee) {
  const selector = getFunctionSelector(EntryPointAbi[27]);
  const paramData = encodeAbiParameters(EntryPointAbi[27].inputs, [
    [op],
    entryPoint
  ]);
  const data3 = concat([selector, paramData]);
  const precompileAddress = "0x00000000000000000000000000000000000000C8";
  const serializedTx = serializeTransaction({
    to: entryPoint,
    chainId: publicClient.chain?.id ?? 10,
    nonce: 999999,
    gasLimit: maxUint64,
    gasPrice: maxUint64,
    data: data3
  }, {
    r: "0x123451234512345123451234512345123451234512345123451234512345",
    s: "0x123451234512345123451234512345123451234512345123451234512345",
    v: 28n
  });
  const arbGasPriceOracle = getContract({
    abi: getArbitrumL1FeeAbi,
    address: precompileAddress,
    publicClient
  });
  const { result } = await arbGasPriceOracle.simulate.gasEstimateL1Component([
    entryPoint,
    false,
    serializedTx
  ]);
  return result[0] + staticFee;
}
function parseViemError(err) {
  if (err instanceof ContractFunctionExecutionError || err instanceof TransactionExecutionError) {
    const e = err.cause;
    if (e instanceof NonceTooLowError) {
      return e;
    }
    if (e instanceof FeeCapTooLowError) {
      return e;
    }
    if (e instanceof InsufficientFundsError) {
      return e;
    }
    if (e instanceof IntrinsicGasTooLowError) {
      return e;
    }
    if (e instanceof ContractFunctionRevertedError) {
      return e;
    }
    if (e instanceof EstimateGasExecutionError) {
      return e;
    }
    return;
  }
  return;
}
var DefaultGasOverheads = {
  fixed: 21000,
  perUserOp: 18300,
  perUserOpWord: 4,
  zeroByte: 4,
  nonZeroByte: 16,
  bundleSize: 1,
  sigSize: 65
};
var maxUint64 = 2n ** 64n - 1n;
var getL1FeeAbi = [
  {
    inputs: [
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "getL1Fee",
    outputs: [
      {
        internalType: "uint256",
        name: "fee",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "l1BaseFee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
];
var getArbitrumL1FeeAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "bool",
        name: "contractCreation",
        type: "bool"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "gasEstimateL1Component",
    outputs: [
      {
        internalType: "uint64",
        name: "gasEstimateForL1",
        type: "uint64"
      },
      {
        internalType: "uint256",
        name: "baseFee",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "l1BaseFeeEstimate",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
// entrypoint-0.6/utils/userop.ts
var sentry2 = __toESM(require_cjs4(), 1);

// entrypoint-0.6/utils/helpers.ts
var maxBigInt2 = (a, b) => {
  return a > b ? a : b;
};
var areAddressesEqual = (a, b) => {
  return getAddress(a) === getAddress(b);
};

// entrypoint-0.6/utils/userop.ts
function deepHexlify(obj) {
  if (typeof obj === "function") {
    return;
  }
  if (obj == null || typeof obj === "string" || typeof obj === "boolean") {
    return obj;
  }
  if (typeof obj === "bigint") {
    return toHex2(obj);
  }
  if (obj._isBigNumber != null || typeof obj !== "object") {
    return toHex2(obj).replace(/^0x0/, "0x");
  }
  if (Array.isArray(obj)) {
    return obj.map((member) => deepHexlify(member));
  }
  return Object.keys(obj).reduce((set, key) => {
    set[key] = deepHexlify(obj[key]);
    return set;
  }, {});
}
function getAddressFromInitCodeOrPaymasterAndData(data3) {
  if (!data3) {
    return;
  }
  if (data3.length >= 42) {
    return getAddress(data3.slice(0, 42));
  }
  return;
}
var transactionIncluded = async (txHash, publicClient, entryPoint) => {
  try {
    const rcp = await publicClient.getTransactionReceipt({ hash: txHash });
    if (rcp.status === "success") {
      const r = rcp.logs.map((l) => {
        if (areAddressesEqual(l.address, entryPoint)) {
          try {
            const log7 = decodeEventLog({
              abi: EntryPointAbi,
              data: l.data,
              topics: l.topics
            });
            if (log7.eventName === "AccountDeployed") {
              return {
                userOperationHash: log7.args.userOpHash,
                success: !!log7.args.factory,
                accountDeployed: true
              };
            }
            if (log7.eventName === "UserOperationEvent") {
              return {
                userOperationHash: log7.args.userOpHash,
                success: !!log7.args.success,
                accountDeployed: false
              };
            }
            return;
          } catch (_e) {
            sentry2.captureException(_e);
            return;
          }
        }
        return;
      }).reduce((result, log7) => {
        if (log7) {
          result[log7.userOperationHash] = {
            userOperationHash: log7.userOperationHash,
            accountDeployed: log7.accountDeployed || result[log7.userOperationHash]?.accountDeployed,
            success: log7.success || result[log7.userOperationHash]?.success
          };
          return result;
        }
        return result;
      }, {});
      const success = Object.values(r).reduce((x, v) => x || v.success, false);
      if (success) {
        return {
          status: "included",
          ...r
        };
      }
      return {
        status: "reverted"
      };
    }
    return {
      status: "failed"
    };
  } catch (_e) {
    return {
      status: "not_found"
    };
  }
};
var getUserOperationHash = (userOperation, entryPointAddress, chainId) => {
  const hash4 = keccak256(encodeAbiParameters([
    {
      name: "sender",
      type: "address"
    },
    {
      name: "nonce",
      type: "uint256"
    },
    {
      name: "initCodeHash",
      type: "bytes32"
    },
    {
      name: "callDataHash",
      type: "bytes32"
    },
    {
      name: "callGasLimit",
      type: "uint256"
    },
    {
      name: "verificationGasLimit",
      type: "uint256"
    },
    {
      name: "preVerificationGas",
      type: "uint256"
    },
    {
      name: "maxFeePerGas",
      type: "uint256"
    },
    {
      name: "maxPriorityFeePerGas",
      type: "uint256"
    },
    {
      name: "paymasterAndDataHash",
      type: "bytes32"
    }
  ], [
    userOperation.sender,
    userOperation.nonce,
    keccak256(userOperation.initCode),
    keccak256(userOperation.callData),
    userOperation.callGasLimit,
    userOperation.verificationGasLimit,
    userOperation.preVerificationGas,
    userOperation.maxFeePerGas,
    userOperation.maxPriorityFeePerGas,
    keccak256(userOperation.paymasterAndData)
  ]));
  return keccak256(encodeAbiParameters([
    {
      name: "userOpHash",
      type: "bytes32"
    },
    {
      name: "entryPointAddress",
      type: "address"
    },
    {
      name: "chainId",
      type: "uint256"
    }
  ], [hash4, entryPointAddress, BigInt(chainId)]));
};
var getNonceKeyAndValue = (nonce) => {
  const nonceKey = nonce >> 64n;
  const userOperationNonceValue = nonce & 0xffffffffffffffffn;
  return [nonceKey, userOperationNonceValue];
};
// entrypoint-0.6/utils/compressionHandler.ts
class CompressionHandler {
  bundleBulkerAddress;
  perOpInflatorAddress;
  perOpInflatorId;
  constructor(bundleBulkerAddress, perOpInflatorAddress, perOpInflatorId) {
    this.bundleBulkerAddress = bundleBulkerAddress;
    this.perOpInflatorAddress = perOpInflatorAddress;
    this.perOpInflatorId = perOpInflatorId;
  }
  static createAsync = async (bundleBulkerAddress, perOpInflatorAddress, publicClient) => {
    const compressionHandler = new CompressionHandler(bundleBulkerAddress, perOpInflatorAddress, 0);
    const bundleBulker = getContract({
      address: bundleBulkerAddress,
      abi: BundleBulkerAbi,
      publicClient
    });
    compressionHandler.perOpInflatorId = await bundleBulker.read.inflatorToID([perOpInflatorAddress]);
    if (compressionHandler.perOpInflatorId === 0) {
      throw new Error(`PerOpInflator (${perOpInflatorAddress}) is not registered with BundleBulker (${bundleBulkerAddress})`);
    }
    return compressionHandler;
  };
  async getInflatorRegisteredId(inflator, publicClient) {
    const perOpInflator = getContract({
      address: this.perOpInflatorAddress,
      abi: PerOpInfaltorAbi,
      publicClient
    });
    return await perOpInflator.read.inflatorToID([inflator]);
  }
}
// entrypoint-0.6/mempool/reputationManager.ts
var EntityType;
(function(EntityType2) {
  EntityType2["ACCOUNT"] = "Account";
  EntityType2["PAYMASTER"] = "Paymaster";
  EntityType2["FACTORY"] = "Factory";
  EntityType2["AGGREGATOR"] = "Aggregator";
})(EntityType || (EntityType = {}));
var ReputationStatuses = {
  OK: 0n,
  THROTTLED: 1n,
  BANNED: 2n
};
var BundlerReputationParams = {
  minInclusionDenominator: 10n,
  throttlingSlack: 10n,
  banSlack: 50n
};

class NullReputationManager {
  async checkReputation(userOperation, validationResult) {
    return;
  }
  increaseUserOperationCount(_) {
    return;
  }
  decreaseUserOperationCount(_) {
    return;
  }
  updateUserOperationSeenStatus(_) {
    return;
  }
  updateUserOperationIncludedStatus(_, __2) {
    return;
  }
  crashedHandleOps(_, __2) {
    return;
  }
  setReputation(_) {
    return;
  }
  dumpReputations() {
    return [];
  }
  getStatus(_address) {
    throw new Error("Method not implemented.");
  }
  getStakeStatus(_) {
    throw new Error("Method not implemented.");
  }
  clear() {
    return;
  }
  clearEntityCount() {
    return;
  }
}

class ReputationManager {
  publicClient;
  entryPoint;
  minStake;
  minUnstakeDelay;
  entityCount = {};
  throttledEntityMinMempoolCount;
  maxMempoolUserOperationsPerSender;
  maxMempoolUserOperationsPerNewUnstakedEntity;
  inclusionRateFactor;
  entries = {};
  whitelist = new Set;
  blackList = new Set;
  bundlerReputationParams;
  logger;
  constructor(publicClient, entryPoint, minStake, minUnstakeDelay, logger3, maxMempoolUserOperationsPerNewUnstakedEntity, throttledEntityMinMempoolCount, inclusionRateFactor, maxMempoolUserOperationsPerSender, blackList, whiteList, bundlerReputationParams) {
    this.publicClient = publicClient;
    this.entryPoint = entryPoint;
    this.minStake = minStake;
    this.minUnstakeDelay = minUnstakeDelay;
    this.logger = logger3;
    this.maxMempoolUserOperationsPerNewUnstakedEntity = maxMempoolUserOperationsPerNewUnstakedEntity ?? 10n;
    this.inclusionRateFactor = inclusionRateFactor ?? 10n;
    this.throttledEntityMinMempoolCount = throttledEntityMinMempoolCount ?? 4n;
    this.maxMempoolUserOperationsPerSender = maxMempoolUserOperationsPerSender ?? 4n;
    this.bundlerReputationParams = bundlerReputationParams ?? BundlerReputationParams;
    for (const address10 of blackList || []) {
      this.blackList.add(address10);
    }
    for (const address10 of whiteList || []) {
      this.whitelist.add(address10);
    }
  }
  setReputation(reputations) {
    for (const reputation of reputations) {
      const address10 = getAddress(reputation.address);
      this.entries[address10] = {
        address: address10,
        opsSeen: BigInt(reputation.opsSeen),
        opsIncluded: BigInt(reputation.opsIncluded)
      };
    }
    this.logger.debug({
      reputations: this.entries
    }, "Reputation set");
  }
  dumpReputations() {
    return Object.values(this.entries).map((entry) => ({
      ...entry,
      status: this.getStatus(entry.address)
    }));
  }
  clear() {
    this.entries = {};
    this.entityCount = {};
  }
  clearEntityCount() {
    this.entityCount = {};
  }
  async getStakeStatus(address10) {
    const entryPoint = getContract({
      abi: EntryPointAbi,
      address: this.entryPoint,
      publicClient: this.publicClient
    });
    const stakeInfo = await entryPoint.read.getDepositInfo([address10]);
    const stake = BigInt(stakeInfo.stake);
    const unstakeDelaySec = BigInt(stakeInfo.unstakeDelaySec);
    const isStaked = stake >= this.minStake && unstakeDelaySec >= this.minUnstakeDelay;
    return {
      stakeInfo: {
        addr: address10,
        stake,
        unstakeDelaySec
      },
      isStaked
    };
  }
  async checkReputation(userOperation, validationResult) {
    this.increaseUserOperationCount(userOperation);
    this.checkReputationStatus(EntityType.ACCOUNT, validationResult.senderInfo, this.maxMempoolUserOperationsPerSender);
    if (validationResult.paymasterInfo) {
      this.checkReputationStatus(EntityType.PAYMASTER, validationResult.paymasterInfo);
    }
    if (validationResult.factoryInfo) {
      this.checkReputationStatus(EntityType.FACTORY, validationResult.factoryInfo);
    }
    const aggregaorValidationResult = validationResult;
    if (aggregaorValidationResult.aggregatorInfo) {
      this.checkReputationStatus(EntityType.AGGREGATOR, aggregaorValidationResult.aggregatorInfo.stakeInfo);
    }
  }
  getEntityCount(address10) {
    return this.entityCount[address10] ?? 0;
  }
  increaseSeen(address10) {
    const entry = this.entries[address10];
    if (!entry) {
      this.entries[address10] = {
        address: address10,
        opsSeen: 1n,
        opsIncluded: 0n
      };
      return;
    }
    entry.opsSeen++;
  }
  updateCrashedHandleOps(address10) {
    const entry = this.entries[address10];
    if (!entry) {
      this.entries[address10] = {
        address: address10,
        opsSeen: 1000n,
        opsIncluded: 0n
      };
      return;
    }
    entry.opsSeen = 1000n;
    entry.opsIncluded = 0n;
  }
  crashedHandleOps(op, reason) {
    if (reason.startsWith("AA3")) {
      const paymaster = getAddressFromInitCodeOrPaymasterAndData(op.paymasterAndData);
      if (paymaster) {
        this.updateCrashedHandleOps(paymaster);
      }
    } else if (reason.startsWith("AA2")) {
      const sender = op.sender;
      this.updateCrashedHandleOps(sender);
    } else if (reason.startsWith("AA1")) {
      const factory = getAddressFromInitCodeOrPaymasterAndData(op.initCode);
      if (factory) {
        this.updateCrashedHandleOps(factory);
      }
    }
  }
  updateIncludedStatus(address10) {
    const entry = this.entries[address10];
    if (!entry) {
      this.entries[address10] = {
        address: address10,
        opsSeen: 0n,
        opsIncluded: 1n
      };
      return;
    }
    entry.opsIncluded++;
  }
  updateUserOperationIncludedStatus(userOperation, accountDeployed) {
    const sender = userOperation.sender;
    this.updateIncludedStatus(sender);
    const paymaster = getAddressFromInitCodeOrPaymasterAndData(userOperation.paymasterAndData);
    if (paymaster) {
      this.updateIncludedStatus(paymaster);
    }
    if (accountDeployed) {
      const factory = getAddressFromInitCodeOrPaymasterAndData(userOperation.initCode);
      if (factory) {
        this.updateIncludedStatus(factory);
      }
    }
  }
  updateUserOperationSeenStatus(userOperation) {
    const sender = userOperation.sender;
    this.increaseSeen(sender);
    const paymaster = getAddressFromInitCodeOrPaymasterAndData(userOperation.paymasterAndData);
    if (paymaster) {
      this.increaseSeen(paymaster);
    }
    const factory = getAddressFromInitCodeOrPaymasterAndData(userOperation.initCode);
    this.logger.debug({ userOperation, factory }, "updateUserOperationSeenStatus");
    if (factory) {
      this.increaseSeen(factory);
    }
  }
  increaseUserOperationCount(userOperation) {
    const sender = userOperation.sender;
    this.entityCount[sender] = (this.entityCount[sender] ?? 0n) + 1n;
    const paymaster = getAddressFromInitCodeOrPaymasterAndData(userOperation.paymasterAndData);
    if (paymaster) {
      this.entityCount[paymaster] = (this.entityCount[paymaster] ?? 0n) + 1n;
    }
    const factory = getAddressFromInitCodeOrPaymasterAndData(userOperation.initCode);
    if (factory) {
      this.entityCount[factory] = (this.entityCount[factory] ?? 0n) + 1n;
    }
  }
  decreaseUserOperationCount(userOperation) {
    const sender = userOperation.sender;
    this.entityCount[sender] = (this.entityCount[sender] ?? 0n) - 1n;
    this.entityCount[sender] = this.entityCount[sender] < 0n ? 0n : this.entityCount[sender];
    const paymaster = getAddressFromInitCodeOrPaymasterAndData(userOperation.paymasterAndData);
    if (paymaster) {
      this.entityCount[paymaster] = (this.entityCount[paymaster] ?? 0n) - 1n;
      this.entityCount[paymaster] = this.entityCount[paymaster] < 0n ? 0n : this.entityCount[paymaster];
    }
    const factory = getAddressFromInitCodeOrPaymasterAndData(userOperation.initCode);
    if (factory) {
      this.entityCount[factory] = (this.entityCount[factory] ?? 0n) - 1n;
      this.entityCount[factory] = this.entityCount[factory] < 0n ? 0n : this.entityCount[factory];
    }
  }
  checkReputationStatus(entyType, stakeInfo, maxMempoolUserOperationsPerSenderOverride) {
    const maxTxMempoolAllowedEntity = maxMempoolUserOperationsPerSenderOverride ?? this.calCulateMaxMempoolUserOperationsPerEntity(stakeInfo.addr);
    this.checkBanned(entyType, stakeInfo);
    const entityCount = this.getEntityCount(stakeInfo.addr);
    if (entityCount > this.throttledEntityMinMempoolCount) {
      this.checkThrottled(entyType, stakeInfo);
    }
    if (entityCount > maxTxMempoolAllowedEntity) {
      this.checkStake(entyType, stakeInfo);
    }
  }
  getStatus(address10) {
    if (!address10 || this.whitelist.has(address10)) {
      return ReputationStatuses.OK;
    }
    if (this.blackList.has(address10)) {
      return ReputationStatuses.BANNED;
    }
    const entry = this.entries[address10];
    if (!entry) {
      return ReputationStatuses.OK;
    }
    const minExpectedIncluded = entry.opsSeen / this.bundlerReputationParams.minInclusionDenominator;
    this.logger.debug({
      address: address10,
      minExpectedIncluded,
      opsSeen: entry.opsSeen,
      minInclusionDenominator: this.bundlerReputationParams.minInclusionDenominator,
      opsIncluded: entry.opsIncluded,
      throttlingSlack: this.bundlerReputationParams.throttlingSlack,
      banSlack: this.bundlerReputationParams.banSlack
    }, "minExpectedIncluded");
    if (minExpectedIncluded <= entry.opsIncluded + this.bundlerReputationParams.throttlingSlack) {
      entry.status = ReputationStatuses.OK;
      return ReputationStatuses.OK;
    } else if (minExpectedIncluded <= entry.opsIncluded + this.bundlerReputationParams.banSlack) {
      entry.status = ReputationStatuses.THROTTLED;
      return ReputationStatuses.THROTTLED;
    } else {
      entry.status = ReputationStatuses.BANNED;
      return ReputationStatuses.BANNED;
    }
  }
  checkBanned(entityType, stakeInfo) {
    const status = this.getStatus(stakeInfo.addr);
    if (status === ReputationStatuses.BANNED) {
      throw new RpcError2(`${entityType} ${stakeInfo.addr} is banned from using the pimlico`, ValidationErrors.Reputation);
    }
  }
  checkThrottled(entityType, stakeInfo) {
    const status = this.getStatus(stakeInfo.addr);
    if (status === ReputationStatuses.THROTTLED) {
      throw new RpcError2(`${entityType} ${stakeInfo.addr} is throttled by the pimlico`, ValidationErrors.Reputation);
    }
  }
  isWhiteListed(address10) {
    return this.whitelist.has(address10);
  }
  checkStake(entityType, stakeInfo) {
    if (this.isWhiteListed(stakeInfo.addr)) {
      return;
    }
    this.checkBanned(entityType, stakeInfo);
    if (stakeInfo.stake < this.minStake) {
      if (stakeInfo.stake === 0n) {
        throw new RpcError2(`${entityType} ${stakeInfo.addr} is unstaked and must stake minimum ${this.minStake} to use pimlico`, ValidationErrors.InsufficientStake);
      }
      throw new RpcError2(`${entityType} ${stakeInfo.addr} does not have enough stake to use pimlico`, ValidationErrors.InsufficientStake);
    }
    if (stakeInfo.unstakeDelaySec < this.minUnstakeDelay) {
      throw new RpcError2(`${entityType} ${stakeInfo.addr} does not have enough unstake delay to use pimlico`, ValidationErrors.InsufficientStake);
    }
  }
  calCulateMaxMempoolUserOperationsPerEntity(address10) {
    const entry = this.entries[address10];
    if (!entry) {
      return this.maxMempoolUserOperationsPerNewUnstakedEntity;
    }
    let inclusionRate = 0n;
    if (entry.opsSeen !== 0n) {
      inclusionRate = entry.opsIncluded / entry.opsSeen;
    }
    return this.maxMempoolUserOperationsPerNewUnstakedEntity + inclusionRate * this.inclusionRateFactor + (entry.opsIncluded > 10000n ? 10000n : entry.opsIncluded);
  }
}

// entrypoint-0.6/mempool/store.ts
class MemoryStore {
  outstandingUserOperations = [];
  processingUserOperations = [];
  submittedUserOperations = [];
  logger;
  metrics;
  constructor(logger3, metrics2) {
    this.logger = logger3;
    this.metrics = metrics2;
  }
  addOutstanding(op) {
    const store = this.outstandingUserOperations;
    store.push(op);
    this.logger.debug({ userOpHash: op.userOperationHash, store: "outstanding" }, "added user op to mempool");
    this.metrics.userOperationsInMempool.labels({
      status: "outstanding"
    }).inc();
  }
  addProcessing(op) {
    const store = this.processingUserOperations;
    store.push(op);
    this.logger.debug({ userOpHash: op.userOperationHash, store: "processing" }, "added user op to mempool");
    this.metrics.userOperationsInMempool.labels({
      status: "processing"
    }).inc();
  }
  addSubmitted(op) {
    const store = this.submittedUserOperations;
    store.push(op);
    this.logger.debug({
      userOpHash: op.userOperation.userOperationHash,
      store: "submitted"
    }, "added user op to submitted mempool");
    this.metrics.userOperationsInMempool.labels({
      status: "submitted"
    }).inc();
  }
  removeOutstanding(userOpHash) {
    const index2 = this.outstandingUserOperations.findIndex((op) => op.userOperationHash === userOpHash);
    if (index2 === -1) {
      this.logger.warn({ userOpHash, store: "outstanding" }, "tried to remove non-existent user op from mempool");
      return;
    }
    this.outstandingUserOperations.splice(index2, 1);
    this.logger.debug({ userOpHash, store: "outstanding" }, "removed user op from mempool");
    this.metrics.userOperationsInMempool.labels({
      status: "outstanding"
    }).dec();
  }
  removeProcessing(userOpHash) {
    const index2 = this.processingUserOperations.findIndex((op) => op.userOperationHash === userOpHash);
    if (index2 === -1) {
      this.logger.warn({ userOpHash, store: "outstanding" }, "tried to remove non-existent user op from mempool");
      return;
    }
    this.processingUserOperations.splice(index2, 1);
    this.logger.debug({ userOpHash, store: "processing" }, "removed user op from mempool");
    this.metrics.userOperationsInMempool.labels({
      status: "processing"
    }).dec();
  }
  removeSubmitted(userOpHash) {
    const index2 = this.submittedUserOperations.findIndex((op) => op.userOperation.userOperationHash === userOpHash);
    if (index2 === -1) {
      this.logger.warn({ userOpHash, store: "submitted" }, "tried to remove non-existent user op from mempool");
      return;
    }
    this.submittedUserOperations.splice(index2, 1);
    this.logger.debug({ userOpHash, store: "submitted" }, "removed user op from mempool");
    this.metrics.userOperationsInMempool.labels({
      status: "submitted"
    }).dec();
  }
  dumpOutstanding() {
    this.logger.trace({
      store: "outstanding",
      length: this.outstandingUserOperations.length
    }, "dumping mempool");
    return this.outstandingUserOperations;
  }
  dumpProcessing() {
    this.logger.trace({
      store: "processing",
      length: this.processingUserOperations.length
    }, "dumping mempool");
    return this.processingUserOperations;
  }
  dumpSubmitted() {
    this.logger.trace({ store: "submitted", length: this.submittedUserOperations.length }, "dumping mempool");
    return this.submittedUserOperations;
  }
  clear(from) {
    if (from === "outstanding") {
      this.outstandingUserOperations = [];
      this.logger.debug({ store: from, length: this.outstandingUserOperations.length }, "clearing mempool");
    } else if (from === "processing") {
      this.processingUserOperations = [];
      this.logger.debug({ store: from, length: this.processingUserOperations.length }, "clearing mempool");
    } else if (from === "submitted") {
      this.submittedUserOperations = [];
      this.logger.debug({ store: from, length: this.submittedUserOperations.length }, "clearing mempool");
    } else {
      throw new Error("unreachable");
    }
  }
}

// entrypoint-0.6/mempool/mempool.ts
class MemoryMempool {
  monitor;
  publicClient;
  entryPointAddress;
  reputationManager;
  store;
  throttledEntityBundleCount;
  logger;
  validator;
  safeMode;
  constructor(monitor, reputationManager2, validator, publicClient, entryPointAddress, safeMode, logger3, metrics2, throttledEntityBundleCount) {
    this.reputationManager = reputationManager2;
    this.monitor = monitor;
    this.validator = validator;
    this.publicClient = publicClient;
    this.entryPointAddress = entryPointAddress;
    this.safeMode = safeMode;
    this.logger = logger3;
    this.store = new MemoryStore(logger3, metrics2);
    this.throttledEntityBundleCount = throttledEntityBundleCount ?? 4;
  }
  replaceSubmitted(userOperation, transactionInfo) {
    const op = this.store.dumpSubmitted().find((op2) => op2.userOperation.userOperationHash === userOperation.userOperationHash);
    if (op) {
      this.store.removeSubmitted(userOperation.userOperationHash);
      this.store.addSubmitted({
        userOperation,
        transactionInfo
      });
      this.monitor.setUserOperationStatus(userOperation.userOperationHash, {
        status: "submitted",
        transactionHash: transactionInfo.transactionHash
      });
    }
  }
  markSubmitted(userOpHash, transactionInfo) {
    const op = this.store.dumpProcessing().find((op2) => op2.userOperationHash === userOpHash);
    if (op) {
      this.store.removeProcessing(userOpHash);
      this.store.addSubmitted({
        userOperation: op,
        transactionInfo
      });
      this.monitor.setUserOperationStatus(userOpHash, {
        status: "submitted",
        transactionHash: transactionInfo.transactionHash
      });
    }
  }
  dumpOutstanding() {
    return this.store.dumpOutstanding();
  }
  dumpProcessing() {
    return this.store.dumpProcessing();
  }
  dumpSubmittedOps() {
    return this.store.dumpSubmitted();
  }
  removeSubmitted(userOpHash) {
    this.store.removeSubmitted(userOpHash);
  }
  removeProcessing(userOpHash) {
    this.store.removeProcessing(userOpHash);
  }
  async checkEntityMultipleRoleViolation(op) {
    if (!this.safeMode) {
      return;
    }
    const knownEntities = this.getKnownEntities();
    if (knownEntities.paymasters.has(op.sender) || knownEntities.facotries.has(op.sender)) {
      throw new RpcError2(`The sender address "${op.sender}" is used as a different entity in another UserOperation currently in mempool`, ValidationErrors.OpcodeValidation);
    }
    const paymaster = getAddressFromInitCodeOrPaymasterAndData(op.paymasterAndData);
    if (paymaster && knownEntities.sender.has(paymaster)) {
      throw new RpcError2(`A Paymaster at ${paymaster} in this UserOperation is used as a sender entity in another UserOperation currently in mempool.`, ValidationErrors.OpcodeValidation);
    }
    const factory = getAddressFromInitCodeOrPaymasterAndData(op.initCode);
    if (factory && knownEntities.sender.has(factory)) {
      throw new RpcError2(`A Factory at ${factory} in this UserOperation is used as a sender entity in another UserOperation currently in mempool.`, ValidationErrors.OpcodeValidation);
    }
  }
  getKnownEntities() {
    const allOps = [...this.store.dumpOutstanding()];
    const entities = {
      sender: new Set,
      paymasters: new Set,
      facotries: new Set
    };
    for (const mempoolOp of allOps) {
      const op = deriveUserOperation(mempoolOp.mempoolUserOperation);
      entities.sender.add(op.sender);
      const paymaster = getAddressFromInitCodeOrPaymasterAndData(op.paymasterAndData);
      if (paymaster) {
        entities.paymasters.add(paymaster);
      }
      const factory = getAddressFromInitCodeOrPaymasterAndData(op.initCode);
      if (factory) {
        entities.facotries.add(factory);
      }
    }
    return entities;
  }
  add(mempoolUserOperation, referencedContracts) {
    const op = deriveUserOperation(mempoolUserOperation);
    const outstandingOps = [...this.store.dumpOutstanding()];
    const processedOrSubmittedOps = [
      ...this.store.dumpProcessing(),
      ...this.store.dumpSubmitted().map((sop) => sop.userOperation)
    ];
    if (processedOrSubmittedOps.find((uo) => {
      const userOp = deriveUserOperation(uo.mempoolUserOperation);
      return userOp.sender === op.sender && userOp.nonce === op.nonce;
    })) {
      return false;
    }
    this.reputationManager.updateUserOperationSeenStatus(op);
    const oldUserOp = outstandingOps.find((uo) => {
      const userOp = deriveUserOperation(uo.mempoolUserOperation);
      return userOp.sender === op.sender && userOp.nonce === op.nonce;
    });
    if (oldUserOp) {
      const oldOp = deriveUserOperation(oldUserOp.mempoolUserOperation);
      const oldMaxPriorityFeePerGas = oldOp.maxPriorityFeePerGas;
      const newMaxPriorityFeePerGas = op.maxPriorityFeePerGas;
      const oldMaxFeePerGas = oldOp.maxFeePerGas;
      const newMaxFeePerGas = op.maxFeePerGas;
      const incrementMaxPriorityFeePerGas = oldMaxPriorityFeePerGas * BigInt(10) / BigInt(100);
      const incrementMaxFeePerGas = oldMaxFeePerGas * BigInt(10) / BigInt(100);
      if (newMaxPriorityFeePerGas < oldMaxPriorityFeePerGas + incrementMaxPriorityFeePerGas || newMaxFeePerGas < oldMaxFeePerGas + incrementMaxFeePerGas) {
        return false;
      }
      this.store.removeOutstanding(oldUserOp.userOperationHash);
    }
    const hash4 = getUserOperationHash(op, this.entryPointAddress, this.publicClient.chain.id);
    this.store.addOutstanding({
      mempoolUserOperation,
      userOperationHash: hash4,
      firstSubmitted: oldUserOp ? oldUserOp.firstSubmitted : Date.now(),
      lastReplaced: Date.now(),
      referencedContracts
    });
    this.monitor.setUserOperationStatus(hash4, {
      status: "not_submitted",
      transactionHash: null
    });
    return true;
  }
  async shouldSkip(opInfo, paymasterDeposit, stakedEntityCount, knownEntities, senders, storageMap) {
    const op = deriveUserOperation(opInfo.mempoolUserOperation);
    if (!this.safeMode) {
      return {
        skip: false,
        paymasterDeposit,
        stakedEntityCount,
        knownEntities,
        senders,
        storageMap
      };
    }
    const paymaster = getAddressFromInitCodeOrPaymasterAndData(op.paymasterAndData);
    const factory = getAddressFromInitCodeOrPaymasterAndData(op.initCode);
    const paymasterStatus = this.reputationManager.getStatus(paymaster);
    const factoryStatus = this.reputationManager.getStatus(factory);
    if (paymasterStatus === ReputationStatuses.BANNED || factoryStatus === ReputationStatuses.BANNED) {
      this.store.removeOutstanding(opInfo.userOperationHash);
      return {
        skip: true,
        paymasterDeposit,
        stakedEntityCount,
        knownEntities,
        senders,
        storageMap
      };
    }
    if (paymasterStatus === ReputationStatuses.THROTTLED && paymaster && stakedEntityCount[paymaster] >= this.throttledEntityBundleCount) {
      this.logger.trace({
        paymaster,
        opHash: opInfo.userOperationHash
      }, "Throttled paymaster skipped");
      return {
        skip: true,
        paymasterDeposit,
        stakedEntityCount,
        knownEntities,
        senders,
        storageMap
      };
    }
    if (factoryStatus === ReputationStatuses.THROTTLED && factory && stakedEntityCount[factory] >= this.throttledEntityBundleCount) {
      this.logger.trace({
        factory,
        opHash: opInfo.userOperationHash
      }, "Throttled factory skipped");
      return {
        skip: true,
        paymasterDeposit,
        stakedEntityCount,
        knownEntities,
        senders,
        storageMap
      };
    }
    if (senders.has(op.sender)) {
      this.logger.trace({
        sender: op.sender,
        opHash: opInfo.userOperationHash
      }, "Sender skipped because already included in bundle");
      return {
        skip: true,
        paymasterDeposit,
        stakedEntityCount,
        knownEntities,
        senders,
        storageMap
      };
    }
    let validationResult;
    try {
      validationResult = await this.validator.validateUserOperation(op, opInfo.referencedContracts);
    } catch (e) {
      this.logger.error({
        opHash: opInfo.userOperationHash,
        error: JSON.stringify(e)
      }, "2nd Validation error");
      this.store.removeOutstanding(opInfo.userOperationHash);
      return {
        skip: true,
        paymasterDeposit,
        stakedEntityCount,
        knownEntities,
        senders,
        storageMap
      };
    }
    for (const storageAddress of Object.keys(validationResult.storageMap)) {
      const address10 = getAddress(storageAddress);
      if (address10 !== op.sender && knownEntities.sender.has(address10)) {
        this.logger.trace({
          storageAddress,
          opHash: opInfo.userOperationHash
        }, "Storage address skipped");
        return {
          skip: true,
          paymasterDeposit,
          stakedEntityCount,
          knownEntities,
          senders,
          storageMap
        };
      }
    }
    if (paymaster) {
      if (paymasterDeposit[paymaster] === undefined) {
        const entryPointContract = getContract({
          abi: EntryPointAbi,
          address: this.entryPointAddress,
          publicClient: this.publicClient
        });
        paymasterDeposit[paymaster] = await entryPointContract.read.balanceOf([paymaster]);
      }
      if (paymasterDeposit[paymaster] < validationResult.returnInfo.prefund) {
        this.logger.trace({
          paymaster,
          opHash: opInfo.userOperationHash
        }, "Paymaster skipped because of insufficient balance left to sponsor all user ops in the bundle");
        return {
          skip: true,
          paymasterDeposit,
          stakedEntityCount,
          knownEntities,
          senders,
          storageMap
        };
      }
      stakedEntityCount[paymaster] = (stakedEntityCount[paymaster] ?? 0) + 1;
      paymasterDeposit[paymaster] -= validationResult.returnInfo.prefund;
    }
    if (factory) {
      stakedEntityCount[factory] = (stakedEntityCount[factory] ?? 0) + 1;
    }
    senders.add(op.sender);
    return {
      skip: false,
      paymasterDeposit,
      stakedEntityCount,
      knownEntities,
      senders,
      storageMap
    };
  }
  async process(maxGasLimit, minOps) {
    const outstandingUserOperations = this.store.dumpOutstanding().slice();
    let opsTaken = 0;
    let gasUsed = 0n;
    const result = [];
    let paymasterDeposit = {};
    let stakedEntityCount = {};
    let senders = new Set;
    let knownEntities = this.getKnownEntities();
    let storageMap = {};
    for (const opInfo of outstandingUserOperations) {
      const op = deriveUserOperation(opInfo.mempoolUserOperation);
      gasUsed += op.callGasLimit + op.verificationGasLimit * 3n + op.preVerificationGas;
      if (gasUsed > maxGasLimit && opsTaken >= (minOps || 0)) {
        break;
      }
      const skipResult = await this.shouldSkip(opInfo, paymasterDeposit, stakedEntityCount, knownEntities, senders, storageMap);
      paymasterDeposit = skipResult.paymasterDeposit;
      stakedEntityCount = skipResult.stakedEntityCount;
      knownEntities = skipResult.knownEntities;
      senders = skipResult.senders;
      storageMap = skipResult.storageMap;
      if (skipResult.skip) {
        continue;
      }
      this.reputationManager.decreaseUserOperationCount(op);
      this.store.removeOutstanding(opInfo.userOperationHash);
      this.store.addProcessing(opInfo);
      result.push(opInfo.mempoolUserOperation);
      opsTaken++;
    }
    return result;
  }
  get(opHash) {
    const outstanding = this.store.dumpOutstanding().find((op) => op.userOperationHash === opHash);
    if (outstanding) {
      return deriveUserOperation(outstanding.mempoolUserOperation);
    }
    const submitted = this.store.dumpSubmitted().find((op) => op.userOperation.userOperationHash === opHash);
    if (submitted) {
      return deriveUserOperation(submitted.userOperation.mempoolUserOperation);
    }
    return null;
  }
  clear() {
    this.store.clear("outstanding");
  }
}
// entrypoint-0.6/mempool/monitoring.ts
class Monitor {
  userOperationToStatus;
  userOperationTimeouts;
  timeout;
  constructor(timeout = 3600000) {
    this.timeout = timeout;
    this.userOperationToStatus = {};
    this.userOperationTimeouts = {};
  }
  setUserOperationStatus(userOperation, status) {
    if (this.userOperationTimeouts[userOperation]) {
      clearTimeout(this.userOperationTimeouts[userOperation]);
    }
    this.userOperationToStatus[userOperation] = status;
    this.userOperationTimeouts[userOperation] = setTimeout(() => {
      delete this.userOperationToStatus[userOperation];
      delete this.userOperationTimeouts[userOperation];
    }, this.timeout);
  }
  getUserOperationStatus(userOperation) {
    const status = this.userOperationToStatus[userOperation];
    if (status === undefined) {
      return {
        status: "not_found",
        transactionHash: null
      };
    }
    return status;
  }
}
// entrypoint-0.6/rpc/rpcHandler.ts
var import_zod_validation_error = __toESM(require_cjs5(), 1);

// entrypoint-0.6/rpc/ExecuteSimulator.ts
var ExecuteSimulatorAbi = [
  {
    inputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "gasUsed",
        type: "uint256"
      }
    ],
    name: "CallExecuteResult",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "callData",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "gas",
        type: "uint256"
      }
    ],
    name: "callExecute",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var ExecuteSimulatorDeployedBytecode = "0x60806040526004361061012e5760003560e01c806372b37bca116100ab578063b760faf91161006f578063b760faf914610452578063bb9fe6bf14610465578063c23a5cea1461047a578063d6383f941461049a578063ee219423146104ba578063fc7e286d146104da57600080fd5b806372b37bca146103bd5780638f41ec5a146103dd578063957122ab146103f25780639b249f6914610412578063a61935311461043257600080fd5b8063205c2878116100f2578063205c28781461020157806335567e1a146102215780634b1d7cf5146102415780635287ce121461026157806370a082311461037e57600080fd5b80630396cb60146101435780630bd28e3b146101565780631b2e01b8146101765780631d732756146101c15780631fad948c146101e157600080fd5b3661013e5761013c3361058f565b005b600080fd5b61013c6101513660046131c9565b6105f6565b34801561016257600080fd5b5061013c61017136600461320b565b610885565b34801561018257600080fd5b506101ae610191366004613246565b600160209081526000928352604080842090915290825290205481565b6040519081526020015b60405180910390f35b3480156101cd57600080fd5b506101ae6101dc366004613440565b6108bc565b3480156101ed57600080fd5b5061013c6101fc366004613549565b610a2f565b34801561020d57600080fd5b5061013c61021c36600461359f565b610bab565b34801561022d57600080fd5b506101ae61023c366004613246565b610d27565b34801561024d57600080fd5b5061013c61025c366004613549565b610d6d565b34801561026d57600080fd5b5061032661027c3660046135cb565b6040805160a081018252600080825260208201819052918101829052606081018290526080810191909152506001600160a01b031660009081526020818152604091829020825160a08101845281546001600160701b038082168352600160701b820460ff16151594830194909452600160781b90049092169282019290925260019091015463ffffffff81166060830152640100000000900465ffffffffffff16608082015290565b6040805182516001600160701b03908116825260208085015115159083015283830151169181019190915260608083015163ffffffff169082015260809182015165ffffffffffff169181019190915260a0016101b8565b34801561038a57600080fd5b506101ae6103993660046135cb565b6001600160a01b03166000908152602081905260409020546001600160701b031690565b3480156103c957600080fd5b5061013c6103d83660046135e8565b6111b0565b3480156103e957600080fd5b506101ae600181565b3480156103fe57600080fd5b5061013c61040d366004613643565b611289565b34801561041e57600080fd5b5061013c61042d3660046136c7565b611386565b34801561043e57600080fd5b506101ae61044d366004613721565b611441565b61013c6104603660046135cb565b61058f565b34801561047157600080fd5b5061013c611483565b34801561048657600080fd5b5061013c6104953660046135cb565b6115ac565b3480156104a657600080fd5b5061013c6104b5366004613755565b6117e4565b3480156104c657600080fd5b5061013c6104d5366004613721565b6118df565b3480156104e657600080fd5b506105496104f53660046135cb565b600060208190529081526040902080546001909101546001600160701b0380831692600160701b810460ff1692600160781b9091049091169063ffffffff811690640100000000900465ffffffffffff1685565b604080516001600160701b0396871681529415156020860152929094169183019190915263ffffffff16606082015265ffffffffffff909116608082015260a0016101b8565b6105998134611abb565b6001600160a01b03811660008181526020818152604091829020805492516001600160701b03909316835292917f2da466a7b24304f47e87fa2e1e5a81b9831ce54fec19055ce277ca2f39ba42c491015b60405180910390a25050565b33600090815260208190526040902063ffffffff821661065d5760405162461bcd60e51b815260206004820152601a60248201527f6d757374207370656369667920756e7374616b652064656c617900000000000060448201526064015b60405180910390fd5b600181015463ffffffff90811690831610156106bb5760405162461bcd60e51b815260206004820152601c60248201527f63616e6e6f7420646563726561736520756e7374616b652074696d65000000006044820152606401610654565b80546000906106db903490600160781b90046001600160701b03166137cc565b9050600081116107225760405162461bcd60e51b81526020600482015260126024820152711b9bc81cdd185ad9481cdc1958da599a595960721b6044820152606401610654565b6001600160701b0381111561076a5760405162461bcd60e51b815260206004820152600e60248201526d7374616b65206f766572666c6f7760901b6044820152606401610654565b6040805160a08101825283546001600160701b0390811682526001602080840182815286841685870190815263ffffffff808b16606088019081526000608089018181523380835296829052908a902098518954955194518916600160781b02600160781b600160e81b0319951515600160701b026effffffffffffffffffffffffffffff199097169190991617949094179290921695909517865551949092018054925165ffffffffffff166401000000000269ffffffffffffffffffff19909316949093169390931717905590517fa5ae833d0bb1dcd632d98a8b70973e8516812898e19bf27b70071ebc8dc52c0190610878908490879091825263ffffffff16602082015260400190565b60405180910390a2505050565b3360009081526001602090815260408083206001600160c01b038516845290915281208054916108b4836137df565b919050555050565b6000805a90503330146109115760405162461bcd60e51b815260206004820152601760248201527f4141393220696e7465726e616c2063616c6c206f6e6c790000000000000000006044820152606401610654565b8451604081015160608201518101611388015a101561093b5763deaddead60e01b60005260206000fd5b8751600090156109cf576000610958846000015160008c86611b57565b9050806109cd57600061096c610800611b6f565b8051909150156109c75784600001516001600160a01b03168a602001517f1c4fada7374c0a9ee8841fc38afe82932dc0f8e69012e927f061a8bae611a2018760200151846040516109be929190613848565b60405180910390a35b60019250505b505b600088608001515a8603019050610a216000838b8b8b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250889250611b9b915050565b9a9950505050505050505050565b610a37611e92565b816000816001600160401b03811115610a5257610a5261327b565b604051908082528060200260200182016040528015610a8b57816020015b610a7861313f565b815260200190600190039081610a705790505b50905060005b82811015610b04576000828281518110610aad57610aad613861565b60200260200101519050600080610ae8848a8a87818110610ad057610ad0613861565b9050602002810190610ae29190613877565b85611ee9565b91509150610af984838360006120d4565b505050600101610a91565b506040516000907fbb47ee3e183a558b1a2ff0874b079f3fc5478b7454eacf2bfc5af2ff5878f972908290a160005b83811015610b8e57610b8281888884818110610b5157610b51613861565b9050602002810190610b639190613877565b858481518110610b7557610b75613861565b6020026020010151612270565b90910190600101610b33565b50610b998482612397565b505050610ba66001600255565b505050565b33600090815260208190526040902080546001600160701b0316821115610c145760405162461bcd60e51b815260206004820152601960248201527f576974686472617720616d6f756e7420746f6f206c61726765000000000000006044820152606401610654565b8054610c2a9083906001600160701b0316613898565b81546001600160701b0319166001600160701b0391909116178155604080516001600160a01b03851681526020810184905233917fd1c19fbcd4551a5edfb66d43d2e337c04837afda3482b42bdf569a8fccdae5fb910160405180910390a26000836001600160a01b03168360405160006040518083038185875af1925050503d8060008114610cd6576040519150601f19603f3d011682016040523d82523d6000602084013e610cdb565b606091505b5050905080610d215760405162461bcd60e51b81526020600482015260126024820152716661696c656420746f20776974686472617760701b6044820152606401610654565b50505050565b6001600160a01b03821660009081526001602090815260408083206001600160c01b038516845290915290819020549082901b67ffffffffffffffff1916175b92915050565b610d75611e92565b816000805b82811015610ee95736868683818110610d9557610d95613861565b9050602002810190610da791906138ab565b9050366000610db683806138c1565b90925090506000610dcd60408501602086016135cb565b90506000196001600160a01b03821601610e295760405162461bcd60e51b815260206004820152601760248201527f4141393620696e76616c69642061676772656761746f720000000000000000006044820152606401610654565b6001600160a01b03811615610ec6576001600160a01b03811663e3563a4f8484610e56604089018961390a565b6040518563ffffffff1660e01b8152600401610e759493929190613ab5565b60006040518083038186803b158015610e8d57600080fd5b505afa925050508015610e9e575060015b610ec65760405163086a9f7560e41b81526001600160a01b0382166004820152602401610654565b610ed082876137cc565b9550505050508080610ee1906137df565b915050610d7a565b506000816001600160401b03811115610f0457610f0461327b565b604051908082528060200260200182016040528015610f3d57816020015b610f2a61313f565b815260200190600190039081610f225790505b506040519091507fbb47ee3e183a558b1a2ff0874b079f3fc5478b7454eacf2bfc5af2ff5878f97290600090a16000805b848110156110525736888883818110610f8957610f89613861565b9050602002810190610f9b91906138ab565b9050366000610faa83806138c1565b90925090506000610fc160408501602086016135cb565b90508160005b81811015611039576000898981518110610fe357610fe3613861565b602002602001015190506000806110068b898987818110610ad057610ad0613861565b91509150611016848383896120d4565b8a611020816137df565b9b50505050508080611031906137df565b915050610fc7565b505050505050808061104a906137df565b915050610f6e565b50600080915060005b8581101561116b573689898381811061107657611076613861565b905060200281019061108891906138ab565b905061109a60408201602083016135cb565b6001600160a01b03167f575ff3acadd5ab348fe1855e217e0f3678f8d767d7494c9f9fefbee2e17cca4d60405160405180910390a23660006110dc83806138c1565b90925090508060005b81811015611153576111278885858481811061110357611103613861565b90506020028101906111159190613877565b8b8b81518110610b7557610b75613861565b61113190886137cc565b96508761113d816137df565b985050808061114b906137df565b9150506110e5565b50505050508080611163906137df565b91505061105b565b506040516000907f575ff3acadd5ab348fe1855e217e0f3678f8d767d7494c9f9fefbee2e17cca4d908290a26111a18682612397565b5050505050610ba66001600255565b735ff137d4b0fdcd49dca30c7cf57e578a026d278933146111d057600080fd5b60005a9050600080866001600160a01b03168487876040516111f3929190613b32565b60006040518083038160008787f1925050503d8060008114611231576040519150601f19603f3d011682016040523d82523d6000602084013e611236565b606091505b509150915060005a6112489085613898565b90506000836112575782611268565b604051806020016040528060008152505b9050838183604051636c6238f160e01b815260040161065493929190613b42565b8315801561129f57506001600160a01b0383163b155b156112ec5760405162461bcd60e51b815260206004820152601960248201527f41413230206163636f756e74206e6f74206465706c6f796564000000000000006044820152606401610654565b601481106113645760006113036014828486613b6d565b61130c91613b97565b60601c9050803b6000036113625760405162461bcd60e51b815260206004820152601b60248201527f41413330207061796d6173746572206e6f74206465706c6f79656400000000006044820152606401610654565b505b60405162461bcd60e51b81526020600482015260006024820152604401610654565b604051632b870d1b60e11b81526000906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063570e1a36906113d79086908690600401613bcc565b6020604051808303816000875af11580156113f6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061141a9190613be0565b604051633653dc0360e11b81526001600160a01b0382166004820152909150602401610654565b600061144c82612490565b6040805160208101929092523090820152466060820152608001604051602081830303815290604052805190602001209050919050565b3360009081526020819052604081206001810154909163ffffffff90911690036114dc5760405162461bcd60e51b815260206004820152600a6024820152691b9bdd081cdd185ad95960b21b6044820152606401610654565b8054600160701b900460ff166115285760405162461bcd60e51b8152602060048201526011602482015270616c726561647920756e7374616b696e6760781b6044820152606401610654565b60018101546000906115409063ffffffff1642613bfd565b60018301805469ffffffffffff00000000191664010000000065ffffffffffff841690810291909117909155835460ff60701b1916845560405190815290915033907ffa9b3c14cc825c412c9ed81b3ba365a5b459439403f18829e572ed53a4180f0a906020016105ea565b3360009081526020819052604090208054600160781b90046001600160701b0316806116115760405162461bcd60e51b81526020600482015260146024820152734e6f207374616b6520746f20776974686472617760601b6044820152606401610654565b6001820154640100000000900465ffffffffffff166116725760405162461bcd60e51b815260206004820152601d60248201527f6d7573742063616c6c20756e6c6f636b5374616b6528292066697273740000006044820152606401610654565b60018201544264010000000090910465ffffffffffff1611156116d75760405162461bcd60e51b815260206004820152601b60248201527f5374616b65207769746864726177616c206973206e6f742064756500000000006044820152606401610654565b60018201805469ffffffffffffffffffff191690558154600160781b600160e81b0319168255604080516001600160a01b03851681526020810183905233917fb7c918e0e249f999e965cafeb6c664271b3f4317d296461500e71da39f0cbda3910160405180910390a26000836001600160a01b03168260405160006040518083038185875af1925050503d806000811461178e576040519150601f19603f3d011682016040523d82523d6000602084013e611793565b606091505b5050905080610d215760405162461bcd60e51b815260206004820152601860248201527f6661696c656420746f207769746864726177207374616b6500000000000000006044820152606401610654565b6117ec61313f565b6117f5856124a9565b60008061180460008885611ee9565b9150915060006118148383612583565b905061181f43600052565b600061182d60008a87612270565b905061183843600052565b600060606001600160a01b038a16156118ae57896001600160a01b03168989604051611865929190613b32565b6000604051808303816000865af19150503d80600081146118a2576040519150601f19603f3d011682016040523d82523d6000602084013e6118a7565b606091505b5090925090505b866080015183856020015186604001518585604051630116f59360e71b815260040161065496959493929190613c23565b6118e761313f565b6118f0826124a9565b6000806118ff60008585611ee9565b915091506000611916846000015160a0015161264f565b8451519091506000906119289061264f565b9050611947604051806040016040528060008152602001600081525090565b36600061195760408a018a61390a565b90925090506000601482101561196e576000611989565b61197c601460008486613b6d565b61198591613b97565b60601c5b90506119948161264f565b935050505060006119a58686612583565b9050600081600001519050600060016001600160a01b0316826001600160a01b031614905060006040518060c001604052808b6080015181526020018b6040015181526020018315158152602001856020015165ffffffffffff168152602001856040015165ffffffffffff168152602001611a228c6060015190565b905290506001600160a01b03831615801590611a4857506001600160a01b038316600114155b15611a9a5760006040518060400160405280856001600160a01b03168152602001611a728661264f565b81525090508187878a84604051633ebb2d3960e21b8152600401610654959493929190613cc5565b8086868960405163e0cff05f60e01b81526004016106549493929190613d45565b6001600160a01b03821660009081526020819052604081208054909190611aec9084906001600160701b03166137cc565b90506001600160701b03811115611b385760405162461bcd60e51b815260206004820152601060248201526f6465706f736974206f766572666c6f7760801b6044820152606401610654565b81546001600160701b0319166001600160701b03919091161790555050565b6000806000845160208601878987f195945050505050565b60603d82811115611b7d5750815b604051602082018101604052818152816000602083013e9392505050565b6000805a855190915060009081611bb18261269e565b60a08301519091506001600160a01b038116611bd05782519350611d77565b809350600088511115611d7757868202955060028a6002811115611bf657611bf6613d9c565b14611c6857606083015160405163a9a2340960e01b81526001600160a01b0383169163a9a2340991611c30908e908d908c90600401613db2565b600060405180830381600088803b158015611c4a57600080fd5b5087f1158015611c5e573d6000803e3d6000fd5b5050505050611d77565b606083015160405163a9a2340960e01b81526001600160a01b0383169163a9a2340991611c9d908e908d908c90600401613db2565b600060405180830381600088803b158015611cb757600080fd5b5087f193505050508015611cc9575060015b611d7757611cd5613de9565b806308c379a003611d2e5750611ce9613e05565b80611cf45750611d30565b8b81604051602001611d069190613e8e565b60408051601f1981840301815290829052631101335b60e11b82526106549291600401613848565b505b8a604051631101335b60e11b81526004016106549181526040602082018190526012908201527110504d4c081c1bdcdd13dc081c995d995c9d60721b606082015260800190565b5a85038701965081870295508589604001511015611de0578a604051631101335b60e11b815260040161065491815260406020808301829052908201527f414135312070726566756e642062656c6f772061637475616c476173436f7374606082015260800190565b6040890151869003611df28582611abb565b6000808c6002811115611e0757611e07613d9c565b1490508460a001516001600160a01b031685600001516001600160a01b03168c602001517f49628fd1471006c1482da88028e9ce4dbb080b815c9b0344d39e5a8e6ec1419f8860200151858d8f604051611e7a949392919093845291151560208401526040830152606082015260800190565b60405180910390a45050505050505095945050505050565b6002805403611ee35760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610654565b60028055565b60008060005a8451909150611efe86826126ce565b611f0786611441565b6020860152604081015160608201516080830151171760e087013517610100870135176effffffffffffffffffffffffffffff811115611f895760405162461bcd60e51b815260206004820152601860248201527f41413934206761732076616c756573206f766572666c6f7700000000000000006044820152606401610654565b600080611f95846127c7565b9050611fa38a8a8a84612814565b85516020870151919950919350611fba9190612a4c565b6120105789604051631101335b60e11b8152600401610654918152604060208201819052601a908201527f4141323520696e76616c6964206163636f756e74206e6f6e6365000000000000606082015260800190565b61201943600052565b60a08401516060906001600160a01b0316156120415761203c8b8b8b8587612a99565b975090505b60005a87039050808b60a0013510156120a6578b604051631101335b60e11b8152600401610654918152604060208201819052601e908201527f41413430206f76657220766572696669636174696f6e4761734c696d69740000606082015260800190565b60408a018390528160608b015260c08b01355a8803018a608001818152505050505050505050935093915050565b6000806120e085612cbc565b91509150816001600160a01b0316836001600160a01b0316146121465785604051631101335b60e11b81526004016106549181526040602082018190526014908201527320a0991a1039b4b3b730ba3ab9329032b93937b960611b606082015260800190565b801561219e5785604051631101335b60e11b81526004016106549181526040602082018190526017908201527f414132322065787069726564206f72206e6f7420647565000000000000000000606082015260800190565b60006121a985612cbc565b925090506001600160a01b038116156122055786604051631101335b60e11b81526004016106549181526040602082018190526014908201527320a0999a1039b4b3b730ba3ab9329032b93937b960611b606082015260800190565b81156122675786604051631101335b60e11b81526004016106549181526040602082018190526021908201527f41413332207061796d61737465722065787069726564206f72206e6f742064756060820152606560f81b608082015260a00190565b50505050505050565b6000805a90506000612283846060015190565b905030631d732756612298606088018861390a565b87856040518563ffffffff1660e01b81526004016122b99493929190613ecc565b6020604051808303816000875af19250505080156122f4575060408051601f3d908101601f191682019092526122f191810190613f7f565b60015b61238b57600060206000803e50600051632152215360e01b81016123565786604051631101335b60e11b8152600401610654918152604060208201819052600f908201526e41413935206f7574206f662067617360881b606082015260800190565b600085608001515a6123689086613898565b61237291906137cc565b9050612382886002888685611b9b565b9450505061238e565b92505b50509392505050565b6001600160a01b0382166123ed5760405162461bcd60e51b815260206004820152601860248201527f4141393020696e76616c69642062656e656669636961727900000000000000006044820152606401610654565b6000826001600160a01b03168260405160006040518083038185875af1925050503d806000811461243a576040519150601f19603f3d011682016040523d82523d6000602084013e61243f565b606091505b5050905080610ba65760405162461bcd60e51b815260206004820152601f60248201527f41413931206661696c65642073656e6420746f2062656e6566696369617279006044820152606401610654565b600061249b82612d0f565b805190602001209050919050565b3063957122ab6124bc604084018461390a565b6124c960208601866135cb565b6124d761012087018761390a565b6040518663ffffffff1660e01b81526004016124f7959493929190613f98565b60006040518083038186803b15801561250f57600080fd5b505afa925050508015612520575060015b6125805761252c613de9565b806308c379a0036125745750612540613e05565b8061254b5750612576565b80511561257057600081604051631101335b60e11b8152600401610654929190613848565b5050565b505b3d6000803e3d6000fd5b50565b60408051606081018252600080825260208201819052918101829052906125a984612de2565b905060006125b684612de2565b82519091506001600160a01b0381166125cd575080515b602080840151604080860151928501519085015191929165ffffffffffff80831690851610156125fb578193505b8065ffffffffffff168365ffffffffffff161115612617578092505b5050604080516060810182526001600160a01b03909416845265ffffffffffff92831660208501529116908201529250505092915050565b604080518082018252600080825260208083018281526001600160a01b03959095168252819052919091208054600160781b90046001600160701b031682526001015463ffffffff1690915290565b60c081015160e0820151600091908082036126ba575092915050565b6126c682488301612e53565b949350505050565b6126db60208301836135cb565b6001600160a01b0316815260208083013590820152608080830135604083015260a0830135606083015260c0808401359183019190915260e080840135918301919091526101008301359082015236600061273a61012085018561390a565b909250905080156127ba5760148110156127965760405162461bcd60e51b815260206004820152601d60248201527f4141393320696e76616c6964207061796d6173746572416e64446174610000006044820152606401610654565b6127a4601460008385613b6d565b6127ad91613b97565b60601c60a0840152610d21565b600060a084015250505050565b60a081015160009081906001600160a01b03166127e55760016127e8565b60035b60ff16905060008360800151828560600151028560400151010190508360c00151810292505050919050565b60008060005a8551805191925090612839898861283460408c018c61390a565b612e6b565b60a082015161284743600052565b60006001600160a01b03821661288f576001600160a01b0383166000908152602081905260409020546001600160701b03168881116128885780890361288b565b60005b9150505b606084015160208a0151604051633a871cdd60e01b81526001600160a01b03861692633a871cdd9290916128c9918f918790600401613fce565b60206040518083038160008887f193505050508015612905575060408051601f3d908101601f1916820190925261290291810190613f7f565b60015b61298f57612911613de9565b806308c379a0036129425750612925613e05565b806129305750612944565b8b81604051602001611d069190613ff3565b505b8a604051631101335b60e11b8152600401610654918152604060208201819052601690820152754141323320726576657274656420286f72204f4f472960501b606082015260800190565b95506001600160a01b038216612a39576001600160a01b038316600090815260208190526040902080546001600160701b0316808a1115612a1c578c604051631101335b60e11b81526004016106549181526040602082018190526017908201527f41413231206469646e2774207061792070726566756e64000000000000000000606082015260800190565b81546001600160701b031916908a90036001600160701b03161790555b5a85039650505050505094509492505050565b6001600160a01b038216600090815260016020908152604080832084821c80855292528220805484916001600160401b038316919085612a8b836137df565b909155501495945050505050565b82516060818101519091600091848111612af55760405162461bcd60e51b815260206004820152601f60248201527f4141343120746f6f206c6974746c6520766572696669636174696f6e476173006044820152606401610654565b60a08201516001600160a01b038116600090815260208190526040902080548784039291906001600160701b031689811015612b7d578c604051631101335b60e11b8152600401610654918152604060208201819052601e908201527f41413331207061796d6173746572206465706f73697420746f6f206c6f770000606082015260800190565b8981038260000160006101000a8154816001600160701b0302191690836001600160701b03160217905550826001600160a01b031663f465c77e858e8e602001518e6040518563ffffffff1660e01b8152600401612bdd93929190613fce565b60006040518083038160008887f193505050508015612c1e57506040513d6000823e601f3d908101601f19168201604052612c1b919081019061402a565b60015b612ca857612c2a613de9565b806308c379a003612c5b5750612c3e613e05565b80612c495750612c5d565b8d81604051602001611d0691906140b5565b505b8c604051631101335b60e11b8152600401610654918152604060208201819052601690820152754141333320726576657274656420286f72204f4f472960501b606082015260800190565b909e909d509b505050505050505050505050565b60008082600003612cd257506000928392509050565b6000612cdd84612de2565b9050806040015165ffffffffffff16421180612d045750806020015165ffffffffffff1642105b905194909350915050565b6060813560208301356000612d2f612d2a604087018761390a565b61312c565b90506000612d43612d2a606088018861390a565b9050608086013560a087013560c088013560e08901356101008a01356000612d72612d2a6101208e018e61390a565b604080516001600160a01b039c909c1660208d01528b81019a909a5260608b019890985250608089019590955260a088019390935260c087019190915260e08601526101008501526101208401526101408084019190915281518084039091018152610160909201905292915050565b60408051606081018252600080825260208201819052918101919091528160a081901c65ffffffffffff8116600003612e1e575065ffffffffffff5b604080516060810182526001600160a01b03909316835260d09490941c602083015265ffffffffffff16928101929092525090565b6000818310612e625781612e64565b825b9392505050565b8015610d21578251516001600160a01b0381163b15612ed65784604051631101335b60e11b8152600401610654918152604060208201819052601f908201527f414131302073656e64657220616c726561647920636f6e737472756374656400606082015260800190565b835160600151604051632b870d1b60e11b81526000916001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169163570e1a369190612f2e9088908890600401613bcc565b60206040518083038160008887f1158015612f4d573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190612f729190613be0565b90506001600160a01b038116612fd45785604051631101335b60e11b8152600401610654918152604060208201819052601b908201527f4141313320696e6974436f6465206661696c6564206f72204f4f470000000000606082015260800190565b816001600160a01b0316816001600160a01b03161461303e5785604051631101335b60e11b815260040161065491815260406020808301829052908201527f4141313420696e6974436f6465206d7573742072657475726e2073656e646572606082015260800190565b806001600160a01b03163b6000036130a15785604051631101335b60e11b815260040161065491815260406020808301829052908201527f4141313520696e6974436f6465206d757374206372656174652073656e646572606082015260800190565b60006130b06014828688613b6d565b6130b991613b97565b60601c9050826001600160a01b031686602001517fd51a9c61267aa6196961883ecf5ff2da6619c37dac0fa92122513fb32c032d2d83896000015160a0015160405161311b9291906001600160a01b0392831681529116602082015260400190565b60405180910390a350505050505050565b6000604051828085833790209392505050565b6040518060a001604052806131a460405180610100016040528060006001600160a01b031681526020016000815260200160008152602001600081526020016000815260200160006001600160a01b0316815260200160008152602001600081525090565b8152602001600080191681526020016000815260200160008152602001600081525090565b6000602082840312156131db57600080fd5b813563ffffffff81168114612e6457600080fd5b80356001600160c01b038116811461320657600080fd5b919050565b60006020828403121561321d57600080fd5b612e64826131ef565b6001600160a01b038116811461258057600080fd5b803561320681613226565b6000806040838503121561325957600080fd5b823561326481613226565b9150613272602084016131ef565b90509250929050565b634e487b7160e01b600052604160045260246000fd5b60a081018181106001600160401b03821117156132b0576132b061327b565b60405250565b61010081018181106001600160401b03821117156132b0576132b061327b565b601f8201601f191681016001600160401b03811182821017156132fb576132fb61327b565b6040525050565b60006001600160401b0382111561331b5761331b61327b565b50601f01601f191660200190565b600081830361018081121561333d57600080fd5b60405161334981613291565b8092506101008083121561335c57600080fd5b604051925061336a836132b6565b6133738561323b565b8352602085013560208401526040850135604084015260608501356060840152608085013560808401526133a960a0860161323b565b60a084015260c085013560c084015260e085013560e084015282825280850135602083015250610120840135604082015261014084013560608201526101608401356080820152505092915050565b60008083601f84011261340a57600080fd5b5081356001600160401b0381111561342157600080fd5b60208301915083602082850101111561343957600080fd5b9250929050565b6000806000806101c0858703121561345757600080fd5b84356001600160401b038082111561346e57600080fd5b818701915087601f83011261348257600080fd5b813561348d81613302565b60405161349a82826132d6565b8281528a60208487010111156134af57600080fd5b826020860160208301376000602084830101528098505050506134d58860208901613329565b94506101a08701359150808211156134ec57600080fd5b506134f9878288016133f8565b95989497509550505050565b60008083601f84011261351757600080fd5b5081356001600160401b0381111561352e57600080fd5b6020830191508360208260051b850101111561343957600080fd5b60008060006040848603121561355e57600080fd5b83356001600160401b0381111561357457600080fd5b61358086828701613505565b909450925050602084013561359481613226565b809150509250925092565b600080604083850312156135b257600080fd5b82356135bd81613226565b946020939093013593505050565b6000602082840312156135dd57600080fd5b8135612e6481613226565b600080600080606085870312156135fe57600080fd5b843561360981613226565b935060208501356001600160401b0381111561362457600080fd5b613630878288016133f8565b9598909750949560400135949350505050565b60008060008060006060868803121561365b57600080fd5b85356001600160401b038082111561367257600080fd5b61367e89838a016133f8565b90975095506020880135915061369382613226565b909350604087013590808211156136a957600080fd5b506136b6888289016133f8565b969995985093965092949392505050565b600080602083850312156136da57600080fd5b82356001600160401b038111156136f057600080fd5b6136fc858286016133f8565b90969095509350505050565b6000610160828403121561371b57600080fd5b50919050565b60006020828403121561373357600080fd5b81356001600160401b0381111561374957600080fd5b6126c684828501613708565b6000806000806060858703121561376b57600080fd5b84356001600160401b038082111561378257600080fd5b61378e88838901613708565b9550602087013591506137a082613226565b909350604086013590808211156134ec57600080fd5b634e487b7160e01b600052601160045260246000fd5b80820180821115610d6757610d676137b6565b6000600182016137f1576137f16137b6565b5060010190565b60005b838110156138135781810151838201526020016137fb565b50506000910152565b600081518084526138348160208601602086016137f8565b601f01601f19169290920160200192915050565b8281526040602082015260006126c6604083018461381c565b634e487b7160e01b600052603260045260246000fd5b6000823561015e1983360301811261388e57600080fd5b9190910192915050565b81810381811115610d6757610d676137b6565b60008235605e1983360301811261388e57600080fd5b6000808335601e198436030181126138d857600080fd5b8301803591506001600160401b038211156138f257600080fd5b6020019150600581901b360382131561343957600080fd5b6000808335601e1984360301811261392157600080fd5b8301803591506001600160401b0382111561393b57600080fd5b60200191503681900382131561343957600080fd5b6000808335601e1984360301811261396757600080fd5b83016020810192503590506001600160401b0381111561398657600080fd5b80360382131561343957600080fd5b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b60006101606139dd846139d08561323b565b6001600160a01b03169052565b602083013560208501526139f46040840184613950565b826040870152613a078387018284613995565b92505050613a186060840184613950565b8583036060870152613a2b838284613995565b925050506080830135608085015260a083013560a085015260c083013560c085015260e083013560e0850152610100808401358186015250610120613a7281850185613950565b86840383880152613a84848284613995565b9350505050610140613a9881850185613950565b86840383880152613aaa848284613995565b979650505050505050565b6040808252810184905260006060600586901b830181019083018783805b89811015613b1b57868503605f190184528235368c900361015e19018112613af9578283fd5b613b05868d83016139be565b9550506020938401939290920191600101613ad3565b505050508281036020840152613aaa818587613995565b8183823760009101908152919050565b8315158152606060208201526000613b5d606083018561381c565b9050826040830152949350505050565b60008085851115613b7d57600080fd5b83861115613b8a57600080fd5b5050820193919092039150565b6bffffffffffffffffffffffff198135818116916014851015613bc45780818660140360031b1b83161692505b505092915050565b6020815260006126c6602083018486613995565b600060208284031215613bf257600080fd5b8151612e6481613226565b65ffffffffffff818116838216019080821115613c1c57613c1c6137b6565b5092915050565b868152856020820152600065ffffffffffff8087166040840152808616606084015250831515608083015260c060a0830152613c6260c083018461381c565b98975050505050505050565b80518252602081015160208301526040810151151560408301526000606082015165ffffffffffff8082166060860152806080850151166080860152505060a082015160c060a08501526126c660c085018261381c565b6000610140808352613cd981840189613c6e565b915050613cf3602083018780518252602090810151910152565b845160608301526020948501516080830152835160a08301529284015160c082015281516001600160a01b031660e0820152908301518051610100830152909201516101209092019190915292915050565b60e081526000613d5860e0830187613c6e565b9050613d71602083018680518252602090810151910152565b8351606083015260208401516080830152825160a0830152602083015160c083015295945050505050565b634e487b7160e01b600052602160045260246000fd5b600060038510613dd257634e487b7160e01b600052602160045260246000fd5b84825260606020830152613b5d606083018561381c565b600060033d1115613e025760046000803e5060005160e01c5b90565b600060443d1015613e135790565b6040516003193d81016004833e81513d6001600160401b038160248401118184111715613e4257505050505090565b8285019150815181811115613e5a5750505050505090565b843d8701016020828501011115613e745750505050505090565b613e83602082860101876132d6565b509095945050505050565b75020a09a98103837b9ba27b8103932bb32b93a32b21d160551b815260008251613ebf8160168501602087016137f8565b9190910160160192915050565b60006101c0808352613ee18184018789613995565b9050845160018060a01b03808251166020860152602082015160408601526040820151606086015260608201516080860152608082015160a08601528060a08301511660c08601525060c081015160e085015260e08101516101008501525060208501516101208401526040850151610140840152606085015161016084015260808501516101808401528281036101a0840152613aaa818561381c565b600060208284031215613f9157600080fd5b5051919050565b606081526000613fac606083018789613995565b6001600160a01b03861660208401528281036040840152613c62818587613995565b606081526000613fe160608301866139be565b60208301949094525060400152919050565b6e020a09919903932bb32b93a32b21d1608d1b81526000825161401d81600f8501602087016137f8565b91909101600f0192915050565b6000806040838503121561403d57600080fd5b82516001600160401b0381111561405357600080fd5b8301601f8101851361406457600080fd5b805161406f81613302565b60405161407c82826132d6565b82815287602084860101111561409157600080fd5b6140a28360208301602087016137f8565b6020969096015195979596505050505050565b6e020a09999903932bb32b93a32b21d1608d1b81526000825161401d81600f8501602087016137f856fea26469706673582212201892e38d1eac5b99b119bf1333f8e39f72ad5274c5da6bb916f97bef4e7e0afc64736f6c63430008140033";

// entrypoint-0.6/rpc/gasEstimation.ts
async function simulateHandleOp(userOperation, entryPoint, publicClient, replacedEntryPoint, targetAddress, targetCallData, stateOverride) {
  const finalParam = replacedEntryPoint ? {
    ...stateOverride,
    [userOperation.sender]: {
      balance: toHex2(100000000000000000000000n),
      ...stateOverride ? deepHexlify(stateOverride?.[userOperation.sender]) : []
    },
    [entryPoint]: {
      code: ExecuteSimulatorDeployedBytecode
    }
  } : {
    ...stateOverride,
    [userOperation.sender]: {
      balance: toHex2(100000000000000000000000n),
      ...stateOverride ? deepHexlify(stateOverride?.[userOperation.sender]) : []
    }
  };
  try {
    await publicClient.request({
      method: "eth_call",
      params: [
        {
          to: entryPoint,
          data: encodeFunctionData({
            abi: EntryPointAbi,
            functionName: "simulateHandleOp",
            args: [userOperation, targetAddress, targetCallData]
          })
        },
        "latest",
        finalParam
      ]
    });
  } catch (e) {
    const err = e;
    const causeParseResult = z.object({
      code: z.literal(3),
      message: z.string().regex(/execution reverted.*/),
      data: hexDataSchema
    }).safeParse(err.cause);
    if (!causeParseResult.success) {
      throw new Error(JSON.stringify(err.cause));
    }
    const cause = causeParseResult.data;
    const decodedError = decodeErrorResult({
      abi: [...EntryPointAbi, ...EntryPointSimulationsAbi],
      data: cause.data
    });
    if (decodedError && decodedError.errorName === "FailedOp" && decodedError.args) {
      return { result: "failed", data: decodedError.args[1] };
    }
    if (decodedError && decodedError.errorName === "Error" && decodedError.args) {
      return { result: "failed", data: decodedError.args[0] };
    }
    if (decodedError.errorName === "ExecutionResult") {
      const parsedExecutionResult = executionResultSchema.parse(decodedError.args);
      return { result: "execution", data: parsedExecutionResult };
    }
  }
  throw new Error("Unexpected error");
}
var tooLow = function(error) {
  return error === "AA40 over verificationGasLimit" || error === "AA41 too little verificationGas" || error === "AA51 prefund below actualGasCost" || error === "AA13 initCode failed or OOG" || error === "AA21 didn't pay prefund" || error === "AA23 reverted (or OOG)" || error === "AA33 reverted (or OOG)" || error === "return data out of bounds" || error === "validation OOG";
};
async function estimateVerificationGasLimit(userOperation, entryPoint, publicClient, logger3, metrics2, stateOverrides) {
  userOperation.callGasLimit = 0n;
  let lower = 0n;
  let upper = 10000000n;
  let final = null;
  const cutoff = 20000n;
  userOperation.verificationGasLimit = upper;
  userOperation.callGasLimit = 0n;
  let simulationCounter = 1;
  const initial = await simulateHandleOp(userOperation, entryPoint, publicClient, false, zeroAddress, "0x", stateOverrides);
  if (initial.result === "execution") {
    upper = 6n * (initial.data.preOpGas - userOperation.preVerificationGas);
  } else {
    throw new RpcError2(`UserOperation reverted during simulation with reason: ${initial.data}`, ValidationErrors.SimulateValidation);
  }
  while (upper - lower > cutoff) {
    const mid = (upper + lower) / 2n;
    userOperation.verificationGasLimit = mid;
    userOperation.callGasLimit = 0n;
    const error = await simulateHandleOp(userOperation, entryPoint, publicClient, false, zeroAddress, "0x", stateOverrides);
    simulationCounter++;
    if (error.result === "execution") {
      upper = mid;
      final = mid;
      logger3.debug(`Verification gas limit: ${mid}`);
    } else if (tooLow(error.data)) {
      logger3.debug(`Verification gas limit: ${mid}, error: ${error.data}`);
      lower = mid;
    } else {
      logger3.debug(`Verification gas limit: ${mid}, error: ${error.data}`);
      throw new Error("Unexpected error");
    }
  }
  if (final === null) {
    throw new RpcError2("Failed to estimate verification gas limit");
  }
  if (userOperation.paymasterAndData === "0x") {
    final = final + 30000n;
  }
  logger3.info(`Verification gas limit: ${final}`);
  metrics2.verificationGasLimitEstimationCount.observe(simulationCounter);
  return final;
}
var getCallExecuteResult = function(data3) {
  const callExecuteResult = decodeErrorResult({
    abi: ExecuteSimulatorAbi,
    data: data3.targetResult
  });
  const success = callExecuteResult.args[0];
  const revertData = callExecuteResult.args[1];
  const gasUsed = callExecuteResult.args[2];
  return {
    success,
    revertData,
    gasUsed
  };
};
async function estimateCallGasLimit(userOperation, entryPoint, publicClient, logger3, metrics2, stateOverrides) {
  const targetCallData = encodeFunctionData({
    abi: ExecuteSimulatorAbi,
    functionName: "callExecute",
    args: [userOperation.sender, userOperation.callData, 2000000n]
  });
  userOperation.callGasLimit = 0n;
  const error = await simulateHandleOp(userOperation, entryPoint, publicClient, true, entryPoint, targetCallData, stateOverrides);
  if (error.result === "failed") {
    throw new RpcError2(`UserOperation reverted during simulation with reason: ${error.data}`, ExecutionErrors.UserOperationReverted);
  }
  const result = getCallExecuteResult(error.data);
  let lower = 0n;
  let upper;
  let final = null;
  const cutoff = 10000n;
  if (result.success) {
    upper = 6n * result.gasUsed;
    final = 6n * result.gasUsed;
  } else {
    try {
      const reason = decodeErrorResult({
        abi: EntryPointSimulationsAbi,
        data: result.revertData
      });
      throw new RpcError2(`UserOperation reverted during execution phase with reason: ${reason.args[0]}`, ExecutionErrors.UserOperationReverted);
    } catch (e) {
      if (e instanceof RpcError2)
        throw e;
      throw new RpcError2("UserOperation reverted during execution phase", ExecutionErrors.UserOperationReverted, result.revertData);
    }
  }
  while (upper - lower > cutoff) {
    const mid = (upper + lower) / 2n;
    userOperation.callGasLimit = 0n;
    const targetCallData2 = encodeFunctionData({
      abi: ExecuteSimulatorAbi,
      functionName: "callExecute",
      args: [userOperation.sender, userOperation.callData, mid]
    });
    const error2 = await simulateHandleOp(userOperation, entryPoint, publicClient, true, entryPoint, targetCallData2, stateOverrides);
    if (error2.result !== "execution") {
      throw new Error("Unexpected error");
    }
    const result2 = getCallExecuteResult(error2.data);
    if (result2.success) {
      upper = mid;
      final = mid;
      logger3.debug(`Call gas limit: ${mid}`);
    } else {
      lower = mid;
      logger3.debug(`Call gas limit: ${mid}, error: ${result2.revertData}`);
    }
  }
  if (final === null) {
    throw new RpcError2("Failed to estimate call gas limit");
  }
  logger3.info(`Call gas limit estimate: ${final}`);
  return final;
}

// entrypoint-0.6/rpc/rpcHandler.ts
class RpcHandler {
  entryPoint;
  publicClient;
  validator;
  mempool;
  executor;
  monitor;
  nonceQueuer;
  usingTenderly;
  minimumGasPricePercent;
  apiVersion;
  noEthCallOverrideSupport;
  rpcMaxBlockRange;
  logger;
  metrics;
  chainId;
  environment;
  executorManager;
  reputationManager;
  compressionHandler;
  noEip1559Support;
  dangerousSkipUserOperationValidation;
  gasPriceManager;
  constructor(entryPoint, publicClient, validator, mempool6, executor, monitor, nonceQueuer, executorManager, reputationManager3, usingTenderly, minimumGasPricePercent, apiVersion, noEthCallOverrideSupport, rpcMaxBlockRange, logger3, metrics2, environment, compressionHandler2, noEip1559Support, gasPriceManager2, dangerousSkipUserOperationValidation = false) {
    this.entryPoint = entryPoint;
    this.publicClient = publicClient;
    this.validator = validator;
    this.mempool = mempool6;
    this.executor = executor;
    this.monitor = monitor;
    this.nonceQueuer = nonceQueuer;
    this.usingTenderly = usingTenderly;
    this.minimumGasPricePercent = minimumGasPricePercent;
    this.apiVersion = apiVersion;
    this.noEthCallOverrideSupport = noEthCallOverrideSupport;
    this.rpcMaxBlockRange = rpcMaxBlockRange;
    this.logger = logger3;
    this.metrics = metrics2;
    this.environment = environment;
    this.chainId = publicClient.chain.id;
    this.executorManager = executorManager;
    this.reputationManager = reputationManager3;
    this.compressionHandler = compressionHandler2;
    this.noEip1559Support = noEip1559Support;
    this.dangerousSkipUserOperationValidation = dangerousSkipUserOperationValidation;
    this.gasPriceManager = gasPriceManager2;
  }
  async handleMethod(request5) {
    const method = request5.method;
    switch (method) {
      case "eth_chainId":
        return {
          method,
          result: this.eth_chainId(...request5.params)
        };
      case "eth_supportedEntryPoints":
        return {
          method,
          result: this.eth_supportedEntryPoints(...request5.params)
        };
      case "eth_estimateUserOperationGas":
        return {
          method,
          result: await this.eth_estimateUserOperationGas(request5.params[0], request5.params[1], request5.params[2])
        };
      case "eth_sendUserOperation":
        return {
          method,
          result: await this.eth_sendUserOperation(...request5.params)
        };
      case "eth_getUserOperationByHash":
        return {
          method,
          result: await this.eth_getUserOperationByHash(...request5.params)
        };
      case "eth_getUserOperationReceipt":
        return {
          method,
          result: await this.eth_getUserOperationReceipt(...request5.params)
        };
      case "debug_bundler_clearMempool":
        return {
          method,
          result: this.debug_bundler_clearMempool(...request5.params)
        };
      case "debug_bundler_clearState":
        return {
          method,
          result: this.debug_bundler_clearState(...request5.params)
        };
      case "debug_bundler_dumpMempool":
        return {
          method,
          result: await this.debug_bundler_dumpMempool(...request5.params)
        };
      case "debug_bundler_sendBundleNow":
        return {
          method,
          result: await this.debug_bundler_sendBundleNow(...request5.params)
        };
      case "debug_bundler_setBundlingMode":
        return {
          method,
          result: this.debug_bundler_setBundlingMode(...request5.params)
        };
      case "debug_bundler_setReputation":
        return {
          method,
          result: this.debug_bundler_setReputation(request5.params)
        };
      case "debug_bundler_dumpReputation":
        return {
          method,
          result: this.debug_bundler_dumpReputation(...request5.params)
        };
      case "debug_bundler_getStakeStatus":
        return {
          method,
          result: await this.debug_bundler_getStakeStatus(...request5.params)
        };
      case "pimlico_getUserOperationStatus":
        return {
          method,
          result: this.pimlico_getUserOperationStatus(...request5.params)
        };
      case "pimlico_getUserOperationGasPrice":
        return {
          method,
          result: await this.pimlico_getUserOperationGasPrice(...request5.params)
        };
      case "pimlico_sendCompressedUserOperation":
        return {
          method,
          result: await this.pimlico_sendCompressedUserOperation(...request5.params)
        };
    }
  }
  eth_chainId() {
    return BigInt(this.chainId);
  }
  eth_supportedEntryPoints() {
    return [this.entryPoint];
  }
  async eth_estimateUserOperationGas(userOperation, entryPoint, stateOverrides) {
    if (this.entryPoint !== entryPoint) {
      throw new Error(`EntryPoint ${entryPoint} not supported, supported EntryPoints: ${this.entryPoint}`);
    }
    if (userOperation.maxFeePerGas === 0n) {
      throw new RpcError2("user operation max fee per gas must be larger than 0 during gas estimation");
    }
    const preVerificationGas = await calcPreVerificationGas(this.publicClient, userOperation, entryPoint, this.chainId);
    let verificationGasLimit;
    let callGasLimit;
    if (this.noEthCallOverrideSupport) {
      userOperation.preVerificationGas = 1000000n;
      userOperation.verificationGasLimit = 10000000n;
      userOperation.callGasLimit = 10000000n;
      if (this.chainId === base29.id) {
        userOperation.verificationGasLimit = 5000000n;
      }
      if (this.chainId === celoAlfajores.id || this.chainId === celo.id) {
        userOperation.verificationGasLimit = 1000000n;
        userOperation.callGasLimit = 1000000n;
      }
      userOperation.maxPriorityFeePerGas = userOperation.maxFeePerGas;
      const executionResult = await this.validator.getExecutionResult(userOperation, stateOverrides);
      [verificationGasLimit, callGasLimit] = await calcVerificationGasAndCallGasLimit(this.publicClient, userOperation, executionResult, this.chainId);
      if (this.chainId === base29.id || this.chainId === baseSepolia.id) {
        callGasLimit += 10000n;
      }
      if (this.chainId === base29.id || this.chainId === optimism.id) {
        callGasLimit = maxBigInt2(callGasLimit, 120000n);
      }
      if (userOperation.callData === "0x") {
        callGasLimit = 0n;
      }
    } else {
      userOperation.maxFeePerGas = 0n;
      userOperation.maxPriorityFeePerGas = 0n;
      const time = Date.now();
      verificationGasLimit = await estimateVerificationGasLimit(userOperation, entryPoint, this.publicClient, this.logger, this.metrics, stateOverrides);
      userOperation.preVerificationGas = preVerificationGas;
      userOperation.verificationGasLimit = verificationGasLimit;
      this.metrics.verificationGasLimitEstimationTime.observe((Date.now() - time) / 1000);
      callGasLimit = await estimateCallGasLimit(userOperation, entryPoint, this.publicClient, this.logger, this.metrics, stateOverrides);
    }
    if (this.apiVersion === "v2") {
      return {
        preVerificationGas,
        verificationGasLimit,
        callGasLimit
      };
    }
    return {
      preVerificationGas,
      verificationGas: verificationGasLimit,
      verificationGasLimit,
      callGasLimit
    };
  }
  async eth_sendUserOperation(userOperation, entryPoint) {
    let status = "rejected";
    try {
      status = await this.addToMempoolIfValid(userOperation, entryPoint);
      const hash4 = getUserOperationHash(userOperation, entryPoint, this.chainId);
      return hash4;
    } catch (error) {
      status = "rejected";
      throw error;
    } finally {
      this.metrics.userOperationsReceived.labels({
        status,
        type: "regular"
      }).inc();
    }
  }
  async eth_getUserOperationByHash(userOperationHash) {
    const userOperationEventAbiItem = getAbiItem({
      abi: EntryPointAbi,
      name: "UserOperationEvent"
    });
    let fromBlock = undefined;
    let toBlock = undefined;
    if (this.rpcMaxBlockRange !== undefined) {
      const latestBlock = await this.publicClient.getBlockNumber();
      fromBlock = latestBlock - BigInt(this.rpcMaxBlockRange);
      if (fromBlock < 0n) {
        fromBlock = 0n;
      }
      toBlock = "latest";
    }
    const filterResult = await this.publicClient.getLogs({
      address: this.entryPoint,
      event: userOperationEventAbiItem,
      fromBlock,
      toBlock,
      args: {
        userOpHash: userOperationHash
      }
    });
    if (filterResult.length === 0) {
      return null;
    }
    const userOperationEvent = filterResult[0];
    const txHash = userOperationEvent.transactionHash;
    if (txHash === null) {
      return null;
    }
    const getTransaction5 = async (txHash2) => {
      try {
        return await this.publicClient.getTransaction({ hash: txHash2 });
      } catch (e) {
        if (e instanceof TransactionNotFoundError) {
          return getTransaction5(txHash2);
        }
        throw e;
      }
    };
    const tx = await getTransaction5(txHash);
    let op = undefined;
    try {
      const decoded = decodeFunctionData({
        abi: EntryPointAbi,
        data: tx.input
      });
      if (decoded.functionName !== "handleOps") {
        return null;
      }
      const ops = decoded.args[0];
      op = ops.find((op2) => op2.sender === userOperationEvent.args.sender && op2.nonce === userOperationEvent.args.nonce);
    } catch {
      return null;
    }
    if (op === undefined) {
      return null;
    }
    const result = {
      userOperation: op,
      entryPoint: this.entryPoint,
      transactionHash: txHash,
      blockHash: tx.blockHash ?? "0x",
      blockNumber: BigInt(tx.blockNumber ?? 0n)
    };
    return result;
  }
  async eth_getUserOperationReceipt(userOperationHash) {
    const userOperationEventAbiItem = getAbiItem({
      abi: EntryPointAbi,
      name: "UserOperationEvent"
    });
    let fromBlock = undefined;
    let toBlock = undefined;
    if (this.rpcMaxBlockRange !== undefined) {
      const latestBlock = await this.publicClient.getBlockNumber();
      fromBlock = latestBlock - BigInt(this.rpcMaxBlockRange);
      if (fromBlock < 0n) {
        fromBlock = 0n;
      }
      toBlock = "latest";
    }
    const filterResult = await this.publicClient.getLogs({
      address: this.entryPoint,
      event: userOperationEventAbiItem,
      fromBlock,
      toBlock,
      args: {
        userOpHash: userOperationHash
      }
    });
    if (filterResult.length === 0) {
      return null;
    }
    const userOperationEvent = filterResult[0];
    if (userOperationEvent.args.actualGasCost === undefined || userOperationEvent.args.sender === undefined || userOperationEvent.args.nonce === undefined || userOperationEvent.args.userOpHash === undefined || userOperationEvent.args.success === undefined || userOperationEvent.args.paymaster === undefined || userOperationEvent.args.actualGasUsed === undefined) {
      throw new Error("userOperationEvent has undefined members");
    }
    const txHash = userOperationEvent.transactionHash;
    if (txHash === null) {
      return null;
    }
    const getTransactionReceipt4 = async (txHash2) => {
      while (true) {
        try {
          return await this.publicClient.getTransactionReceipt({
            hash: txHash2
          });
        } catch (e) {
          if (e instanceof TransactionReceiptNotFoundError) {
            continue;
          }
          throw e;
        }
      }
    };
    const receipt = await getTransactionReceipt4(txHash);
    const logs = receipt.logs;
    if (logs.some((log7) => log7.blockHash === null || log7.blockNumber === null || log7.transactionIndex === null || log7.transactionHash === null || log7.logIndex === null || log7.topics.length === 0)) {
      return null;
    }
    let startIndex = -1;
    let endIndex = -1;
    logs.forEach((log7, index2) => {
      if (log7?.topics[0] === userOperationEvent.topics[0]) {
        if (log7.topics[1] === userOperationEvent.topics[1]) {
          endIndex = index2;
        } else if (endIndex === -1) {
          startIndex = index2;
        }
      }
    });
    if (endIndex === -1) {
      throw new Error("fatal: no UserOperationEvent in logs");
    }
    const filteredLogs = logs.slice(startIndex + 1, endIndex);
    const logsParsing = z.array(logSchema).safeParse(filteredLogs);
    if (!logsParsing.success) {
      const err = import_zod_validation_error.fromZodError(logsParsing.error);
      throw err;
    }
    const receiptParsing = receiptSchema.safeParse({
      ...receipt,
      status: receipt.status === "success" ? 1 : 0
    });
    if (!receiptParsing.success) {
      const err = import_zod_validation_error.fromZodError(receiptParsing.error);
      throw err;
    }
    const userOperationReceipt = {
      userOpHash: userOperationHash,
      sender: userOperationEvent.args.sender,
      nonce: userOperationEvent.args.nonce,
      actualGasUsed: userOperationEvent.args.actualGasUsed,
      actualGasCost: userOperationEvent.args.actualGasCost,
      success: userOperationEvent.args.success,
      logs: logsParsing.data,
      receipt: receiptParsing.data
    };
    return userOperationReceipt;
  }
  debug_bundler_clearState() {
    if (this.environment !== "development") {
      throw new RpcError2("debug_bundler_clearState is only available in development environment");
    }
    this.mempool.clear();
    this.reputationManager.clear();
    return "ok";
  }
  debug_bundler_clearMempool() {
    if (this.environment !== "development") {
      throw new RpcError2("debug_bundler_clearMempool is only available in development environment");
    }
    this.mempool.clear();
    this.reputationManager.clearEntityCount();
    return "ok";
  }
  async debug_bundler_dumpMempool(entryPoint) {
    if (this.environment !== "development") {
      throw new RpcError2("debug_bundler_dumpMempool is only available in development environment");
    }
    if (this.entryPoint !== entryPoint) {
      throw new RpcError2(`EntryPoint ${entryPoint} not supported, supported EntryPoints: ${this.entryPoint}`);
    }
    return this.mempool.dumpOutstanding().map((userOpInfo) => deriveUserOperation(userOpInfo.mempoolUserOperation));
  }
  debug_bundler_sendBundleNow() {
    if (this.environment !== "development") {
      throw new RpcError2("debug_bundler_sendBundleNow is only available in development environment");
    }
    return this.executorManager.bundleNow();
  }
  debug_bundler_setBundlingMode(bundlingMode) {
    if (this.environment !== "development") {
      throw new RpcError2("debug_bundler_setBundlingMode is only available in development environment");
    }
    this.executorManager.setBundlingMode(bundlingMode);
    return "ok";
  }
  debug_bundler_dumpReputation(entryPoint) {
    if (this.environment !== "development") {
      throw new RpcError2("debug_bundler_setRe is only available in development environment");
    }
    if (this.entryPoint !== entryPoint) {
      throw new RpcError2(`EntryPoint ${entryPoint} not supported, supported EntryPoints: ${this.entryPoint}`);
    }
    return this.reputationManager.dumpReputations();
  }
  async debug_bundler_getStakeStatus(address10, entryPoint) {
    if (this.environment !== "development") {
      throw new RpcError2("debug_bundler_getStakeStatus is only available in development environment");
    }
    if (this.entryPoint !== entryPoint) {
      throw new RpcError2(`EntryPoint ${entryPoint} not supported, supported EntryPoints: ${this.entryPoint}`);
    }
    return bundlerGetStakeStatusResponseSchema.parse({
      method: "debug_bundler_getStakeStatus",
      result: await this.reputationManager.getStakeStatus(address10)
    }).result;
  }
  debug_bundler_setReputation(args) {
    if (this.environment !== "development") {
      throw new RpcError2("debug_bundler_setReputation is only available in development environment");
    }
    this.reputationManager.setReputation(args[0]);
    return "ok";
  }
  pimlico_getUserOperationStatus(userOperationHash) {
    return this.monitor.getUserOperationStatus(userOperationHash);
  }
  async pimlico_getUserOperationGasPrice() {
    const gasPrice7 = await this.gasPriceManager.getGasPrice();
    return {
      slow: {
        maxFeePerGas: gasPrice7.maxFeePerGas * 105n / 100n,
        maxPriorityFeePerGas: gasPrice7.maxPriorityFeePerGas * 105n / 100n
      },
      standard: {
        maxFeePerGas: gasPrice7.maxFeePerGas * 110n / 100n,
        maxPriorityFeePerGas: gasPrice7.maxPriorityFeePerGas * 110n / 100n
      },
      fast: {
        maxFeePerGas: gasPrice7.maxFeePerGas * 115n / 100n,
        maxPriorityFeePerGas: gasPrice7.maxPriorityFeePerGas * 115n / 100n
      }
    };
  }
  async addToMempoolIfValid(op, entryPoint) {
    const userOperation = deriveUserOperation(op);
    if (this.entryPoint !== entryPoint) {
      throw new RpcError2(`EntryPoint ${entryPoint} not supported, supported EntryPoints: ${this.entryPoint}`);
    }
    if (this.chainId === celoAlfajores.id || this.chainId === celo.id) {
      if (userOperation.maxFeePerGas !== userOperation.maxPriorityFeePerGas) {
        throw new RpcError2("maxPriorityFeePerGas must equal maxFeePerGas on Celo chains");
      }
    }
    if (this.minimumGasPricePercent !== 0) {
      const gasPrice7 = await this.gasPriceManager.getGasPrice();
      const minMaxFeePerGas = gasPrice7.maxFeePerGas * BigInt(this.minimumGasPricePercent) / 100n;
      const minMaxPriorityFeePerGas = gasPrice7.maxPriorityFeePerGas * BigInt(this.minimumGasPricePercent) / 100n;
      if (userOperation.maxFeePerGas < minMaxFeePerGas) {
        throw new RpcError2(`maxFeePerGas must be at least ${minMaxFeePerGas} (current maxFeePerGas: ${userOperation.maxFeePerGas}) - use pimlico_getUserOperationGasPrice to get the current gas price`);
      }
      if (userOperation.maxPriorityFeePerGas < minMaxPriorityFeePerGas) {
        throw new RpcError2(`maxPriorityFeePerGas must be at least ${minMaxPriorityFeePerGas} (current maxPriorityFeePerGas: ${userOperation.maxPriorityFeePerGas}) - use pimlico_getUserOperationGasPrice to get the current gas price`);
      }
    }
    if (userOperation.verificationGasLimit < 10000n) {
      throw new RpcError2("verificationGasLimit must be at least 10000");
    }
    this.logger.trace({ userOperation, entryPoint }, "beginning validation");
    if (userOperation.preVerificationGas === 0n || userOperation.verificationGasLimit === 0n) {
      throw new RpcError2("user operation gas limits must be larger than 0");
    }
    const entryPointContract = getContract({
      address: this.entryPoint,
      abi: EntryPointAbi,
      publicClient: this.publicClient
    });
    const [nonceKey, userOperationNonceValue] = getNonceKeyAndValue(userOperation.nonce);
    const getNonceResult = await entryPointContract.read.getNonce([userOperation.sender, nonceKey], {
      blockTag: "latest"
    });
    const [_, currentNonceValue] = getNonceKeyAndValue(getNonceResult);
    if (userOperationNonceValue < currentNonceValue) {
      throw new RpcError2("UserOperation reverted during simulation with reason: AA25 invalid account nonce", ValidationErrors.InvalidFields);
    }
    if (userOperationNonceValue > currentNonceValue + 10n) {
      throw new RpcError2("UserOperation reverted during simulation with reason: AA25 invalid account nonce", ValidationErrors.InvalidFields);
    }
    if (userOperationNonceValue === currentNonceValue) {
      if (this.dangerousSkipUserOperationValidation) {
        const success = this.mempool.add(userOperation);
        if (!success) {
          throw new RpcError2("UserOperation reverted during simulation with reason: AA25 invalid account nonce", ValidationErrors.InvalidFields);
        }
      } else {
        await this.validator.validatePreVerificationGas(userOperation);
        const validationResult = await this.validator.validateUserOperation(userOperation);
        await this.reputationManager.checkReputation(userOperation, validationResult);
        await this.mempool.checkEntityMultipleRoleViolation(userOperation);
        const success = this.mempool.add(op, validationResult.referencedContracts);
        if (!success) {
          throw new RpcError2("UserOperation reverted during simulation with reason: AA25 invalid account nonce", ValidationErrors.InvalidFields);
        }
        return "added";
      }
    }
    this.nonceQueuer.add(userOperation);
    return "queued";
  }
  async pimlico_sendCompressedUserOperation(compressedCalldata, inflatorAddress, entryPoint) {
    let status = "rejected";
    try {
      const { inflatedOp, inflatorId } = await this.validateAndInflateCompressedUserOperation(inflatorAddress, compressedCalldata);
      const compressedUserOp = {
        compressedCalldata,
        inflatedOp,
        inflatorAddress,
        inflatorId
      };
      status = await this.addToMempoolIfValid(compressedUserOp, entryPoint);
      const hash4 = getUserOperationHash(inflatedOp, entryPoint, this.chainId);
      return hash4;
    } catch (error) {
      status = "rejected";
      throw error;
    } finally {
      this.metrics.userOperationsReceived.labels({
        status,
        type: "compressed"
      }).inc();
    }
  }
  async validateAndInflateCompressedUserOperation(inflatorAddress, compressedCalldata) {
    if (this.compressionHandler === null) {
      throw new RpcError2("Endpoint not supported");
    }
    const inflatorId = await this.compressionHandler.getInflatorRegisteredId(inflatorAddress, this.publicClient);
    if (inflatorId === 0) {
      throw new RpcError2(`Inflator ${inflatorAddress} is not registered`, ValidationErrors.InvalidFields);
    }
    const inflatorContract = getContract({
      address: inflatorAddress,
      abi: IOpInflatorAbi,
      publicClient: this.publicClient
    });
    let inflatedOp;
    try {
      inflatedOp = await inflatorContract.read.inflate([
        compressedCalldata
      ]);
    } catch (e) {
      throw new RpcError2(`Inflator ${inflatorAddress} failed to inflate calldata ${compressedCalldata}, due to ${e}`, ValidationErrors.InvalidFields);
    }
    const perOpInflatorId = this.compressionHandler.perOpInflatorId;
    if (perOpInflatorId === 0) {
      throw new RpcError2(`PerUserOp ${this.compressionHandler.perOpInflatorAddress} has not been registered with BundelBulker`, ValidationErrors.InvalidFields);
    }
    return { inflatedOp, inflatorId };
  }
}
// entrypoint-0.6/rpc/server.ts
var sentry3 = __toESM(require_cjs4(), 1);
var import_fastify = __toESM(require_fastify(), 1);
var import_zod_validation_error2 = __toESM(require_cjs5(), 1);
var originalJsonStringify = JSON.stringify;
JSON.stringify = (value, replacer, space) => {
  const bigintReplacer = (_key, value2) => {
    if (typeof value2 === "bigint") {
      return toHex2(value2);
    }
    return value2;
  };
  const wrapperReplacer = (key, value2) => {
    if (typeof replacer === "function") {
      value2 = replacer(key, value2);
    } else if (Array.isArray(replacer)) {
      if (!replacer.includes(key)) {
        return;
      }
    }
    return bigintReplacer(key, value2);
  };
  return originalJsonStringify(value, wrapperReplacer, space);
};

class Server {
  fastify;
  rpcEndpoint;
  port;
  registry;
  metrics;
  constructor(rpcEndpoint, port, requestTimeout, logger3, registry, metrics2) {
    this.fastify = import_fastify.default({
      logger: logger3,
      requestTimeout,
      disableRequestLogging: true
    });
    this.fastify.register(require_fastify_cors(), {
      origin: "*",
      methods: ["POST", "GET", "OPTIONS"]
    });
    this.fastify.decorateRequest("rpcMethod", null);
    this.fastify.decorateReply("rpcStatus", null);
    this.fastify.addHook("onResponse", (request5, reply) => {
      const ignoredRoutes = ["/health", "/metrics"];
      if (ignoredRoutes.includes(request5.routeOptions.url)) {
        return;
      }
      const labels = {
        route: request5.routeOptions.url,
        code: reply.statusCode,
        method: request5.method,
        rpc_method: request5.rpcMethod,
        rpc_status: reply.rpcStatus
      };
      this.metrics.httpRequests.labels(labels).inc();
      const durationMs = reply.getResponseTime();
      const durationSeconds = durationMs / 1000;
      this.metrics.httpRequestsDuration.labels(labels).observe(durationSeconds);
    });
    this.fastify.post("/rpc", this.rpc.bind(this));
    this.fastify.post("/", this.rpc.bind(this));
    this.fastify.get("/health", this.healthCheck.bind(this));
    this.fastify.get("/metrics", this.serveMetrics.bind(this));
    this.rpcEndpoint = rpcEndpoint;
    this.port = port;
    this.registry = registry;
    this.metrics = metrics2;
  }
  start() {
    this.fastify.listen({ port: this.port, host: "0.0.0.0" });
  }
  async stop() {
    await this.fastify.close();
  }
  async healthCheck(_request, reply) {
    await reply.status(200).send("OK");
  }
  async rpc(request5, reply) {
    reply.rpcStatus = "failed";
    let requestId = null;
    try {
      const contentTypeHeader = request5.headers["content-type"];
      if (contentTypeHeader !== "application/json") {
        throw new RpcError2("invalid content-type, content-type must be application/json", ValidationErrors.InvalidFields);
      }
      this.fastify.log.trace({ body: JSON.stringify(request5.body) }, "received request");
      const jsonRpcParsing = jsonRpcSchema.safeParse(request5.body);
      if (!jsonRpcParsing.success) {
        const validationError = import_zod_validation_error2.fromZodError(jsonRpcParsing.error);
        throw new RpcError2(`invalid JSON-RPC request ${validationError.message}`, ValidationErrors.InvalidFields);
      }
      const jsonRpcRequest = jsonRpcParsing.data;
      requestId = jsonRpcRequest.id;
      const bundlerRequestParsing = bundlerRequestSchema.safeParse(jsonRpcRequest);
      if (!bundlerRequestParsing.success) {
        const validationError = import_zod_validation_error2.fromZodError(bundlerRequestParsing.error);
        throw new RpcError2(validationError.message, ValidationErrors.InvalidRequest);
      }
      const bundlerRequest = bundlerRequestParsing.data;
      request5.rpcMethod = bundlerRequest.method;
      this.fastify.log.info({
        data: JSON.stringify(bundlerRequest, null),
        method: bundlerRequest.method
      }, "incoming request");
      const result = await this.rpcEndpoint.handleMethod(bundlerRequest);
      const jsonRpcResponse = {
        jsonrpc: "2.0",
        id: jsonRpcRequest.id,
        result: result.result
      };
      await reply.status(200).send(jsonRpcResponse);
      reply.rpcStatus = "success";
      this.fastify.log.info({
        data: JSON.stringify(jsonRpcResponse),
        method: bundlerRequest.method
      }, "sent reply");
    } catch (err) {
      if (err instanceof RpcError2) {
        const rpcError = {
          jsonrpc: "2.0",
          id: requestId,
          error: {
            message: err.message,
            data: err.data,
            code: err.code
          }
        };
        await reply.status(200).send(rpcError);
        this.fastify.log.info(rpcError, "error reply");
      } else if (err instanceof Error) {
        sentry3.captureException(err);
        const rpcError = {
          jsonrpc: "2.0",
          id: requestId,
          error: {
            message: err.message
          }
        };
        await reply.status(500).send(rpcError);
        this.fastify.log.error(err, "error reply (non-rpc)");
      } else {
        const rpcError = {
          jsonrpc: "2.0",
          id: requestId,
          error: {
            message: "Unknown error"
          }
        };
        await reply.status(500).send(rpcError);
        this.fastify.log.info(reply.raw, "error reply (non-rpc)");
      }
    }
  }
  async serveMetrics(_request, reply) {
    reply.headers({ "Content-Type": this.registry.contentType });
    const metrics2 = await this.registry.metrics();
    await reply.send(metrics2);
  }
}
// entrypoint-0.6/rpc/validation/BundlerCollectorTracer.ts
function bundlerCollectorTracer() {
  return {
    callsFromEntryPoint: [],
    currentLevel: null,
    keccak: [],
    calls: [],
    logs: [],
    debug: [],
    lastOp: "",
    lastThreeOpcodes: [],
    stopCollectingTopic: "bb47ee3e183a558b1a2ff0874b079f3fc5478b7454eacf2bfc5af2ff5878f972",
    stopCollecting: false,
    topLevelCallCounter: 0,
    fault(log7, _db) {
      this.debug.push(JSON.stringify({
        type: "fault",
        depth: log7.getDepth(),
        gas: log7.getGas(),
        cost: log7.getCost(),
        err: log7.getError()
      }));
    },
    result(_ctx, _db) {
      return {
        callsFromEntryPoint: this.callsFromEntryPoint,
        keccak: this.keccak,
        logs: this.logs,
        calls: this.calls,
        debug: this.debug
      };
    },
    enter(frame) {
      if (this.stopCollecting) {
        return;
      }
      this.calls.push({
        type: frame.getType(),
        from: toHex(frame.getFrom()),
        to: toHex(frame.getTo()),
        method: toHex(frame.getInput()).slice(0, 10),
        gas: frame.getGas(),
        value: frame.getValue()
      });
    },
    exit(frame) {
      if (this.stopCollecting) {
        return;
      }
      this.calls.push({
        type: frame.getError() != null ? "REVERT" : "RETURN",
        gasUsed: frame.getGasUsed(),
        data: toHex(frame.getOutput()).slice(0, 4000)
      });
    },
    countSlot(list, key) {
      if (list[key]) {
        list[key] += 1;
      } else {
        list[key] = 1;
      }
    },
    step(log7, db) {
      if (this.stopCollecting) {
        return;
      }
      const opcode = log7.op.toString();
      const stackSize = log7.stack.length();
      const stackTop3 = [];
      for (let i = 0;i < 3 && i < stackSize; i++) {
        stackTop3.push(log7.stack.peek(i));
      }
      this.lastThreeOpcodes.push({ opcode, stackTop3 });
      if (this.lastThreeOpcodes.length > 3) {
        this.lastThreeOpcodes.shift();
      }
      if (log7.getGas() < log7.getCost() || opcode === "SSTORE" && log7.getGas() < 2300) {
        this.currentLevel.oog = true;
      }
      if (opcode === "REVERT" || opcode === "RETURN") {
        if (log7.getDepth() === 1) {
          const ofs = Number.parseInt(log7.stack.peek(0).toString());
          const len = Number.parseInt(log7.stack.peek(1).toString());
          const data3 = toHex(log7.memory.slice(ofs, ofs + len)).slice(0, 4000);
          this.calls.push({
            type: opcode,
            gasUsed: 0,
            data: data3
          });
        }
        this.lastThreeOpcodes = [];
      }
      if (log7.getDepth() === 1) {
        if (opcode === "CALL" || opcode === "STATICCALL") {
          const addr = toAddress(log7.stack.peek(1).toString(16));
          const topLevelTargetAddress = toHex(addr);
          const ofs = Number.parseInt(log7.stack.peek(3).toString());
          const topLevelMethodSig = toHex(log7.memory.slice(ofs, ofs + 4));
          this.currentLevel = this.callsFromEntryPoint[this.topLevelCallCounter] = {
            topLevelMethodSig,
            topLevelTargetAddress,
            access: {},
            opcodes: {},
            extCodeAccessInfo: {},
            contractSize: {}
          };
          this.topLevelCallCounter++;
        } else if (opcode === "LOG1") {
          const topic = log7.stack.peek(2).toString(16);
          if (topic === this.stopCollectingTopic) {
            this.stopCollecting = true;
          }
        }
        this.lastOp = "";
        return;
      }
      const lastOpInfo = this.lastThreeOpcodes[this.lastThreeOpcodes.length - 2];
      if (lastOpInfo && lastOpInfo.opcode && lastOpInfo.opcode.match(/^(EXT.*)$/) != null) {
        const addr = toAddress(lastOpInfo.stackTop3[0].toString(16));
        const addrHex = toHex(addr);
        if (!(this.lastThreeOpcodes[0].opcode.match(/\w+/) !== null && this.lastThreeOpcodes[1].opcode === "EXTCODESIZE" && this.lastThreeOpcodes[2].opcode === "ISZERO")) {
          this.currentLevel.extCodeAccessInfo[addrHex] = opcode;
        }
      }
      const isAllowedPrecompiled = (address10) => {
        const addrHex = toHex(address10);
        const addressInt = Number.parseInt(addrHex);
        return addressInt > 0 && addressInt < 10;
      };
      if (opcode.match(/^(EXT.*|CALL|CALLCODE|DELEGATECALL|STATICCALL)$/) != null) {
        const idx = opcode.startsWith("EXT") ? 0 : 1;
        const addr = toAddress(log7.stack.peek(idx).toString(16));
        const addrHex = toHex(addr);
        if (this.currentLevel.contractSize[addrHex] == null && !isAllowedPrecompiled(addr)) {
          this.currentLevel.contractSize[addrHex] = {
            contractSize: db.getCode(addr).length,
            opcode
          };
        }
      }
      if (this.lastOp === "GAS" && !opcode.includes("CALL")) {
        this.countSlot(this.currentLevel.opcodes, "GAS");
      }
      if (opcode !== "GAS") {
        if (opcode.match(/^(DUP\d+|PUSH\d+|SWAP\d+|POP|ADD|SUB|MUL|DIV|EQ|LTE?|S?GTE?|SLT|SH[LR]|AND|OR|NOT|ISZERO)$/) == null) {
          this.countSlot(this.currentLevel.opcodes, opcode);
        }
      }
      this.lastOp = opcode;
      if (opcode === "SLOAD" || opcode === "SSTORE") {
        const slot = toWord(log7.stack.peek(0).toString(16));
        const slotHex = toHex(slot);
        const addr = log7.contract.getAddress();
        const addrHex = toHex(addr);
        let access = this.currentLevel.access[addrHex];
        if (access == null) {
          access = {
            reads: {},
            writes: {}
          };
          this.currentLevel.access[addrHex] = access;
        }
        if (opcode === "SLOAD") {
          if (access.reads[slotHex] == null && access.writes[slotHex] == null) {
            access.reads[slotHex] = toHex(db.getState(addr, slot));
          }
        } else {
          this.countSlot(access.writes, slotHex);
        }
      }
      if (opcode === "KECCAK256") {
        const ofs = Number.parseInt(log7.stack.peek(0).toString());
        const len = Number.parseInt(log7.stack.peek(1).toString());
        if (len > 20 && len < 512) {
          this.keccak.push(toHex(log7.memory.slice(ofs, ofs + len)));
        }
      } else if (opcode.startsWith("LOG")) {
        const count = Number.parseInt(opcode.substring(3));
        const ofs = Number.parseInt(log7.stack.peek(0).toString());
        const len = Number.parseInt(log7.stack.peek(1).toString());
        const topics = [];
        for (let i = 0;i < count; i++) {
          topics.push("0x" + log7.stack.peek(2 + i).toString(16));
        }
        const data3 = toHex(log7.memory.slice(ofs, ofs + len));
        this.logs.push({
          topics,
          data: data3
        });
      }
    }
  };
}

// entrypoint-0.6/rpc/validation/TracerResultParser.ts
var parseCallStack = function(tracerResults) {
  function callCatch(x, def) {
    try {
      return x();
    } catch (_) {
      return def;
    }
  }
  const out = [];
  const stack = [];
  const filteredTracerResultCalls = tracerResults.calls.filter((x) => !x.type.startsWith("depth"));
  for (const c of filteredTracerResultCalls) {
    if (c.type.match(/REVERT|RETURN/) !== null) {
      const top2 = stack.splice(-1)[0] ?? {
        type: "top",
        method: "validateUserOp"
      };
      const returnData = c.data;
      if (top2.type.match(/CREATE/) !== null) {
        out.push({
          to: top2.to,
          from: top2.from,
          type: top2.type,
          method: "",
          return: `len=${returnData.length}`
        });
      } else {
        const method = callCatch(() => functionSignatureToMethodName(top2.method), top2.method);
        if (c.type === "REVERT") {
          const parsedError = callCatch(() => decodeErrorResult({ abi: abi21, data: returnData }), returnData);
          out.push({
            to: top2.to,
            from: top2.from,
            type: top2.type,
            method,
            value: top2.value,
            revert: parsedError
          });
        } else {
          const ret2 = callCatch(() => decodeFunctionResult({
            abi: abi21,
            functionName: method,
            data: returnData
          }), returnData);
          out.push({
            to: top2.to,
            from: top2.from,
            type: top2.type,
            value: top2.value,
            method,
            return: ret2
          });
        }
      }
    } else {
      stack.push(c);
    }
  }
  return out;
};
var parseEntitySlots = function(stakeInfoEntities, keccak) {
  const entitySlots = {};
  for (const k of keccak) {
    const values = Object.values(stakeInfoEntities);
    for (const info of values) {
      const addr = info?.addr?.toLowerCase();
      if (!addr) {
        continue;
      }
      const addrPadded = pad(addr).toLowerCase();
      if (!entitySlots[addr]) {
        entitySlots[addr] = new Set;
      }
      const currentEntitySlots = entitySlots[addr];
      if (k.startsWith(addrPadded)) {
        currentEntitySlots.add(keccak256(k));
      }
    }
  }
  return entitySlots;
};
function tracerResultParser(userOp, tracerResults, validationResult, entryPointAddress) {
  const bannedOpCodes = new Set([
    "GASPRICE",
    "GASLIMIT",
    "DIFFICULTY",
    "TIMESTAMP",
    "BASEFEE",
    "BLOCKHASH",
    "NUMBER",
    "SELFBALANCE",
    "BALANCE",
    "ORIGIN",
    "GAS",
    "CREATE",
    "COINBASE",
    "SELFDESTRUCT",
    "RANDOM",
    "PREVRANDAO",
    "INVALID"
  ]);
  if (Object.values(tracerResults.callsFromEntryPoint).length < 1) {
    throw new Error("Unexpected traceCall result: no calls from entrypoint.");
  }
  const callStack = parseCallStack(tracerResults);
  const callInfoEntryPoint = callStack.find((call7) => call7.to === entryPointAddress && call7.from !== entryPointAddress && call7.method !== "0x" && call7.method !== "depositTo");
  if (callInfoEntryPoint) {
    throw new RpcError2(`illegal call into EntryPoint during validation ${callInfoEntryPoint?.method}`, ValidationErrors.OpcodeValidation);
  }
  const illegalNonZeroValueCall = callStack.find((call7) => call7.to !== entryPointAddress && hexToBigInt(call7.value ?? "0x0") !== 0n);
  if (illegalNonZeroValueCall) {
    throw new RpcError2("May not may CALL with value", ValidationErrors.OpcodeValidation);
  }
  const sender = userOp.sender.toLowerCase();
  const stakeInfoEntities = {
    factory: validationResult.factoryInfo,
    account: validationResult.senderInfo,
    paymaster: validationResult.paymasterInfo
  };
  const entitySlots = parseEntitySlots(stakeInfoEntities, tracerResults.keccak);
  for (const [title, entStakes] of Object.entries(stakeInfoEntities)) {
    let isStaked = function(entStake) {
      return Boolean(entStake && 1n <= entStake.stake && 1n <= entStake.unstakeDelaySec);
    }, requireCondAndStake = function(cond, entStake, failureMessage) {
      if (!cond) {
        return;
      }
      if (!entStake) {
        throw new Error(`internal: ${entityTitle} not in userOp, but has storage accesses in ${JSON.stringify(access)}`);
      }
      if (!isStaked(entStake)) {
        throw new RpcError2(failureMessage, ValidationErrors.OpcodeValidation, {
          [entityTitle]: entStakes?.addr
        });
      }
    };
    const entityTitle = title;
    const entityAddr = (entStakes?.addr ?? "").toLowerCase();
    const currentNumLevel = tracerResults.callsFromEntryPoint.find((info) => info.topLevelMethodSig === callsFromEntryPointMethodSigs[entityTitle]);
    if (!currentNumLevel) {
      if (entityTitle === "account") {
        throw new Error("missing trace into validateUserOp");
      }
      continue;
    }
    const opcodes = currentNumLevel.opcodes;
    const access = currentNumLevel.access;
    if (currentNumLevel.oog ?? false) {
      throw new RpcError2(`${entityTitle} internally reverts on oog`, ValidationErrors.OpcodeValidation);
    }
    for (const opcode of Object.keys(opcodes)) {
      if (bannedOpCodes.has(opcode)) {
        throw new RpcError2(`${entityTitle} uses banned opcode: ${opcode}`, ValidationErrors.OpcodeValidation);
      }
    }
    if (entityTitle === "factory") {
      if ((opcodes.CREATE2 ?? 0) > 1) {
        throw new RpcError2(`${entityTitle} with too many CREATE2`, ValidationErrors.OpcodeValidation);
      }
    } else if (opcodes.CREATE2) {
      throw new RpcError2(`${entityTitle} uses banned opcode: CREATE2`, ValidationErrors.OpcodeValidation);
    }
    for (const [addr, { reads, writes }] of Object.entries(access)) {
      let associatedWith = function(slot, addr2, entitySlots2) {
        const addrPadded = pad(addr2, {
          size: 32
        }).toLowerCase();
        if (slot.toLowerCase() === addrPadded) {
          return true;
        }
        const k = entitySlots2[addr2];
        if (!k) {
          return false;
        }
        const slotN = hexToBigInt(slot);
        for (const k1 of k.keys()) {
          const kn = hexToBigInt(k1);
          if (slotN >= kn && slotN < kn + 128n) {
            return true;
          }
        }
        return false;
      }, nameAddr = function(addr2, currentEntity) {
        const [title2] = Object.entries(stakeInfoEntities).find(([title3, info]) => info?.addr?.toLowerCase() === addr2.toLowerCase()) ?? [];
        return title2 ?? addr2;
      };
      if (addr === sender) {
        continue;
      }
      if (addr === entryPointAddress) {
        continue;
      }
      let requireStakeSlot;
      const slots = [...Object.keys(writes), ...Object.keys(reads)];
      for (const slot of slots) {
        if (associatedWith(slot, sender, entitySlots)) {
          if (userOp.initCode.length > 2) {
            if (!(entityAddr === sender && isStaked(stakeInfoEntities.factory))) {
              requireStakeSlot = slot;
            }
          }
        } else if (associatedWith(slot, entityAddr, entitySlots)) {
          requireStakeSlot = slot;
        } else if (addr === entityAddr) {
          requireStakeSlot = slot;
        } else if (writes[slot] === undefined) {
          requireStakeSlot = slot;
        } else {
          const readWrite = Object.keys(writes).includes(addr) ? "write to" : "read from";
          const message = `${entityTitle} has forbidden ${readWrite} ${nameAddr(addr, entityTitle)} slot ${slot}`;
          throw new RpcError2(message, ValidationErrors.OpcodeValidation, {
            [entityTitle]: entStakes?.addr
          });
        }
      }
      requireCondAndStake(requireStakeSlot !== undefined, entStakes, `unstaked ${entityTitle} accessed ${nameAddr(addr, entityTitle)} slot ${requireStakeSlot}`);
    }
    if (entityTitle === "paymaster") {
      const validatePaymasterUserOp = callStack.find((call7) => call7.method === "validatePaymasterUserOp" && call7.to === entityAddr);
      const context = validatePaymasterUserOp?.return ? validatePaymasterUserOp?.return[0] : undefined;
      requireCondAndStake(context && context !== "0x", entStakes, "unstaked paymaster must not return context");
    }
    let illegalZeroCodeAccess;
    for (const addr of Object.keys(currentNumLevel.contractSize)) {
      if (addr !== sender && currentNumLevel.contractSize[addr].contractSize <= 2) {
        illegalZeroCodeAccess = currentNumLevel.contractSize[addr];
        illegalZeroCodeAccess.address = addr;
        break;
      }
    }
    if (illegalZeroCodeAccess) {
      throw new RpcError2(`${entityTitle} accesses un-deployed contract address ${illegalZeroCodeAccess?.address} with opcode ${illegalZeroCodeAccess?.opcode}`, ValidationErrors.OpcodeValidation);
    }
    let illegalEntryPointCodeAccess = undefined;
    for (const addr of Object.keys(currentNumLevel.extCodeAccessInfo)) {
      if (addr === entryPointAddress) {
        illegalEntryPointCodeAccess = currentNumLevel.extCodeAccessInfo[addr];
        break;
      }
    }
    if (illegalEntryPointCodeAccess) {
      throw new RpcError2(`${entityTitle} accesses EntryPoint contract address ${entryPointAddress} with opcode ${illegalEntryPointCodeAccess}`, ValidationErrors.OpcodeValidation);
    }
  }
  const addresses = tracerResults.callsFromEntryPoint.flatMap((level) => Object.keys(level.contractSize));
  const storageMap = {};
  for (const level of tracerResults.callsFromEntryPoint) {
    for (const addr of Object.keys(level.access)) {
      storageMap[addr] = storageMap[addr] ?? level.access[addr].reads;
    }
  }
  return [addresses, storageMap];
}
var abi21 = [...SenderCreatorAbi, ...EntryPointAbi, ...PaymasterAbi];
var functionSignatureToMethodName = (hash4) => {
  let functionName = undefined;
  for (const item of abi21) {
    const signature = getFunctionSelector(item);
    if (signature === hash4) {
      functionName = item.name;
    }
  }
  if (functionName === undefined) {
    throw new Error(`Could not find function name for hash ${hash4}`);
  }
  return functionName;
};
var callsFromEntryPointMethodSigs = {
  factory: getFunctionSelector({
    inputs: [
      {
        internalType: "bytes",
        name: "initCode",
        type: "bytes"
      }
    ],
    name: "createSender",
    outputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }),
  account: getFunctionSelector({
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "callGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxFeePerGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct UserOperation",
        name: "userOp",
        type: "tuple"
      },
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "missingAccountFunds",
        type: "uint256"
      }
    ],
    name: "validateUserOp",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }),
  paymaster: getFunctionSelector({
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "callGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxFeePerGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct UserOperation",
        name: "userOp",
        type: "tuple"
      },
      {
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "maxCost",
        type: "uint256"
      }
    ],
    name: "validatePaymasterUserOp",
    outputs: [
      {
        internalType: "bytes",
        name: "context",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "validationData",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  })
};

// entrypoint-0.6/rpc/validation/UnsafeValidator.ts
var sentry4 = __toESM(require_cjs4(), 1);
var import_zod_validation_error3 = __toESM(require_cjs5(), 1);
async function simulateTenderlyCall(publicClient, params) {
  const response = await publicClient.transport.request({ method: "eth_call", params }).catch((e) => {
    return e;
  });
  const parsedObject = z.object({
    cause: z.object({
      data: hexDataSchema
    })
  }).parse(response);
  return parsedObject.cause.data;
}
async function getSimulationResult(errorResult, logger3, simulationType, usingTenderly = false) {
  const entryPointErrorSchemaParsing = usingTenderly ? entryPointErrorsSchema.safeParse(errorResult) : entryPointExecutionErrorSchema.safeParse(errorResult);
  if (!entryPointErrorSchemaParsing.success) {
    try {
      const err = import_zod_validation_error3.fromZodError(entryPointErrorSchemaParsing.error);
      logger3.error({ error: err.message }, "unexpected error during valiation");
      logger3.error(JSON.stringify(errorResult));
      err.message = `User Operation simulation returned unexpected invalid response: ${err.message}`;
      throw err;
    } catch {
      if (errorResult instanceof BaseError) {
        const revertError = errorResult.walk((err) => err instanceof ContractFunctionExecutionError);
        throw new RpcError2(`UserOperation reverted during simulation with reason: ${revertError?.cause?.reason}`, ValidationErrors.SimulateValidation);
      }
      sentry4.captureException(errorResult);
      throw new Error(`User Operation simulation returned unexpected invalid response: ${errorResult}`);
    }
  }
  const errorData = entryPointErrorSchemaParsing.data;
  if (errorData.errorName === "FailedOp") {
    const reason = errorData.args.reason;
    throw new RpcError2(`UserOperation reverted during simulation with reason: ${reason}`, ValidationErrors.SimulateValidation);
  }
  if (simulationType === "validation") {
    if (errorData.errorName !== "ValidationResult" && errorData.errorName !== "ValidationResultWithAggregation") {
      throw new Error("Unexpected error - errorName is not ValidationResult or ValidationResultWithAggregation");
    }
  } else if (errorData.errorName !== "ExecutionResult") {
    throw new Error("Unexpected error - errorName is not ExecutionResult");
  }
  const simulationResult = errorData.args;
  return simulationResult;
}

class UnsafeValidator {
  publicClient;
  entryPoint;
  logger;
  metrics;
  utilityWallet;
  usingTenderly;
  balanceOverrideEnabled;
  disableExpirationCheck;
  apiVersion;
  chainId;
  gasPriceManager;
  constructor(publicClient, entryPoint, logger3, metrics2, utilityWallet, apiVersion, gasPriceManager2, usingTenderly = false, balanceOverrideEnabled = false, disableExpirationCheck = false) {
    this.publicClient = publicClient;
    this.entryPoint = entryPoint;
    this.logger = logger3;
    this.metrics = metrics2;
    this.utilityWallet = utilityWallet;
    this.usingTenderly = usingTenderly;
    this.balanceOverrideEnabled = balanceOverrideEnabled;
    this.disableExpirationCheck = disableExpirationCheck;
    this.apiVersion = apiVersion;
    this.chainId = publicClient.chain.id;
    this.gasPriceManager = gasPriceManager2;
  }
  async getExecutionResult(userOperation, stateOverrides) {
    const entryPointContract = getContract({
      address: this.entryPoint,
      abi: EntryPointAbi,
      publicClient: this.publicClient
    });
    if (this.usingTenderly) {
      const tenderlyResult = await simulateTenderlyCall(this.publicClient, [
        {
          to: this.entryPoint,
          data: encodeFunctionData({
            abi: entryPointContract.abi,
            functionName: "simulateHandleOp",
            args: [
              userOperation,
              "0x0000000000000000000000000000000000000000",
              "0x"
            ]
          })
        },
        "latest"
      ]);
      const errorResult2 = decodeErrorResult({
        abi: entryPointContract.abi,
        data: tenderlyResult
      });
      return getSimulationResult(errorResult2, this.logger, "execution", this.usingTenderly);
    }
    if (this.balanceOverrideEnabled) {
      const error = await simulateHandleOp(userOperation, this.entryPoint, this.publicClient, false, zeroAddress, "0x", stateOverrides);
      if (error.result === "failed") {
        throw new RpcError2(`UserOperation reverted during simulation with reason: ${error.data}`, ExecutionErrors.UserOperationReverted);
      }
      return error.data;
    }
    const errorResult = await entryPointContract.simulate.simulateHandleOp([
      userOperation,
      "0x0000000000000000000000000000000000000000",
      "0x"
    ], {
      account: this.utilityWallet
    }).catch((e) => {
      if (e instanceof Error) {
        return e;
      }
      throw e;
    });
    return getSimulationResult(errorResult, this.logger, "execution", this.usingTenderly);
  }
  async getValidationResult(userOperation, _codeHashes) {
    const entryPointContract = getContract({
      address: this.entryPoint,
      abi: EntryPointAbi,
      publicClient: this.publicClient
    });
    if (this.usingTenderly) {
      const tenderlyResult = await simulateTenderlyCall(this.publicClient, [
        {
          to: this.entryPoint,
          data: encodeFunctionData({
            abi: entryPointContract.abi,
            functionName: "simulateValidation",
            args: [userOperation]
          })
        },
        "latest"
      ]);
      const errorResult2 = decodeErrorResult({
        abi: entryPointContract.abi,
        data: tenderlyResult
      });
      return {
        ...await getSimulationResult(errorResult2, this.logger, "validation", this.usingTenderly),
        storageMap: {}
      };
    }
    const errorResult = await entryPointContract.simulate.simulateValidation([userOperation]).catch((e) => {
      if (e instanceof Error) {
        return e;
      }
      throw e;
    });
    return {
      ...await getSimulationResult(errorResult, this.logger, "validation", this.usingTenderly),
      storageMap: {}
    };
  }
  async validatePreVerificationGas(userOperation) {
    if (this.apiVersion !== "v1") {
      const preVerificationGas = await calcPreVerificationGas(this.publicClient, userOperation, this.entryPoint, this.chainId);
      if (preVerificationGas > userOperation.preVerificationGas) {
        throw new RpcError2(`preVerificationGas is not enough, required: ${preVerificationGas}, got: ${userOperation.preVerificationGas}`, ValidationErrors.SimulateValidation);
      }
    }
  }
  async validateUserOperation(userOperation, _referencedContracts) {
    try {
      const validationResult = await this.getValidationResult(userOperation);
      if (validationResult.returnInfo.sigFailed) {
        throw new RpcError2("Invalid UserOp signature or  paymaster signature", ValidationErrors.InvalidSignature);
      }
      const now = Date.now() / 1000;
      this.logger.debug({
        validAfter: validationResult.returnInfo.validAfter,
        validUntil: validationResult.returnInfo.validUntil,
        now
      });
      if (validationResult.returnInfo.validAfter > now - 5 && !this.disableExpirationCheck) {
        throw new RpcError2("User operation is not valid yet", ValidationErrors.ExpiresShortly);
      }
      if (validationResult.returnInfo.validUntil < now + 30 && !this.disableExpirationCheck) {
        throw new RpcError2("expires too soon", ValidationErrors.ExpiresShortly);
      }
      if (this.apiVersion !== "v1") {
        const prefund = validationResult.returnInfo.prefund;
        const [verificationGasLimit, callGasLimit] = await calcVerificationGasAndCallGasLimit(this.publicClient, userOperation, {
          preOpGas: validationResult.returnInfo.preOpGas,
          paid: validationResult.returnInfo.prefund
        }, this.chainId);
        const mul = userOperation.paymasterAndData === "0x" ? 3n : 1n;
        const requiredPreFund = callGasLimit + verificationGasLimit * mul + userOperation.preVerificationGas;
        if (requiredPreFund > prefund) {
          throw new RpcError2(`prefund is not enough, required: ${requiredPreFund}, got: ${prefund}`, ValidationErrors.SimulateValidation);
        }
      }
      this.metrics.userOperationsValidationSuccess.inc();
      return validationResult;
    } catch (e) {
      this.metrics.userOperationsValidationFailure.inc();
      throw e;
    }
  }
}

// entrypoint-0.6/rpc/validation/tracer.ts
var sentry5 = __toESM(require_cjs4(), 1);
async function debug_traceCall(client, tx, options) {
  const traceOptions = tracer2string(options);
  const ret2 = await client.request({
    method: "debug_traceCall",
    params: [formatTransactionRequest(tx), "latest", traceOptions]
  }).catch((e) => {
    if (e instanceof Error) {
      throw e;
    }
    sentry5.captureException(e);
  });
  return ret2;
}
function getTracerBodyString(func) {
  const tracerFunc = func.toString();
  const regexp = /function \w+\s*\(\s*\)\s*{\s*return\s*(\{[\s\S]+\});?\s*\}\s*$/;
  const match = tracerFunc.match(regexp);
  if (match === null) {
    throw new Error("Not a simple method returning value");
  }
  let ret2 = match[1];
  ret2 = ret2.replace(/\b(?:const|let)\b/g, "");
  return ret2;
}
var tracer2string = function(options) {
  if (typeof options.tracer === "function") {
    return {
      ...options,
      tracer: getTracerBodyString(options.tracer)
    };
  }
  return options;
};

// entrypoint-0.6/rpc/validation/SafeValidator.ts
class SafeValidator extends UnsafeValidator {
  senderManager;
  constructor(publicClient, senderManager, entryPoint, logger3, metrics2, utilityWallet, apiVersion, gasPriceManager2, usingTenderly = false, balanceOverrideEnabled = false) {
    super(publicClient, entryPoint, logger3, metrics2, utilityWallet, apiVersion, gasPriceManager2, usingTenderly, balanceOverrideEnabled);
    this.senderManager = senderManager;
  }
  async validateUserOperation(userOperation, referencedContracts) {
    try {
      const validationResult = await this.getValidationResult(userOperation, referencedContracts);
      if (validationResult.returnInfo.sigFailed) {
        throw new RpcError2("Invalid UserOp signature or paymaster signature", ValidationErrors.InvalidSignature);
      }
      const now = Date.now() / 1000;
      this.logger.debug({
        validAfter: validationResult.returnInfo.validAfter,
        validUntil: validationResult.returnInfo.validUntil,
        now
      });
      if (validationResult.returnInfo.validAfter > now - 5) {
        throw new RpcError2("User operation is not valid yet", ValidationErrors.ExpiresShortly);
      }
      if (validationResult.returnInfo.validUntil < now + 30) {
        throw new RpcError2("expires too soon", ValidationErrors.ExpiresShortly);
      }
      if (this.apiVersion !== "v1") {
        const prefund = validationResult.returnInfo.prefund;
        const [verificationGasLimit, callGasLimit] = await calcVerificationGasAndCallGasLimit(this.publicClient, userOperation, {
          preOpGas: validationResult.returnInfo.preOpGas,
          paid: validationResult.returnInfo.prefund
        }, this.chainId);
        const mul = userOperation.paymasterAndData === "0x" ? 3n : 1n;
        const requiredPreFund = callGasLimit + verificationGasLimit * mul + userOperation.preVerificationGas;
        if (requiredPreFund > prefund) {
          throw new RpcError2(`prefund is not enough, required: ${requiredPreFund}, got: ${prefund}`, ValidationErrors.SimulateValidation);
        }
      }
      this.metrics.userOperationsValidationSuccess.inc();
      return validationResult;
    } catch (e) {
      this.metrics.userOperationsValidationFailure.inc();
      throw e;
    }
  }
  async getCodeHashes(addresses) {
    const deployData = encodeDeployData({
      abi: CodeHashGetterAbi,
      bytecode: CodeHashGetterBytecode,
      args: [addresses]
    });
    const wallet2 = await this.senderManager.getWallet();
    let hash4 = "";
    try {
      await this.publicClient.call({
        account: wallet2,
        data: deployData
      });
    } catch (e) {
      const error = e;
      hash4 = error.walk().data;
    }
    this.senderManager.pushWallet(wallet2);
    return {
      hash: hash4,
      addresses
    };
  }
  async getValidationResult(userOperation, preCodeHashes) {
    if (this.usingTenderly) {
      return super.getValidationResult(userOperation);
    }
    if (preCodeHashes && preCodeHashes.addresses.length > 0) {
      const { hash: hash4 } = await this.getCodeHashes(preCodeHashes.addresses);
      if (hash4 !== preCodeHashes.hash) {
        throw new RpcError2("code hashes mismatch", ValidationErrors.OpcodeValidation);
      }
    }
    const [res, tracerResult] = await this.getValidationResultWithTracer(userOperation);
    const [contractAddresses, storageMap] = tracerResultParser(userOperation, tracerResult, res, this.entryPoint.toLowerCase());
    const codeHashes = preCodeHashes || await this.getCodeHashes(contractAddresses);
    if (res === "0x") {
      throw new Error("simulateValidation reverted with no revert string!");
    }
    return {
      ...res,
      referencedContracts: codeHashes,
      storageMap
    };
  }
  async getValidationResultWithTracer(userOperation) {
    const tracerResult = await debug_traceCall(this.publicClient, {
      from: zeroAddress,
      to: this.entryPoint,
      data: encodeFunctionData({
        abi: EntryPointAbi,
        functionName: "simulateValidation",
        args: [userOperation]
      })
    }, {
      tracer: bundlerCollectorTracer
    });
    const lastResult = tracerResult.calls.slice(-1)[0];
    if (lastResult.type !== "REVERT") {
      throw new Error("Invalid response. simulateCall must revert");
    }
    const data3 = lastResult.data;
    if (data3 === "0x") {
      return [data3, tracerResult];
    }
    try {
      const { errorName, args: errorArgs } = decodeErrorResult({
        abi: EntryPointAbi,
        data: data3
      });
      const errFullName = `${errorName}(${errorArgs.toString()})`;
      const errorResult = this.parseErrorResult(userOperation, {
        errorName,
        errorArgs
      });
      if (!errorName.includes("Result")) {
        throw new Error(errFullName);
      }
      return [errorResult, tracerResult];
    } catch (e) {
      if (e.code != null) {
        throw e;
      }
      throw new RpcError2(data3);
    }
  }
  parseErrorResult(userOp, errorResult) {
    if (!errorResult?.errorName?.startsWith("ValidationResult")) {
      let paymaster = errorResult.errorArgs.paymaster;
      if (paymaster === zeroAddress) {
        paymaster = undefined;
      }
      const msg = errorResult.errorArgs[1] ?? errorResult.toString();
      if (paymaster == null) {
        throw new RpcError2(`account validation failed: ${msg}`, ValidationErrors.SimulateValidation);
      }
      throw new RpcError2(`paymaster validation failed: ${msg}`, ValidationErrors.SimulatePaymasterValidation, {
        paymaster
      });
    }
    const [
      returnInfo,
      senderInfo,
      factoryInfo,
      paymasterInfo,
      aggregatorInfo
    ] = errorResult.errorArgs;
    function fillEntity(data3, info) {
      const addr = getAddressFromInitCodeOrPaymasterAndData(data3);
      return addr == null ? undefined : {
        ...info,
        addr
      };
    }
    function fillEntityAggregator(data3, info) {
      const addr = getAddressFromInitCodeOrPaymasterAndData(data3);
      return addr == null ? undefined : {
        aggregator: data3,
        stakeInfo: {
          ...info,
          addr
        }
      };
    }
    return {
      returnInfo,
      senderInfo: {
        ...senderInfo,
        addr: userOp.sender
      },
      factoryInfo: fillEntity(userOp.initCode, factoryInfo),
      paymasterInfo: fillEntity(userOp.paymasterAndData, paymasterInfo),
      aggregatorInfo: fillEntityAggregator(aggregatorInfo?.actualAggregator, aggregatorInfo?.stakeInfo)
    };
  }
}
// entrypoint-0.6/rpc/nonceQueuer.ts
class NonceQueuer {
  queuedUserOperations = [];
  mempool;
  publicClient;
  entryPoint;
  logger;
  constructor(mempool6, publicClient, entryPoint, logger3) {
    this.mempool = mempool6;
    this.publicClient = publicClient;
    this.entryPoint = entryPoint;
    this.logger = logger3;
    setInterval(() => {
      this.process();
    }, 2000);
  }
  async process() {
    this.queuedUserOperations = this.queuedUserOperations.filter((qop) => {
      return qop.addedAt > Date.now() - 900000;
    });
    if (this.queuedUserOperations.length === 0) {
      return;
    }
    const availableOps = await this.getAvailableUserOperations(this.publicClient, this.entryPoint);
    if (availableOps.length === 0) {
      return;
    }
    this.queuedUserOperations = this.queuedUserOperations.filter((qop) => {
      return !availableOps.some((op) => {
        return op.userOperationHash === qop.userOperationHash;
      });
    });
    availableOps.map((op) => {
      this.resubmitUserOperation(op.mempoolUserOperation);
    });
    this.logger.info({ availableOps: availableOps.map((qop) => qop.userOperationHash) }, "submitted user operations from nonce queue");
  }
  add(mempoolUserOperation) {
    const userOp = deriveUserOperation(mempoolUserOperation);
    const [nonceKey, nonceValue] = getNonceKeyAndValue(userOp.nonce);
    this.queuedUserOperations.push({
      userOperationHash: getUserOperationHash(deriveUserOperation(mempoolUserOperation), this.entryPoint, this.publicClient.chain.id),
      mempoolUserOperation,
      nonceKey,
      nonceValue,
      addedAt: Date.now()
    });
  }
  resubmitUserOperation(mempoolUserOperation) {
    const userOperation = mempoolUserOperation;
    this.logger.info({ userOperation }, "submitting user operation from nonce queue");
    const result = this.mempool.add(mempoolUserOperation);
    if (result) {
      this.logger.info({ userOperation, result }, "added user operation");
    } else {
      this.logger.error("error adding user operation");
    }
  }
  async getAvailableUserOperations(publicClient, entryPoint) {
    const queuedUserOperations = this.queuedUserOperations.slice();
    let results;
    try {
      results = await publicClient.multicall({
        contracts: queuedUserOperations.map((qop) => {
          const userOp = deriveUserOperation(qop.mempoolUserOperation);
          return {
            address: entryPoint,
            abi: EntryPointAbi,
            functionName: "getNonce",
            args: [userOp.sender, qop.nonceKey]
          };
        }),
        blockTag: "latest"
      });
    } catch (error) {
      this.logger.error({ error: JSON.stringify(error) }, "error fetching with multiCall");
      const entryPointContract = getContract({
        abi: EntryPointAbi,
        address: entryPoint,
        publicClient
      });
      results = await Promise.all(queuedUserOperations.map(async (qop) => {
        const userOp = deriveUserOperation(qop.mempoolUserOperation);
        try {
          const nonce = await entryPointContract.read.getNonce([userOp.sender, qop.nonceKey], { blockTag: "latest" });
          return {
            result: nonce,
            status: "success"
          };
        } catch (e) {
          return {
            error: e,
            status: "failure"
          };
        }
      }));
    }
    if (results.length !== queuedUserOperations.length) {
      this.logger.error("error fetching nonces");
      return [];
    }
    const currentOutstandingOps = [];
    for (let i = 0;i < queuedUserOperations.length; i++) {
      const qop = queuedUserOperations[i];
      const result = results[i];
      if (result.status !== "success") {
        this.logger.error({ error: result.error }, "error fetching nonce");
        continue;
      }
      const onchainNonceValue = result.result;
      if (onchainNonceValue === qop.nonceValue) {
        currentOutstandingOps.push(qop);
      }
    }
    return currentOutstandingOps;
  }
}
// entrypoint-0.6/executor/executor.ts
var sentry7 = __toESM(require_cjs4(), 1);

// /home/mous/work/pimlico/alto/src/node_modules/async-mutex/index.mjs
var E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
var E_ALREADY_LOCKED = new Error("mutex already locked");
var E_CANCELED = new Error("request for lock canceled");
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P || (P = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class Semaphore {
  constructor(_value, _cancelError = E_CANCELED) {
    this._value = _value;
    this._cancelError = _cancelError;
    this._weightedQueues = [];
    this._weightedWaiters = [];
  }
  acquire(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise((resolve5, reject) => {
      if (!this._weightedQueues[weight - 1])
        this._weightedQueues[weight - 1] = [];
      this._weightedQueues[weight - 1].push({ resolve: resolve5, reject });
      this._dispatch();
    });
  }
  runExclusive(callback, weight = 1) {
    return __awaiter$2(this, undefined, undefined, function* () {
      const [value, release] = yield this.acquire(weight);
      try {
        return yield callback(value);
      } finally {
        release();
      }
    });
  }
  waitForUnlock(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise((resolve5) => {
      if (!this._weightedWaiters[weight - 1])
        this._weightedWaiters[weight - 1] = [];
      this._weightedWaiters[weight - 1].push(resolve5);
      this._dispatch();
    });
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(value) {
    this._value = value;
    this._dispatch();
  }
  release(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    this._value += weight;
    this._dispatch();
  }
  cancel() {
    this._weightedQueues.forEach((queue) => queue.forEach((entry) => entry.reject(this._cancelError)));
    this._weightedQueues = [];
  }
  _dispatch() {
    var _a2;
    for (let weight = this._value;weight > 0; weight--) {
      const queueEntry = (_a2 = this._weightedQueues[weight - 1]) === null || _a2 === undefined ? undefined : _a2.shift();
      if (!queueEntry)
        continue;
      const previousValue = this._value;
      const previousWeight = weight;
      this._value -= weight;
      weight = this._value + 1;
      queueEntry.resolve([previousValue, this._newReleaser(previousWeight)]);
    }
    this._drainUnlockWaiters();
  }
  _newReleaser(weight) {
    let called = false;
    return () => {
      if (called)
        return;
      called = true;
      this.release(weight);
    };
  }
  _drainUnlockWaiters() {
    for (let weight = this._value;weight > 0; weight--) {
      if (!this._weightedWaiters[weight - 1])
        continue;
      this._weightedWaiters[weight - 1].forEach((waiter) => waiter());
      this._weightedWaiters[weight - 1] = [];
    }
  }
}
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P || (P = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class Mutex {
  constructor(cancelError) {
    this._semaphore = new Semaphore(1, cancelError);
  }
  acquire() {
    return __awaiter$1(this, undefined, undefined, function* () {
      const [, releaser] = yield this._semaphore.acquire();
      return releaser;
    });
  }
  runExclusive(callback) {
    return this._semaphore.runExclusive(() => callback());
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock() {
    return this._semaphore.waitForUnlock();
  }
  release() {
    if (this._semaphore.isLocked())
      this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
}

// entrypoint-0.6/executor/utils.ts
var sentry6 = __toESM(require_cjs4(), 1);
function simulatedOpsToResults(simulatedOps, transactionInfo) {
  return simulatedOps.map((sop) => {
    if (sop.reason === undefined) {
      return {
        status: "success",
        value: {
          userOperation: {
            mempoolUserOperation: sop.owh.mempoolUserOperation,
            userOperationHash: sop.owh.userOperationHash,
            lastReplaced: Date.now(),
            firstSubmitted: Date.now()
          },
          transactionInfo
        }
      };
    }
    return {
      status: "failure",
      error: {
        userOpHash: sop.owh.userOperationHash,
        reason: sop.reason
      }
    };
  });
}
function createCompressedCalldata(compressedOps, perOpInflatorId) {
  const bundleBulkerPayload = numberToHex(perOpInflatorId, { size: 4 });
  const perOpInflatorPayload = numberToHex(compressedOps.length, { size: 1 });
  return compressedOps.reduce((currentCallData, op) => {
    const nextCallData = concat([
      numberToHex(op.inflatorId, { size: 4 }),
      numberToHex(hexToBytes(op.compressedCalldata).length, {
        size: 2
      }),
      op.compressedCalldata
    ]);
    return concat([currentCallData, nextCallData]);
  }, concat([bundleBulkerPayload, perOpInflatorPayload]));
}
async function filterOpsAndEstimateGas(callContext, wallet2, ops, nonce, maxFeePerGas, maxPriorityFeePerGas, blockTag, onlyPre1559, customGasLimitForEstimation, reputationManager3, logger3) {
  const simulatedOps = ops.map((owh) => {
    return { owh, reason: undefined };
  });
  let gasLimit;
  while (simulatedOps.filter((op) => op.reason === undefined).length > 0) {
    try {
      const gasOptions = onlyPre1559 ? { gasPrice: maxFeePerGas } : { maxFeePerGas, maxPriorityFeePerGas };
      if (callContext.type === "default") {
        const ep = callContext.ep;
        const opsToSend = simulatedOps.filter((op) => op.reason === undefined).map((op) => op.owh.mempoolUserOperation);
        gasLimit = await ep.estimateGas.handleOps([opsToSend, wallet2.address], {
          account: wallet2,
          gas: customGasLimitForEstimation,
          nonce,
          blockTag,
          ...gasOptions
        });
      } else {
        const { publicClient, bundleBulker, perOpInflatorId } = callContext;
        const opsToSend = simulatedOps.filter((op) => op.reason === undefined).map((op) => op.owh.mempoolUserOperation);
        gasLimit = await publicClient.estimateGas({
          to: bundleBulker,
          account: wallet2,
          data: createCompressedCalldata(opsToSend, perOpInflatorId),
          gas: customGasLimitForEstimation,
          nonce,
          blockTag,
          ...gasOptions
        });
      }
      return { simulatedOps, gasLimit, resubmitAllOps: false };
    } catch (err) {
      const e = parseViemError(err);
      if (e instanceof ContractFunctionRevertedError) {
        const parsingResult = failedOpErrorSchema.safeParse(e.data);
        if (parsingResult.success) {
          const failedOpError = parsingResult.data;
          logger3.debug({
            failedOpError,
            userOpHashes: simulatedOps.filter((op) => op.reason === undefined).map((op) => op.owh.userOperationHash)
          }, "user op in batch invalid");
          const failingOp = simulatedOps.filter((op) => op.reason === undefined)[Number(failedOpError.args.opIndex)];
          failingOp.reason = failedOpError.args.reason;
          reputationManager3.crashedHandleOps(deriveUserOperation(failingOp.owh.mempoolUserOperation), failingOp.reason);
        } else {
          sentry6.captureException(err);
          logger3.error({
            error: parsingResult.error
          }, "failed to parse failedOpError");
          return {
            simulatedOps: [],
            gasLimit: 0n,
            resubmitAllOps: false
          };
        }
      } else if (e instanceof EstimateGasExecutionError) {
        try {
          const errorHexData = e.details.split("Reverted ")[1];
          const errorResult = decodeErrorResult({
            abi: EntryPointAbi,
            data: errorHexData
          });
          logger3.debug({
            errorName: errorResult.errorName,
            args: errorResult.args,
            userOpHashes: simulatedOps.filter((op) => op.reason === undefined).map((op) => op.owh.userOperationHash)
          }, "user op in batch invalid");
          if (errorResult.errorName !== "FailedOp") {
            logger3.error({
              errorName: errorResult.errorName,
              args: errorResult.args
            }, "unexpected error result");
            return {
              simulatedOps: [],
              gasLimit: 0n,
              resubmitAllOps: false
            };
          }
          const failingOp = simulatedOps.filter((op) => op.reason === undefined)[Number(errorResult.args[0])];
          failingOp.reason = errorResult.args[1];
        } catch (_e) {
          logger3.error({ error: JSON.stringify(err) }, "failed to parse error result");
          return {
            simulatedOps: [],
            gasLimit: 0n,
            resubmitAllOps: false
          };
        }
      } else if (e instanceof EstimateGasExecutionError) {
        if (e.cause instanceof FeeCapTooLowError) {
          logger3.info({ error: e.shortMessage }, "error estimating gas due to max fee < basefee");
          return {
            simulatedOps,
            gasLimit: 0n,
            resubmitAllOps: true
          };
        }
      } else {
        sentry6.captureException(err);
        logger3.error({ error: JSON.stringify(err) }, "error estimating gas");
        return { simulatedOps: [], gasLimit: 0n, resubmitAllOps: false };
      }
    }
  }
  return { simulatedOps, gasLimit: 0n, resubmitAllOps: false };
}
async function flushStuckTransaction(publicClient, walletClient, wallet2, gasPrice7, logger3, entryPoint) {
  const latestNonce = await publicClient.getTransactionCount({
    address: wallet2.address,
    blockTag: "latest"
  });
  const pendingNonce = await publicClient.getTransactionCount({
    address: wallet2.address,
    blockTag: "pending"
  });
  logger3.debug({ latestNonce, pendingNonce, wallet: wallet2.address }, "checking for stuck transactions");
  if (latestNonce === pendingNonce) {
    return;
  }
  if (latestNonce + 1 === pendingNonce) {
    return;
  }
  logger3.info({ latestNonce, pendingNonce, wallet: wallet2.address }, "found stuck transaction, flushing");
  for (let nonceToFlush = latestNonce;nonceToFlush < pendingNonce; nonceToFlush++) {
    try {
      const txHash = await walletClient.sendTransaction({
        account: wallet2,
        to: wallet2.address,
        value: 0n,
        nonce: nonceToFlush,
        maxFeePerGas: gasPrice7,
        maxPriorityFeePerGas: gasPrice7
      });
      logger3.debug({ txHash, nonce: nonceToFlush, wallet: wallet2.address }, "flushed stuck transaction");
      await transactionIncluded(txHash, publicClient, entryPoint);
    } catch (e) {
      sentry6.captureException(e);
      logger3.warn({ error: e }, "error flushing stuck transaction");
    }
  }
}

// entrypoint-0.6/executor/executor.ts
class BasicExecutor {
  publicClient;
  walletClient;
  senderManager;
  entryPoint;
  logger;
  metrics;
  simulateTransaction;
  noEip1559Support;
  customGasLimitForEstimation;
  useUserOperationGasLimitsForSubmission;
  reputationManager;
  compressionHandler;
  gasPriceManager;
  mutex;
  constructor(publicClient, walletClient, senderManager, reputationManager3, entryPoint, logger3, metrics2, compressionHandler2, gasPriceManager2, simulateTransaction = false, noEip1559Support = false, customGasLimitForEstimation, useUserOperationGasLimitsForSubmission = false) {
    this.publicClient = publicClient;
    this.walletClient = walletClient;
    this.senderManager = senderManager;
    this.reputationManager = reputationManager3;
    this.entryPoint = entryPoint;
    this.logger = logger3;
    this.metrics = metrics2;
    this.simulateTransaction = simulateTransaction;
    this.noEip1559Support = noEip1559Support;
    this.customGasLimitForEstimation = customGasLimitForEstimation;
    this.useUserOperationGasLimitsForSubmission = useUserOperationGasLimitsForSubmission;
    this.compressionHandler = compressionHandler2;
    this.gasPriceManager = gasPriceManager2;
    this.mutex = new Mutex;
  }
  getCompressionHandler() {
    if (!this.compressionHandler) {
      throw new Error("Support for compressed bundles has not initialized");
    }
    return this.compressionHandler;
  }
  cancelOps(_entryPoint, _ops) {
    throw new Error("Method not implemented.");
  }
  markWalletProcessed(executor) {
    if (!this.senderManager.availableWallets.includes(executor)) {
      this.senderManager.pushWallet(executor);
    }
    return Promise.resolve();
  }
  async replaceTransaction(transactionInfo) {
    const newRequest = { ...transactionInfo.transactionRequest };
    const gasPriceParameters = await this.gasPriceManager.getGasPrice();
    newRequest.maxFeePerGas = maxBigInt2(gasPriceParameters.maxFeePerGas, (newRequest.maxFeePerGas * 11n + 9n) / 10n);
    newRequest.maxPriorityFeePerGas = maxBigInt2(gasPriceParameters.maxPriorityFeePerGas, (newRequest.maxPriorityFeePerGas * 11n + 9n) / 10n);
    newRequest.account = transactionInfo.executor;
    const opsWithHashes = transactionInfo.userOperationInfos.map((opInfo) => {
      const op = deriveUserOperation(opInfo.mempoolUserOperation);
      return {
        mempoolUserOperation: opInfo.mempoolUserOperation,
        userOperationHash: getUserOperationHash(op, this.entryPoint, this.walletClient.chain.id)
      };
    });
    let callContext;
    if (transactionInfo.transactionType === "default") {
      const ep = getContract({
        abi: EntryPointAbi,
        address: this.entryPoint,
        publicClient: this.publicClient,
        walletClient: this.walletClient
      });
      callContext = {
        ep,
        type: "default"
      };
    } else {
      const compressionHandler2 = this.getCompressionHandler();
      callContext = {
        publicClient: this.publicClient,
        bundleBulker: compressionHandler2.bundleBulkerAddress,
        perOpInflatorId: compressionHandler2.perOpInflatorId,
        type: "compressed"
      };
    }
    const result = await filterOpsAndEstimateGas(callContext, transactionInfo.executor, opsWithHashes, newRequest.nonce, newRequest.maxFeePerGas, newRequest.maxPriorityFeePerGas, "latest", this.noEip1559Support, this.customGasLimitForEstimation, this.reputationManager, this.logger);
    const childLogger = this.logger.child({
      transactionHash: transactionInfo.transactionHash,
      executor: transactionInfo.executor.address
    });
    if (result.simulatedOps.length === 0) {
      childLogger.warn("no ops to bundle");
      this.markWalletProcessed(transactionInfo.executor);
      return { status: "failed" };
    }
    if (result.simulatedOps.every((op) => op.reason === "AA25 invalid account nonce" || op.reason === "AA10 sender already constructed")) {
      childLogger.trace({ reasons: result.simulatedOps.map((sop) => sop.reason) }, "all ops failed simulation with nonce error");
      return { status: "potentially_already_included" };
    }
    if (result.simulatedOps.every((op) => op.reason !== undefined)) {
      childLogger.warn("all ops failed simulation");
      this.markWalletProcessed(transactionInfo.executor);
      return { status: "failed" };
    }
    const opsToBundle = result.simulatedOps.filter((op) => op.reason === undefined).map((op) => {
      const opInfo = transactionInfo.userOperationInfos.find((info) => info.userOperationHash === op.owh.userOperationHash);
      if (!opInfo) {
        throw new Error("opInfo not found");
      }
      return opInfo;
    });
    newRequest.gas = this.useUserOperationGasLimitsForSubmission ? opsToBundle.reduce((acc, opInfo) => {
      const userOperation = deriveUserOperation(opInfo.mempoolUserOperation);
      return acc + userOperation.preVerificationGas + 3n * userOperation.verificationGasLimit + userOperation.callGasLimit;
    }, 0n) : result.gasLimit;
    if (transactionInfo.transactionType === "default") {
      newRequest.data = encodeFunctionData({
        abi: EntryPointAbi,
        functionName: "handleOps",
        args: [
          opsToBundle.map((opInfo) => opInfo.mempoolUserOperation),
          transactionInfo.executor.address
        ]
      });
    } else if (transactionInfo.transactionType === "compressed") {
      const compressedOps = opsToBundle.map((opInfo) => opInfo.mempoolUserOperation);
      newRequest.data = createCompressedCalldata(compressedOps, this.getCompressionHandler().perOpInflatorId);
    }
    try {
      childLogger.info({
        newRequest: {
          ...newRequest,
          abi: undefined,
          chain: undefined
        },
        executor: newRequest.account.address,
        opsToBundle: opsToBundle.map((opInfo) => opInfo.userOperationHash)
      }, "replacing transaction");
      const txHash = await this.walletClient.sendTransaction(this.noEip1559Support ? {
        ...newRequest,
        gasPrice: newRequest.maxFeePerGas,
        maxFeePerGas: undefined,
        maxPriorityFeePerGas: undefined,
        type: "legacy",
        accessList: undefined
      } : newRequest);
      const newTxInfo = {
        ...transactionInfo,
        transactionRequest: newRequest,
        transactionHash: txHash,
        previousTransactionHashes: [
          transactionInfo.transactionHash,
          ...transactionInfo.previousTransactionHashes
        ],
        lastReplaced: Date.now(),
        userOperationInfos: opsToBundle.map((opInfo) => {
          return {
            mempoolUserOperation: opInfo.mempoolUserOperation,
            userOperationHash: opInfo.userOperationHash,
            lastReplaced: Date.now(),
            firstSubmitted: opInfo.firstSubmitted
          };
        })
      };
      return { status: "replaced", transactionInfo: newTxInfo };
    } catch (err) {
      const e = parseViemError(err);
      if (!e) {
        sentry7.captureException(err);
        childLogger.error({ error: err }, "unknown error replacing transaction");
      }
      if (e instanceof NonceTooLowError) {
        childLogger.trace({ error: e }, "nonce too low, potentially already included");
        return { status: "potentially_already_included" };
      }
      if (e instanceof FeeCapTooLowError) {
        childLogger.warn({ error: e }, "fee cap too low, not replacing");
      }
      if (e instanceof InsufficientFundsError) {
        childLogger.warn({ error: e }, "insufficient funds, not replacing");
      }
      if (e instanceof IntrinsicGasTooLowError) {
        childLogger.warn({ error: e }, "intrinsic gas too low, not replacing");
      }
      childLogger.warn({ error: e }, "error replacing transaction");
      this.markWalletProcessed(transactionInfo.executor);
      return { status: "failed" };
    }
  }
  async flushStuckTransactions() {
    const gasPrice7 = await this.gasPriceManager.getGasPrice();
    const wallets = Array.from(new Set([
      ...this.senderManager.wallets,
      this.senderManager.utilityAccount
    ]));
    const promises = wallets.map(async (wallet2) => {
      return flushStuckTransaction(this.publicClient, this.walletClient, wallet2, gasPrice7.maxFeePerGas * 5n, this.logger, this.entryPoint);
    });
    await Promise.all(promises);
  }
  async bundle(entryPoint, ops) {
    const wallet2 = await this.senderManager.getWallet();
    const opsWithHashes = ops.map((op) => {
      return {
        mempoolUserOperation: op,
        userOperationHash: getUserOperationHash(op, entryPoint, this.walletClient.chain.id)
      };
    });
    const ep = getContract({
      abi: EntryPointAbi,
      address: entryPoint,
      publicClient: this.publicClient,
      walletClient: this.walletClient
    });
    let childLogger = this.logger.child({
      userOperations: opsWithHashes.map((oh) => oh.userOperationHash),
      entryPoint
    });
    childLogger.debug("bundling user operation");
    const gasPriceParameters = await this.gasPriceManager.getGasPrice();
    childLogger.debug({ gasPriceParameters }, "got gas price");
    const nonce = await this.publicClient.getTransactionCount({
      address: wallet2.address,
      blockTag: "pending"
    });
    childLogger.trace({ nonce }, "got nonce");
    const callContext = {
      ep,
      type: "default"
    };
    let { gasLimit, simulatedOps, resubmitAllOps } = await filterOpsAndEstimateGas(callContext, wallet2, opsWithHashes, nonce, gasPriceParameters.maxFeePerGas, gasPriceParameters.maxPriorityFeePerGas, "pending", this.noEip1559Support, this.customGasLimitForEstimation, this.reputationManager, childLogger);
    gasLimit += 10000n;
    if (resubmitAllOps) {
      this.markWalletProcessed(wallet2);
      return opsWithHashes.map((owh) => {
        return {
          status: "resubmit",
          info: {
            userOpHash: owh.userOperationHash,
            userOperation: owh.mempoolUserOperation,
            reason: FeeCapTooLowError.name
          }
        };
      });
    }
    if (simulatedOps.length === 0) {
      childLogger.error("gas limit simulation encountered unexpected failure");
      this.markWalletProcessed(wallet2);
      return opsWithHashes.map((owh) => {
        return {
          status: "failure",
          error: {
            userOpHash: owh.userOperationHash,
            reason: "INTERNAL FAILURE"
          }
        };
      });
    }
    if (simulatedOps.every((op) => op.reason !== undefined)) {
      childLogger.warn("all ops failed simulation");
      this.markWalletProcessed(wallet2);
      return simulatedOps.map((op) => {
        return {
          status: "failure",
          error: {
            userOpHash: op.owh.userOperationHash,
            reason: op.reason
          }
        };
      });
    }
    const opsWithHashToBundle = simulatedOps.filter((op) => op.reason === undefined).map((op) => op.owh);
    childLogger = this.logger.child({
      userOperations: opsWithHashToBundle.map((owh) => owh.userOperationHash),
      entryPoint
    });
    childLogger.trace({ gasLimit }, "got gas limit");
    let txHash;
    try {
      const gasOptions = this.noEip1559Support ? {
        gasPrice: gasPriceParameters.maxFeePerGas
      } : {
        maxFeePerGas: gasPriceParameters.maxFeePerGas,
        maxPriorityFeePerGas: gasPriceParameters.maxPriorityFeePerGas
      };
      txHash = await ep.write.handleOps([
        opsWithHashToBundle.map((owh) => owh.mempoolUserOperation),
        wallet2.address
      ], {
        account: wallet2,
        gas: gasLimit,
        nonce,
        ...gasOptions
      });
    } catch (err) {
      sentry7.captureException(err);
      childLogger.error({ error: JSON.stringify(err) }, "error submitting bundle transaction");
      this.markWalletProcessed(wallet2);
      return opsWithHashes.map((owh) => {
        return {
          status: "failure",
          error: {
            userOpHash: owh.userOperationHash,
            reason: "INTERNAL FAILURE"
          }
        };
      });
    }
    const userOperationInfos = opsWithHashToBundle.map((op) => {
      return {
        mempoolUserOperation: op.mempoolUserOperation,
        userOperationHash: op.userOperationHash,
        lastReplaced: Date.now(),
        firstSubmitted: Date.now()
      };
    });
    const transactionInfo = {
      transactionType: "default",
      transactionHash: txHash,
      previousTransactionHashes: [],
      transactionRequest: {
        account: wallet2,
        to: ep.address,
        data: encodeFunctionData({
          abi: ep.abi,
          functionName: "handleOps",
          args: [
            opsWithHashToBundle.map((owh) => owh.mempoolUserOperation),
            wallet2.address
          ]
        }),
        gas: gasLimit,
        chain: this.walletClient.chain,
        maxFeePerGas: gasPriceParameters.maxFeePerGas,
        maxPriorityFeePerGas: gasPriceParameters.maxPriorityFeePerGas,
        nonce
      },
      executor: wallet2,
      userOperationInfos,
      lastReplaced: Date.now(),
      firstSubmitted: Date.now(),
      timesPotentiallyIncluded: 0
    };
    const userOperationResults = simulatedOpsToResults(simulatedOps, transactionInfo);
    childLogger.info({
      transactionRequest: {
        ...transactionInfo.transactionRequest,
        abi: undefined
      },
      txHash,
      opHashes: opsWithHashToBundle.map((owh) => owh.userOperationHash)
    }, "submitted bundle transaction");
    return userOperationResults;
  }
  async bundleCompressed(entryPoint, compressedOps) {
    const compressionHandler2 = this.getCompressionHandler();
    const wallet2 = await this.senderManager.getWallet();
    const childLogger = this.logger.child({
      compressedUserOperations: compressedOps,
      entryPoint: this.entryPoint
    });
    childLogger.debug("bundling compressed user operation");
    const gasPriceParameters = await this.gasPriceManager.getGasPrice();
    childLogger.debug({ gasPriceParameters }, "got gas price");
    const nonce = await this.publicClient.getTransactionCount({
      address: wallet2.address,
      blockTag: "pending"
    });
    childLogger.trace({ nonce }, "got nonce");
    const callContext = {
      publicClient: this.publicClient,
      bundleBulker: compressionHandler2.bundleBulkerAddress,
      perOpInflatorId: compressionHandler2.perOpInflatorId,
      type: "compressed"
    };
    let { gasLimit, simulatedOps, resubmitAllOps } = await filterOpsAndEstimateGas(callContext, wallet2, compressedOps.map((compressedOp) => {
      return {
        mempoolUserOperation: compressedOp,
        userOperationHash: getUserOperationHash(compressedOp.inflatedOp, entryPoint, this.walletClient.chain.id)
      };
    }), nonce, gasPriceParameters.maxFeePerGas, gasPriceParameters.maxPriorityFeePerGas, "pending", this.noEip1559Support, this.customGasLimitForEstimation, this.reputationManager, childLogger);
    gasLimit += 10000n;
    if (resubmitAllOps) {
      this.markWalletProcessed(wallet2);
      return compressedOps.map((compressedOp) => {
        return {
          status: "resubmit",
          info: {
            userOpHash: getUserOperationHash(compressedOp.inflatedOp, entryPoint, this.walletClient.chain.id),
            userOperation: compressedOp,
            reason: FeeCapTooLowError.name
          }
        };
      });
    }
    if (simulatedOps.length === 0) {
      childLogger.warn("no ops to bundle");
      this.markWalletProcessed(wallet2);
      return compressedOps.map((compressedOp) => {
        return {
          status: "failure",
          error: {
            userOpHash: getUserOperationHash(compressedOp.inflatedOp, entryPoint, this.walletClient.chain.id),
            reason: "INTERNAL FAILURE"
          }
        };
      });
    }
    if (simulatedOps.some((simulatedOp) => simulatedOp.reason !== undefined)) {
      childLogger.warn("some ops failed simulation");
      this.markWalletProcessed(wallet2);
      return simulatedOps.map((simulatedOp) => {
        return {
          status: "failure",
          error: {
            userOpHash: simulatedOp.owh.userOperationHash,
            reason: simulatedOp.reason
          }
        };
      });
    }
    const opsToBundle = simulatedOps.filter((simulatedOp) => simulatedOp.reason === undefined).map((simulatedOp) => simulatedOp.owh);
    let txHash;
    try {
      const gasOptions = this.noEip1559Support ? {
        gasPrice: gasPriceParameters.maxFeePerGas
      } : {
        maxFeePerGas: gasPriceParameters.maxFeePerGas,
        maxPriorityFeePerGas: gasPriceParameters.maxPriorityFeePerGas
      };
      txHash = await this.walletClient.sendTransaction({
        account: wallet2,
        to: compressionHandler2.bundleBulkerAddress,
        data: createCompressedCalldata(compressedOps, compressionHandler2.perOpInflatorId),
        gas: gasLimit,
        nonce,
        ...gasOptions
      });
    } catch (err) {
      sentry7.captureException(err);
      childLogger.error({ error: JSON.stringify(err) }, "error submitting bundle transaction");
      this.markWalletProcessed(wallet2);
      return opsToBundle.map((op) => {
        return {
          status: "failure",
          error: {
            userOpHash: op.userOperationHash,
            reason: "INTERNAL FAILURE"
          }
        };
      });
    }
    const userOperationInfos = opsToBundle.map((owh) => {
      return {
        mempoolUserOperation: owh.mempoolUserOperation,
        userOperationHash: owh.userOperationHash,
        lastReplaced: Date.now(),
        firstSubmitted: Date.now()
      };
    });
    const transactionInfo = {
      transactionType: "compressed",
      transactionHash: txHash,
      previousTransactionHashes: [],
      transactionRequest: {
        to: compressionHandler2.bundleBulkerAddress,
        data: createCompressedCalldata(compressedOps, compressionHandler2.perOpInflatorId),
        gas: gasLimit,
        account: wallet2,
        chain: this.walletClient.chain,
        maxFeePerGas: gasPriceParameters.maxFeePerGas,
        maxPriorityFeePerGas: gasPriceParameters.maxPriorityFeePerGas,
        nonce
      },
      executor: wallet2,
      userOperationInfos,
      lastReplaced: Date.now(),
      firstSubmitted: Date.now(),
      timesPotentiallyIncluded: 0
    };
    const userOperationResults = simulatedOpsToResults(simulatedOps, transactionInfo);
    childLogger.info({
      txHash,
      opHashes: opsToBundle.map((owh) => owh.userOperationHash)
    }, "submitted bundle transaction");
    return userOperationResults;
  }
}
// entrypoint-0.6/executor/executorManager.ts
var getTransactionsFromUserOperationEntries = function(entries) {
  return Array.from(new Set(entries.map((entry) => {
    return entry.transactionInfo;
  })));
};

class ExecutorManager {
  executor;
  mempool;
  monitor;
  publicClient;
  entryPointAddress;
  pollingInterval;
  logger;
  metrics;
  reputationManager;
  unWatch;
  currentlyHandlingBlock = false;
  timer;
  bundlerFrequency;
  gasPriceManager;
  constructor(executor, mempool6, monitor, reputationManager3, publicClient, entryPointAddress, pollingInterval, logger3, metrics2, bundleMode, bundlerFrequency, gasPriceManager2) {
    this.reputationManager = reputationManager3;
    this.executor = executor;
    this.mempool = mempool6;
    this.monitor = monitor;
    this.publicClient = publicClient;
    this.entryPointAddress = entryPointAddress;
    this.pollingInterval = pollingInterval;
    this.logger = logger3;
    this.metrics = metrics2;
    this.bundlerFrequency = bundlerFrequency;
    this.gasPriceManager = gasPriceManager2;
    if (bundleMode === "auto") {
      this.timer = setInterval(async () => {
        await this.bundle();
      }, bundlerFrequency);
    }
  }
  setBundlingMode(bundleMode) {
    if (bundleMode === "auto" && !this.timer) {
      this.timer = setInterval(async () => {
        await this.bundle();
      }, this.bundlerFrequency);
    } else if (bundleMode === "manual" && this.timer) {
      clearInterval(this.timer);
      this.timer = undefined;
    }
  }
  async bundleNow() {
    const ops = await this.mempool.process(5000000n, 1);
    if (ops.length === 0) {
      throw new Error("no ops to bundle");
    }
    const txHash = await this.sendToExecutor(ops);
    if (!txHash) {
      throw new Error("no tx hash");
    }
    return txHash;
  }
  async sendToExecutor(mempoolOps) {
    const ops = mempoolOps.filter((op) => !isCompressedType(op)).map((op) => op);
    const compressedOps = mempoolOps.filter((op) => isCompressedType(op)).map((op) => op);
    const bundles = [];
    if (ops.length > 0) {
      bundles.push(await this.executor.bundle(this.entryPointAddress, ops));
    }
    if (compressedOps.length > 0) {
      bundles.push(await this.executor.bundleCompressed(this.entryPointAddress, compressedOps));
    }
    for (const bundle of bundles) {
      const isBundleSuccess = bundle.every((result) => result.status === "success");
      if (isBundleSuccess) {
        this.metrics.bundlesSubmitted.labels({ status: "success" }).inc();
      } else {
        this.metrics.bundlesSubmitted.labels({ status: "failed" }).inc();
      }
    }
    const results = bundles.flat();
    const filteredOutOps = mempoolOps.length - results.length;
    if (filteredOutOps > 0) {
      this.logger.debug({ filteredOutOps }, "user operations filtered out");
      this.metrics.userOperationsSubmitted.labels({ status: "filtered" }).inc(filteredOutOps);
    }
    let txHash = undefined;
    for (const result of results) {
      if (result.status === "success") {
        const res = result.value;
        this.mempool.markSubmitted(res.userOperation.userOperationHash, res.transactionInfo);
        this.monitor.setUserOperationStatus(res.userOperation.userOperationHash, {
          status: "submitted",
          transactionHash: res.transactionInfo.transactionHash
        });
        txHash = res.transactionInfo.transactionHash;
        this.startWatchingBlocks(this.handleBlock.bind(this));
        this.metrics.userOperationsSubmitted.labels({ status: "success" }).inc();
      }
      if (result.status === "failure") {
        this.mempool.removeProcessing(result.error.userOpHash);
        this.monitor.setUserOperationStatus(result.error.userOpHash, {
          status: "rejected",
          transactionHash: null
        });
        this.logger.warn({
          userOpHash: result.error.userOpHash,
          reason: result.error.reason
        }, "user operation rejected");
        this.metrics.userOperationsSubmitted.labels({ status: "failed" }).inc();
      }
      if (result.status === "resubmit") {
        this.logger.info({
          userOpHash: result.info.userOpHash,
          reason: result.info.reason
        }, "resubmitting user operation");
        this.mempool.removeProcessing(result.info.userOpHash);
        this.mempool.add(result.info.userOperation);
        this.metrics.userOperationsResubmitted.inc();
      }
    }
    return txHash;
  }
  async bundle() {
    const opsToBundle = [];
    while (true) {
      const ops = await this.mempool.process(5000000n, 1);
      if (ops?.length > 0) {
        opsToBundle.push(ops);
      } else {
        break;
      }
    }
    if (opsToBundle.length === 0) {
      return;
    }
    await Promise.all(opsToBundle.map(async (ops) => {
      await this.sendToExecutor(ops);
    }));
  }
  startWatchingBlocks(handleBlock) {
    if (this.unWatch) {
      return;
    }
    this.unWatch = this.publicClient.watchBlocks({
      onBlock: handleBlock,
      onError: (error) => {
        this.logger.error({ error }, "error while watching blocks");
      },
      emitMissed: false,
      includeTransactions: false,
      pollingInterval: this.pollingInterval
    });
    this.logger.debug("started watching blocks");
  }
  stopWatchingBlocks() {
    if (this.unWatch) {
      this.logger.debug("stopped watching blocks");
      this.unWatch();
      this.unWatch = undefined;
    }
  }
  async refreshTransactionStatus(transactionInfo) {
    const hashesToCheck = [
      transactionInfo.transactionHash,
      ...transactionInfo.previousTransactionHashes
    ];
    const opInfos = transactionInfo.userOperationInfos;
    const transactionStatuses = await Promise.all(hashesToCheck.map(async (hash4) => {
      return {
        hash: hash4,
        transactionStatuses: await transactionIncluded(hash4, this.publicClient, this.entryPointAddress)
      };
    }));
    const status = transactionStatuses.find((status2) => status2.transactionStatuses.status === "included" || status2.transactionStatuses.status === "failed" || status2.transactionStatuses.status === "reverted");
    if (!status) {
      opInfos.map((info) => {
        this.logger.trace({
          userOpHash: info.userOperationHash,
          transactionHash: transactionInfo.transactionHash
        }, "user op still pending");
      });
      return;
    }
    this.metrics.userOperationsOnChain.labels({ status: status.transactionStatuses.status }).inc(opInfos.length);
    if (status.transactionStatuses.status === "included") {
      opInfos.map((info) => {
        this.metrics.userOperationInclusionDuration.observe((Date.now() - info.firstSubmitted) / 1000);
        this.reputationManager.updateUserOperationIncludedStatus(deriveUserOperation(info.mempoolUserOperation), status.transactionStatuses[info.userOperationHash].accountDeployed);
        this.mempool.removeSubmitted(info.userOperationHash);
        this.monitor.setUserOperationStatus(info.userOperationHash, {
          status: "included",
          transactionHash: status.hash
        });
        this.logger.info({
          userOpHash: info.userOperationHash,
          transactionHash: status.hash
        }, "user op included");
      });
      this.executor.markWalletProcessed(transactionInfo.executor);
    } else if (status.transactionStatuses.status === "failed" || status.transactionStatuses.status === "reverted") {
      opInfos.map((info) => {
        this.mempool.removeSubmitted(info.userOperationHash);
        this.monitor.setUserOperationStatus(info.userOperationHash, {
          status: "rejected",
          transactionHash: status.hash
        });
        this.logger.info({
          userOpHash: info.userOperationHash,
          transactionHash: status.hash
        }, "user op rejected");
      });
      this.executor.markWalletProcessed(transactionInfo.executor);
    }
  }
  async refreshUserOperationStatuses() {
    const ops = this.mempool.dumpSubmittedOps();
    const txs = getTransactionsFromUserOperationEntries(ops);
    await Promise.all(txs.map(async (txInfo) => {
      await this.refreshTransactionStatus(txInfo);
    }));
  }
  async handleBlock(block7) {
    if (this.currentlyHandlingBlock) {
      return;
    }
    this.currentlyHandlingBlock = true;
    this.logger.debug({ blockNumber: block7.number }, "handling block");
    const submittedEntries = this.mempool.dumpSubmittedOps();
    if (submittedEntries.length === 0) {
      this.stopWatchingBlocks();
      this.currentlyHandlingBlock = false;
      return;
    }
    await this.refreshUserOperationStatuses();
    const gasPriceParameters = await this.gasPriceManager.getGasPrice();
    this.logger.trace({ gasPriceParameters }, "fetched gas price parameters");
    const transactionInfos = getTransactionsFromUserOperationEntries(this.mempool.dumpSubmittedOps());
    await Promise.all(transactionInfos.map(async (txInfo) => {
      if (txInfo.transactionRequest.maxFeePerGas >= gasPriceParameters.maxFeePerGas && txInfo.transactionRequest.maxPriorityFeePerGas >= gasPriceParameters.maxPriorityFeePerGas) {
        return;
      }
      await this.replaceTransaction(txInfo, "gas_price");
    }));
    const transactionInfos2 = getTransactionsFromUserOperationEntries(this.mempool.dumpSubmittedOps());
    await Promise.all(transactionInfos2.map(async (txInfo) => {
      if (Date.now() - txInfo.lastReplaced < 300000) {
        return;
      }
      await this.replaceTransaction(txInfo, "stuck");
    }));
    this.currentlyHandlingBlock = false;
  }
  async replaceTransaction(txInfo, reason) {
    let replaceResult = undefined;
    try {
      replaceResult = await this.executor.replaceTransaction(txInfo);
    } finally {
      this.metrics.replacedTransactions.labels({ reason, status: replaceResult?.status || "failed" }).inc();
    }
    if (replaceResult.status === "failed") {
      txInfo.userOperationInfos.map((opInfo) => {
        this.mempool.removeSubmitted(opInfo.userOperationHash);
      });
      this.logger.warn({ oldTxHash: txInfo.transactionHash, reason }, "failed to replace transaction");
      return;
    }
    if (replaceResult.status === "potentially_already_included") {
      this.logger.info({ oldTxHash: txInfo.transactionHash, reason }, "transaction potentially already included");
      txInfo.timesPotentiallyIncluded += 1;
      if (txInfo.timesPotentiallyIncluded >= 3) {
        txInfo.userOperationInfos.map((opInfo) => {
          this.mempool.removeSubmitted(opInfo.userOperationHash);
        });
        this.executor.markWalletProcessed(txInfo.executor);
        this.logger.warn({ oldTxHash: txInfo.transactionHash, reason }, "transaction potentially already included too many times, removing");
      }
      return;
    }
    const newTxInfo = replaceResult.transactionInfo;
    const missingOps = txInfo.userOperationInfos.filter((info) => !newTxInfo.userOperationInfos.map((ni) => ni.userOperationHash).includes(info.userOperationHash));
    const matchingOps = txInfo.userOperationInfos.filter((info) => newTxInfo.userOperationInfos.map((ni) => ni.userOperationHash).includes(info.userOperationHash));
    matchingOps.map((opInfo) => {
      this.mempool.replaceSubmitted(opInfo, newTxInfo);
    });
    missingOps.map((opInfo) => {
      this.mempool.removeSubmitted(opInfo.userOperationHash);
      this.logger.warn({
        oldTxHash: txInfo.transactionHash,
        newTxHash: newTxInfo.transactionHash,
        reason
      }, "missing op in new tx");
    });
    this.logger.info({
      oldTxHash: txInfo.transactionHash,
      newTxHash: newTxInfo.transactionHash,
      reason
    }, "replaced transaction");
    return;
  }
}
// entrypoint-0.6/cli/setup-entrypoint-point-six.ts
var getReputationManager = ({
  client,
  parsedArgs,
  logger: logger3
}) => {
  if (parsedArgs.safeMode) {
    return new ReputationManager(client, parsedArgs.entryPoint, BigInt(parsedArgs.minStake), BigInt(parsedArgs.minUnstakeDelay), logger3.child({ module: "reputation_manager" }, {
      level: parsedArgs.reputationManagerLogLevel || parsedArgs.logLevel
    }));
  }
  return new NullReputationManager;
};
var getValidator = ({
  client,
  parsedArgs,
  logger: logger3,
  senderManager,
  metrics: metrics2,
  gasPriceManager: gasPriceManager2
}) => {
  if (parsedArgs.safeMode) {
    return new SafeValidator(client, senderManager, parsedArgs.entryPoint, logger3.child({ module: "rpc" }, { level: parsedArgs.rpcLogLevel || parsedArgs.logLevel }), metrics2, parsedArgs.utilityPrivateKey, parsedArgs.apiVersion, gasPriceManager2, parsedArgs.tenderlyEnabled, parsedArgs.balanceOverrideEnabled);
  }
  return new UnsafeValidator(client, parsedArgs.entryPoint, logger3.child({ module: "rpc" }, { level: parsedArgs.rpcLogLevel || parsedArgs.logLevel }), metrics2, parsedArgs.utilityPrivateKey, parsedArgs.apiVersion, gasPriceManager2, parsedArgs.tenderlyEnabled, parsedArgs.balanceOverrideEnabled, parsedArgs.disableExpirationCheck);
};
var getMonitor = () => {
  return new Monitor;
};
var getMempool = ({
  monitor,
  reputationManager: reputationManager3,
  validator,
  client,
  parsedArgs,
  logger: logger3,
  metrics: metrics2
}) => {
  return new MemoryMempool(monitor, reputationManager3, validator, client, parsedArgs.entryPoint, parsedArgs.safeMode, logger3.child({ module: "mempool" }, { level: parsedArgs.mempoolLogLevel || parsedArgs.logLevel }), metrics2);
};
var getCompressionHandler = async ({
  client,
  parsedArgs
}) => {
  let compressionHandler2 = null;
  if (parsedArgs.bundleBulkerAddress !== undefined && parsedArgs.perOpInflatorAddress !== undefined) {
    compressionHandler2 = await CompressionHandler.createAsync(parsedArgs.bundleBulkerAddress, parsedArgs.perOpInflatorAddress, client);
  }
  return compressionHandler2;
};
var getExecutor = ({
  client,
  walletClient,
  senderManager,
  reputationManager: reputationManager3,
  parsedArgs,
  logger: logger3,
  metrics: metrics2,
  compressionHandler: compressionHandler2,
  gasPriceManager: gasPriceManager2
}) => {
  return new BasicExecutor(client, walletClient, senderManager, reputationManager3, parsedArgs.entryPoint, logger3.child({ module: "executor" }, { level: parsedArgs.executorLogLevel || parsedArgs.logLevel }), metrics2, compressionHandler2, gasPriceManager2, !parsedArgs.tenderlyEnabled, parsedArgs.noEip1559Support, parsedArgs.customGasLimitForEstimation, parsedArgs.useUserOperationGasLimitsForSubmission);
};
var getExecutorManager = ({
  executor: executor3,
  mempool: mempool7,
  monitor,
  reputationManager: reputationManager3,
  client,
  parsedArgs,
  logger: logger3,
  metrics: metrics2,
  gasPriceManager: gasPriceManager2
}) => {
  return new ExecutorManager(executor3, mempool7, monitor, reputationManager3, client, parsedArgs.entryPoint, parsedArgs.pollingInterval, logger3.child({ module: "executor" }, { level: parsedArgs.executorLogLevel || parsedArgs.logLevel }), metrics2, parsedArgs.bundleMode, parsedArgs.bundlerFrequency, gasPriceManager2);
};
var getNonceQueuer = ({
  mempool: mempool7,
  client,
  parsedArgs,
  logger: logger3
}) => {
  return new NonceQueuer(mempool7, client, parsedArgs.entryPoint, logger3.child({ module: "nonce_queuer" }, { level: parsedArgs.nonceQueuerLogLevel || parsedArgs.logLevel }));
};
var getRpcHandler = ({
  client,
  validator,
  mempool: mempool7,
  executor: executor3,
  monitor,
  nonceQueuer: nonceQueuer2,
  executorManager: executorManager2,
  reputationManager: reputationManager3,
  parsedArgs,
  logger: logger3,
  metrics: metrics2,
  compressionHandler: compressionHandler2,
  gasPriceManager: gasPriceManager2
}) => {
  return new RpcHandler(parsedArgs.entryPoint, client, validator, mempool7, executor3, monitor, nonceQueuer2, executorManager2, reputationManager3, parsedArgs.tenderlyEnabled ?? false, parsedArgs.minimumGasPricePercent, parsedArgs.apiVersion, parsedArgs.noEthCallOverrideSupport, parsedArgs.rpcMaxBlockRange, logger3.child({ module: "rpc" }, { level: parsedArgs.rpcLogLevel || parsedArgs.logLevel }), metrics2, parsedArgs.environment, compressionHandler2, parsedArgs.noEip1559Support, gasPriceManager2, parsedArgs.dangerousSkipUserOperationValidation);
};
var getServer = ({
  rpcEndpoint,
  parsedArgs,
  logger: logger3,
  registry,
  metrics: metrics2
}) => {
  return new Server(rpcEndpoint, parsedArgs.port, parsedArgs.requestTimeout, logger3.child({ module: "rpc" }, { level: parsedArgs.rpcLogLevel || parsedArgs.logLevel }), registry, metrics2);
};
var setupEntryPointPointSix = async ({
  client,
  walletClient,
  parsedArgs,
  logger: logger3,
  rootLogger,
  registry,
  metrics: metrics2,
  senderManager,
  gasPriceManager: gasPriceManager2
}) => {
  const validator = getValidator({
    client,
    logger: logger3,
    parsedArgs,
    senderManager,
    metrics: metrics2,
    gasPriceManager: gasPriceManager2
  });
  const reputationManager3 = getReputationManager({
    client,
    parsedArgs,
    logger: logger3
  });
  await senderManager.validateAndRefillWallets(client, walletClient, parsedArgs.minBalance);
  setInterval(async () => {
    await senderManager.validateAndRefillWallets(client, walletClient, parsedArgs.minBalance);
  }, parsedArgs.refillInterval);
  const monitor = getMonitor();
  const mempool7 = getMempool({
    monitor,
    reputationManager: reputationManager3,
    validator,
    client,
    parsedArgs,
    logger: logger3,
    metrics: metrics2
  });
  const compressionHandler2 = await getCompressionHandler({
    client,
    parsedArgs
  });
  const executor3 = getExecutor({
    client,
    walletClient,
    senderManager,
    reputationManager: reputationManager3,
    parsedArgs,
    logger: logger3,
    metrics: metrics2,
    compressionHandler: compressionHandler2,
    gasPriceManager: gasPriceManager2
  });
  const executorManager2 = getExecutorManager({
    executor: executor3,
    mempool: mempool7,
    monitor,
    reputationManager: reputationManager3,
    client,
    parsedArgs,
    logger: logger3,
    metrics: metrics2,
    gasPriceManager: gasPriceManager2
  });
  const nonceQueuer2 = getNonceQueuer({ mempool: mempool7, client, parsedArgs, logger: logger3 });
  const rpcEndpoint = getRpcHandler({
    client,
    validator,
    mempool: mempool7,
    executor: executor3,
    monitor,
    nonceQueuer: nonceQueuer2,
    executorManager: executorManager2,
    reputationManager: reputationManager3,
    parsedArgs,
    logger: logger3,
    metrics: metrics2,
    compressionHandler: compressionHandler2,
    gasPriceManager: gasPriceManager2
  });
  if (parsedArgs.flushStuckTransactionsDuringStartup) {
    executor3.flushStuckTransactions();
  }
  rootLogger.info(`Initialized ${senderManager.wallets.length} executor wallets`);
  const server2 = getServer({
    rpcEndpoint,
    parsedArgs,
    logger: logger3,
    registry,
    metrics: metrics2
  });
  server2.start();
  const gracefulShutdown = async (signal) => {
    rootLogger.info(`${signal} received, shutting down`);
    await server2.stop();
    rootLogger.info("server stopped");
    const outstanding = mempool7.dumpOutstanding().length;
    const submitted = mempool7.dumpSubmittedOps().length;
    const processing = mempool7.dumpProcessing().length;
    rootLogger.info({ outstanding, submitted, processing }, "dumping mempool before shutdown");
    process.exit(0);
  };
  process.on("SIGINT", gracefulShutdown);
  process.on("SIGTERM", gracefulShutdown);
};
// executor/senderManager.ts
var waitForTransactionReceipt3 = async (publicClient, tx) => {
  try {
    return await publicClient.waitForTransactionReceipt({ hash: tx });
  } catch {
    return await waitForTransactionReceipt3(publicClient, tx);
  }
};

class SenderManager {
  wallets;
  utilityAccount;
  availableWallets;
  logger;
  metrics;
  noEip1559Support;
  semaphore;
  apiVersion;
  gasPriceManager;
  constructor(wallets, utilityAccount, logger3, metrics2, noEip1559Support, apiVersion, gasPriceManager2, maxSigners) {
    if (maxSigners !== undefined && wallets.length > maxSigners) {
      this.wallets = wallets.slice(0, maxSigners);
      this.availableWallets = wallets.slice(0, maxSigners);
    } else {
      this.wallets = wallets;
      this.availableWallets = wallets;
    }
    this.utilityAccount = utilityAccount;
    this.logger = logger3;
    this.metrics = metrics2;
    this.noEip1559Support = noEip1559Support;
    metrics2.walletsAvailable.set(this.availableWallets.length);
    metrics2.walletsTotal.set(this.wallets.length);
    this.semaphore = new Semaphore(this.availableWallets.length);
    this.apiVersion = apiVersion;
    this.gasPriceManager = gasPriceManager2;
  }
  async validateWallets(publicClient, minBalance) {
    const promises = this.availableWallets.map(async (wallet2) => {
      const balance = await publicClient.getBalance({
        address: wallet2.address
      });
      if (balance < minBalance) {
        this.logger.error({
          balance,
          requiredBalance: minBalance,
          executor: wallet2.address
        }, "wallet has insufficient balance");
        throw new Error(`wallet ${wallet2.address} has insufficient balance ${formatEther(balance)} < ${formatEther(minBalance)}`);
      }
    });
    await Promise.all(promises);
  }
  async validateAndRefillWallets(publicClient, walletClient, minBalance) {
    const utilityWalletBalance = await publicClient.getBalance({
      address: this.utilityAccount.address
    });
    const balancesMissing = {};
    const balanceRequestPromises = this.availableWallets.map(async (wallet2) => {
      const balance = await publicClient.getBalance({
        address: wallet2.address
      });
      if (balance < minBalance) {
        const missingBalance = minBalance * 6n / 5n - balance;
        balancesMissing[wallet2.address] = missingBalance;
      }
    });
    await Promise.all(balanceRequestPromises);
    const totalBalanceMissing = Object.values(balancesMissing).reduce((a, b) => a + b, 0n);
    if (utilityWalletBalance < totalBalanceMissing * 11n / 10n) {
      this.logger.info({ balancesMissing, totalBalanceMissing }, "balances missing");
      this.logger.error({ utilityWalletBalance, totalBalanceMissing }, "utility wallet has insufficient balance to refill wallets");
      throw new Error(`utility wallet ${this.utilityAccount.address} has insufficient balance ${formatEther(utilityWalletBalance)} < ${formatEther(totalBalanceMissing)}`);
    }
    if (Object.keys(balancesMissing).length > 0) {
      const { maxFeePerGas, maxPriorityFeePerGas } = await this.gasPriceManager.getGasPrice();
      if (walletClient.chain.id === 59140 || walletClient.chain.id === 137 || walletClient.chain.id === 10) {
        const instructions = [];
        for (const [address10, missingBalance] of Object.entries(balancesMissing)) {
          instructions.push({
            to: address10,
            value: missingBalance,
            data: "0x"
          });
        }
        let refillAddress;
        if (walletClient.chain.id === 59140) {
          refillAddress = "0xEad1aC3DF6F96b91491d6396F4d1610C5638B4Db";
        } else if (walletClient.chain.id === 137) {
          refillAddress = "0x3402DB43152dAB9ab72fa805fdD5f391cD3E3822";
        } else {
          refillAddress = "0x3402DB43152dAB9ab72fa805fdD5f391cD3E3822";
        }
        const callEngine = getContract({
          abi: CallEngineAbi,
          address: refillAddress,
          publicClient,
          walletClient
        });
        const tx = await callEngine.write.execute([instructions], {
          account: this.utilityAccount,
          value: totalBalanceMissing,
          maxFeePerGas: maxFeePerGas * 2n,
          maxPriorityFeePerGas: maxPriorityFeePerGas * 2n
        });
        await waitForTransactionReceipt3(publicClient, tx);
        for (const [address10, missingBalance] of Object.entries(balancesMissing)) {
          this.logger.info({ tx, executor: address10, missingBalance }, "refilled wallet");
        }
      } else {
        for (const [address10, missingBalance] of Object.entries(balancesMissing)) {
          const tx = await walletClient.sendTransaction({
            account: this.utilityAccount,
            to: address10,
            value: missingBalance,
            maxFeePerGas: this.noEip1559Support ? undefined : maxFeePerGas,
            maxPriorityFeePerGas: this.noEip1559Support ? undefined : maxPriorityFeePerGas,
            gasPrice: this.noEip1559Support ? maxFeePerGas : undefined
          });
          await waitForTransactionReceipt3(publicClient, tx);
          this.logger.info({ tx, executor: address10, missingBalance }, "refilled wallet");
        }
      }
    } else {
      this.logger.info("no wallets need to be refilled");
    }
  }
  async getWallet() {
    this.logger.trace(`waiting for semaphore with count ${this.semaphore.getValue()}`);
    await this.semaphore.waitForUnlock();
    await this.semaphore.acquire();
    const wallet2 = this.apiVersion === "v1" ? this.availableWallets.shift() : this.availableWallets.pop();
    if (!wallet2) {
      this.semaphore.release();
      this.logger.error("no more wallets");
      throw new Error("no more wallets");
    }
    this.logger.trace({ executor: wallet2.address }, "got wallet from sender manager");
    this.metrics.walletsAvailable.set(this.availableWallets.length);
    return wallet2;
  }
  pushWallet(wallet2) {
    this.apiVersion === "v1" ? this.availableWallets.push(wallet2) : this.availableWallets.unshift(wallet2);
    this.semaphore.release();
    this.logger.trace({ executor: wallet2.address }, "pushed wallet to sender manager");
    this.metrics.walletsAvailable.set(this.availableWallets.length);
    return;
  }
}
// entrypoint-0.7/utils/userop.ts
var sentry8 = __toESM(require_cjs4(), 1);
function getInitCode(unpackedUserOperation) {
  return unpackedUserOperation.factory ? concat([
    unpackedUserOperation.factory,
    unpackedUserOperation.factoryData || "0x"
  ]) : "0x";
}
function unPackInitCode(initCode) {
  if (initCode === "0x") {
    return {
      factory: null,
      factoryData: null
    };
  }
  return {
    factory: getAddress(slice(initCode, 0, 20)),
    factoryData: slice(initCode, 20)
  };
}
function getAccountGasLimits(unpackedUserOperation) {
  return concat([
    pad(toHex2(unpackedUserOperation.verificationGasLimit), {
      size: 16
    }),
    pad(toHex2(unpackedUserOperation.callGasLimit), { size: 16 })
  ]);
}
function unpackAccountGasLimits(accountGasLimits) {
  return {
    verificationGasLimit: BigInt(slice(accountGasLimits, 0, 16)),
    callGasLimit: BigInt(slice(accountGasLimits, 16))
  };
}
function getGasLimits(unpackedUserOperation) {
  return concat([
    pad(toHex2(unpackedUserOperation.maxPriorityFeePerGas), {
      size: 16
    }),
    pad(toHex2(unpackedUserOperation.maxFeePerGas), { size: 16 })
  ]);
}
function unpackGasLimits(gasLimits) {
  return {
    maxPriorityFeePerGas: BigInt(slice(gasLimits, 0, 16)),
    maxFeePerGas: BigInt(slice(gasLimits, 16))
  };
}
function getPaymasterAndData(unpackedUserOperation) {
  return unpackedUserOperation.paymaster ? concat([
    unpackedUserOperation.paymaster,
    pad(toHex2(unpackedUserOperation.paymasterVerificationGasLimit || 0n), {
      size: 16
    }),
    pad(toHex2(unpackedUserOperation.paymasterPostOpGasLimit || 0n), {
      size: 16
    }),
    unpackedUserOperation.paymasterData || "0x"
  ]) : "0x";
}
function unpackPaymasterAndData(paymasterAndData) {
  if (paymasterAndData === "0x") {
    return {
      paymaster: null,
      paymasterVerificationGasLimit: null,
      paymasterPostOpGasLimit: null,
      paymasterData: null
    };
  }
  return {
    paymaster: getAddress(slice(paymasterAndData, 0, 20)),
    paymasterVerificationGasLimit: BigInt(slice(paymasterAndData, 20, 36)),
    paymasterPostOpGasLimit: BigInt(slice(paymasterAndData, 36, 52)),
    paymasterData: slice(paymasterAndData, 52)
  };
}
function toPackedUserOperation(unpackedUserOperation) {
  return {
    sender: unpackedUserOperation.sender,
    nonce: unpackedUserOperation.nonce,
    initCode: getInitCode(unpackedUserOperation),
    callData: unpackedUserOperation.callData,
    accountGasLimits: getAccountGasLimits(unpackedUserOperation),
    preVerificationGas: unpackedUserOperation.preVerificationGas,
    gasFees: getGasLimits(unpackedUserOperation),
    paymasterAndData: getPaymasterAndData(unpackedUserOperation),
    signature: unpackedUserOperation.signature
  };
}
function toUnPackedUserOperation(packedUserOperation) {
  const { factory, factoryData } = unPackInitCode(packedUserOperation.initCode);
  const { callGasLimit, verificationGasLimit } = unpackAccountGasLimits(packedUserOperation.accountGasLimits);
  const { maxFeePerGas, maxPriorityFeePerGas } = unpackGasLimits(packedUserOperation.gasFees);
  const {
    paymaster,
    paymasterVerificationGasLimit,
    paymasterPostOpGasLimit,
    paymasterData
  } = unpackPaymasterAndData(packedUserOperation.paymasterAndData);
  return {
    sender: packedUserOperation.sender,
    nonce: packedUserOperation.nonce,
    factory,
    factoryData,
    callData: packedUserOperation.callData,
    callGasLimit,
    verificationGasLimit,
    preVerificationGas: packedUserOperation.preVerificationGas,
    maxFeePerGas,
    maxPriorityFeePerGas,
    paymaster,
    paymasterVerificationGasLimit,
    paymasterPostOpGasLimit,
    paymasterData,
    signature: packedUserOperation.signature
  };
}
function deepHexlify2(obj) {
  if (typeof obj === "function") {
    return;
  }
  if (obj == null || typeof obj === "string" || typeof obj === "boolean") {
    return obj;
  }
  if (typeof obj === "bigint") {
    return toHex2(obj);
  }
  if (obj._isBigNumber != null || typeof obj !== "object") {
    return toHex2(obj).replace(/^0x0/, "0x");
  }
  if (Array.isArray(obj)) {
    return obj.map((member) => deepHexlify2(member));
  }
  return Object.keys(obj).reduce((set, key) => {
    set[key] = deepHexlify2(obj[key]);
    return set;
  }, {});
}
var transactionIncluded2 = async (txHash, publicClient) => {
  try {
    const rcp = await publicClient.getTransactionReceipt({ hash: txHash });
    if (rcp.status === "success") {
      const r = rcp.logs.map((l) => {
        if (l.address === rcp.to) {
          try {
            const log7 = decodeEventLog({
              abi: EntryPointAbi2,
              data: l.data,
              topics: l.topics
            });
            if (log7.eventName === "AccountDeployed") {
              return {
                userOperationHash: log7.args.userOpHash,
                success: !!log7.args.factory,
                accountDeployed: true
              };
            }
            if (log7.eventName === "UserOperationEvent") {
              return {
                userOperationHash: log7.args.userOpHash,
                success: !!log7.args.success,
                accountDeployed: false
              };
            }
            return;
          } catch (_e) {
            sentry8.captureException(_e);
            return;
          }
        }
        return;
      }).reduce((result, log7) => {
        if (log7) {
          result[log7.userOperationHash] = {
            userOperationHash: log7.userOperationHash,
            accountDeployed: log7.accountDeployed || result[log7.userOperationHash]?.accountDeployed,
            success: log7.success || result[log7.userOperationHash]?.success
          };
          return result;
        }
        return result;
      }, {});
      const success = Object.values(r).reduce((x, v) => x || v.success, false);
      if (success) {
        return {
          status: "included",
          ...r
        };
      }
      return {
        status: "reverted"
      };
    }
    return {
      status: "failed"
    };
  } catch (_e) {
    return {
      status: "not_found"
    };
  }
};
var getUserOperationHash2 = (userOperation, entryPointAddress, chainId) => {
  const hash4 = keccak256(encodeAbiParameters([
    {
      name: "sender",
      type: "address"
    },
    {
      name: "nonce",
      type: "uint256"
    },
    {
      name: "initCodeHash",
      type: "bytes32"
    },
    {
      name: "callDataHash",
      type: "bytes32"
    },
    {
      name: "accountGasLimits",
      type: "bytes32"
    },
    {
      name: "preVerificationGas",
      type: "uint256"
    },
    {
      name: "gasFees",
      type: "bytes32"
    },
    {
      name: "paymasterAndDataHash",
      type: "bytes32"
    }
  ], [
    userOperation.sender,
    userOperation.nonce,
    keccak256(userOperation.initCode),
    keccak256(userOperation.callData),
    userOperation.accountGasLimits,
    userOperation.preVerificationGas,
    userOperation.gasFees,
    keccak256(userOperation.paymasterAndData)
  ]));
  return keccak256(encodeAbiParameters([
    {
      name: "userOpHash",
      type: "bytes32"
    },
    {
      name: "entryPointAddress",
      type: "address"
    },
    {
      name: "chainId",
      type: "uint256"
    }
  ], [hash4, entryPointAddress, BigInt(chainId)]));
};
var getNonceKeyAndValue2 = (nonce) => {
  const nonceKey = nonce >> 64n;
  const userOperationNonceValue = nonce & 0xffffffffffffffffn;
  return [nonceKey, userOperationNonceValue];
};
// entrypoint-0.7/utils/validation.ts
function packUserOp2(op) {
  const packedUserOperation = toPackedUserOperation(op);
  const randomDataUserOp = packedUserOperationToRandomDataUserOp(packedUserOperation);
  return encodeAbiParameters([
    {
      internalType: "address",
      name: "sender",
      type: "address"
    },
    {
      internalType: "uint256",
      name: "nonce",
      type: "uint256"
    },
    {
      internalType: "bytes",
      name: "initCode",
      type: "bytes"
    },
    {
      internalType: "bytes",
      name: "callData",
      type: "bytes"
    },
    {
      internalType: "uint256",
      name: "accountGasLimits",
      type: "bytes32"
    },
    {
      internalType: "uint256",
      name: "preVerificationGas",
      type: "uint256"
    },
    {
      internalType: "uint256",
      name: "gasFees",
      type: "bytes32"
    },
    {
      internalType: "bytes",
      name: "paymasterAndData",
      type: "bytes"
    },
    {
      internalType: "bytes",
      name: "signature",
      type: "bytes"
    }
  ], [
    randomDataUserOp.sender,
    randomDataUserOp.nonce,
    packedUserOperation.initCode,
    packedUserOperation.callData,
    randomDataUserOp.accountGasLimits,
    randomDataUserOp.preVerificationGas,
    randomDataUserOp.gasFees,
    randomDataUserOp.paymasterAndData,
    randomDataUserOp.signature
  ]);
}
function packedUserOperationToRandomDataUserOp(packedUserOperation) {
  return {
    sender: packedUserOperation.sender,
    nonce: BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"),
    initCode: packedUserOperation.initCode,
    callData: packedUserOperation.callData,
    accountGasLimits: bytesToHex(new Uint8Array(32).fill(255)),
    preVerificationGas: BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"),
    gasFees: bytesToHex(new Uint8Array(32).fill(255)),
    paymasterAndData: bytesToHex(new Uint8Array(packedUserOperation.paymasterAndData.length).fill(255)),
    signature: bytesToHex(new Uint8Array(packedUserOperation.signature.length).fill(255))
  };
}
async function calcPreVerificationGas2(publicClient, userOperation, entryPoint, chainId, overheads) {
  let preVerificationGas = calcDefaultPreVerificationGas2(userOperation, overheads);
  if (chainId === 59140 || chainId === 59142) {
    preVerificationGas *= 2n;
  } else if (chainId === optimism.id || chainId === optimismSepolia.id || chainId === optimismGoerli.id || chainId === base29.id || chainId === baseGoerli.id || chainId === baseSepolia.id || chainId === opBNB.id || chainId === opBNBTestnet.id || chainId === 957) {
    preVerificationGas = await calcOptimismPreVerificationGas2(publicClient, userOperation, entryPoint, preVerificationGas);
  } else if (chainId === arbitrum.id || chainId === arbitrumNova.id || chainId === arbitrumSepolia.id) {
    preVerificationGas = await calcArbitrumPreVerificationGas2(publicClient, userOperation, entryPoint, preVerificationGas);
  }
  return preVerificationGas;
}
async function calcVerificationGasAndCallGasLimit2(publicClient, userOperation, executionResult, chainId) {
  const verificationGasLimit = (executionResult.preOpGas - userOperation.preVerificationGas) * 3n / 2n;
  let gasPrice7;
  if (userOperation.maxPriorityFeePerGas === userOperation.maxFeePerGas) {
    gasPrice7 = userOperation.maxFeePerGas;
  } else {
    const blockBaseFee = (await publicClient.getBlock()).baseFeePerGas;
    gasPrice7 = userOperation.maxFeePerGas < (blockBaseFee ?? 0n) + userOperation.maxPriorityFeePerGas ? userOperation.maxFeePerGas : userOperation.maxPriorityFeePerGas + (blockBaseFee ?? 0n);
  }
  const calculatedCallGasLimit = executionResult.paid / gasPrice7 - executionResult.preOpGas + 21000n + 50000n;
  let callGasLimit = calculatedCallGasLimit > 9000n ? calculatedCallGasLimit : 9000n;
  if (chainId === baseGoerli.id || chainId === baseSepolia.id || chainId === base29.id) {
    callGasLimit = 110n * callGasLimit / 100n;
  }
  if (userOperation.callData === "0x") {
    callGasLimit = 0n;
  }
  return [verificationGasLimit, callGasLimit];
}
function calcDefaultPreVerificationGas2(userOperation, overheads) {
  const ov = { ...DefaultGasOverheads2, ...overheads ?? {} };
  const uop = {
    ...userOperation
  };
  uop.preVerificationGas;
  uop.signature = uop.signature === "0x" ? toHex2(Buffer.alloc(ov.sigSize, 1)) : uop.signature;
  const packedUserOperation = packUserOp2(uop);
  const packed = toBytes2(packedUserOperation);
  const lengthInWord = (packed.length + 31) / 32;
  const callDataCost = packed.map((x) => x === 0 ? ov.zeroByte : ov.nonZeroByte).reduce((sum, x) => sum + x);
  const ret2 = Math.round(callDataCost + ov.fixed / ov.bundleSize + ov.perUserOp + ov.perUserOpWord * lengthInWord);
  return BigInt(ret2);
}
async function calcOptimismPreVerificationGas2(publicClient, op, entryPoint, staticFee) {
  const packedUserOperation = toPackedUserOperation(op);
  const randomDataUserOp = packedUserOperationToRandomDataUserOp(packedUserOperation);
  const selector = getFunctionSelector(EntryPointAbi2[28]);
  const paramData = encodeAbiParameters(EntryPointAbi2[28].inputs, [
    [randomDataUserOp],
    entryPoint
  ]);
  const data3 = concat([selector, paramData]);
  const latestBlock = await publicClient.getBlock();
  if (latestBlock.baseFeePerGas === null) {
    throw new RpcError3("block does not have baseFeePerGas");
  }
  const serializedTx = serializeTransaction({
    to: entryPoint,
    chainId: publicClient.chain.id,
    nonce: 999999,
    gasLimit: maxUint642,
    gasPrice: maxUint642,
    data: data3
  }, {
    r: "0x123451234512345123451234512345123451234512345123451234512345",
    s: "0x123451234512345123451234512345123451234512345123451234512345",
    v: 28n
  });
  const opGasPriceOracle = getContract({
    abi: getL1FeeAbi2,
    address: "0x420000000000000000000000000000000000000F",
    publicClient
  });
  const { result: l1Fee } = await opGasPriceOracle.simulate.getL1Fee([
    serializedTx
  ]);
  const l2MaxFee = op.maxFeePerGas;
  const l2PriorityFee = latestBlock.baseFeePerGas + op.maxPriorityFeePerGas;
  const l2price = l2MaxFee < l2PriorityFee ? l2MaxFee : l2PriorityFee;
  return staticFee + l1Fee / l2price;
}
async function calcArbitrumPreVerificationGas2(publicClient, op, entryPoint, staticFee) {
  const packedUserOperation = toPackedUserOperation(op);
  const randomDataUserOp = packedUserOperationToRandomDataUserOp(packedUserOperation);
  const selector = getFunctionSelector(EntryPointAbi2[28]);
  const paramData = encodeAbiParameters(EntryPointAbi2[28].inputs, [
    [randomDataUserOp],
    entryPoint
  ]);
  const data3 = concat([selector, paramData]);
  const precompileAddress = "0x00000000000000000000000000000000000000C8";
  const serializedTx = serializeTransaction({
    to: entryPoint,
    chainId: publicClient.chain?.id ?? 10,
    nonce: 999999,
    gasLimit: maxUint642,
    gasPrice: maxUint642,
    data: data3
  }, {
    r: "0x123451234512345123451234512345123451234512345123451234512345",
    s: "0x123451234512345123451234512345123451234512345123451234512345",
    v: 28n
  });
  const arbGasPriceOracle = getContract({
    abi: getArbitrumL1FeeAbi2,
    address: precompileAddress,
    publicClient
  });
  const { result } = await arbGasPriceOracle.simulate.gasEstimateL1Component([
    entryPoint,
    false,
    serializedTx
  ]);
  return result[0] + staticFee;
}
function parseViemError2(err) {
  if (err instanceof ContractFunctionExecutionError || err instanceof TransactionExecutionError) {
    const e = err.cause;
    if (e instanceof NonceTooLowError) {
      return e;
    }
    if (e instanceof FeeCapTooLowError) {
      return e;
    }
    if (e instanceof InsufficientFundsError) {
      return e;
    }
    if (e instanceof IntrinsicGasTooLowError) {
      return e;
    }
    if (e instanceof ContractFunctionRevertedError) {
      return e;
    }
    if (e instanceof EstimateGasExecutionError) {
      return e;
    }
    return;
  }
  return;
}
var DefaultGasOverheads2 = {
  fixed: 21000,
  perUserOp: 18300,
  perUserOpWord: 4,
  zeroByte: 4,
  nonZeroByte: 16,
  bundleSize: 1,
  sigSize: 65
};
var maxUint642 = 2n ** 64n - 1n;
var getL1FeeAbi2 = [
  {
    inputs: [
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "getL1Fee",
    outputs: [
      {
        internalType: "uint256",
        name: "fee",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "l1BaseFee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
];
var getArbitrumL1FeeAbi2 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "bool",
        name: "contractCreation",
        type: "bool"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "gasEstimateL1Component",
    outputs: [
      {
        internalType: "uint64",
        name: "gasEstimateForL1",
        type: "uint64"
      },
      {
        internalType: "uint256",
        name: "baseFee",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "l1BaseFeeEstimate",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
// entrypoint-0.7/utils/compressionHandler.ts
class CompressionHandler2 {
  bundleBulkerAddress;
  perOpInflatorAddress;
  perOpInflatorId;
  constructor(bundleBulkerAddress, perOpInflatorAddress, perOpInflatorId) {
    this.bundleBulkerAddress = bundleBulkerAddress;
    this.perOpInflatorAddress = perOpInflatorAddress;
    this.perOpInflatorId = perOpInflatorId;
  }
  static createAsync = async (bundleBulkerAddress, perOpInflatorAddress, publicClient) => {
    const compressionHandler2 = new CompressionHandler2(bundleBulkerAddress, perOpInflatorAddress, 0);
    const bundleBulker = getContract({
      address: bundleBulkerAddress,
      abi: BundleBulkerAbi2,
      publicClient
    });
    compressionHandler2.perOpInflatorId = await bundleBulker.read.inflatorToID([perOpInflatorAddress]);
    if (compressionHandler2.perOpInflatorId === 0) {
      throw new Error(`PerOpInflator (${perOpInflatorAddress}) is not registered with BundleBulker (${bundleBulkerAddress})`);
    }
    return compressionHandler2;
  };
  async getInflatorRegisteredId(inflator, publicClient) {
    const perOpInflator = getContract({
      address: this.perOpInflatorAddress,
      abi: PerOpInfaltorAbi2,
      publicClient
    });
    return await perOpInflator.read.inflatorToID([inflator]);
  }
}
// entrypoint-0.7/mempool/reputationManager.ts
var EntityType2;
(function(EntityType3) {
  EntityType3["Account"] = "Account";
  EntityType3["Paymaster"] = "Paymaster";
  EntityType3["Factory"] = "Factory";
  EntityType3["Aggregator"] = "Aggregator";
})(EntityType2 || (EntityType2 = {}));
var ReputationStatuses2 = {
  ok: 0n,
  throttled: 1n,
  banned: 2n
};
var BundlerReputationParams2 = {
  minInclusionDenominator: 10n,
  throttlingSlack: 10n,
  banSlack: 50n
};

class NullReputationManager2 {
  checkReputation(_userOperation, _validationResult) {
    return Promise.resolve();
  }
  increaseUserOperationCount(_) {
    return;
  }
  decreaseUserOperationCount(_) {
    return;
  }
  updateUserOperationSeenStatus(_) {
    return;
  }
  updateUserOperationIncludedStatus(_, __2) {
    return;
  }
  crashedHandleOps(_, __2) {
    return;
  }
  setReputation(_) {
    return;
  }
  dumpReputations() {
    return [];
  }
  getStatus(_address) {
    throw new Error("Method not implemented.");
  }
  getStakeStatus(_) {
    throw new Error("Method not implemented.");
  }
  clear() {
    return;
  }
  clearEntityCount() {
    return;
  }
}

class ReputationManager2 {
  publicClient;
  entryPoint;
  minStake;
  minUnstakeDelay;
  entityCount = {};
  throttledEntityMinMempoolCount;
  maxMempoolUserOperationsPerSender;
  maxMempoolUserOperationsPerNewUnstakedEntity;
  inclusionRateFactor;
  entries = {};
  whitelist = new Set;
  blackList = new Set;
  bundlerReputationParams;
  logger;
  constructor(publicClient, entryPoint, minStake, minUnstakeDelay, logger3, maxMempoolUserOperationsPerNewUnstakedEntity, throttledEntityMinMempoolCount, inclusionRateFactor, maxMempoolUserOperationsPerSender, blackList, whiteList, bundlerReputationParams) {
    this.publicClient = publicClient;
    this.entryPoint = entryPoint;
    this.minStake = minStake;
    this.minUnstakeDelay = minUnstakeDelay;
    this.logger = logger3;
    this.maxMempoolUserOperationsPerNewUnstakedEntity = maxMempoolUserOperationsPerNewUnstakedEntity ?? 10n;
    this.inclusionRateFactor = inclusionRateFactor ?? 10n;
    this.throttledEntityMinMempoolCount = throttledEntityMinMempoolCount ?? 4n;
    this.maxMempoolUserOperationsPerSender = maxMempoolUserOperationsPerSender ?? 4n;
    this.bundlerReputationParams = bundlerReputationParams ?? BundlerReputationParams2;
    for (const address10 of blackList || []) {
      this.blackList.add(address10);
    }
    for (const address10 of whiteList || []) {
      this.whitelist.add(address10);
    }
  }
  setReputation(reputations) {
    for (const reputation of reputations) {
      const address10 = getAddress(reputation.address);
      this.entries[address10] = {
        address: address10,
        opsSeen: BigInt(reputation.opsSeen),
        opsIncluded: BigInt(reputation.opsIncluded)
      };
    }
    this.logger.debug({
      reputations: this.entries
    }, "Reputation set");
  }
  dumpReputations() {
    return Object.values(this.entries).map((entry) => ({
      ...entry,
      status: this.getStatus(entry.address)
    }));
  }
  clear() {
    this.entries = {};
    this.entityCount = {};
  }
  clearEntityCount() {
    this.entityCount = {};
  }
  async getStakeStatus(address10) {
    const entryPoint = getContract({
      abi: EntryPointAbi2,
      address: this.entryPoint,
      publicClient: this.publicClient
    });
    const stakeInfo = await entryPoint.read.getDepositInfo([address10]);
    const stake = BigInt(stakeInfo.stake);
    const unstakeDelaySec = BigInt(stakeInfo.unstakeDelaySec);
    const isStaked = stake >= this.minStake && unstakeDelaySec >= this.minUnstakeDelay;
    return {
      stakeInfo: {
        addr: address10,
        stake,
        unstakeDelaySec
      },
      isStaked
    };
  }
  checkReputation(userOperation, validationResult) {
    this.increaseUserOperationCount(userOperation);
    this.checkReputationStatus(EntityType2.Account, validationResult.senderInfo, this.maxMempoolUserOperationsPerSender);
    if (validationResult.paymasterInfo) {
      this.checkReputationStatus(EntityType2.Paymaster, validationResult.paymasterInfo);
    }
    if (validationResult.factoryInfo) {
      this.checkReputationStatus(EntityType2.Factory, validationResult.factoryInfo);
    }
    const aggregatorValidationResult = validationResult;
    if (aggregatorValidationResult.aggregatorInfo) {
      this.checkReputationStatus(EntityType2.Aggregator, aggregatorValidationResult.aggregatorInfo.stakeInfo);
    }
    return Promise.resolve();
  }
  getEntityCount(address10) {
    return this.entityCount[address10] ?? 0;
  }
  increaseSeen(address10) {
    const entry = this.entries[address10];
    if (!entry) {
      this.entries[address10] = {
        address: address10,
        opsSeen: 1n,
        opsIncluded: 0n
      };
      return;
    }
    entry.opsSeen++;
  }
  updateCrashedHandleOps(address10) {
    const entry = this.entries[address10];
    if (!entry) {
      this.entries[address10] = {
        address: address10,
        opsSeen: 1000n,
        opsIncluded: 0n
      };
      return;
    }
    entry.opsSeen = 1000n;
    entry.opsIncluded = 0n;
  }
  crashedHandleOps(op, reason) {
    if (reason.startsWith("AA3")) {
      if (op.paymaster) {
        this.updateCrashedHandleOps(op.paymaster);
      }
    } else if (reason.startsWith("AA2")) {
      const sender = op.sender;
      this.updateCrashedHandleOps(sender);
    } else if (reason.startsWith("AA1")) {
      if (op.factory) {
        this.updateCrashedHandleOps(op.factory);
      }
    }
  }
  updateIncludedStatus(address10) {
    const entry = this.entries[address10];
    if (!entry) {
      this.entries[address10] = {
        address: address10,
        opsSeen: 0n,
        opsIncluded: 1n
      };
      return;
    }
    entry.opsIncluded++;
  }
  updateUserOperationIncludedStatus(userOperation, accountDeployed) {
    const sender = userOperation.sender;
    this.updateIncludedStatus(sender);
    if (userOperation.paymaster) {
      this.updateIncludedStatus(userOperation.paymaster);
    }
    if (accountDeployed) {
      if (userOperation.factory) {
        this.updateIncludedStatus(userOperation.factory);
      }
    }
  }
  updateUserOperationSeenStatus(userOperation) {
    const sender = userOperation.sender;
    this.increaseSeen(sender);
    if (userOperation.paymaster) {
      this.increaseSeen(userOperation.paymaster);
    }
    if (userOperation.factory) {
      this.increaseSeen(userOperation.factory);
    }
  }
  increaseUserOperationCount(userOperation) {
    const sender = userOperation.sender;
    this.entityCount[sender] = (this.entityCount[sender] ?? 0n) + 1n;
    if (userOperation.paymaster) {
      this.entityCount[userOperation.paymaster] = (this.entityCount[userOperation.paymaster] ?? 0n) + 1n;
    }
    if (userOperation.factory) {
      this.entityCount[userOperation.factory] = (this.entityCount[userOperation.factory] ?? 0n) + 1n;
    }
  }
  decreaseUserOperationCount(userOperation) {
    const sender = userOperation.sender;
    this.entityCount[sender] = (this.entityCount[sender] ?? 0n) - 1n;
    this.entityCount[sender] = this.entityCount[sender] < 0n ? 0n : this.entityCount[sender];
    const paymaster = userOperation.paymaster;
    if (paymaster) {
      this.entityCount[paymaster] = (this.entityCount[paymaster] ?? 0n) - 1n;
      this.entityCount[paymaster] = this.entityCount[paymaster] < 0n ? 0n : this.entityCount[paymaster];
    }
    const factory = userOperation.factory;
    if (factory) {
      this.entityCount[factory] = (this.entityCount[factory] ?? 0n) - 1n;
      this.entityCount[factory] = this.entityCount[factory] < 0n ? 0n : this.entityCount[factory];
    }
  }
  checkReputationStatus(entityType, stakeInfo, maxMempoolUserOperationsPerSenderOverride) {
    const maxTxMempoolAllowedEntity = maxMempoolUserOperationsPerSenderOverride ?? this.calCulateMaxMempoolUserOperationsPerEntity(stakeInfo.addr);
    this.checkBanned(entityType, stakeInfo);
    const entityCount = this.getEntityCount(stakeInfo.addr);
    if (entityCount > this.throttledEntityMinMempoolCount) {
      this.checkThrottled(entityType, stakeInfo);
    }
    if (entityCount > maxTxMempoolAllowedEntity) {
      this.checkStake(entityType, stakeInfo);
    }
  }
  getStatus(address10) {
    if (!address10 || this.whitelist.has(address10)) {
      return ReputationStatuses2.ok;
    }
    if (this.blackList.has(address10)) {
      return ReputationStatuses2.banned;
    }
    const entry = this.entries[address10];
    if (!entry) {
      return ReputationStatuses2.ok;
    }
    const minExpectedIncluded = entry.opsSeen / this.bundlerReputationParams.minInclusionDenominator;
    this.logger.debug({
      address: address10,
      minExpectedIncluded,
      opsSeen: entry.opsSeen,
      minInclusionDenominator: this.bundlerReputationParams.minInclusionDenominator,
      opsIncluded: entry.opsIncluded,
      throttlingSlack: this.bundlerReputationParams.throttlingSlack,
      banSlack: this.bundlerReputationParams.banSlack
    }, "minExpectedIncluded");
    if (minExpectedIncluded <= entry.opsIncluded + this.bundlerReputationParams.throttlingSlack) {
      entry.status = ReputationStatuses2.ok;
      return ReputationStatuses2.ok;
    }
    if (minExpectedIncluded <= entry.opsIncluded + this.bundlerReputationParams.banSlack) {
      entry.status = ReputationStatuses2.throttled;
      return ReputationStatuses2.throttled;
    }
    entry.status = ReputationStatuses2.banned;
    return ReputationStatuses2.banned;
  }
  checkBanned(entityType, stakeInfo) {
    const status = this.getStatus(stakeInfo.addr);
    if (status === ReputationStatuses2.banned) {
      throw new RpcError3(`${entityType} ${stakeInfo.addr} is banned from using the pimlico`, ValidationErrors2.Reputation);
    }
  }
  checkThrottled(entityType, stakeInfo) {
    const status = this.getStatus(stakeInfo.addr);
    if (status === ReputationStatuses2.throttled) {
      throw new RpcError3(`${entityType} ${stakeInfo.addr} is throttled by the pimlico`, ValidationErrors2.Reputation);
    }
  }
  isWhiteListed(address10) {
    return this.whitelist.has(address10);
  }
  checkStake(entityType, stakeInfo) {
    if (this.isWhiteListed(stakeInfo.addr)) {
      return;
    }
    this.checkBanned(entityType, stakeInfo);
    if (stakeInfo.stake < this.minStake) {
      if (stakeInfo.stake === 0n) {
        throw new RpcError3(`${entityType} ${stakeInfo.addr} is unstaked and must stake minimum ${this.minStake} to use pimlico`, ValidationErrors2.InsufficientStake);
      }
      throw new RpcError3(`${entityType} ${stakeInfo.addr} does not have enough stake to use pimlico`, ValidationErrors2.InsufficientStake);
    }
    if (stakeInfo.unstakeDelaySec < this.minUnstakeDelay) {
      throw new RpcError3(`${entityType} ${stakeInfo.addr} does not have enough unstake delay to use pimlico`, ValidationErrors2.InsufficientStake);
    }
  }
  calCulateMaxMempoolUserOperationsPerEntity(address10) {
    const entry = this.entries[address10];
    if (!entry) {
      return this.maxMempoolUserOperationsPerNewUnstakedEntity;
    }
    let inclusionRate = 0n;
    if (entry.opsSeen !== 0n) {
      inclusionRate = entry.opsIncluded / entry.opsSeen;
    }
    return this.maxMempoolUserOperationsPerNewUnstakedEntity + inclusionRate * this.inclusionRateFactor + (entry.opsIncluded > 10000n ? 10000n : entry.opsIncluded);
  }
}

// entrypoint-0.7/mempool/store.ts
class MemoryStore2 {
  outstandingUserOperations = [];
  processingUserOperations = [];
  submittedUserOperations = [];
  logger;
  metrics;
  constructor(logger3, metrics2) {
    this.logger = logger3;
    this.metrics = metrics2;
  }
  addOutstanding(op) {
    const store2 = this.outstandingUserOperations;
    store2.push(op);
    this.logger.debug({ userOpHash: op.userOperationHash, store: "outstanding" }, "added user op to mempool");
    this.metrics.userOperationsInMempool.labels({
      status: "outstanding"
    }).inc();
  }
  addProcessing(op) {
    const store2 = this.processingUserOperations;
    store2.push(op);
    this.logger.debug({ userOpHash: op.userOperationHash, store: "processing" }, "added user op to mempool");
    this.metrics.userOperationsInMempool.labels({
      status: "processing"
    }).inc();
  }
  addSubmitted(op) {
    const store2 = this.submittedUserOperations;
    store2.push(op);
    this.logger.debug({
      userOpHash: op.userOperation.userOperationHash,
      store: "submitted"
    }, "added user op to submitted mempool");
    this.metrics.userOperationsInMempool.labels({
      status: "submitted"
    }).inc();
  }
  removeOutstanding(userOpHash) {
    const index2 = this.outstandingUserOperations.findIndex((op) => op.userOperationHash === userOpHash);
    if (index2 === -1) {
      this.logger.warn({ userOpHash, store: "outstanding" }, "tried to remove non-existent user op from mempool");
      return;
    }
    this.outstandingUserOperations.splice(index2, 1);
    this.logger.debug({ userOpHash, store: "outstanding" }, "removed user op from mempool");
    this.metrics.userOperationsInMempool.labels({
      status: "outstanding"
    }).dec();
  }
  removeProcessing(userOpHash) {
    const index2 = this.processingUserOperations.findIndex((op) => op.userOperationHash === userOpHash);
    if (index2 === -1) {
      this.logger.warn({ userOpHash, store: "outstanding" }, "tried to remove non-existent user op from mempool");
      return;
    }
    this.processingUserOperations.splice(index2, 1);
    this.logger.debug({ userOpHash, store: "processing" }, "removed user op from mempool");
    this.metrics.userOperationsInMempool.labels({
      status: "processing"
    }).dec();
  }
  removeSubmitted(userOpHash) {
    const index2 = this.submittedUserOperations.findIndex((op) => op.userOperation.userOperationHash === userOpHash);
    if (index2 === -1) {
      this.logger.warn({ userOpHash, store: "submitted" }, "tried to remove non-existent user op from mempool");
      return;
    }
    this.submittedUserOperations.splice(index2, 1);
    this.logger.debug({ userOpHash, store: "submitted" }, "removed user op from mempool");
    this.metrics.userOperationsInMempool.labels({
      status: "submitted"
    }).dec();
  }
  dumpOutstanding() {
    this.logger.trace({
      store: "outstanding",
      length: this.outstandingUserOperations.length
    }, "dumping mempool");
    return this.outstandingUserOperations;
  }
  dumpProcessing() {
    this.logger.trace({
      store: "processing",
      length: this.processingUserOperations.length
    }, "dumping mempool");
    return this.processingUserOperations;
  }
  dumpSubmitted() {
    this.logger.trace({ store: "submitted", length: this.submittedUserOperations.length }, "dumping mempool");
    return this.submittedUserOperations;
  }
  clear(from) {
    if (from === "outstanding") {
      this.outstandingUserOperations = [];
      this.logger.debug({ store: from, length: this.outstandingUserOperations.length }, "clearing mempool");
    } else if (from === "processing") {
      this.processingUserOperations = [];
      this.logger.debug({ store: from, length: this.processingUserOperations.length }, "clearing mempool");
    } else if (from === "submitted") {
      this.submittedUserOperations = [];
      this.logger.debug({ store: from, length: this.submittedUserOperations.length }, "clearing mempool");
    } else {
      throw new Error("unreachable");
    }
  }
}

// entrypoint-0.7/mempool/mempool.ts
class MemoryMempool2 {
  monitor;
  publicClient;
  entryPointAddress;
  reputationManager;
  store;
  throttledEntityBundleCount;
  logger;
  validator;
  safeMode;
  constructor(monitor, reputationManager4, validator, publicClient, entryPointAddress, safeMode, logger3, metrics2, throttledEntityBundleCount) {
    this.reputationManager = reputationManager4;
    this.monitor = monitor;
    this.validator = validator;
    this.publicClient = publicClient;
    this.entryPointAddress = entryPointAddress;
    this.safeMode = safeMode;
    this.logger = logger3;
    this.store = new MemoryStore2(logger3, metrics2);
    this.throttledEntityBundleCount = throttledEntityBundleCount ?? 4;
  }
  replaceSubmitted(userOperation, transactionInfo) {
    const op = this.store.dumpSubmitted().find((op2) => op2.userOperation.userOperationHash === userOperation.userOperationHash);
    if (op) {
      this.store.removeSubmitted(userOperation.userOperationHash);
      this.store.addSubmitted({
        userOperation,
        transactionInfo
      });
      this.monitor.setUserOperationStatus(userOperation.userOperationHash, {
        status: "submitted",
        transactionHash: transactionInfo.transactionHash
      });
    }
  }
  markSubmitted(userOpHash, transactionInfo) {
    const op = this.store.dumpProcessing().find((op2) => op2.userOperationHash === userOpHash);
    if (op) {
      this.store.removeProcessing(userOpHash);
      this.store.addSubmitted({
        userOperation: op,
        transactionInfo
      });
      this.monitor.setUserOperationStatus(userOpHash, {
        status: "submitted",
        transactionHash: transactionInfo.transactionHash
      });
    }
  }
  dumpOutstanding() {
    return this.store.dumpOutstanding();
  }
  dumpProcessing() {
    return this.store.dumpProcessing();
  }
  dumpSubmittedOps() {
    return this.store.dumpSubmitted();
  }
  removeSubmitted(userOpHash) {
    this.store.removeSubmitted(userOpHash);
  }
  removeProcessing(userOpHash) {
    this.store.removeProcessing(userOpHash);
  }
  async checkEntityMultipleRoleViolation(op) {
    if (!this.safeMode) {
      return;
    }
    const knownEntities = this.getKnownEntities();
    if (knownEntities.paymasters.has(op.sender) || knownEntities.factories.has(op.sender)) {
      throw new RpcError3(`The sender address "${op.sender}" is used as a different entity in another UserOperation currently in mempool`, ValidationErrors2.OpcodeValidation);
    }
    if (op.paymaster && knownEntities.sender.has(op.paymaster)) {
      throw new RpcError3(`A Paymaster at ${op.paymaster} in this UserOperation is used as a sender entity in another UserOperation currently in mempool.`, ValidationErrors2.OpcodeValidation);
    }
    if (op.factory && knownEntities.sender.has(op.factory)) {
      throw new RpcError3(`A Factory at ${op.factory} in this UserOperation is used as a sender entity in another UserOperation currently in mempool.`, ValidationErrors2.OpcodeValidation);
    }
  }
  getKnownEntities() {
    const allOps = [...this.store.dumpOutstanding()];
    const entities = {
      sender: new Set,
      paymasters: new Set,
      factories: new Set
    };
    for (const mempoolOp of allOps) {
      const op = deriveUserOperation2(mempoolOp.mempoolUserOperation);
      entities.sender.add(op.sender);
      if (op.paymaster) {
        entities.paymasters.add(op.paymaster);
      }
      if (op.factory) {
        entities.factories.add(op.factory);
      }
    }
    return entities;
  }
  add(mempoolUserOperation, referencedContracts) {
    const op = deriveUserOperation2(mempoolUserOperation);
    const outstandingOps = [...this.store.dumpOutstanding()];
    const processedOrSubmittedOps = [
      ...this.store.dumpProcessing(),
      ...this.store.dumpSubmitted().map((sop) => sop.userOperation)
    ];
    if (processedOrSubmittedOps.find((uo) => {
      const userOp = deriveUserOperation2(uo.mempoolUserOperation);
      return userOp.sender === op.sender && userOp.nonce === op.nonce;
    })) {
      return false;
    }
    this.reputationManager.updateUserOperationSeenStatus(op);
    const oldUserOp = outstandingOps.find((uo) => {
      const userOp = deriveUserOperation2(uo.mempoolUserOperation);
      return userOp.sender === op.sender && userOp.nonce === op.nonce;
    });
    if (oldUserOp) {
      const oldOp = deriveUserOperation2(oldUserOp.mempoolUserOperation);
      const oldMaxPriorityFeePerGas = oldOp.maxPriorityFeePerGas;
      const newMaxPriorityFeePerGas = op.maxPriorityFeePerGas;
      const oldMaxFeePerGas = oldOp.maxFeePerGas;
      const newMaxFeePerGas = op.maxFeePerGas;
      const incrementMaxPriorityFeePerGas = oldMaxPriorityFeePerGas * BigInt(10) / BigInt(100);
      const incrementMaxFeePerGas = oldMaxFeePerGas * BigInt(10) / BigInt(100);
      if (newMaxPriorityFeePerGas < oldMaxPriorityFeePerGas + incrementMaxPriorityFeePerGas || newMaxFeePerGas < oldMaxFeePerGas + incrementMaxFeePerGas) {
        return false;
      }
      this.store.removeOutstanding(oldUserOp.userOperationHash);
    }
    const hash4 = getUserOperationHash2(toPackedUserOperation(op), this.entryPointAddress, this.publicClient.chain.id);
    this.store.addOutstanding({
      mempoolUserOperation,
      userOperationHash: hash4,
      firstSubmitted: oldUserOp ? oldUserOp.firstSubmitted : Date.now(),
      lastReplaced: Date.now(),
      referencedContracts
    });
    this.monitor.setUserOperationStatus(hash4, {
      status: "not_submitted",
      transactionHash: null
    });
    return true;
  }
  async shouldSkip(opInfo, paymasterDeposit, stakedEntityCount, knownEntities, senders, storageMap) {
    const op = deriveUserOperation2(opInfo.mempoolUserOperation);
    if (!this.safeMode) {
      return {
        skip: false,
        paymasterDeposit,
        stakedEntityCount,
        knownEntities,
        senders,
        storageMap
      };
    }
    const paymaster = op.paymaster;
    const factory = op.factory;
    const paymasterStatus = this.reputationManager.getStatus(paymaster);
    const factoryStatus = this.reputationManager.getStatus(factory);
    if (paymasterStatus === ReputationStatuses2.banned || factoryStatus === ReputationStatuses2.banned) {
      this.store.removeOutstanding(opInfo.userOperationHash);
      return {
        skip: true,
        paymasterDeposit,
        stakedEntityCount,
        knownEntities,
        senders,
        storageMap
      };
    }
    if (paymasterStatus === ReputationStatuses2.throttled && paymaster && stakedEntityCount[paymaster] >= this.throttledEntityBundleCount) {
      this.logger.trace({
        paymaster,
        opHash: opInfo.userOperationHash
      }, "Throttled paymaster skipped");
      return {
        skip: true,
        paymasterDeposit,
        stakedEntityCount,
        knownEntities,
        senders,
        storageMap
      };
    }
    if (factoryStatus === ReputationStatuses2.throttled && factory && stakedEntityCount[factory] >= this.throttledEntityBundleCount) {
      this.logger.trace({
        factory,
        opHash: opInfo.userOperationHash
      }, "Throttled factory skipped");
      return {
        skip: true,
        paymasterDeposit,
        stakedEntityCount,
        knownEntities,
        senders,
        storageMap
      };
    }
    if (senders.has(op.sender)) {
      this.logger.trace({
        sender: op.sender,
        opHash: opInfo.userOperationHash
      }, "Sender skipped because already included in bundle");
      return {
        skip: true,
        paymasterDeposit,
        stakedEntityCount,
        knownEntities,
        senders,
        storageMap
      };
    }
    let validationResult;
    try {
      validationResult = await this.validator.validateUserOperation(op, opInfo.referencedContracts);
    } catch (e) {
      this.logger.error({
        opHash: opInfo.userOperationHash,
        error: JSON.stringify(e)
      }, "2nd Validation error");
      this.store.removeOutstanding(opInfo.userOperationHash);
      return {
        skip: true,
        paymasterDeposit,
        stakedEntityCount,
        knownEntities,
        senders,
        storageMap
      };
    }
    for (const storageAddress of Object.keys(validationResult.storageMap)) {
      const address10 = getAddress(storageAddress);
      if (address10 !== op.sender && knownEntities.sender.has(address10)) {
        this.logger.trace({
          storageAddress,
          opHash: opInfo.userOperationHash
        }, "Storage address skipped");
        return {
          skip: true,
          paymasterDeposit,
          stakedEntityCount,
          knownEntities,
          senders,
          storageMap
        };
      }
    }
    if (paymaster) {
      if (paymasterDeposit[paymaster] === undefined) {
        const entryPointContract = getContract({
          abi: EntryPointAbi2,
          address: this.entryPointAddress,
          publicClient: this.publicClient
        });
        paymasterDeposit[paymaster] = await entryPointContract.read.balanceOf([paymaster]);
      }
      if (paymasterDeposit[paymaster] < validationResult.returnInfo.prefund) {
        this.logger.trace({
          paymaster,
          opHash: opInfo.userOperationHash
        }, "Paymaster skipped because of insufficient balance left to sponsor all user ops in the bundle");
        return {
          skip: true,
          paymasterDeposit,
          stakedEntityCount,
          knownEntities,
          senders,
          storageMap
        };
      }
      stakedEntityCount[paymaster] = (stakedEntityCount[paymaster] ?? 0) + 1;
      paymasterDeposit[paymaster] -= validationResult.returnInfo.prefund;
    }
    if (factory) {
      stakedEntityCount[factory] = (stakedEntityCount[factory] ?? 0) + 1;
    }
    senders.add(op.sender);
    return {
      skip: false,
      paymasterDeposit,
      stakedEntityCount,
      knownEntities,
      senders,
      storageMap
    };
  }
  async process(maxGasLimit, minOps) {
    const outstandingUserOperations = this.store.dumpOutstanding().slice();
    let opsTaken = 0;
    let gasUsed = 0n;
    const result = [];
    let paymasterDeposit = {};
    let stakedEntityCount = {};
    let senders = new Set;
    let knownEntities = this.getKnownEntities();
    let storageMap = {};
    for (const opInfo of outstandingUserOperations) {
      const op = deriveUserOperation2(opInfo.mempoolUserOperation);
      gasUsed += op.callGasLimit + op.verificationGasLimit * 3n + op.preVerificationGas;
      if (gasUsed > maxGasLimit && opsTaken >= (minOps || 0)) {
        break;
      }
      const skipResult = await this.shouldSkip(opInfo, paymasterDeposit, stakedEntityCount, knownEntities, senders, storageMap);
      paymasterDeposit = skipResult.paymasterDeposit;
      stakedEntityCount = skipResult.stakedEntityCount;
      knownEntities = skipResult.knownEntities;
      senders = skipResult.senders;
      storageMap = skipResult.storageMap;
      if (skipResult.skip) {
        continue;
      }
      this.reputationManager.decreaseUserOperationCount(op);
      this.store.removeOutstanding(opInfo.userOperationHash);
      this.store.addProcessing(opInfo);
      result.push(opInfo.mempoolUserOperation);
      opsTaken++;
    }
    return result;
  }
  get(opHash) {
    const outstanding = this.store.dumpOutstanding().find((op) => op.userOperationHash === opHash);
    if (outstanding) {
      return deriveUserOperation2(outstanding.mempoolUserOperation);
    }
    const submitted = this.store.dumpSubmitted().find((op) => op.userOperation.userOperationHash === opHash);
    if (submitted) {
      return deriveUserOperation2(submitted.userOperation.mempoolUserOperation);
    }
    return null;
  }
  clear() {
    this.store.clear("outstanding");
  }
}
// entrypoint-0.7/mempool/monitoring.ts
class Monitor2 {
  userOperationToStatus;
  userOperationTimeouts;
  timeout;
  constructor(timeout = 3600000) {
    this.timeout = timeout;
    this.userOperationToStatus = {};
    this.userOperationTimeouts = {};
  }
  setUserOperationStatus(userOperation, status) {
    if (this.userOperationTimeouts[userOperation]) {
      clearTimeout(this.userOperationTimeouts[userOperation]);
    }
    this.userOperationToStatus[userOperation] = status;
    this.userOperationTimeouts[userOperation] = setTimeout(() => {
      delete this.userOperationToStatus[userOperation];
      delete this.userOperationTimeouts[userOperation];
    }, this.timeout);
  }
  getUserOperationStatus(userOperation) {
    const status = this.userOperationToStatus[userOperation];
    if (status === undefined) {
      return {
        status: "not_found",
        transactionHash: null
      };
    }
    return status;
  }
}
// entrypoint-0.7/rpc/rpcHandler.ts
var import_zod_validation_error4 = __toESM(require_cjs5(), 1);

class RpcHandler2 {
  entryPoint;
  publicClient;
  validator;
  mempool;
  executor;
  monitor;
  nonceQueuer;
  usingTenderly;
  minimumGasPricePercent;
  apiVersion;
  noEthCallOverrideSupport;
  rpcMaxBlockRange;
  logger;
  metrics;
  chainId;
  environment;
  executorManager;
  reputationManager;
  compressionHandler;
  noEip1559Support;
  dangerousSkipUserOperationValidation;
  gasPriceManager;
  constructor(entryPoint, publicClient, validator, mempool8, executor3, monitor, nonceQueuer2, executorManager2, reputationManager5, usingTenderly, minimumGasPricePercent, apiVersion, noEthCallOverrideSupport, rpcMaxBlockRange, logger3, metrics2, environment, compressionHandler3, noEip1559Support, gasPriceManager2, dangerousSkipUserOperationValidation = false) {
    this.entryPoint = entryPoint;
    this.publicClient = publicClient;
    this.validator = validator;
    this.mempool = mempool8;
    this.executor = executor3;
    this.monitor = monitor;
    this.nonceQueuer = nonceQueuer2;
    this.usingTenderly = usingTenderly;
    this.minimumGasPricePercent = minimumGasPricePercent;
    this.apiVersion = apiVersion;
    this.noEthCallOverrideSupport = noEthCallOverrideSupport;
    this.rpcMaxBlockRange = rpcMaxBlockRange;
    this.logger = logger3;
    this.metrics = metrics2;
    this.environment = environment;
    this.chainId = publicClient.chain.id;
    this.executorManager = executorManager2;
    this.reputationManager = reputationManager5;
    this.compressionHandler = compressionHandler3;
    this.noEip1559Support = noEip1559Support;
    this.gasPriceManager = gasPriceManager2;
    this.dangerousSkipUserOperationValidation = dangerousSkipUserOperationValidation;
  }
  async handleMethod(request5) {
    const method = request5.method;
    switch (method) {
      case "eth_chainId":
        return {
          method,
          result: this.eth_chainId(...request5.params)
        };
      case "eth_supportedEntryPoints":
        return {
          method,
          result: this.eth_supportedEntryPoints(...request5.params)
        };
      case "eth_estimateUserOperationGas":
        return {
          method,
          result: await this.eth_estimateUserOperationGas(request5.params[0], request5.params[1], request5.params[2])
        };
      case "eth_sendUserOperation":
        return {
          method,
          result: await this.eth_sendUserOperation(...request5.params)
        };
      case "eth_getUserOperationByHash":
        return {
          method,
          result: await this.eth_getUserOperationByHash(...request5.params)
        };
      case "eth_getUserOperationReceipt":
        return {
          method,
          result: await this.eth_getUserOperationReceipt(...request5.params)
        };
      case "debug_bundler_clearMempool":
        return {
          method,
          result: this.debug_bundler_clearMempool(...request5.params)
        };
      case "debug_bundler_clearState":
        return {
          method,
          result: this.debug_bundler_clearState(...request5.params)
        };
      case "debug_bundler_dumpMempool":
        return {
          method,
          result: await this.debug_bundler_dumpMempool(...request5.params)
        };
      case "debug_bundler_sendBundleNow":
        return {
          method,
          result: await this.debug_bundler_sendBundleNow(...request5.params)
        };
      case "debug_bundler_setBundlingMode":
        return {
          method,
          result: this.debug_bundler_setBundlingMode(...request5.params)
        };
      case "debug_bundler_setReputation":
        return {
          method,
          result: this.debug_bundler_setReputation(request5.params)
        };
      case "debug_bundler_dumpReputation":
        return {
          method,
          result: this.debug_bundler_dumpReputation(...request5.params)
        };
      case "debug_bundler_getStakeStatus":
        return {
          method,
          result: await this.debug_bundler_getStakeStatus(...request5.params)
        };
      case "pimlico_getUserOperationStatus":
        return {
          method,
          result: this.pimlico_getUserOperationStatus(...request5.params)
        };
      case "pimlico_getUserOperationGasPrice":
        return {
          method,
          result: await this.pimlico_getUserOperationGasPrice(...request5.params)
        };
      case "pimlico_sendCompressedUserOperation":
        return {
          method,
          result: await this.pimlico_sendCompressedUserOperation(...request5.params)
        };
    }
  }
  eth_chainId() {
    return BigInt(this.chainId);
  }
  eth_supportedEntryPoints() {
    return [this.entryPoint];
  }
  async eth_estimateUserOperationGas(userOperation, entryPoint, stateOverrides) {
    if (this.entryPoint !== entryPoint) {
      throw new RpcError3(`EntryPoint ${entryPoint} not supported, supported EntryPoints: ${this.entryPoint}`);
    }
    if (userOperation.maxFeePerGas === 0n) {
      throw new RpcError3("user operation max fee per gas must be larger than 0 during gas estimation");
    }
    let preVerificationGas = await calcPreVerificationGas2(this.publicClient, userOperation, entryPoint, this.chainId);
    if (this.chainId === optimism.id || this.chainId === optimismSepolia.id || this.chainId === optimismGoerli.id || this.chainId === base29.id || this.chainId === baseGoerli.id || this.chainId === baseSepolia.id || this.chainId === opBNB.id || this.chainId === opBNBTestnet.id || this.chainId === 957 || this.chainId === arbitrum.id || this.chainId === arbitrumNova.id) {
      preVerificationGas = preVerificationGas * 130n / 100n;
    }
    userOperation.preVerificationGas = 1000000n;
    userOperation.verificationGasLimit = 10000000n;
    userOperation.callGasLimit = 10000000n;
    userOperation.paymasterPostOpGasLimit = 2000000n;
    userOperation.paymasterVerificationGasLimit = 5000000n;
    userOperation.maxPriorityFeePerGas = userOperation.maxFeePerGas;
    if (this.chainId === base29.id) {
      userOperation.verificationGasLimit = 2500000n;
      userOperation.callGasLimit = 2500000n;
    }
    if (this.chainId === celoAlfajores.id || this.chainId === celo.id) {
      userOperation.verificationGasLimit = 1000000n;
      userOperation.callGasLimit = 1000000n;
    }
    const executionResult = await this.validator.getExecutionResult(userOperation, stateOverrides);
    const [verificationGasLimit, callGasLimit] = await calcVerificationGasAndCallGasLimit2(this.publicClient, userOperation, executionResult, this.chainId);
    if (this.apiVersion === "v2") {
      return {
        preVerificationGas,
        verificationGasLimit,
        callGasLimit,
        paymasterVerificationGasLimit: verificationGasLimit,
        paymasterPostOpGasLimit: verificationGasLimit
      };
    }
    return {
      preVerificationGas,
      verificationGasLimit,
      callGasLimit
    };
  }
  async eth_sendUserOperation(userOperation, entryPoint) {
    let status = "rejected";
    try {
      status = await this.addToMempoolIfValid(userOperation, entryPoint);
      const hash4 = getUserOperationHash2(toPackedUserOperation(userOperation), entryPoint, this.chainId);
      return hash4;
    } catch (error) {
      status = "rejected";
      throw error;
    } finally {
      this.metrics.userOperationsReceived.labels({
        status,
        type: "regular"
      }).inc();
    }
  }
  async eth_getUserOperationByHash(userOperationHash) {
    const userOperationEventAbiItem = getAbiItem({
      abi: EntryPointAbi2,
      name: "UserOperationEvent"
    });
    let fromBlock = undefined;
    let toBlock = undefined;
    if (this.rpcMaxBlockRange !== undefined) {
      const latestBlock = await this.publicClient.getBlockNumber();
      fromBlock = latestBlock - BigInt(this.rpcMaxBlockRange);
      if (fromBlock < 0n) {
        fromBlock = 0n;
      }
      toBlock = "latest";
    }
    const filterResult = await this.publicClient.getLogs({
      address: this.entryPoint,
      event: userOperationEventAbiItem,
      fromBlock,
      toBlock,
      args: {
        userOpHash: userOperationHash
      }
    });
    if (filterResult.length === 0) {
      return null;
    }
    const userOperationEvent = filterResult[0];
    const txHash = userOperationEvent.transactionHash;
    if (txHash === null) {
      return null;
    }
    const getTransaction5 = async (txHash2) => {
      try {
        return await this.publicClient.getTransaction({ hash: txHash2 });
      } catch (e) {
        if (e instanceof TransactionNotFoundError) {
          return getTransaction5(txHash2);
        }
        throw e;
      }
    };
    const tx = await getTransaction5(txHash);
    let op = undefined;
    try {
      const decoded = decodeFunctionData({
        abi: EntryPointAbi2,
        data: tx.input
      });
      if (decoded.functionName !== "handleOps") {
        return null;
      }
      const ops = decoded.args[0];
      op = ops.find((op2) => op2.sender === userOperationEvent.args.sender && op2.nonce === userOperationEvent.args.nonce);
    } catch {
      return null;
    }
    if (op === undefined) {
      return null;
    }
    const result = {
      userOperation: toUnPackedUserOperation(op),
      entryPoint: this.entryPoint,
      transactionHash: txHash,
      blockHash: tx.blockHash ?? "0x",
      blockNumber: BigInt(tx.blockNumber ?? 0n)
    };
    return result;
  }
  async eth_getUserOperationReceipt(userOperationHash) {
    const userOperationEventAbiItem = getAbiItem({
      abi: EntryPointAbi2,
      name: "UserOperationEvent"
    });
    let fromBlock = undefined;
    let toBlock = undefined;
    if (this.rpcMaxBlockRange !== undefined) {
      const latestBlock = await this.publicClient.getBlockNumber();
      fromBlock = latestBlock - BigInt(this.rpcMaxBlockRange);
      if (fromBlock < 0n) {
        fromBlock = 0n;
      }
      toBlock = "latest";
    }
    const filterResult = await this.publicClient.getLogs({
      address: this.entryPoint,
      event: userOperationEventAbiItem,
      fromBlock,
      toBlock,
      args: {
        userOpHash: userOperationHash
      }
    });
    if (filterResult.length === 0) {
      return null;
    }
    const userOperationEvent = filterResult[0];
    if (userOperationEvent.args.actualGasCost === undefined || userOperationEvent.args.sender === undefined || userOperationEvent.args.nonce === undefined || userOperationEvent.args.userOpHash === undefined || userOperationEvent.args.success === undefined || userOperationEvent.args.paymaster === undefined || userOperationEvent.args.actualGasUsed === undefined) {
      throw new Error("userOperationEvent has undefined members");
    }
    const txHash = userOperationEvent.transactionHash;
    if (txHash === null) {
      return null;
    }
    const getTransactionReceipt4 = async (txHash2) => {
      while (true) {
        try {
          return await this.publicClient.getTransactionReceipt({
            hash: txHash2
          });
        } catch (e) {
          if (e instanceof TransactionReceiptNotFoundError) {
            continue;
          }
          throw e;
        }
      }
    };
    const receipt = await getTransactionReceipt4(txHash);
    const logs = receipt.logs;
    if (logs.some((log7) => log7.blockHash === null || log7.blockNumber === null || log7.transactionIndex === null || log7.transactionHash === null || log7.logIndex === null || log7.topics.length === 0)) {
      return null;
    }
    let startIndex = -1;
    let endIndex = -1;
    logs.forEach((log7, index2) => {
      if (log7?.topics[0] === userOperationEvent.topics[0]) {
        if (log7.topics[1] === userOperationEvent.topics[1]) {
          endIndex = index2;
        } else if (endIndex === -1) {
          startIndex = index2;
        }
      }
    });
    if (endIndex === -1) {
      throw new Error("fatal: no UserOperationEvent in logs");
    }
    const filteredLogs = logs.slice(startIndex + 1, endIndex);
    const logsParsing = z.array(logSchema2).safeParse(filteredLogs);
    if (!logsParsing.success) {
      const err = import_zod_validation_error4.fromZodError(logsParsing.error);
      throw err;
    }
    const receiptParsing = receiptSchema2.safeParse({
      ...receipt,
      status: receipt.status === "success" ? 1 : 0
    });
    if (!receiptParsing.success) {
      const err = import_zod_validation_error4.fromZodError(receiptParsing.error);
      throw err;
    }
    const userOperationReceipt = {
      userOpHash: userOperationHash,
      sender: userOperationEvent.args.sender,
      nonce: userOperationEvent.args.nonce,
      actualGasUsed: userOperationEvent.args.actualGasUsed,
      actualGasCost: userOperationEvent.args.actualGasCost,
      success: userOperationEvent.args.success,
      logs: logsParsing.data,
      receipt: receiptParsing.data
    };
    return userOperationReceipt;
  }
  debug_bundler_clearState() {
    if (this.environment !== "development") {
      throw new RpcError3("debug_bundler_clearState is only available in development environment");
    }
    this.mempool.clear();
    this.reputationManager.clear();
    return "ok";
  }
  debug_bundler_clearMempool() {
    if (this.environment !== "development") {
      throw new RpcError3("debug_bundler_clearMempool is only available in development environment");
    }
    this.mempool.clear();
    this.reputationManager.clearEntityCount();
    return "ok";
  }
  async debug_bundler_dumpMempool(entryPoint) {
    if (this.environment !== "development") {
      throw new RpcError3("debug_bundler_dumpMempool is only available in development environment");
    }
    if (this.entryPoint !== entryPoint) {
      throw new RpcError3(`EntryPoint ${entryPoint} not supported, supported EntryPoints: ${this.entryPoint}`);
    }
    return this.mempool.dumpOutstanding().map((userOpInfo) => deriveUserOperation2(userOpInfo.mempoolUserOperation));
  }
  debug_bundler_sendBundleNow() {
    if (this.environment !== "development") {
      throw new RpcError3("debug_bundler_sendBundleNow is only available in development environment");
    }
    return this.executorManager.bundleNow();
  }
  debug_bundler_setBundlingMode(bundlingMode) {
    if (this.environment !== "development") {
      throw new RpcError3("debug_bundler_setBundlingMode is only available in development environment");
    }
    this.executorManager.setBundlingMode(bundlingMode);
    return "ok";
  }
  debug_bundler_dumpReputation(entryPoint) {
    if (this.environment !== "development") {
      throw new RpcError3("debug_bundler_setRe is only available in development environment");
    }
    if (this.entryPoint !== entryPoint) {
      throw new RpcError3(`EntryPoint ${entryPoint} not supported, supported EntryPoints: ${this.entryPoint}`);
    }
    return this.reputationManager.dumpReputations();
  }
  async debug_bundler_getStakeStatus(address10, entryPoint) {
    if (this.environment !== "development") {
      throw new RpcError3("debug_bundler_getStakeStatus is only available in development environment");
    }
    if (this.entryPoint !== entryPoint) {
      throw new RpcError3(`EntryPoint ${entryPoint} not supported, supported EntryPoints: ${this.entryPoint}`);
    }
    return bundlerGetStakeStatusResponseSchema2.parse({
      method: "debug_bundler_getStakeStatus",
      result: await this.reputationManager.getStakeStatus(address10)
    }).result;
  }
  debug_bundler_setReputation(args) {
    if (this.environment !== "development") {
      throw new RpcError3("debug_bundler_setReputation is only available in development environment");
    }
    this.reputationManager.setReputation(args[0]);
    return "ok";
  }
  pimlico_getUserOperationStatus(userOperationHash) {
    return this.monitor.getUserOperationStatus(userOperationHash);
  }
  async pimlico_getUserOperationGasPrice() {
    const gasPrice7 = await this.gasPriceManager.getGasPrice();
    return {
      slow: {
        maxFeePerGas: gasPrice7.maxFeePerGas * 105n / 100n,
        maxPriorityFeePerGas: gasPrice7.maxPriorityFeePerGas * 105n / 100n
      },
      standard: {
        maxFeePerGas: gasPrice7.maxFeePerGas * 110n / 100n,
        maxPriorityFeePerGas: gasPrice7.maxPriorityFeePerGas * 110n / 100n
      },
      fast: {
        maxFeePerGas: gasPrice7.maxFeePerGas * 115n / 100n,
        maxPriorityFeePerGas: gasPrice7.maxPriorityFeePerGas * 115n / 100n
      }
    };
  }
  async addToMempoolIfValid(op, entryPoint) {
    const userOperation = deriveUserOperation2(op);
    if (this.entryPoint !== entryPoint) {
      throw new RpcError3(`EntryPoint ${entryPoint} not supported, supported EntryPoints: ${this.entryPoint}`);
    }
    if (this.chainId === celoAlfajores.id || this.chainId === celo.id) {
      if (userOperation.maxFeePerGas !== userOperation.maxPriorityFeePerGas) {
        throw new RpcError3("maxPriorityFeePerGas must equal maxFeePerGas on Celo chains");
      }
    }
    this.gasPriceManager.validateGasPrice({
      maxFeePerGas: userOperation.maxFeePerGas,
      maxPriorityFeePerGas: userOperation.maxPriorityFeePerGas
    });
    if (userOperation.verificationGasLimit < 10000n) {
      throw new RpcError3("verificationGasLimit must be at least 10000");
    }
    this.logger.trace({ userOperation, entryPoint }, "beginning validation");
    if (userOperation.preVerificationGas === 0n || userOperation.verificationGasLimit === 0n) {
      throw new RpcError3("user operation gas limits must be larger than 0");
    }
    const entryPointContract = getContract({
      address: this.entryPoint,
      abi: EntryPointAbi2,
      publicClient: this.publicClient
    });
    const [nonceKey, userOperationNonceValue] = getNonceKeyAndValue2(userOperation.nonce);
    const getNonceResult = await entryPointContract.read.getNonce([userOperation.sender, nonceKey], {
      blockTag: "latest"
    });
    const [_, currentNonceValue] = getNonceKeyAndValue2(getNonceResult);
    if (userOperationNonceValue < currentNonceValue) {
      throw new RpcError3("UserOperation reverted during simulation with reason: AA25 invalid account nonce", ValidationErrors2.InvalidFields);
    }
    if (userOperationNonceValue > currentNonceValue + 10n) {
      throw new RpcError3("UserOperation reverted during simulation with reason: AA25 invalid account nonce", ValidationErrors2.InvalidFields);
    }
    if (userOperationNonceValue === currentNonceValue) {
      if (this.dangerousSkipUserOperationValidation) {
        const success = this.mempool.add(userOperation);
        if (!success) {
          throw new RpcError3("UserOperation reverted during simulation with reason: AA25 invalid account nonce", ValidationErrors2.InvalidFields);
        }
      } else {
        await this.validator.validatePreVerificationGas(userOperation);
        const validationResult = await this.validator.validateUserOperation(userOperation);
        await this.reputationManager.checkReputation(userOperation, validationResult);
        await this.mempool.checkEntityMultipleRoleViolation(userOperation);
        const success = this.mempool.add(op, validationResult.referencedContracts);
        if (!success) {
          throw new RpcError3("UserOperation reverted during simulation with reason: AA25 invalid account nonce", ValidationErrors2.InvalidFields);
        }
        return "added";
      }
    }
    this.nonceQueuer.add(userOperation);
    return "queued";
  }
  async pimlico_sendCompressedUserOperation(compressedCalldata, inflatorAddress, entryPoint) {
    let status = "rejected";
    try {
      const { inflatedOp, inflatorId } = await this.validateAndInflateCompressedUserOperation(inflatorAddress, compressedCalldata);
      const compressedUserOp = {
        compressedCalldata,
        inflatedOp,
        inflatorAddress,
        inflatorId
      };
      status = await this.addToMempoolIfValid(compressedUserOp, entryPoint);
      const hash4 = getUserOperationHash2(toPackedUserOperation(inflatedOp), entryPoint, this.chainId);
      return hash4;
    } catch (error) {
      status = "rejected";
      throw error;
    } finally {
      this.metrics.userOperationsReceived.labels({
        status,
        type: "compressed"
      }).inc();
    }
  }
  async validateAndInflateCompressedUserOperation(inflatorAddress, compressedCalldata) {
    if (this.compressionHandler === null) {
      throw new RpcError3("Endpoint not supported");
    }
    const inflatorId = await this.compressionHandler.getInflatorRegisteredId(inflatorAddress, this.publicClient);
    if (inflatorId === 0) {
      throw new RpcError3(`Inflator ${inflatorAddress} is not registered`, ValidationErrors2.InvalidFields);
    }
    const inflatorContract = getContract({
      address: inflatorAddress,
      abi: IOpInflatorAbi2,
      publicClient: this.publicClient
    });
    let inflatedOp;
    try {
      inflatedOp = await inflatorContract.read.inflate([
        compressedCalldata
      ]);
    } catch (e) {
      throw new RpcError3(`Inflator ${inflatorAddress} failed to inflate calldata ${compressedCalldata}, due to ${e}`, ValidationErrors2.InvalidFields);
    }
    const perOpInflatorId = this.compressionHandler.perOpInflatorId;
    if (perOpInflatorId === 0) {
      throw new RpcError3(`PerUserOp ${this.compressionHandler.perOpInflatorAddress} has not been registered with BundelBulker`, ValidationErrors2.InvalidFields);
    }
    return { inflatedOp: toUnPackedUserOperation(inflatedOp), inflatorId };
  }
}
// entrypoint-0.7/rpc/server.ts
var sentry9 = __toESM(require_cjs4(), 1);
var import_fastify2 = __toESM(require_fastify(), 1);
var import_zod_validation_error5 = __toESM(require_cjs5(), 1);
var originalJsonStringify2 = JSON.stringify;
JSON.stringify = (value, replacer, space) => {
  const bigintReplacer = (_key, value2) => {
    if (typeof value2 === "bigint") {
      return toHex2(value2);
    }
    return value2;
  };
  const wrapperReplacer = (key, value2) => {
    if (typeof replacer === "function") {
      value2 = replacer(key, value2);
    } else if (Array.isArray(replacer)) {
      if (!replacer.includes(key)) {
        return;
      }
    }
    return bigintReplacer(key, value2);
  };
  return originalJsonStringify2(value, wrapperReplacer, space);
};

class Server2 {
  fastify;
  rpcEndpoint;
  port;
  registry;
  metrics;
  constructor(rpcEndpoint, port, requestTimeout, logger3, registry, metrics2) {
    this.fastify = import_fastify2.default({
      logger: logger3,
      requestTimeout,
      disableRequestLogging: true
    });
    this.fastify.register(require_fastify_cors(), {
      origin: "*",
      methods: ["POST", "GET", "OPTIONS"]
    });
    this.fastify.decorateRequest("rpcMethod", null);
    this.fastify.decorateReply("rpcStatus", null);
    this.fastify.addHook("onResponse", (request5, reply) => {
      const ignoredRoutes = ["/health", "/metrics"];
      if (ignoredRoutes.includes(request5.routeOptions.url)) {
        return;
      }
      const labels = {
        route: request5.routeOptions.url,
        code: reply.statusCode,
        method: request5.method,
        rpc_method: request5.rpcMethod,
        rpc_status: reply.rpcStatus
      };
      this.metrics.httpRequests.labels(labels).inc();
      const durationMs = reply.getResponseTime();
      const durationSeconds = durationMs / 1000;
      this.metrics.httpRequestsDuration.labels(labels).observe(durationSeconds);
    });
    this.fastify.post("/rpc", this.rpc.bind(this));
    this.fastify.post("/", this.rpc.bind(this));
    this.fastify.get("/health", this.healthCheck.bind(this));
    this.fastify.get("/metrics", this.serveMetrics.bind(this));
    this.rpcEndpoint = rpcEndpoint;
    this.port = port;
    this.registry = registry;
    this.metrics = metrics2;
  }
  start() {
    this.fastify.listen({ port: this.port, host: "0.0.0.0" });
  }
  async stop() {
    await this.fastify.close();
  }
  async healthCheck(_request, reply) {
    await reply.status(200).send("OK");
  }
  async rpc(request5, reply) {
    reply.rpcStatus = "failed";
    let requestId = null;
    try {
      const contentTypeHeader = request5.headers["content-type"];
      if (contentTypeHeader !== "application/json") {
        throw new RpcError3("invalid content-type, content-type must be application/json", ValidationErrors2.InvalidFields);
      }
      this.fastify.log.trace({ body: JSON.stringify(request5.body) }, "received request");
      const jsonRpcParsing = jsonRpcSchema2.safeParse(request5.body);
      if (!jsonRpcParsing.success) {
        const validationError = import_zod_validation_error5.fromZodError(jsonRpcParsing.error);
        throw new RpcError3(`invalid JSON-RPC request ${validationError.message}`, ValidationErrors2.InvalidFields);
      }
      const jsonRpcRequest = jsonRpcParsing.data;
      requestId = jsonRpcRequest.id;
      const bundlerRequestParsing = bundlerRequestSchema2.safeParse(jsonRpcRequest);
      if (!bundlerRequestParsing.success) {
        const validationError = import_zod_validation_error5.fromZodError(bundlerRequestParsing.error);
        throw new RpcError3(validationError.message, ValidationErrors2.InvalidRequest);
      }
      const bundlerRequest = bundlerRequestParsing.data;
      request5.rpcMethod = bundlerRequest.method;
      this.fastify.log.info({
        data: JSON.stringify(bundlerRequest, null),
        method: bundlerRequest.method
      }, "incoming request");
      const result = await this.rpcEndpoint.handleMethod(bundlerRequest);
      const jsonRpcResponse = {
        jsonrpc: "2.0",
        id: jsonRpcRequest.id,
        result: result.result
      };
      await reply.status(200).send(jsonRpcResponse);
      reply.rpcStatus = "success";
      this.fastify.log.info({
        data: JSON.stringify(jsonRpcResponse),
        method: bundlerRequest.method
      }, "sent reply");
    } catch (err) {
      if (err instanceof RpcError3) {
        const rpcError = {
          jsonrpc: "2.0",
          id: requestId,
          error: {
            message: err.message,
            data: err.data,
            code: err.code
          }
        };
        await reply.status(200).send(rpcError);
        this.fastify.log.info(rpcError, "error reply");
      } else if (err instanceof Error) {
        sentry9.captureException(err);
        const rpcError = {
          jsonrpc: "2.0",
          id: requestId,
          error: {
            message: err.message
          }
        };
        await reply.status(500).send(rpcError);
        this.fastify.log.error(err, "error reply (non-rpc)");
      } else {
        const rpcError = {
          jsonrpc: "2.0",
          id: requestId,
          error: {
            message: "Unknown error"
          }
        };
        await reply.status(500).send(rpcError);
        this.fastify.log.info(reply.raw, "error reply (non-rpc)");
      }
    }
  }
  async serveMetrics(_request, reply) {
    reply.headers({ "Content-Type": this.registry.contentType });
    const metrics2 = await this.registry.metrics();
    await reply.send(metrics2);
  }
}
// entrypoint-0.7/rpc/validation/BundlerCollectorTracer.ts
function bundlerCollectorTracer2() {
  return {
    callsFromEntryPoint: [],
    currentLevel: null,
    keccak: [],
    calls: [],
    logs: [],
    debug: [],
    lastOp: "",
    lastThreeOpcodes: [],
    stopCollectingTopic: "bb47ee3e183a558b1a2ff0874b079f3fc5478b7454eacf2bfc5af2ff5878f972",
    stopCollecting: false,
    topLevelCallCounter: 0,
    fault(log7, _db) {
      this.debug.push(JSON.stringify({
        type: "fault",
        depth: log7.getDepth(),
        gas: log7.getGas(),
        cost: log7.getCost(),
        err: log7.getError()
      }));
    },
    result(_ctx, _db) {
      return {
        callsFromEntryPoint: this.callsFromEntryPoint,
        keccak: this.keccak,
        logs: this.logs,
        calls: this.calls,
        debug: this.debug
      };
    },
    enter(frame) {
      if (this.stopCollecting) {
        return;
      }
      this.calls.push({
        type: frame.getType(),
        from: toHex(frame.getFrom()),
        to: toHex(frame.getTo()),
        method: toHex(frame.getInput()).slice(0, 10),
        gas: frame.getGas(),
        value: frame.getValue()
      });
    },
    exit(frame) {
      if (this.stopCollecting) {
        return;
      }
      this.calls.push({
        type: frame.getError() != null ? "REVERT" : "RETURN",
        gasUsed: frame.getGasUsed(),
        data: toHex(frame.getOutput()).slice(0, 4000)
      });
    },
    countSlot(list, key) {
      if (list[key]) {
        list[key] += 1;
      } else {
        list[key] = 1;
      }
    },
    step(log7, db) {
      if (log7.getDepth() < 3) {
        return;
      }
      if (this.stopCollecting) {
        return;
      }
      const opcode = log7.op.toString();
      const stackSize = log7.stack.length();
      const stackTop3 = [];
      for (let i = 0;i < 3 && i < stackSize; i++) {
        stackTop3.push(log7.stack.peek(i));
      }
      this.lastThreeOpcodes.push({ opcode, stackTop3 });
      if (this.lastThreeOpcodes.length > 3) {
        this.lastThreeOpcodes.shift();
      }
      if (log7.getGas() < log7.getCost() || opcode === "SSTORE" && log7.getGas() < 2300) {
        this.currentLevel.oog = true;
      }
      if (opcode === "REVERT" || opcode === "RETURN") {
        if (log7.getDepth() === 3) {
          const ofs = Number.parseInt(log7.stack.peek(0).toString());
          const len = Number.parseInt(log7.stack.peek(1).toString());
          const data3 = toHex(log7.memory.slice(ofs, ofs + len)).slice(0, 4000);
          this.calls.push({
            type: opcode,
            gasUsed: 0,
            data: data3
          });
        }
        this.lastThreeOpcodes = [];
      }
      if (log7.getDepth() === 3) {
        if (opcode === "CALL" || opcode === "STATICCALL") {
          const addr = toAddress(log7.stack.peek(1).toString(16));
          const topLevelTargetAddress = toHex(addr);
          const ofs = Number.parseInt(log7.stack.peek(3).toString());
          const topLevelMethodSig = toHex(log7.memory.slice(ofs, ofs + 4));
          this.currentLevel = this.callsFromEntryPoint[this.topLevelCallCounter] = {
            topLevelMethodSig,
            topLevelTargetAddress,
            access: {},
            opcodes: {},
            extCodeAccessInfo: {},
            contractSize: {}
          };
          this.topLevelCallCounter++;
        } else if (opcode === "LOG1") {
          const topic = log7.stack.peek(2).toString(16);
          if (topic === this.stopCollectingTopic) {
            this.stopCollecting = true;
          }
        }
        this.lastOp = "";
        return;
      }
      const lastOpInfo = this.lastThreeOpcodes[this.lastThreeOpcodes.length - 2];
      if (lastOpInfo && lastOpInfo.opcode && lastOpInfo.opcode.match(/^(EXT.*)$/) != null) {
        const addr = toAddress(lastOpInfo.stackTop3[0].toString(16));
        const addrHex = toHex(addr);
        if (!(this.lastThreeOpcodes[0].opcode.match(/\w+/) !== null && this.lastThreeOpcodes[1].opcode === "EXTCODESIZE" && this.lastThreeOpcodes[2].opcode === "ISZERO")) {
          this.currentLevel.extCodeAccessInfo[addrHex] = opcode;
        }
      }
      const isAllowedPrecompiled = (address10) => {
        const addrHex = toHex(address10);
        const addressInt = Number.parseInt(addrHex);
        return addressInt > 0 && addressInt < 10;
      };
      if (opcode.match(/^(EXT.*|CALL|CALLCODE|DELEGATECALL|STATICCALL)$/) != null) {
        const idx = opcode.startsWith("EXT") ? 0 : 1;
        const addr = toAddress(log7.stack.peek(idx).toString(16));
        const addrHex = toHex(addr);
        if (this.currentLevel.contractSize[addrHex] == null && !isAllowedPrecompiled(addr)) {
          this.currentLevel.contractSize[addrHex] = {
            contractSize: db.getCode(addr).length,
            opcode
          };
        }
      }
      if (this.lastOp === "GAS" && !opcode.includes("CALL")) {
        this.countSlot(this.currentLevel.opcodes, "GAS");
      }
      if (opcode !== "GAS") {
        if (opcode.match(/^(DUP\d+|PUSH\d+|SWAP\d+|POP|ADD|SUB|MUL|DIV|EQ|LTE?|S?GTE?|SLT|SH[LR]|AND|OR|NOT|ISZERO)$/) == null) {
          this.countSlot(this.currentLevel.opcodes, opcode);
        }
      }
      this.lastOp = opcode;
      if (opcode === "SLOAD" || opcode === "SSTORE") {
        const slot = toWord(log7.stack.peek(0).toString(16));
        const slotHex = toHex(slot);
        const addr = log7.contract.getAddress();
        const addrHex = toHex(addr);
        let access = this.currentLevel.access[addrHex];
        if (access == null) {
          access = {
            reads: {},
            writes: {}
          };
          this.currentLevel.access[addrHex] = access;
        }
        if (opcode === "SLOAD") {
          if (access.reads[slotHex] == null && access.writes[slotHex] == null) {
            access.reads[slotHex] = toHex(db.getState(addr, slot));
          }
        } else {
          this.countSlot(access.writes, slotHex);
        }
      }
      if (opcode === "KECCAK256") {
        const ofs = Number.parseInt(log7.stack.peek(0).toString());
        const len = Number.parseInt(log7.stack.peek(1).toString());
        if (len > 20 && len < 512) {
          this.keccak.push(toHex(log7.memory.slice(ofs, ofs + len)));
        }
      } else if (opcode.startsWith("LOG")) {
        const count = Number.parseInt(opcode.substring(3));
        const ofs = Number.parseInt(log7.stack.peek(0).toString());
        const len = Number.parseInt(log7.stack.peek(1).toString());
        const topics = [];
        for (let i = 0;i < count; i++) {
          topics.push(`0x${log7.stack.peek(2 + i).toString(16)}`);
        }
        const data3 = toHex(log7.memory.slice(ofs, ofs + len));
        this.logs.push({
          topics,
          data: data3
        });
      }
    }
  };
}

// entrypoint-0.7/rpc/validation/TracerResultParser.ts
function isStaked(entStake) {
  return Boolean(entStake && 1n <= entStake.stake && 1n <= entStake.unstakeDelaySec);
}
function associatedWith(slot, addr, entitySlots) {
  const addrPadded = pad(addr, {
    size: 32
  }).toLowerCase();
  if (slot.toLowerCase() === addrPadded) {
    return true;
  }
  const k = entitySlots[addr];
  if (!k) {
    return false;
  }
  const slotN = hexToBigInt(slot);
  for (const k1 of k.keys()) {
    const kn = hexToBigInt(k1);
    if (slotN >= kn && slotN < kn + 128n) {
      return true;
    }
  }
  return false;
}
var parseCallStack2 = function(tracerResults) {
  function callCatch(x, def) {
    try {
      return x();
    } catch (_) {
      return def;
    }
  }
  const out = [];
  const stack = [];
  const filteredTracerResultCalls = tracerResults.calls.filter((x) => !x.type.startsWith("depth"));
  for (const c of filteredTracerResultCalls) {
    if (c.type.match(/REVERT|RETURN/) !== null) {
      const top2 = stack.splice(-1)[0] ?? {
        type: "top",
        method: "validateUserOp"
      };
      const returnData = c.data;
      if (top2.type.match(/CREATE/) !== null) {
        out.push({
          to: top2.to,
          from: top2.from,
          type: top2.type,
          method: "",
          return: `len=${returnData.length}`
        });
      } else {
        const method = callCatch(() => functionSignatureToMethodName2(top2.method), top2.method);
        if (c.type === "REVERT") {
          const parsedError = callCatch(() => decodeErrorResult({ abi: abi22, data: returnData }), returnData);
          out.push({
            to: top2.to,
            from: top2.from,
            type: top2.type,
            method,
            value: top2.value,
            revert: parsedError
          });
        } else {
          const ret2 = callCatch(() => decodeFunctionResult({
            abi: abi22,
            functionName: method,
            data: returnData
          }), returnData);
          out.push({
            to: top2.to,
            from: top2.from,
            type: top2.type,
            value: top2.value,
            method,
            return: ret2
          });
        }
      }
    } else {
      stack.push(c);
    }
  }
  return out;
};
function parseEntitySlots2(stakeInfoEntities, keccak) {
  const entitySlots = {};
  for (const k of keccak) {
    const values = Object.values(stakeInfoEntities);
    for (const info of values) {
      const addr = info?.addr?.toLowerCase();
      if (!addr) {
        continue;
      }
      const addrPadded = pad(addr).toLowerCase();
      if (!entitySlots[addr]) {
        entitySlots[addr] = new Set;
      }
      const currentEntitySlots = entitySlots[addr];
      if (k.startsWith(addrPadded)) {
        currentEntitySlots.add(keccak256(k));
      }
    }
  }
  return entitySlots;
}
function tracerResultParser2(userOp, tracerResults, validationResult, entryPointAddress) {
  const bannedOpCodes = new Set([
    "GASPRICE",
    "GASLIMIT",
    "DIFFICULTY",
    "TIMESTAMP",
    "BASEFEE",
    "BLOCKHASH",
    "NUMBER",
    "SELFBALANCE",
    "BALANCE",
    "ORIGIN",
    "GAS",
    "CREATE",
    "COINBASE",
    "SELFDESTRUCT",
    "RANDOM",
    "PREVRANDAO",
    "INVALID"
  ]);
  if (Object.values(tracerResults.callsFromEntryPoint).length < 1) {
    throw new Error("Unexpected traceCall result: no calls from entrypoint.");
  }
  const callStack = parseCallStack2(tracerResults);
  const callInfoEntryPoint = callStack.find((call7) => call7.to === entryPointAddress && call7.from !== entryPointAddress && call7.method !== "0x" && call7.method !== "depositTo");
  if (callInfoEntryPoint && callInfoEntryPoint?.method !== "delegateAndRevert") {
    throw new RpcError3(`illegal call into EntryPoint during validation ${callInfoEntryPoint?.method}`, ValidationErrors2.OpcodeValidation);
  }
  const illegalNonZeroValueCall = callStack.find((call7) => call7.to !== entryPointAddress && hexToBigInt(call7.value ?? "0x0") !== 0n);
  if (illegalNonZeroValueCall) {
    throw new RpcError3("May not may CALL with value", ValidationErrors2.OpcodeValidation);
  }
  const sender = userOp.sender.toLowerCase();
  const stakeInfoEntities = {
    factory: validationResult.factoryInfo,
    account: validationResult.senderInfo,
    paymaster: validationResult.paymasterInfo
  };
  const entitySlots = parseEntitySlots2(stakeInfoEntities, tracerResults.keccak);
  for (const [title, entStakes] of Object.entries(stakeInfoEntities)) {
    let requireCondAndStake = function(cond, entStake, failureMessage) {
      if (!cond) {
        return;
      }
      if (!entStake) {
        throw new Error(`internal: ${entityTitle} not in userOp, but has storage accesses in ${JSON.stringify(access)}`);
      }
      if (!isStaked(entStake)) {
        throw new RpcError3(failureMessage, ValidationErrors2.OpcodeValidation, {
          [entityTitle]: entStakes?.addr
        });
      }
    };
    const entityTitle = title;
    const entityAddr = (entStakes?.addr ?? "").toLowerCase();
    const currentNumLevel = tracerResults.callsFromEntryPoint.find((info) => info.topLevelMethodSig === callsFromEntryPointMethodSigs2[entityTitle]);
    if (!currentNumLevel) {
      if (entityTitle === "account") {
        throw new Error("missing trace into validateUserOp");
      }
      continue;
    }
    const opcodes = currentNumLevel.opcodes;
    const access = currentNumLevel.access;
    if (currentNumLevel.oog ?? false) {
      throw new RpcError3(`${entityTitle} internally reverts on oog`, ValidationErrors2.OpcodeValidation);
    }
    for (const opcode of Object.keys(opcodes)) {
      if (bannedOpCodes.has(opcode)) {
        throw new RpcError3(`${entityTitle} uses banned opcode: ${opcode}`, ValidationErrors2.OpcodeValidation);
      }
    }
    if (entityTitle === "factory") {
      if ((opcodes.CREATE2 ?? 0) > 1) {
        throw new RpcError3(`${entityTitle} with too many CREATE2`, ValidationErrors2.OpcodeValidation);
      }
    } else if (opcodes.CREATE2) {
      throw new RpcError3(`${entityTitle} uses banned opcode: CREATE2`, ValidationErrors2.OpcodeValidation);
    }
    for (const [addr, { reads, writes }] of Object.entries(access)) {
      let nameAddr = function(addr2, _currentEntity) {
        const [title2] = Object.entries(stakeInfoEntities).find(([_title, info]) => info?.addr?.toLowerCase() === addr2.toLowerCase()) ?? [];
        return title2 ?? addr2;
      };
      if (addr === sender) {
        continue;
      }
      if (addr === entryPointAddress) {
        continue;
      }
      let requireStakeSlot;
      const slots = [...Object.keys(writes), ...Object.keys(reads)];
      for (const slot of slots) {
        if (associatedWith(slot, sender, entitySlots)) {
          if (userOp.factory) {
            if (!(entityAddr === sender && isStaked(stakeInfoEntities.factory))) {
              requireStakeSlot = slot;
            }
          }
        } else if (associatedWith(slot, entityAddr, entitySlots)) {
          requireStakeSlot = slot;
        } else if (addr === entityAddr) {
          requireStakeSlot = slot;
        } else if (writes[slot] === undefined) {
          requireStakeSlot = slot;
        } else {
          const readWrite = Object.keys(writes).includes(addr) ? "write to" : "read from";
          const message = `${entityTitle} has forbidden ${readWrite} ${nameAddr(addr, entityTitle)} slot ${slot}`;
          throw new RpcError3(message, ValidationErrors2.OpcodeValidation, {
            [entityTitle]: entStakes?.addr
          });
        }
      }
      requireCondAndStake(requireStakeSlot !== undefined, entStakes, `unstaked ${entityTitle} accessed ${nameAddr(addr, entityTitle)} slot ${requireStakeSlot}`);
    }
    if (entityTitle === "paymaster") {
      const validatePaymasterUserOp = callStack.find((call7) => call7.method === "validatePaymasterUserOp" && call7.to === entityAddr);
      const context = validatePaymasterUserOp?.return ? validatePaymasterUserOp?.return[0] : undefined;
      requireCondAndStake(context && context !== "0x", entStakes, "unstaked paymaster must not return context");
    }
    let illegalZeroCodeAccess;
    for (const addr of Object.keys(currentNumLevel.contractSize)) {
      if (addr !== sender && currentNumLevel.contractSize[addr].contractSize <= 2) {
        illegalZeroCodeAccess = currentNumLevel.contractSize[addr];
        illegalZeroCodeAccess.address = addr;
        break;
      }
    }
    if (illegalZeroCodeAccess) {
      throw new RpcError3(`${entityTitle} accesses un-deployed contract address ${illegalZeroCodeAccess?.address} with opcode ${illegalZeroCodeAccess?.opcode}`, ValidationErrors2.OpcodeValidation);
    }
    let illegalEntryPointCodeAccess = undefined;
    for (const addr of Object.keys(currentNumLevel.extCodeAccessInfo)) {
      if (addr === entryPointAddress) {
        illegalEntryPointCodeAccess = currentNumLevel.extCodeAccessInfo[addr];
        break;
      }
    }
    if (illegalEntryPointCodeAccess) {
      throw new RpcError3(`${entityTitle} accesses EntryPoint contract address ${entryPointAddress} with opcode ${illegalEntryPointCodeAccess}`, ValidationErrors2.OpcodeValidation);
    }
  }
  const addresses = tracerResults.callsFromEntryPoint.flatMap((level) => Object.keys(level.contractSize));
  const storageMap = {};
  for (const level of tracerResults.callsFromEntryPoint) {
    for (const addr of Object.keys(level.access)) {
      storageMap[addr] = storageMap[addr] ?? level.access[addr].reads;
    }
  }
  return [addresses, storageMap];
}
var abi22 = [...SenderCreatorAbi2, ...EntryPointAbi2, ...PaymasterAbi2];
var functionSignatureToMethodName2 = (hash4) => {
  let functionName = undefined;
  for (const item of abi22) {
    const signature = getFunctionSelector(item);
    if (signature === hash4) {
      functionName = item.name;
    }
  }
  if (functionName === undefined) {
    throw new Error(`Could not find function name for hash ${hash4}`);
  }
  return functionName;
};
var callsFromEntryPointMethodSigs2 = {
  factory: getFunctionSelector({
    inputs: [
      {
        internalType: "bytes",
        name: "initCode",
        type: "bytes"
      }
    ],
    name: "createSender",
    outputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }),
  account: getFunctionSelector({
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "gasFees",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct PackedUserOperation",
        name: "userOp",
        type: "tuple"
      },
      {
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "missingAccountFunds",
        type: "uint256"
      }
    ],
    name: "validateUserOp",
    outputs: [
      {
        internalType: "uint256",
        name: "validationData",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }),
  paymaster: getFunctionSelector({
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "gasFees",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct PackedUserOperation",
        name: "userOp",
        type: "tuple"
      },
      {
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "maxCost",
        type: "uint256"
      }
    ],
    name: "validatePaymasterUserOp",
    outputs: [
      {
        internalType: "bytes",
        name: "context",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "validationData",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  })
};

// entrypoint-0.7/rpc/ExecuteSimulator.ts
var ExecuteSimulatorDeployedBytecode2 = "0x60806040526004361061012e5760003560e01c806372b37bca116100ab578063b760faf91161006f578063b760faf914610452578063bb9fe6bf14610465578063c23a5cea1461047a578063d6383f941461049a578063ee219423146104ba578063fc7e286d146104da57600080fd5b806372b37bca146103bd5780638f41ec5a146103dd578063957122ab146103f25780639b249f6914610412578063a61935311461043257600080fd5b8063205c2878116100f2578063205c28781461020157806335567e1a146102215780634b1d7cf5146102415780635287ce121461026157806370a082311461037e57600080fd5b80630396cb60146101435780630bd28e3b146101565780631b2e01b8146101765780631d732756146101c15780631fad948c146101e157600080fd5b3661013e5761013c3361058f565b005b600080fd5b61013c6101513660046131c9565b6105f6565b34801561016257600080fd5b5061013c61017136600461320b565b610885565b34801561018257600080fd5b506101ae610191366004613246565b600160209081526000928352604080842090915290825290205481565b6040519081526020015b60405180910390f35b3480156101cd57600080fd5b506101ae6101dc366004613440565b6108bc565b3480156101ed57600080fd5b5061013c6101fc366004613549565b610a2f565b34801561020d57600080fd5b5061013c61021c36600461359f565b610bab565b34801561022d57600080fd5b506101ae61023c366004613246565b610d27565b34801561024d57600080fd5b5061013c61025c366004613549565b610d6d565b34801561026d57600080fd5b5061032661027c3660046135cb565b6040805160a081018252600080825260208201819052918101829052606081018290526080810191909152506001600160a01b031660009081526020818152604091829020825160a08101845281546001600160701b038082168352600160701b820460ff16151594830194909452600160781b90049092169282019290925260019091015463ffffffff81166060830152640100000000900465ffffffffffff16608082015290565b6040805182516001600160701b03908116825260208085015115159083015283830151169181019190915260608083015163ffffffff169082015260809182015165ffffffffffff169181019190915260a0016101b8565b34801561038a57600080fd5b506101ae6103993660046135cb565b6001600160a01b03166000908152602081905260409020546001600160701b031690565b3480156103c957600080fd5b5061013c6103d83660046135e8565b6111b0565b3480156103e957600080fd5b506101ae600181565b3480156103fe57600080fd5b5061013c61040d366004613643565b611289565b34801561041e57600080fd5b5061013c61042d3660046136c7565b611386565b34801561043e57600080fd5b506101ae61044d366004613721565b611441565b61013c6104603660046135cb565b61058f565b34801561047157600080fd5b5061013c611483565b34801561048657600080fd5b5061013c6104953660046135cb565b6115ac565b3480156104a657600080fd5b5061013c6104b5366004613755565b6117e4565b3480156104c657600080fd5b5061013c6104d5366004613721565b6118df565b3480156104e657600080fd5b506105496104f53660046135cb565b600060208190529081526040902080546001909101546001600160701b0380831692600160701b810460ff1692600160781b9091049091169063ffffffff811690640100000000900465ffffffffffff1685565b604080516001600160701b0396871681529415156020860152929094169183019190915263ffffffff16606082015265ffffffffffff909116608082015260a0016101b8565b6105998134611abb565b6001600160a01b03811660008181526020818152604091829020805492516001600160701b03909316835292917f2da466a7b24304f47e87fa2e1e5a81b9831ce54fec19055ce277ca2f39ba42c491015b60405180910390a25050565b33600090815260208190526040902063ffffffff821661065d5760405162461bcd60e51b815260206004820152601a60248201527f6d757374207370656369667920756e7374616b652064656c617900000000000060448201526064015b60405180910390fd5b600181015463ffffffff90811690831610156106bb5760405162461bcd60e51b815260206004820152601c60248201527f63616e6e6f7420646563726561736520756e7374616b652074696d65000000006044820152606401610654565b80546000906106db903490600160781b90046001600160701b03166137cc565b9050600081116107225760405162461bcd60e51b81526020600482015260126024820152711b9bc81cdd185ad9481cdc1958da599a595960721b6044820152606401610654565b6001600160701b0381111561076a5760405162461bcd60e51b815260206004820152600e60248201526d7374616b65206f766572666c6f7760901b6044820152606401610654565b6040805160a08101825283546001600160701b0390811682526001602080840182815286841685870190815263ffffffff808b16606088019081526000608089018181523380835296829052908a902098518954955194518916600160781b02600160781b600160e81b0319951515600160701b026effffffffffffffffffffffffffffff199097169190991617949094179290921695909517865551949092018054925165ffffffffffff166401000000000269ffffffffffffffffffff19909316949093169390931717905590517fa5ae833d0bb1dcd632d98a8b70973e8516812898e19bf27b70071ebc8dc52c0190610878908490879091825263ffffffff16602082015260400190565b60405180910390a2505050565b3360009081526001602090815260408083206001600160c01b038516845290915281208054916108b4836137df565b919050555050565b6000805a90503330146109115760405162461bcd60e51b815260206004820152601760248201527f4141393220696e7465726e616c2063616c6c206f6e6c790000000000000000006044820152606401610654565b8451604081015160608201518101611388015a101561093b5763deaddead60e01b60005260206000fd5b8751600090156109cf576000610958846000015160008c86611b57565b9050806109cd57600061096c610800611b6f565b8051909150156109c75784600001516001600160a01b03168a602001517f1c4fada7374c0a9ee8841fc38afe82932dc0f8e69012e927f061a8bae611a2018760200151846040516109be929190613848565b60405180910390a35b60019250505b505b600088608001515a8603019050610a216000838b8b8b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250889250611b9b915050565b9a9950505050505050505050565b610a37611e92565b816000816001600160401b03811115610a5257610a5261327b565b604051908082528060200260200182016040528015610a8b57816020015b610a7861313f565b815260200190600190039081610a705790505b50905060005b82811015610b04576000828281518110610aad57610aad613861565b60200260200101519050600080610ae8848a8a87818110610ad057610ad0613861565b9050602002810190610ae29190613877565b85611ee9565b91509150610af984838360006120d4565b505050600101610a91565b506040516000907fbb47ee3e183a558b1a2ff0874b079f3fc5478b7454eacf2bfc5af2ff5878f972908290a160005b83811015610b8e57610b8281888884818110610b5157610b51613861565b9050602002810190610b639190613877565b858481518110610b7557610b75613861565b6020026020010151612270565b90910190600101610b33565b50610b998482612397565b505050610ba66001600255565b505050565b33600090815260208190526040902080546001600160701b0316821115610c145760405162461bcd60e51b815260206004820152601960248201527f576974686472617720616d6f756e7420746f6f206c61726765000000000000006044820152606401610654565b8054610c2a9083906001600160701b0316613898565b81546001600160701b0319166001600160701b0391909116178155604080516001600160a01b03851681526020810184905233917fd1c19fbcd4551a5edfb66d43d2e337c04837afda3482b42bdf569a8fccdae5fb910160405180910390a26000836001600160a01b03168360405160006040518083038185875af1925050503d8060008114610cd6576040519150601f19603f3d011682016040523d82523d6000602084013e610cdb565b606091505b5050905080610d215760405162461bcd60e51b81526020600482015260126024820152716661696c656420746f20776974686472617760701b6044820152606401610654565b50505050565b6001600160a01b03821660009081526001602090815260408083206001600160c01b038516845290915290819020549082901b67ffffffffffffffff1916175b92915050565b610d75611e92565b816000805b82811015610ee95736868683818110610d9557610d95613861565b9050602002810190610da791906138ab565b9050366000610db683806138c1565b90925090506000610dcd60408501602086016135cb565b90506000196001600160a01b03821601610e295760405162461bcd60e51b815260206004820152601760248201527f4141393620696e76616c69642061676772656761746f720000000000000000006044820152606401610654565b6001600160a01b03811615610ec6576001600160a01b03811663e3563a4f8484610e56604089018961390a565b6040518563ffffffff1660e01b8152600401610e759493929190613ab5565b60006040518083038186803b158015610e8d57600080fd5b505afa925050508015610e9e575060015b610ec65760405163086a9f7560e41b81526001600160a01b0382166004820152602401610654565b610ed082876137cc565b9550505050508080610ee1906137df565b915050610d7a565b506000816001600160401b03811115610f0457610f0461327b565b604051908082528060200260200182016040528015610f3d57816020015b610f2a61313f565b815260200190600190039081610f225790505b506040519091507fbb47ee3e183a558b1a2ff0874b079f3fc5478b7454eacf2bfc5af2ff5878f97290600090a16000805b848110156110525736888883818110610f8957610f89613861565b9050602002810190610f9b91906138ab565b9050366000610faa83806138c1565b90925090506000610fc160408501602086016135cb565b90508160005b81811015611039576000898981518110610fe357610fe3613861565b602002602001015190506000806110068b898987818110610ad057610ad0613861565b91509150611016848383896120d4565b8a611020816137df565b9b50505050508080611031906137df565b915050610fc7565b505050505050808061104a906137df565b915050610f6e565b50600080915060005b8581101561116b573689898381811061107657611076613861565b905060200281019061108891906138ab565b905061109a60408201602083016135cb565b6001600160a01b03167f575ff3acadd5ab348fe1855e217e0f3678f8d767d7494c9f9fefbee2e17cca4d60405160405180910390a23660006110dc83806138c1565b90925090508060005b81811015611153576111278885858481811061110357611103613861565b90506020028101906111159190613877565b8b8b81518110610b7557610b75613861565b61113190886137cc565b96508761113d816137df565b985050808061114b906137df565b9150506110e5565b50505050508080611163906137df565b91505061105b565b506040516000907f575ff3acadd5ab348fe1855e217e0f3678f8d767d7494c9f9fefbee2e17cca4d908290a26111a18682612397565b5050505050610ba66001600255565b735ff137d4b0fdcd49dca30c7cf57e578a026d278933146111d057600080fd5b60005a9050600080866001600160a01b03168487876040516111f3929190613b32565b60006040518083038160008787f1925050503d8060008114611231576040519150601f19603f3d011682016040523d82523d6000602084013e611236565b606091505b509150915060005a6112489085613898565b90506000836112575782611268565b604051806020016040528060008152505b9050838183604051636c6238f160e01b815260040161065493929190613b42565b8315801561129f57506001600160a01b0383163b155b156112ec5760405162461bcd60e51b815260206004820152601960248201527f41413230206163636f756e74206e6f74206465706c6f796564000000000000006044820152606401610654565b601481106113645760006113036014828486613b6d565b61130c91613b97565b60601c9050803b6000036113625760405162461bcd60e51b815260206004820152601b60248201527f41413330207061796d6173746572206e6f74206465706c6f79656400000000006044820152606401610654565b505b60405162461bcd60e51b81526020600482015260006024820152604401610654565b604051632b870d1b60e11b81526000906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063570e1a36906113d79086908690600401613bcc565b6020604051808303816000875af11580156113f6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061141a9190613be0565b604051633653dc0360e11b81526001600160a01b0382166004820152909150602401610654565b600061144c82612490565b6040805160208101929092523090820152466060820152608001604051602081830303815290604052805190602001209050919050565b3360009081526020819052604081206001810154909163ffffffff90911690036114dc5760405162461bcd60e51b815260206004820152600a6024820152691b9bdd081cdd185ad95960b21b6044820152606401610654565b8054600160701b900460ff166115285760405162461bcd60e51b8152602060048201526011602482015270616c726561647920756e7374616b696e6760781b6044820152606401610654565b60018101546000906115409063ffffffff1642613bfd565b60018301805469ffffffffffff00000000191664010000000065ffffffffffff841690810291909117909155835460ff60701b1916845560405190815290915033907ffa9b3c14cc825c412c9ed81b3ba365a5b459439403f18829e572ed53a4180f0a906020016105ea565b3360009081526020819052604090208054600160781b90046001600160701b0316806116115760405162461bcd60e51b81526020600482015260146024820152734e6f207374616b6520746f20776974686472617760601b6044820152606401610654565b6001820154640100000000900465ffffffffffff166116725760405162461bcd60e51b815260206004820152601d60248201527f6d7573742063616c6c20756e6c6f636b5374616b6528292066697273740000006044820152606401610654565b60018201544264010000000090910465ffffffffffff1611156116d75760405162461bcd60e51b815260206004820152601b60248201527f5374616b65207769746864726177616c206973206e6f742064756500000000006044820152606401610654565b60018201805469ffffffffffffffffffff191690558154600160781b600160e81b0319168255604080516001600160a01b03851681526020810183905233917fb7c918e0e249f999e965cafeb6c664271b3f4317d296461500e71da39f0cbda3910160405180910390a26000836001600160a01b03168260405160006040518083038185875af1925050503d806000811461178e576040519150601f19603f3d011682016040523d82523d6000602084013e611793565b606091505b5050905080610d215760405162461bcd60e51b815260206004820152601860248201527f6661696c656420746f207769746864726177207374616b6500000000000000006044820152606401610654565b6117ec61313f565b6117f5856124a9565b60008061180460008885611ee9565b9150915060006118148383612583565b905061181f43600052565b600061182d60008a87612270565b905061183843600052565b600060606001600160a01b038a16156118ae57896001600160a01b03168989604051611865929190613b32565b6000604051808303816000865af19150503d80600081146118a2576040519150601f19603f3d011682016040523d82523d6000602084013e6118a7565b606091505b5090925090505b866080015183856020015186604001518585604051630116f59360e71b815260040161065496959493929190613c23565b6118e761313f565b6118f0826124a9565b6000806118ff60008585611ee9565b915091506000611916846000015160a0015161264f565b8451519091506000906119289061264f565b9050611947604051806040016040528060008152602001600081525090565b36600061195760408a018a61390a565b90925090506000601482101561196e576000611989565b61197c601460008486613b6d565b61198591613b97565b60601c5b90506119948161264f565b935050505060006119a58686612583565b9050600081600001519050600060016001600160a01b0316826001600160a01b031614905060006040518060c001604052808b6080015181526020018b6040015181526020018315158152602001856020015165ffffffffffff168152602001856040015165ffffffffffff168152602001611a228c6060015190565b905290506001600160a01b03831615801590611a4857506001600160a01b038316600114155b15611a9a5760006040518060400160405280856001600160a01b03168152602001611a728661264f565b81525090508187878a84604051633ebb2d3960e21b8152600401610654959493929190613cc5565b8086868960405163e0cff05f60e01b81526004016106549493929190613d45565b6001600160a01b03821660009081526020819052604081208054909190611aec9084906001600160701b03166137cc565b90506001600160701b03811115611b385760405162461bcd60e51b815260206004820152601060248201526f6465706f736974206f766572666c6f7760801b6044820152606401610654565b81546001600160701b0319166001600160701b03919091161790555050565b6000806000845160208601878987f195945050505050565b60603d82811115611b7d5750815b604051602082018101604052818152816000602083013e9392505050565b6000805a855190915060009081611bb18261269e565b60a08301519091506001600160a01b038116611bd05782519350611d77565b809350600088511115611d7757868202955060028a6002811115611bf657611bf6613d9c565b14611c6857606083015160405163a9a2340960e01b81526001600160a01b0383169163a9a2340991611c30908e908d908c90600401613db2565b600060405180830381600088803b158015611c4a57600080fd5b5087f1158015611c5e573d6000803e3d6000fd5b5050505050611d77565b606083015160405163a9a2340960e01b81526001600160a01b0383169163a9a2340991611c9d908e908d908c90600401613db2565b600060405180830381600088803b158015611cb757600080fd5b5087f193505050508015611cc9575060015b611d7757611cd5613de9565b806308c379a003611d2e5750611ce9613e05565b80611cf45750611d30565b8b81604051602001611d069190613e8e565b60408051601f1981840301815290829052631101335b60e11b82526106549291600401613848565b505b8a604051631101335b60e11b81526004016106549181526040602082018190526012908201527110504d4c081c1bdcdd13dc081c995d995c9d60721b606082015260800190565b5a85038701965081870295508589604001511015611de0578a604051631101335b60e11b815260040161065491815260406020808301829052908201527f414135312070726566756e642062656c6f772061637475616c476173436f7374606082015260800190565b6040890151869003611df28582611abb565b6000808c6002811115611e0757611e07613d9c565b1490508460a001516001600160a01b031685600001516001600160a01b03168c602001517f49628fd1471006c1482da88028e9ce4dbb080b815c9b0344d39e5a8e6ec1419f8860200151858d8f604051611e7a949392919093845291151560208401526040830152606082015260800190565b60405180910390a45050505050505095945050505050565b6002805403611ee35760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610654565b60028055565b60008060005a8451909150611efe86826126ce565b611f0786611441565b6020860152604081015160608201516080830151171760e087013517610100870135176effffffffffffffffffffffffffffff811115611f895760405162461bcd60e51b815260206004820152601860248201527f41413934206761732076616c756573206f766572666c6f7700000000000000006044820152606401610654565b600080611f95846127c7565b9050611fa38a8a8a84612814565b85516020870151919950919350611fba9190612a4c565b6120105789604051631101335b60e11b8152600401610654918152604060208201819052601a908201527f4141323520696e76616c6964206163636f756e74206e6f6e6365000000000000606082015260800190565b61201943600052565b60a08401516060906001600160a01b0316156120415761203c8b8b8b8587612a99565b975090505b60005a87039050808b60a0013510156120a6578b604051631101335b60e11b8152600401610654918152604060208201819052601e908201527f41413430206f76657220766572696669636174696f6e4761734c696d69740000606082015260800190565b60408a018390528160608b015260c08b01355a8803018a608001818152505050505050505050935093915050565b6000806120e085612cbc565b91509150816001600160a01b0316836001600160a01b0316146121465785604051631101335b60e11b81526004016106549181526040602082018190526014908201527320a0991a1039b4b3b730ba3ab9329032b93937b960611b606082015260800190565b801561219e5785604051631101335b60e11b81526004016106549181526040602082018190526017908201527f414132322065787069726564206f72206e6f7420647565000000000000000000606082015260800190565b60006121a985612cbc565b925090506001600160a01b038116156122055786604051631101335b60e11b81526004016106549181526040602082018190526014908201527320a0999a1039b4b3b730ba3ab9329032b93937b960611b606082015260800190565b81156122675786604051631101335b60e11b81526004016106549181526040602082018190526021908201527f41413332207061796d61737465722065787069726564206f72206e6f742064756060820152606560f81b608082015260a00190565b50505050505050565b6000805a90506000612283846060015190565b905030631d732756612298606088018861390a565b87856040518563ffffffff1660e01b81526004016122b99493929190613ecc565b6020604051808303816000875af19250505080156122f4575060408051601f3d908101601f191682019092526122f191810190613f7f565b60015b61238b57600060206000803e50600051632152215360e01b81016123565786604051631101335b60e11b8152600401610654918152604060208201819052600f908201526e41413935206f7574206f662067617360881b606082015260800190565b600085608001515a6123689086613898565b61237291906137cc565b9050612382886002888685611b9b565b9450505061238e565b92505b50509392505050565b6001600160a01b0382166123ed5760405162461bcd60e51b815260206004820152601860248201527f4141393020696e76616c69642062656e656669636961727900000000000000006044820152606401610654565b6000826001600160a01b03168260405160006040518083038185875af1925050503d806000811461243a576040519150601f19603f3d011682016040523d82523d6000602084013e61243f565b606091505b5050905080610ba65760405162461bcd60e51b815260206004820152601f60248201527f41413931206661696c65642073656e6420746f2062656e6566696369617279006044820152606401610654565b600061249b82612d0f565b805190602001209050919050565b3063957122ab6124bc604084018461390a565b6124c960208601866135cb565b6124d761012087018761390a565b6040518663ffffffff1660e01b81526004016124f7959493929190613f98565b60006040518083038186803b15801561250f57600080fd5b505afa925050508015612520575060015b6125805761252c613de9565b806308c379a0036125745750612540613e05565b8061254b5750612576565b80511561257057600081604051631101335b60e11b8152600401610654929190613848565b5050565b505b3d6000803e3d6000fd5b50565b60408051606081018252600080825260208201819052918101829052906125a984612de2565b905060006125b684612de2565b82519091506001600160a01b0381166125cd575080515b602080840151604080860151928501519085015191929165ffffffffffff80831690851610156125fb578193505b8065ffffffffffff168365ffffffffffff161115612617578092505b5050604080516060810182526001600160a01b03909416845265ffffffffffff92831660208501529116908201529250505092915050565b604080518082018252600080825260208083018281526001600160a01b03959095168252819052919091208054600160781b90046001600160701b031682526001015463ffffffff1690915290565b60c081015160e0820151600091908082036126ba575092915050565b6126c682488301612e53565b949350505050565b6126db60208301836135cb565b6001600160a01b0316815260208083013590820152608080830135604083015260a0830135606083015260c0808401359183019190915260e080840135918301919091526101008301359082015236600061273a61012085018561390a565b909250905080156127ba5760148110156127965760405162461bcd60e51b815260206004820152601d60248201527f4141393320696e76616c6964207061796d6173746572416e64446174610000006044820152606401610654565b6127a4601460008385613b6d565b6127ad91613b97565b60601c60a0840152610d21565b600060a084015250505050565b60a081015160009081906001600160a01b03166127e55760016127e8565b60035b60ff16905060008360800151828560600151028560400151010190508360c00151810292505050919050565b60008060005a8551805191925090612839898861283460408c018c61390a565b612e6b565b60a082015161284743600052565b60006001600160a01b03821661288f576001600160a01b0383166000908152602081905260409020546001600160701b03168881116128885780890361288b565b60005b9150505b606084015160208a0151604051633a871cdd60e01b81526001600160a01b03861692633a871cdd9290916128c9918f918790600401613fce565b60206040518083038160008887f193505050508015612905575060408051601f3d908101601f1916820190925261290291810190613f7f565b60015b61298f57612911613de9565b806308c379a0036129425750612925613e05565b806129305750612944565b8b81604051602001611d069190613ff3565b505b8a604051631101335b60e11b8152600401610654918152604060208201819052601690820152754141323320726576657274656420286f72204f4f472960501b606082015260800190565b95506001600160a01b038216612a39576001600160a01b038316600090815260208190526040902080546001600160701b0316808a1115612a1c578c604051631101335b60e11b81526004016106549181526040602082018190526017908201527f41413231206469646e2774207061792070726566756e64000000000000000000606082015260800190565b81546001600160701b031916908a90036001600160701b03161790555b5a85039650505050505094509492505050565b6001600160a01b038216600090815260016020908152604080832084821c80855292528220805484916001600160401b038316919085612a8b836137df565b909155501495945050505050565b82516060818101519091600091848111612af55760405162461bcd60e51b815260206004820152601f60248201527f4141343120746f6f206c6974746c6520766572696669636174696f6e476173006044820152606401610654565b60a08201516001600160a01b038116600090815260208190526040902080548784039291906001600160701b031689811015612b7d578c604051631101335b60e11b8152600401610654918152604060208201819052601e908201527f41413331207061796d6173746572206465706f73697420746f6f206c6f770000606082015260800190565b8981038260000160006101000a8154816001600160701b0302191690836001600160701b03160217905550826001600160a01b031663f465c77e858e8e602001518e6040518563ffffffff1660e01b8152600401612bdd93929190613fce565b60006040518083038160008887f193505050508015612c1e57506040513d6000823e601f3d908101601f19168201604052612c1b919081019061402a565b60015b612ca857612c2a613de9565b806308c379a003612c5b5750612c3e613e05565b80612c495750612c5d565b8d81604051602001611d0691906140b5565b505b8c604051631101335b60e11b8152600401610654918152604060208201819052601690820152754141333320726576657274656420286f72204f4f472960501b606082015260800190565b909e909d509b505050505050505050505050565b60008082600003612cd257506000928392509050565b6000612cdd84612de2565b9050806040015165ffffffffffff16421180612d045750806020015165ffffffffffff1642105b905194909350915050565b6060813560208301356000612d2f612d2a604087018761390a565b61312c565b90506000612d43612d2a606088018861390a565b9050608086013560a087013560c088013560e08901356101008a01356000612d72612d2a6101208e018e61390a565b604080516001600160a01b039c909c1660208d01528b81019a909a5260608b019890985250608089019590955260a088019390935260c087019190915260e08601526101008501526101208401526101408084019190915281518084039091018152610160909201905292915050565b60408051606081018252600080825260208201819052918101919091528160a081901c65ffffffffffff8116600003612e1e575065ffffffffffff5b604080516060810182526001600160a01b03909316835260d09490941c602083015265ffffffffffff16928101929092525090565b6000818310612e625781612e64565b825b9392505050565b8015610d21578251516001600160a01b0381163b15612ed65784604051631101335b60e11b8152600401610654918152604060208201819052601f908201527f414131302073656e64657220616c726561647920636f6e737472756374656400606082015260800190565b835160600151604051632b870d1b60e11b81526000916001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169163570e1a369190612f2e9088908890600401613bcc565b60206040518083038160008887f1158015612f4d573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190612f729190613be0565b90506001600160a01b038116612fd45785604051631101335b60e11b8152600401610654918152604060208201819052601b908201527f4141313320696e6974436f6465206661696c6564206f72204f4f470000000000606082015260800190565b816001600160a01b0316816001600160a01b03161461303e5785604051631101335b60e11b815260040161065491815260406020808301829052908201527f4141313420696e6974436f6465206d7573742072657475726e2073656e646572606082015260800190565b806001600160a01b03163b6000036130a15785604051631101335b60e11b815260040161065491815260406020808301829052908201527f4141313520696e6974436f6465206d757374206372656174652073656e646572606082015260800190565b60006130b06014828688613b6d565b6130b991613b97565b60601c9050826001600160a01b031686602001517fd51a9c61267aa6196961883ecf5ff2da6619c37dac0fa92122513fb32c032d2d83896000015160a0015160405161311b9291906001600160a01b0392831681529116602082015260400190565b60405180910390a350505050505050565b6000604051828085833790209392505050565b6040518060a001604052806131a460405180610100016040528060006001600160a01b031681526020016000815260200160008152602001600081526020016000815260200160006001600160a01b0316815260200160008152602001600081525090565b8152602001600080191681526020016000815260200160008152602001600081525090565b6000602082840312156131db57600080fd5b813563ffffffff81168114612e6457600080fd5b80356001600160c01b038116811461320657600080fd5b919050565b60006020828403121561321d57600080fd5b612e64826131ef565b6001600160a01b038116811461258057600080fd5b803561320681613226565b6000806040838503121561325957600080fd5b823561326481613226565b9150613272602084016131ef565b90509250929050565b634e487b7160e01b600052604160045260246000fd5b60a081018181106001600160401b03821117156132b0576132b061327b565b60405250565b61010081018181106001600160401b03821117156132b0576132b061327b565b601f8201601f191681016001600160401b03811182821017156132fb576132fb61327b565b6040525050565b60006001600160401b0382111561331b5761331b61327b565b50601f01601f191660200190565b600081830361018081121561333d57600080fd5b60405161334981613291565b8092506101008083121561335c57600080fd5b604051925061336a836132b6565b6133738561323b565b8352602085013560208401526040850135604084015260608501356060840152608085013560808401526133a960a0860161323b565b60a084015260c085013560c084015260e085013560e084015282825280850135602083015250610120840135604082015261014084013560608201526101608401356080820152505092915050565b60008083601f84011261340a57600080fd5b5081356001600160401b0381111561342157600080fd5b60208301915083602082850101111561343957600080fd5b9250929050565b6000806000806101c0858703121561345757600080fd5b84356001600160401b038082111561346e57600080fd5b818701915087601f83011261348257600080fd5b813561348d81613302565b60405161349a82826132d6565b8281528a60208487010111156134af57600080fd5b826020860160208301376000602084830101528098505050506134d58860208901613329565b94506101a08701359150808211156134ec57600080fd5b506134f9878288016133f8565b95989497509550505050565b60008083601f84011261351757600080fd5b5081356001600160401b0381111561352e57600080fd5b6020830191508360208260051b850101111561343957600080fd5b60008060006040848603121561355e57600080fd5b83356001600160401b0381111561357457600080fd5b61358086828701613505565b909450925050602084013561359481613226565b809150509250925092565b600080604083850312156135b257600080fd5b82356135bd81613226565b946020939093013593505050565b6000602082840312156135dd57600080fd5b8135612e6481613226565b600080600080606085870312156135fe57600080fd5b843561360981613226565b935060208501356001600160401b0381111561362457600080fd5b613630878288016133f8565b9598909750949560400135949350505050565b60008060008060006060868803121561365b57600080fd5b85356001600160401b038082111561367257600080fd5b61367e89838a016133f8565b90975095506020880135915061369382613226565b909350604087013590808211156136a957600080fd5b506136b6888289016133f8565b969995985093965092949392505050565b600080602083850312156136da57600080fd5b82356001600160401b038111156136f057600080fd5b6136fc858286016133f8565b90969095509350505050565b6000610160828403121561371b57600080fd5b50919050565b60006020828403121561373357600080fd5b81356001600160401b0381111561374957600080fd5b6126c684828501613708565b6000806000806060858703121561376b57600080fd5b84356001600160401b038082111561378257600080fd5b61378e88838901613708565b9550602087013591506137a082613226565b909350604086013590808211156134ec57600080fd5b634e487b7160e01b600052601160045260246000fd5b80820180821115610d6757610d676137b6565b6000600182016137f1576137f16137b6565b5060010190565b60005b838110156138135781810151838201526020016137fb565b50506000910152565b600081518084526138348160208601602086016137f8565b601f01601f19169290920160200192915050565b8281526040602082015260006126c6604083018461381c565b634e487b7160e01b600052603260045260246000fd5b6000823561015e1983360301811261388e57600080fd5b9190910192915050565b81810381811115610d6757610d676137b6565b60008235605e1983360301811261388e57600080fd5b6000808335601e198436030181126138d857600080fd5b8301803591506001600160401b038211156138f257600080fd5b6020019150600581901b360382131561343957600080fd5b6000808335601e1984360301811261392157600080fd5b8301803591506001600160401b0382111561393b57600080fd5b60200191503681900382131561343957600080fd5b6000808335601e1984360301811261396757600080fd5b83016020810192503590506001600160401b0381111561398657600080fd5b80360382131561343957600080fd5b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b60006101606139dd846139d08561323b565b6001600160a01b03169052565b602083013560208501526139f46040840184613950565b826040870152613a078387018284613995565b92505050613a186060840184613950565b8583036060870152613a2b838284613995565b925050506080830135608085015260a083013560a085015260c083013560c085015260e083013560e0850152610100808401358186015250610120613a7281850185613950565b86840383880152613a84848284613995565b9350505050610140613a9881850185613950565b86840383880152613aaa848284613995565b979650505050505050565b6040808252810184905260006060600586901b830181019083018783805b89811015613b1b57868503605f190184528235368c900361015e19018112613af9578283fd5b613b05868d83016139be565b9550506020938401939290920191600101613ad3565b505050508281036020840152613aaa818587613995565b8183823760009101908152919050565b8315158152606060208201526000613b5d606083018561381c565b9050826040830152949350505050565b60008085851115613b7d57600080fd5b83861115613b8a57600080fd5b5050820193919092039150565b6bffffffffffffffffffffffff198135818116916014851015613bc45780818660140360031b1b83161692505b505092915050565b6020815260006126c6602083018486613995565b600060208284031215613bf257600080fd5b8151612e6481613226565b65ffffffffffff818116838216019080821115613c1c57613c1c6137b6565b5092915050565b868152856020820152600065ffffffffffff8087166040840152808616606084015250831515608083015260c060a0830152613c6260c083018461381c565b98975050505050505050565b80518252602081015160208301526040810151151560408301526000606082015165ffffffffffff8082166060860152806080850151166080860152505060a082015160c060a08501526126c660c085018261381c565b6000610140808352613cd981840189613c6e565b915050613cf3602083018780518252602090810151910152565b845160608301526020948501516080830152835160a08301529284015160c082015281516001600160a01b031660e0820152908301518051610100830152909201516101209092019190915292915050565b60e081526000613d5860e0830187613c6e565b9050613d71602083018680518252602090810151910152565b8351606083015260208401516080830152825160a0830152602083015160c083015295945050505050565b634e487b7160e01b600052602160045260246000fd5b600060038510613dd257634e487b7160e01b600052602160045260246000fd5b84825260606020830152613b5d606083018561381c565b600060033d1115613e025760046000803e5060005160e01c5b90565b600060443d1015613e135790565b6040516003193d81016004833e81513d6001600160401b038160248401118184111715613e4257505050505090565b8285019150815181811115613e5a5750505050505090565b843d8701016020828501011115613e745750505050505090565b613e83602082860101876132d6565b509095945050505050565b75020a09a98103837b9ba27b8103932bb32b93a32b21d160551b815260008251613ebf8160168501602087016137f8565b9190910160160192915050565b60006101c0808352613ee18184018789613995565b9050845160018060a01b03808251166020860152602082015160408601526040820151606086015260608201516080860152608082015160a08601528060a08301511660c08601525060c081015160e085015260e08101516101008501525060208501516101208401526040850151610140840152606085015161016084015260808501516101808401528281036101a0840152613aaa818561381c565b600060208284031215613f9157600080fd5b5051919050565b606081526000613fac606083018789613995565b6001600160a01b03861660208401528281036040840152613c62818587613995565b606081526000613fe160608301866139be565b60208301949094525060400152919050565b6e020a09919903932bb32b93a32b21d1608d1b81526000825161401d81600f8501602087016137f8565b91909101600f0192915050565b6000806040838503121561403d57600080fd5b82516001600160401b0381111561405357600080fd5b8301601f8101851361406457600080fd5b805161406f81613302565b60405161407c82826132d6565b82815287602084860101111561409157600080fd5b6140a28360208301602087016137f8565b6020969096015195979596505050505050565b6e020a09999903932bb32b93a32b21d1608d1b81526000825161401d81600f8501602087016137f856fea26469706673582212201892e38d1eac5b99b119bf1333f8e39f72ad5274c5da6bb916f97bef4e7e0afc64736f6c63430008140033";

// entrypoint-0.7/rpc/EntryPointSimulations.ts
function parseFailedOpWithRevert(data3) {
  const methodSig = data3.slice(0, 10);
  const dataParams = `0x${data3.slice(10)}`;
  if (methodSig === "0x08c379a0") {
    const [err] = decodeAbiParameters([
      {
        name: "err",
        type: "string"
      }
    ], dataParams);
    return err;
  }
  if (methodSig === "0x4e487b71") {
    const [code] = decodeAbiParameters([
      {
        name: "err",
        type: "uint256"
      }
    ], dataParams);
    return panicCodes[Number(code)] ?? `${code}`;
  }
  return data3;
}
var getStateOverrides = function({
  userOperation,
  entryPoint,
  replacedEntryPoint,
  stateOverride = {}
}) {
  return replacedEntryPoint ? {
    ...stateOverride,
    [userOperation.sender]: {
      balance: toHex2(100000000000000000000000n),
      ...stateOverride ? deepHexlify2(stateOverride?.[userOperation.sender]) : []
    },
    [entryPoint]: {
      code: ExecuteSimulatorDeployedBytecode2
    }
  } : {
    ...stateOverride,
    [userOperation.sender]: {
      balance: toHex2(100000000000000000000000n),
      ...stateOverride ? deepHexlify2(stateOverride?.[userOperation.sender]) : []
    }
  };
};
var validateTargetCallDataResult = function(data3) {
  const decodedDelegateAndError = decodeErrorResult({
    abi: EntryPointAbi2,
    data: data3
  });
  if (!decodedDelegateAndError?.args?.[1]) {
    throw new Error("Unexpected error");
  }
  try {
    const decodedError = decodeErrorResult({
      abi: EntryPointSimulationsAbi2,
      data: decodedDelegateAndError.args[1]
    });
    if (decodedError?.args) {
      const targetSuccess = decodedError?.args[0];
      const targetResult = decodedError?.args[1];
      if (!targetSuccess) {
        return {
          result: "failed",
          data: parseFailedOpWithRevert(targetResult),
          code: ExecutionErrors2.UserOperationReverted
        };
      }
      return {
        result: "success"
      };
    }
    return {
      result: "failed",
      data: "Unknown error, could not parse target call data result.",
      code: ExecutionErrors2.UserOperationReverted
    };
  } catch (e) {
    return {
      result: "failed",
      data: "Unknown error, could not parse target call data result.",
      code: ExecutionErrors2.UserOperationReverted
    };
  }
};
var getSimulateHandleOpResult = function(data3) {
  const decodedDelegateAndError = decodeErrorResult({
    abi: EntryPointAbi2,
    data: data3
  });
  if (!decodedDelegateAndError?.args?.[1]) {
    throw new Error("Unexpected error");
  }
  try {
    const decodedError = decodeErrorResult({
      abi: EntryPointSimulationsAbi2,
      data: decodedDelegateAndError.args[1]
    });
    if (decodedError && decodedError.errorName === "FailedOp" && decodedError.args) {
      return {
        result: "failed",
        data: decodedError.args[1],
        code: ValidationErrors2.SimulateValidation
      };
    }
    if (decodedError && decodedError.errorName === "FailedOpWithRevert" && decodedError.args) {
      return {
        result: "failed",
        data: parseFailedOpWithRevert(decodedError.args?.[2]),
        code: ValidationErrors2.SimulateValidation
      };
    }
  } catch {
    const decodedResult = decodeAbiParameters([
      {
        components: [
          {
            internalType: "uint256",
            name: "preOpGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "paid",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "validationData",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "paymasterValidationData",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "targetSuccess",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "targetResult",
            type: "bytes"
          }
        ],
        internalType: "struct IEntryPointSimulations.ExecutionResult",
        name: "",
        type: "tuple"
      }
    ], decodedDelegateAndError.args[1])[0];
    return {
      result: "execution",
      data: decodedResult
    };
  }
  throw new Error("Unexpected error");
};
async function callPimlicoEntryPointSimulations(publicClient, entryPoint, entryPointSimulationsCallData, entryPointSimulationsAddress, stateOverride) {
  const callData = encodeFunctionData({
    abi: PimlicoEntryPointSimulationsAbi,
    functionName: "simulateEntryPoint",
    args: [entryPoint, entryPointSimulationsCallData]
  });
  const result = await publicClient.request({
    method: "eth_call",
    params: [
      {
        to: entryPointSimulationsAddress,
        data: callData
      },
      "latest",
      stateOverride
    ]
  });
  const returnBytes = decodeAbiParameters([{ name: "ret", type: "bytes[]" }], result);
  return returnBytes[0];
}
async function simulateHandleOp2(userOperation, entryPoint, publicClient, replacedEntryPoint, targetAddress, targetCallData, entryPointSimulationsAddress, stateOverride = {}) {
  const finalParam = getStateOverrides({
    userOperation,
    entryPoint,
    replacedEntryPoint,
    stateOverride
  });
  const packedUserOperation = toPackedUserOperation(userOperation);
  const entryPointSimulationsSimulateHandleOpCallData = encodeFunctionData({
    abi: EntryPointSimulationsAbi2,
    functionName: "simulateHandleOp",
    args: [packedUserOperation]
  });
  const entryPointSimulationsSimulateTargetCallData = encodeFunctionData({
    abi: EntryPointSimulationsAbi2,
    functionName: "simulateCallData",
    args: [packedUserOperation, targetAddress, targetCallData]
  });
  const cause = await callPimlicoEntryPointSimulations(publicClient, entryPoint, [
    entryPointSimulationsSimulateHandleOpCallData,
    entryPointSimulationsSimulateTargetCallData
  ], entryPointSimulationsAddress, finalParam);
  const targetCallValidationResult = validateTargetCallDataResult(cause[1]);
  if (targetCallValidationResult.result === "failed") {
    return targetCallValidationResult;
  }
  return getSimulateHandleOpResult(cause[0]);
}
var getSimulateValidationResult = function(errorData) {
  const decodedDelegateAndError = decodeErrorResult({
    abi: EntryPointAbi2,
    data: errorData
  });
  if (!decodedDelegateAndError?.args?.[1]) {
    throw new Error("Unexpected error");
  }
  try {
    const decodedError = decodeErrorResult({
      abi: EntryPointSimulationsAbi2,
      data: decodedDelegateAndError.args[1]
    });
    if (decodedError && decodedError.errorName === "FailedOp" && decodedError.args) {
      return {
        status: "failed",
        data: decodedError.args[1]
      };
    }
    if (decodedError && decodedError.errorName === "FailedOpWithRevert" && decodedError.args) {
      return {
        status: "failed",
        data: parseFailedOpWithRevert(decodedError.args?.[2])
      };
    }
  } catch {
    const decodedResult = decodeAbiParameters([
      {
        components: [
          {
            components: [
              {
                internalType: "uint256",
                name: "preOpGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "prefund",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "accountValidationData",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "paymasterValidationData",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterContext",
                type: "bytes"
              }
            ],
            internalType: "struct IEntryPoint.ReturnInfo",
            name: "returnInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "senderInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "factoryInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "paymasterInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "address",
                name: "aggregator",
                type: "address"
              },
              {
                components: [
                  {
                    internalType: "uint256",
                    name: "stake",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "unstakeDelaySec",
                    type: "uint256"
                  }
                ],
                internalType: "struct IStakeManager.StakeInfo",
                name: "stakeInfo",
                type: "tuple"
              }
            ],
            internalType: "struct IEntryPoint.AggregatorStakeInfo",
            name: "aggregatorInfo",
            type: "tuple"
          }
        ],
        internalType: "struct IEntryPointSimulations.ValidationResult",
        name: "",
        type: "tuple"
      }
    ], decodedDelegateAndError.args[1])[0];
    return {
      status: "validation",
      data: decodedResult
    };
  }
  throw new Error("Unexpected error - errorName is not ValidationResult or ValidationResultWithAggregation");
};
async function simulateValidation(userOperation, entryPoint, publicClient, entryPointSimulationsAddress) {
  const packedUserOperation = toPackedUserOperation(userOperation);
  const entryPointSimulationsCallData = encodeFunctionData({
    abi: EntryPointSimulationsAbi2,
    functionName: "simulateValidation",
    args: [packedUserOperation]
  });
  const errorResult = await callPimlicoEntryPointSimulations(publicClient, entryPoint, [entryPointSimulationsCallData], entryPointSimulationsAddress);
  return {
    simulateValidationResult: getSimulateValidationResult(errorResult[0])
  };
}
var panicCodes = {
  1: "assert(false)",
  17: "arithmetic overflow/underflow",
  18: "divide by zero",
  33: "invalid enum value",
  34: "storage byte array that is incorrectly encoded",
  49: ".pop() on an empty array.",
  50: "array sout-of-bounds or negative index",
  65: "memory overflow",
  81: "zero-initialized variable of internal function type"
};

// entrypoint-0.7/rpc/validation/UnsafeValidator.ts
var maxUint48 = 281474976710655;
var createFakeKeccak = (userOperation, simulatedValidationResult) => {
  const fakeKeccak = [];
  for (let i = 0;i < 1000; i++) {
    simulatedValidationResult.factoryInfo && userOperation.factory && fakeKeccak.push(concat([
      pad(simulatedValidationResult.factoryInfo.addr).toLowerCase(),
      toHex2(i)
    ]));
    simulatedValidationResult.senderInfo && fakeKeccak.push(concat([
      pad(simulatedValidationResult.senderInfo.addr).toLowerCase(),
      toHex2(i)
    ]));
    simulatedValidationResult.paymasterInfo && userOperation.paymaster && fakeKeccak.push(concat([
      pad(simulatedValidationResult.paymasterInfo.addr).toLowerCase(),
      toHex2(i)
    ]));
  }
  return fakeKeccak;
};

class UnsafeValidator4 {
  publicClient;
  entryPoint;
  logger;
  metrics;
  utilityWallet;
  usingTenderly;
  balanceOverrideEnabled;
  disableExpirationCheck;
  apiVersion;
  chainId;
  entryPointSimulationsAddress;
  gasPriceManager;
  constructor(publicClient, entryPoint, logger3, metrics2, gasPriceManager2, utilityWallet, apiVersion, entryPointSimulationsAddress, usingTenderly = false, balanceOverrideEnabled = false, disableExpirationCheck = false) {
    this.publicClient = publicClient;
    this.entryPoint = entryPoint;
    this.logger = logger3;
    this.metrics = metrics2;
    this.utilityWallet = utilityWallet;
    this.usingTenderly = usingTenderly;
    this.gasPriceManager = gasPriceManager2;
    this.balanceOverrideEnabled = balanceOverrideEnabled;
    this.disableExpirationCheck = disableExpirationCheck;
    this.apiVersion = apiVersion;
    this.chainId = publicClient.chain.id;
    this.entryPointSimulationsAddress = entryPointSimulationsAddress;
  }
  async getExecutionResult(userOperation, stateOverrides) {
    const error = await simulateHandleOp2(userOperation, this.entryPoint, this.publicClient, false, userOperation.sender, userOperation.callData, this.entryPointSimulationsAddress, stateOverrides);
    if (error.result === "failed") {
      throw new RpcError3(`UserOperation reverted during simulation with reason: ${error.data}`, error.code ?? ValidationErrors2.SimulateValidation, error.data);
    }
    return error.data;
  }
  validateStorageAccessList(userOperation, simulatedValidationResult, accessList) {
    const stakeInfoEntities = {
      factory: simulatedValidationResult.factoryInfo,
      account: simulatedValidationResult.senderInfo,
      paymaster: simulatedValidationResult.paymasterInfo
    };
    const fakeKeccak = createFakeKeccak(userOperation, simulatedValidationResult);
    const entitySlots = parseEntitySlots2(stakeInfoEntities, fakeKeccak);
    const accessListMap = accessList.reduce((acc, { address: address10, storageKeys }) => {
      acc[address10.toLowerCase()] = {
        address: address10,
        storageKeys
      };
      return acc;
    }, {});
    for (const [title, entStakes] of Object.entries(stakeInfoEntities)) {
      let requireCondAndStake = function(cond, entStake, failureMessage) {
        if (!cond) {
          return;
        }
        if (!entStake) {
          throw new Error(`internal: ${entityTitle} not in userOp, but has storage accesses in`);
        }
        if (!isStaked(entStake)) {
          throw new RpcError3(failureMessage, ValidationErrors2.OpcodeValidation, {
            [entityTitle]: entStakes?.addr
          });
        }
      };
      const entityTitle = title;
      if (!entStakes?.addr) {
        continue;
      }
      const entityAddr = (entStakes?.addr ?? "").toLowerCase();
      for (const [addr, { storageKeys }] of Object.entries(accessListMap)) {
        let nameAddr = function(addr2, _currentEntity) {
          const [title2] = Object.entries(stakeInfoEntities).find(([_title, info]) => info?.addr?.toLowerCase() === addr2.toLowerCase()) ?? [];
          return title2 ?? addr2;
        };
        if (addr === userOperation.sender.toLowerCase()) {
          continue;
        }
        if (addr === this.entryPoint.toLowerCase()) {
          continue;
        }
        let requireStakeSlot;
        for (const slot of storageKeys) {
          if (associatedWith(slot, userOperation.sender, entitySlots)) {
            if (userOperation.factory) {
              if (!(entityAddr === userOperation.sender.toLowerCase() && isStaked(stakeInfoEntities.factory))) {
                requireStakeSlot = slot;
              }
            }
          } else if (associatedWith(slot, entityAddr, entitySlots)) {
            requireStakeSlot = slot;
          } else if (addr === entityAddr) {
            requireStakeSlot = slot;
          } else if (slot !== "0x0000000000000000000000000000000000000000000000000000000000000000") {
            requireStakeSlot = slot;
          }
        }
        requireCondAndStake(requireStakeSlot !== undefined, entStakes, `un staked ${entityTitle} accessed ${nameAddr(addr, entityTitle)} slot ${requireStakeSlot}`);
      }
    }
  }
  async getValidationResult(userOperation, _codeHashes) {
    const { simulateValidationResult } = await simulateValidation(userOperation, this.entryPoint, this.publicClient, this.entryPointSimulationsAddress);
    if (simulateValidationResult.status === "failed") {
      throw new RpcError3(`UserOperation reverted with reason: ${simulateValidationResult.data}`, ValidationErrors2.SimulateValidation);
    }
    const validationResult = simulateValidationResult.data;
    const mergedValidation = this.mergeValidationDataValues(validationResult.returnInfo.accountValidationData, validationResult.returnInfo.paymasterValidationData);
    const res = {
      returnInfo: {
        ...validationResult.returnInfo,
        accountSigFailed: mergedValidation.accountSigFailed,
        paymasterSigFailed: mergedValidation.paymasterSigFailed,
        validUntil: mergedValidation.validUntil,
        validAfter: mergedValidation.validAfter
      },
      senderInfo: {
        ...validationResult.senderInfo,
        addr: userOperation.sender
      },
      factoryInfo: userOperation.factory && validationResult.factoryInfo ? {
        ...validationResult.factoryInfo,
        addr: userOperation.factory
      } : undefined,
      paymasterInfo: userOperation.paymaster && validationResult.paymasterInfo ? {
        ...validationResult.paymasterInfo,
        addr: userOperation.paymaster
      } : undefined,
      aggregatorInfo: validationResult.aggregatorInfo,
      storageMap: {}
    };
    if (res.returnInfo.accountSigFailed) {
      throw new RpcError3("Invalid UserOp signature", ValidationErrors2.InvalidSignature);
    }
    if (res.returnInfo.paymasterSigFailed) {
      throw new RpcError3("Invalid UserOp paymasterData", ValidationErrors2.InvalidSignature);
    }
    const now = Math.floor(Date.now() / 1000);
    if (res.returnInfo.validAfter > now - 5) {
      throw new RpcError3(`User operation is not valid yet, validAfter=${res.returnInfo.validAfter}, now=${now}`, ValidationErrors2.ExpiresShortly);
    }
    if (res.returnInfo.validUntil == null || res.returnInfo.validUntil < now + 30) {
      throw new RpcError3(`UserOperation expires too soon, validUntil=${res.returnInfo.validUntil}, now=${now}`, ValidationErrors2.ExpiresShortly);
    }
    return res;
  }
  async validatePreVerificationGas(userOperation) {
    const preVerificationGas = await calcPreVerificationGas2(this.publicClient, userOperation, this.entryPoint, this.chainId);
    if (preVerificationGas > userOperation.preVerificationGas) {
      throw new RpcError3(`preVerificationGas is not enough, required: ${preVerificationGas}, got: ${userOperation.preVerificationGas}`, ValidationErrors2.SimulateValidation);
    }
  }
  async validateUserOperation(userOperation, _referencedContracts) {
    try {
      const validationResult = await this.getValidationResult(userOperation);
      const prefund = validationResult.returnInfo.prefund;
      const [verificationGasLimit, callGasLimit] = await calcVerificationGasAndCallGasLimit2(this.publicClient, userOperation, {
        preOpGas: validationResult.returnInfo.preOpGas,
        paid: validationResult.returnInfo.prefund
      }, this.chainId);
      const mul = userOperation.paymaster ? 3n : 1n;
      const requiredPreFund = callGasLimit + verificationGasLimit * mul + userOperation.preVerificationGas;
      if (requiredPreFund > prefund) {
        throw new RpcError3(`prefund is not enough, required: ${requiredPreFund}, got: ${prefund}`, ValidationErrors2.SimulateValidation);
      }
      this.metrics.userOperationsValidationSuccess.inc();
      return validationResult;
    } catch (e) {
      this.metrics.userOperationsValidationFailure.inc();
      throw e;
    }
  }
  mergeValidationDataValues(accountValidationData, paymasterValidationData) {
    return this.mergeValidationData(this.parseValidationData(accountValidationData), this.parseValidationData(paymasterValidationData));
  }
  mergeValidationData(accountValidationData, paymasterValidationData) {
    return {
      paymasterSigFailed: paymasterValidationData.aggregator !== zeroAddress,
      accountSigFailed: accountValidationData.aggregator !== zeroAddress,
      validAfter: Math.max(accountValidationData.validAfter, paymasterValidationData.validAfter),
      validUntil: Math.min(accountValidationData.validUntil, paymasterValidationData.validUntil)
    };
  }
  parseValidationData(validationData) {
    const data3 = pad(toHex2(validationData), { size: 32 });
    const aggregator = slice(data3, 12);
    let validUntil = Number.parseInt(slice(data3, 6, 12), 16);
    if (validUntil === 0) {
      validUntil = maxUint48;
    }
    const validAfter = Number.parseInt(slice(data3, 0, 6), 16);
    return {
      aggregator,
      validAfter,
      validUntil
    };
  }
}

// entrypoint-0.7/rpc/validation/tracer.ts
var sentry10 = __toESM(require_cjs4(), 1);
async function debug_traceCall2(client, tx, options) {
  const traceOptions = tracer2string2(options);
  const ret2 = await client.request({
    method: "debug_traceCall",
    params: [formatTransactionRequest(tx), "latest", traceOptions]
  }).catch((e) => {
    if (e instanceof Error) {
      throw e;
    }
    sentry10.captureException(e);
  });
  return ret2;
}
function getTracerBodyString2(func) {
  const tracerFunc = func.toString();
  const regexp = /function \w+\s*\(\s*\)\s*{\s*return\s*(\{[\s\S]+\});?\s*\}\s*$/;
  const match = tracerFunc.match(regexp);
  if (match === null) {
    throw new Error("Not a simple method returning value");
  }
  let ret2 = match[1];
  ret2 = ret2.replace(/\b(?:const|let)\b/g, "");
  return ret2;
}
var tracer2string2 = function(options) {
  if (typeof options.tracer === "function") {
    return {
      ...options,
      tracer: getTracerBodyString2(options.tracer)
    };
  }
  return options;
};

// entrypoint-0.7/rpc/validation/SafeValidator.ts
class SafeValidator3 extends UnsafeValidator4 {
  senderManager;
  constructor(publicClient, senderManager2, entryPoint, logger3, metrics2, gasPriceManager2, utilityWallet, apiVersion, entryPointSimulationsAddress, usingTenderly = false, balanceOverrideEnabled = false) {
    super(publicClient, entryPoint, logger3, metrics2, gasPriceManager2, utilityWallet, apiVersion, entryPointSimulationsAddress, usingTenderly, balanceOverrideEnabled);
    this.senderManager = senderManager2;
  }
  async validateUserOperation(userOperation, referencedContracts) {
    try {
      const validationResult = await this.getValidationResult(userOperation, referencedContracts);
      const prefund = validationResult.returnInfo.prefund;
      const [verificationGasLimit, callGasLimit] = await calcVerificationGasAndCallGasLimit2(this.publicClient, userOperation, {
        preOpGas: validationResult.returnInfo.preOpGas,
        paid: validationResult.returnInfo.prefund
      }, this.chainId);
      const mul = userOperation.paymaster === "0x" ? 3n : 1n;
      const requiredPreFund = callGasLimit + verificationGasLimit * mul + userOperation.preVerificationGas;
      if (requiredPreFund > prefund) {
        throw new RpcError3(`prefund is not enough, required: ${requiredPreFund}, got: ${prefund}`, ValidationErrors2.SimulateValidation);
      }
      this.metrics.userOperationsValidationSuccess.inc();
      return validationResult;
    } catch (e) {
      this.metrics.userOperationsValidationFailure.inc();
      throw e;
    }
  }
  async getCodeHashes(addresses) {
    const deployData = encodeDeployData({
      abi: CodeHashGetterAbi2,
      bytecode: CodeHashGetterBytecode2,
      args: [addresses]
    });
    const wallet2 = await this.senderManager.getWallet();
    let hash4 = "";
    try {
      await this.publicClient.call({
        account: wallet2,
        data: deployData
      });
    } catch (e) {
      const error = e;
      hash4 = error.walk().data;
    }
    this.senderManager.pushWallet(wallet2);
    return {
      hash: hash4,
      addresses
    };
  }
  async getValidationResult(userOperation, preCodeHashes) {
    if (this.usingTenderly) {
      return super.getValidationResult(userOperation);
    }
    if (preCodeHashes && preCodeHashes.addresses.length > 0) {
      const { hash: hash4 } = await this.getCodeHashes(preCodeHashes.addresses);
      if (hash4 !== preCodeHashes.hash) {
        throw new RpcError3("code hashes mismatch", ValidationErrors2.OpcodeValidation);
      }
    }
    const [res, tracerResult] = await this.getValidationResultWithTracer(userOperation);
    const [contractAddresses, storageMap] = tracerResultParser2(userOperation, tracerResult, res, this.entryPoint.toLowerCase());
    const codeHashes = preCodeHashes || await this.getCodeHashes(contractAddresses);
    if (res === "0x") {
      throw new Error("simulateValidation reverted with no revert string!");
    }
    if (res.returnInfo.accountSigFailed) {
      throw new RpcError3("Invalid UserOp signature", ValidationErrors2.InvalidSignature);
    }
    if (res.returnInfo.paymasterSigFailed) {
      throw new RpcError3("Invalid UserOp paymasterData", ValidationErrors2.InvalidSignature);
    }
    const now = Math.floor(Date.now() / 1000);
    if (res.returnInfo.validAfter === undefined || res.returnInfo.validAfter > now - 5) {
      throw new RpcError3(`User operation is not valid yet, validAfter=${res.returnInfo.validAfter}, now=${now}`, ValidationErrors2.ExpiresShortly);
    }
    if (res.returnInfo.validUntil === undefined || res.returnInfo.validUntil < now + 30) {
      throw new RpcError3(`UserOperation expires too soon, validUntil=${res.returnInfo.validUntil}, now=${now}`, ValidationErrors2.ExpiresShortly);
    }
    return {
      ...res,
      referencedContracts: codeHashes,
      storageMap
    };
  }
  async getValidationResultWithTracer(userOperation) {
    const packedUserOperation = toPackedUserOperation(userOperation);
    const entryPointSimulationsCallData = encodeFunctionData({
      abi: EntryPointSimulationsAbi2,
      functionName: "simulateValidation",
      args: [packedUserOperation]
    });
    const callData = encodeDeployData({
      abi: PimlicoEntryPointSimulationsAbi,
      bytecode: PimlicoEntryPointSimulationsBytecode,
      args: [this.entryPoint, entryPointSimulationsCallData]
    });
    const tracerResult = await debug_traceCall2(this.publicClient, {
      from: zeroAddress,
      data: callData
    }, {
      tracer: bundlerCollectorTracer2
    });
    const lastResult = tracerResult.calls.slice(-1)[0];
    if (lastResult.type !== "REVERT") {
      throw new Error("Invalid response. simulateCall must revert");
    }
    const data3 = lastResult.data;
    if (data3 === "0x") {
      return [data3, tracerResult];
    }
    try {
      const { errorName, args: errorArgs } = decodeErrorResult({
        abi: EntryPointAbi2,
        data: data3
      });
      const errorResult = this.parseErrorResult(userOperation, {
        errorName,
        errorArgs
      });
      return [errorResult, tracerResult];
    } catch (e) {
      if (e.code != null) {
        throw e;
      }
      throw new RpcError3(data3);
    }
  }
  parseErrorResult(userOp, errorResult) {
    let decodedResult;
    try {
      decodeErrorResult({
        abi: EntryPointSimulationsAbi2,
        data: errorResult.errorArgs[1]
      });
      const result = decodeErrorResult({
        abi: EntryPointSimulationsAbi2,
        data: errorResult.errorArgs[1]
      });
      if (result.errorName === "FailedOp") {
        if ((result.args?.[1]).includes("AA24")) {
          throw new RpcError3("Invalid UserOp signature", ValidationErrors2.InvalidSignature);
        }
        if ((result.args?.[1]).includes("AA34")) {
          throw new RpcError3("Invalid UserOp paymasterData", ValidationErrors2.InvalidSignature);
        }
        throw new RpcError3(`ValidationResult error: ${result.args?.[1]}`, ValidationErrors2.SimulateValidation);
      }
      if (result.errorName === "FailedOpWithRevert") {
        const data3 = result.args?.[2];
        const error = parseFailedOpWithRevert(data3);
        throw new RpcError3(`ValidationResult error: ${result.args?.[1]} with revert error as: Panic(${error})`, ValidationErrors2.SimulateValidation);
      }
      throw new RpcError3(`ValidationResult error: ${result.errorName}`, ValidationErrors2.SimulateValidation);
    } catch (e) {
      if (e instanceof RpcError3) {
        throw e;
      }
      decodedResult = decodeAbiParameters([
        {
          components: [
            {
              components: [
                {
                  internalType: "uint256",
                  name: "preOpGas",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "prefund",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "accountValidationData",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "paymasterValidationData",
                  type: "uint256"
                },
                {
                  internalType: "bytes",
                  name: "paymasterContext",
                  type: "bytes"
                }
              ],
              internalType: "struct IEntryPoint.ReturnInfo",
              name: "returnInfo",
              type: "tuple"
            },
            {
              components: [
                {
                  internalType: "uint256",
                  name: "stake",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "unstakeDelaySec",
                  type: "uint256"
                }
              ],
              internalType: "struct IStakeManager.StakeInfo",
              name: "senderInfo",
              type: "tuple"
            },
            {
              components: [
                {
                  internalType: "uint256",
                  name: "stake",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "unstakeDelaySec",
                  type: "uint256"
                }
              ],
              internalType: "struct IStakeManager.StakeInfo",
              name: "factoryInfo",
              type: "tuple"
            },
            {
              components: [
                {
                  internalType: "uint256",
                  name: "stake",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "unstakeDelaySec",
                  type: "uint256"
                }
              ],
              internalType: "struct IStakeManager.StakeInfo",
              name: "paymasterInfo",
              type: "tuple"
            },
            {
              components: [
                {
                  internalType: "address",
                  name: "aggregator",
                  type: "address"
                },
                {
                  components: [
                    {
                      internalType: "uint256",
                      name: "stake",
                      type: "uint256"
                    },
                    {
                      internalType: "uint256",
                      name: "unstakeDelaySec",
                      type: "uint256"
                    }
                  ],
                  internalType: "struct IStakeManager.StakeInfo",
                  name: "stakeInfo",
                  type: "tuple"
                }
              ],
              internalType: "struct IEntryPoint.AggregatorStakeInfo",
              name: "aggregatorInfo",
              type: "tuple"
            }
          ],
          internalType: "struct IEntryPointSimulations.ValidationResult",
          name: "",
          type: "tuple"
        }
      ], errorResult.errorArgs[1])[0];
    }
    const mergedValidation = this.mergeValidationDataValues(decodedResult.returnInfo.accountValidationData, decodedResult.returnInfo.paymasterValidationData);
    return {
      returnInfo: {
        ...decodedResult.returnInfo,
        accountSigFailed: mergedValidation.accountSigFailed,
        paymasterSigFailed: mergedValidation.paymasterSigFailed,
        validUntil: mergedValidation.validUntil,
        validAfter: mergedValidation.validAfter
      },
      senderInfo: {
        ...decodedResult.senderInfo,
        addr: userOp.sender
      },
      factoryInfo: userOp.factory && decodedResult.factoryInfo ? {
        ...decodedResult.factoryInfo,
        addr: userOp.factory
      } : undefined,
      paymasterInfo: userOp.paymaster && decodedResult.paymasterInfo ? {
        ...decodedResult.paymasterInfo,
        addr: userOp.paymaster
      } : undefined,
      aggregatorInfo: decodedResult.aggregatorInfo
    };
  }
}
// entrypoint-0.7/rpc/nonceQueuer.ts
class NonceQueuer2 {
  queuedUserOperations = [];
  mempool;
  publicClient;
  entryPoint;
  logger;
  constructor(mempool8, publicClient, entryPoint, logger3) {
    this.mempool = mempool8;
    this.publicClient = publicClient;
    this.entryPoint = entryPoint;
    this.logger = logger3;
    setInterval(() => {
      this.process();
    }, 2000);
  }
  async process() {
    this.queuedUserOperations = this.queuedUserOperations.filter((qop) => {
      return qop.addedAt > Date.now() - 900000;
    });
    if (this.queuedUserOperations.length === 0) {
      return;
    }
    const availableOps = await this.getAvailableUserOperations(this.publicClient, this.entryPoint);
    if (availableOps.length === 0) {
      return;
    }
    this.queuedUserOperations = this.queuedUserOperations.filter((qop) => {
      return !availableOps.some((op) => {
        return op.userOperationHash === qop.userOperationHash;
      });
    });
    availableOps.map((op) => {
      this.resubmitUserOperation(op.mempoolUserOperation);
    });
    this.logger.info({ availableOps: availableOps.map((qop) => qop.userOperationHash) }, "submitted user operations from nonce queue");
  }
  add(mempoolUserOperation) {
    const userOp = deriveUserOperation2(mempoolUserOperation);
    const [nonceKey, nonceValue] = getNonceKeyAndValue2(userOp.nonce);
    this.queuedUserOperations.push({
      userOperationHash: getUserOperationHash2(toPackedUserOperation(deriveUserOperation2(mempoolUserOperation)), this.entryPoint, this.publicClient.chain.id),
      mempoolUserOperation,
      nonceKey,
      nonceValue,
      addedAt: Date.now()
    });
  }
  resubmitUserOperation(mempoolUserOperation) {
    const userOperation = mempoolUserOperation;
    this.logger.info({ userOperation }, "submitting user operation from nonce queue");
    const result = this.mempool.add(mempoolUserOperation);
    if (result) {
      this.logger.info({ userOperation, result }, "added user operation");
    } else {
      this.logger.error("error adding user operation");
    }
  }
  async getAvailableUserOperations(publicClient, entryPoint) {
    const queuedUserOperations = this.queuedUserOperations.slice();
    let results;
    try {
      results = await publicClient.multicall({
        contracts: queuedUserOperations.map((qop) => {
          const userOp = deriveUserOperation2(qop.mempoolUserOperation);
          return {
            address: entryPoint,
            abi: EntryPointAbi2,
            functionName: "getNonce",
            args: [userOp.sender, qop.nonceKey]
          };
        }),
        blockTag: "latest"
      });
    } catch (error) {
      this.logger.error({ error: JSON.stringify(error) }, "error fetching with multiCall");
      const entryPointContract = getContract({
        abi: EntryPointAbi2,
        address: entryPoint,
        publicClient
      });
      results = await Promise.all(queuedUserOperations.map(async (qop) => {
        const userOp = deriveUserOperation2(qop.mempoolUserOperation);
        try {
          const nonce = await entryPointContract.read.getNonce([userOp.sender, qop.nonceKey], { blockTag: "latest" });
          return {
            result: nonce,
            status: "success"
          };
        } catch (e) {
          return {
            error: e,
            status: "failure"
          };
        }
      }));
    }
    if (results.length !== queuedUserOperations.length) {
      this.logger.error("error fetching nonces");
      return [];
    }
    const currentOutstandingOps = [];
    for (let i = 0;i < queuedUserOperations.length; i++) {
      const qop = queuedUserOperations[i];
      const result = results[i];
      if (result.status !== "success") {
        this.logger.error({ error: result.error }, "error fetching nonce");
        continue;
      }
      const onchainNonceValue = result.result;
      if (onchainNonceValue === qop.nonceValue) {
        currentOutstandingOps.push(qop);
      }
    }
    return currentOutstandingOps;
  }
}
// entrypoint-0.7/executor/executor.ts
var sentry12 = __toESM(require_cjs4(), 1);

// entrypoint-0.7/executor/utils.ts
var sentry11 = __toESM(require_cjs4(), 1);
function simulatedOpsToResults2(simulatedOps, transactionInfo) {
  return simulatedOps.map((sop) => {
    if (sop.reason === undefined) {
      return {
        status: "success",
        value: {
          userOperation: {
            mempoolUserOperation: sop.owh.mempoolUserOperation,
            userOperationHash: sop.owh.userOperationHash,
            lastReplaced: Date.now(),
            firstSubmitted: Date.now()
          },
          transactionInfo
        }
      };
    }
    return {
      status: "failure",
      error: {
        userOpHash: sop.owh.userOperationHash,
        reason: sop.reason
      }
    };
  });
}
function createCompressedCalldata2(compressedOps, perOpInflatorId) {
  const bundleBulkerPayload = numberToHex(perOpInflatorId, { size: 4 });
  const perOpInflatorPayload = numberToHex(compressedOps.length, { size: 1 });
  return compressedOps.reduce((currentCallData, op) => {
    const nextCallData = concat([
      numberToHex(op.inflatorId, { size: 4 }),
      numberToHex(hexToBytes(op.compressedCalldata).length, {
        size: 2
      }),
      op.compressedCalldata
    ]);
    return concat([currentCallData, nextCallData]);
  }, concat([bundleBulkerPayload, perOpInflatorPayload]));
}
async function filterOpsAndEstimateGas2(callContext, wallet2, ops, nonce, maxFeePerGas, maxPriorityFeePerGas, blockTag, onlyPre1559, customGasLimitForEstimation, reputationManager5, logger3) {
  const simulatedOps = ops.map((owh) => {
    return { owh, reason: undefined };
  });
  let gasLimit;
  while (simulatedOps.filter((op) => op.reason === undefined).length > 0) {
    try {
      const gasOptions = onlyPre1559 ? { gasPrice: maxFeePerGas } : { maxFeePerGas, maxPriorityFeePerGas };
      if (callContext.type === "default") {
        const ep = callContext.ep;
        const opsToSend = simulatedOps.filter((op) => op.reason === undefined).map((op) => toPackedUserOperation(op.owh.mempoolUserOperation));
        gasLimit = await ep.estimateGas.handleOps([opsToSend, wallet2.address], {
          account: wallet2,
          gas: customGasLimitForEstimation,
          nonce,
          blockTag,
          ...gasOptions
        });
      } else {
        const { publicClient, bundleBulker, perOpInflatorId } = callContext;
        const opsToSend = simulatedOps.filter((op) => op.reason === undefined).map((op) => op.owh.mempoolUserOperation);
        gasLimit = await publicClient.estimateGas({
          to: bundleBulker,
          account: wallet2,
          data: createCompressedCalldata2(opsToSend, perOpInflatorId),
          gas: customGasLimitForEstimation,
          nonce,
          blockTag,
          ...gasOptions
        });
      }
      return { simulatedOps, gasLimit, resubmitAllOps: false };
    } catch (err) {
      const e = parseViemError2(err);
      if (e instanceof ContractFunctionRevertedError) {
        const parsingResult = failedOpErrorSchema2.safeParse(e.data);
        if (parsingResult.success) {
          const failedOpError = parsingResult.data;
          logger3.debug({
            failedOpError,
            userOpHashes: simulatedOps.filter((op) => op.reason === undefined).map((op) => op.owh.userOperationHash)
          }, "user op in batch invalid");
          const failingOp = simulatedOps.filter((op) => op.reason === undefined)[Number(failedOpError.args.opIndex)];
          failingOp.reason = failedOpError.args.reason;
          reputationManager5.crashedHandleOps(deriveUserOperation2(failingOp.owh.mempoolUserOperation), failingOp.reason);
        } else {
          sentry11.captureException(err);
          logger3.error({
            error: parsingResult.error
          }, "failed to parse failedOpError");
          return {
            simulatedOps: [],
            gasLimit: 0n,
            resubmitAllOps: false
          };
        }
      } else if (e instanceof EstimateGasExecutionError) {
        try {
          const errorHexData = e.details.split("Reverted ")[1];
          const errorResult = decodeErrorResult({
            abi: EntryPointAbi2,
            data: errorHexData
          });
          logger3.debug({
            errorName: errorResult.errorName,
            args: errorResult.args,
            userOpHashes: simulatedOps.filter((op) => op.reason === undefined).map((op) => op.owh.userOperationHash)
          }, "user op in batch invalid");
          if (errorResult.errorName !== "FailedOp") {
            logger3.error({
              errorName: errorResult.errorName,
              args: errorResult.args
            }, "unexpected error result");
            return {
              simulatedOps: [],
              gasLimit: 0n,
              resubmitAllOps: false
            };
          }
          const failingOp = simulatedOps.filter((op) => op.reason === undefined)[Number(errorResult.args[0])];
          failingOp.reason = errorResult.args[1];
        } catch (_e) {
          logger3.error({ error: JSON.stringify(err) }, "failed to parse error result");
          return {
            simulatedOps: [],
            gasLimit: 0n,
            resubmitAllOps: false
          };
        }
      } else if (e instanceof EstimateGasExecutionError) {
        if (e.cause instanceof FeeCapTooLowError) {
          logger3.info({ error: e.shortMessage }, "error estimating gas due to max fee < basefee");
          return {
            simulatedOps,
            gasLimit: 0n,
            resubmitAllOps: true
          };
        }
      } else {
        sentry11.captureException(err);
        logger3.error({ error: JSON.stringify(err) }, "error estimating gas");
        return { simulatedOps: [], gasLimit: 0n, resubmitAllOps: false };
      }
    }
  }
  return { simulatedOps, gasLimit: 0n, resubmitAllOps: false };
}
async function flushStuckTransaction2(publicClient, walletClient, wallet2, gasPrice7, logger3) {
  const latestNonce = await publicClient.getTransactionCount({
    address: wallet2.address,
    blockTag: "latest"
  });
  const pendingNonce = await publicClient.getTransactionCount({
    address: wallet2.address,
    blockTag: "pending"
  });
  logger3.debug({ latestNonce, pendingNonce, wallet: wallet2.address }, "checking for stuck transactions");
  if (latestNonce === pendingNonce) {
    return;
  }
  if (latestNonce + 1 === pendingNonce) {
    return;
  }
  logger3.info({ latestNonce, pendingNonce, wallet: wallet2.address }, "found stuck transaction, flushing");
  for (let nonceToFlush = latestNonce;nonceToFlush < pendingNonce; nonceToFlush++) {
    try {
      const txHash = await walletClient.sendTransaction({
        account: wallet2,
        to: wallet2.address,
        value: 0n,
        nonce: nonceToFlush,
        maxFeePerGas: gasPrice7,
        maxPriorityFeePerGas: gasPrice7
      });
      logger3.debug({ txHash, nonce: nonceToFlush, wallet: wallet2.address }, "flushed stuck transaction");
      await transactionIncluded2(txHash, publicClient);
    } catch (e) {
      sentry11.captureException(e);
      logger3.warn({ error: e }, "error flushing stuck transaction");
    }
  }
}

// entrypoint-0.7/executor/executor.ts
class BasicExecutor2 {
  publicClient;
  walletClient;
  senderManager;
  entryPoint;
  logger;
  metrics;
  simulateTransaction;
  noEip1559Support;
  customGasLimitForEstimation;
  useUserOperationGasLimitsForSubmission;
  reputationManager;
  compressionHandler;
  gasPriceManager;
  mutex;
  constructor(publicClient, walletClient, senderManager2, reputationManager5, entryPoint, logger3, metrics2, compressionHandler3, gasPriceManager2, simulateTransaction = false, noEip1559Support = false, customGasLimitForEstimation, useUserOperationGasLimitsForSubmission = false) {
    this.publicClient = publicClient;
    this.walletClient = walletClient;
    this.senderManager = senderManager2;
    this.reputationManager = reputationManager5;
    this.entryPoint = entryPoint;
    this.logger = logger3;
    this.metrics = metrics2;
    this.gasPriceManager = gasPriceManager2;
    this.simulateTransaction = simulateTransaction;
    this.noEip1559Support = noEip1559Support;
    this.customGasLimitForEstimation = customGasLimitForEstimation;
    this.useUserOperationGasLimitsForSubmission = useUserOperationGasLimitsForSubmission;
    this.compressionHandler = compressionHandler3;
    this.mutex = new Mutex;
  }
  getCompressionHandler() {
    if (!this.compressionHandler) {
      throw new Error("Support for compressed bundles has not initialized");
    }
    return this.compressionHandler;
  }
  cancelOps(_entryPoint, _ops) {
    throw new Error("Method not implemented.");
  }
  markWalletProcessed(executor3) {
    return new Promise(() => {
      if (!this.senderManager.availableWallets.includes(executor3)) {
        this.senderManager.pushWallet(executor3);
      }
    });
  }
  async replaceTransaction(transactionInfo) {
    const newRequest = { ...transactionInfo.transactionRequest };
    const gasPriceParameters = await this.gasPriceManager.getGasPrice();
    newRequest.maxFeePerGas = maxBigInt(gasPriceParameters.maxFeePerGas, (newRequest.maxFeePerGas * 11n + 9n) / 10n);
    newRequest.maxPriorityFeePerGas = maxBigInt(gasPriceParameters.maxPriorityFeePerGas, (newRequest.maxPriorityFeePerGas * 11n + 9n) / 10n);
    newRequest.account = transactionInfo.executor;
    const opsWithHashes = transactionInfo.userOperationInfos.map((opInfo) => {
      const op = deriveUserOperation2(opInfo.mempoolUserOperation);
      return {
        mempoolUserOperation: opInfo.mempoolUserOperation,
        userOperationHash: getUserOperationHash2(toPackedUserOperation(op), this.entryPoint, this.walletClient.chain.id)
      };
    });
    let callContext;
    if (transactionInfo.transactionType === "default") {
      const ep = getContract({
        abi: EntryPointAbi2,
        address: this.entryPoint,
        publicClient: this.publicClient,
        walletClient: this.walletClient
      });
      callContext = {
        ep,
        type: "default"
      };
    } else {
      const compressionHandler3 = this.getCompressionHandler();
      callContext = {
        publicClient: this.publicClient,
        bundleBulker: compressionHandler3.bundleBulkerAddress,
        perOpInflatorId: compressionHandler3.perOpInflatorId,
        type: "compressed"
      };
    }
    const result = await filterOpsAndEstimateGas2(callContext, transactionInfo.executor, opsWithHashes, newRequest.nonce, newRequest.maxFeePerGas, newRequest.maxPriorityFeePerGas, "latest", this.noEip1559Support, this.customGasLimitForEstimation, this.reputationManager, this.logger);
    const childLogger = this.logger.child({
      transactionHash: transactionInfo.transactionHash,
      executor: transactionInfo.executor.address
    });
    if (result.simulatedOps.length === 0) {
      childLogger.warn("no ops to bundle");
      this.markWalletProcessed(transactionInfo.executor);
      return { status: "failed" };
    }
    if (result.simulatedOps.every((op) => op.reason === "AA25 invalid account nonce" || op.reason === "AA10 sender already constructed")) {
      childLogger.trace({ reasons: result.simulatedOps.map((sop) => sop.reason) }, "all ops failed simulation with nonce error");
      return { status: "potentially_already_included" };
    }
    if (result.simulatedOps.every((op) => op.reason !== undefined)) {
      childLogger.warn("all ops failed simulation");
      this.markWalletProcessed(transactionInfo.executor);
      return { status: "failed" };
    }
    const opsToBundle = result.simulatedOps.filter((op) => op.reason === undefined).map((op) => {
      const opInfo = transactionInfo.userOperationInfos.find((info) => info.userOperationHash === op.owh.userOperationHash);
      if (!opInfo) {
        throw new Error("opInfo not found");
      }
      return opInfo;
    });
    newRequest.gas = this.useUserOperationGasLimitsForSubmission ? opsToBundle.reduce((acc, opInfo) => {
      const userOperation = deriveUserOperation2(opInfo.mempoolUserOperation);
      return acc + userOperation.preVerificationGas + 3n * userOperation.verificationGasLimit + userOperation.callGasLimit;
    }, 0n) : result.gasLimit;
    if (transactionInfo.transactionType === "default") {
      newRequest.data = encodeFunctionData({
        abi: EntryPointAbi2,
        functionName: "handleOps",
        args: [
          opsToBundle.map((opInfo) => toPackedUserOperation(opInfo.mempoolUserOperation)),
          transactionInfo.executor.address
        ]
      });
    } else if (transactionInfo.transactionType === "compressed") {
      const compressedOps = opsToBundle.map((opInfo) => opInfo.mempoolUserOperation);
      newRequest.data = createCompressedCalldata2(compressedOps, this.getCompressionHandler().perOpInflatorId);
    }
    try {
      childLogger.info({
        newRequest: {
          ...newRequest,
          abi: undefined,
          chain: undefined
        },
        executor: newRequest.account.address,
        opsToBundle: opsToBundle.map((opInfo) => opInfo.userOperationHash)
      }, "replacing transaction");
      const txHash = await this.walletClient.sendTransaction(this.noEip1559Support ? {
        ...newRequest,
        gasPrice: newRequest.maxFeePerGas,
        maxFeePerGas: undefined,
        maxPriorityFeePerGas: undefined,
        type: "legacy",
        accessList: undefined
      } : newRequest);
      const newTxInfo = {
        ...transactionInfo,
        transactionRequest: newRequest,
        transactionHash: txHash,
        previousTransactionHashes: [
          transactionInfo.transactionHash,
          ...transactionInfo.previousTransactionHashes
        ],
        lastReplaced: Date.now(),
        userOperationInfos: opsToBundle.map((opInfo) => {
          return {
            mempoolUserOperation: opInfo.mempoolUserOperation,
            userOperationHash: opInfo.userOperationHash,
            lastReplaced: Date.now(),
            firstSubmitted: opInfo.firstSubmitted
          };
        })
      };
      return { status: "replaced", transactionInfo: newTxInfo };
    } catch (err) {
      const e = parseViemError2(err);
      if (!e) {
        sentry12.captureException(err);
        childLogger.error({ error: err }, "unknown error replacing transaction");
      }
      if (e instanceof NonceTooLowError) {
        childLogger.trace({ error: e }, "nonce too low, potentially already included");
        return { status: "potentially_already_included" };
      }
      if (e instanceof FeeCapTooLowError) {
        childLogger.warn({ error: e }, "fee cap too low, not replacing");
      }
      if (e instanceof InsufficientFundsError) {
        childLogger.warn({ error: e }, "insufficient funds, not replacing");
      }
      if (e instanceof IntrinsicGasTooLowError) {
        childLogger.warn({ error: e }, "intrinsic gas too low, not replacing");
      }
      childLogger.warn({ error: e }, "error replacing transaction");
      this.markWalletProcessed(transactionInfo.executor);
      return { status: "failed" };
    }
  }
  async flushStuckTransactions() {
    const gasPrice7 = await this.gasPriceManager.getGasPrice();
    const wallets = Array.from(new Set([
      ...this.senderManager.wallets,
      this.senderManager.utilityAccount
    ]));
    const promises = wallets.map(async (wallet2) => {
      return flushStuckTransaction2(this.publicClient, this.walletClient, wallet2, gasPrice7.maxFeePerGas * 5n, this.logger);
    });
    await Promise.all(promises);
  }
  async bundle(entryPoint, ops) {
    const wallet2 = await this.senderManager.getWallet();
    const opsWithHashes = ops.map((op) => {
      return {
        mempoolUserOperation: op,
        userOperationHash: getUserOperationHash2(toPackedUserOperation(op), entryPoint, this.walletClient.chain.id)
      };
    });
    const ep = getContract({
      abi: EntryPointAbi2,
      address: entryPoint,
      publicClient: this.publicClient,
      walletClient: this.walletClient
    });
    let childLogger = this.logger.child({
      userOperations: opsWithHashes.map((oh) => oh.userOperationHash),
      entryPoint
    });
    childLogger.debug("bundling user operation");
    const gasPriceParameters = await this.gasPriceManager.getGasPrice();
    childLogger.debug({ gasPriceParameters }, "got gas price");
    const nonce = await this.publicClient.getTransactionCount({
      address: wallet2.address,
      blockTag: "pending"
    });
    childLogger.trace({ nonce }, "got nonce");
    const callContext = {
      ep,
      type: "default"
    };
    const { gasLimit, simulatedOps, resubmitAllOps } = await filterOpsAndEstimateGas2(callContext, wallet2, opsWithHashes, nonce, gasPriceParameters.maxFeePerGas, gasPriceParameters.maxPriorityFeePerGas, "pending", this.noEip1559Support, this.customGasLimitForEstimation, this.reputationManager, childLogger);
    if (resubmitAllOps) {
      this.markWalletProcessed(wallet2);
      return opsWithHashes.map((owh) => {
        return {
          status: "resubmit",
          info: {
            userOpHash: owh.userOperationHash,
            userOperation: owh.mempoolUserOperation,
            reason: FeeCapTooLowError.name
          }
        };
      });
    }
    if (simulatedOps.length === 0) {
      childLogger.error("gas limit simulation encountered unexpected failure");
      this.markWalletProcessed(wallet2);
      return opsWithHashes.map((owh) => {
        return {
          status: "failure",
          error: {
            userOpHash: owh.userOperationHash,
            reason: "INTERNAL FAILURE"
          }
        };
      });
    }
    if (simulatedOps.every((op) => op.reason !== undefined)) {
      childLogger.warn("all ops failed simulation");
      this.markWalletProcessed(wallet2);
      return simulatedOps.map((op) => {
        return {
          status: "failure",
          error: {
            userOpHash: op.owh.userOperationHash,
            reason: op.reason
          }
        };
      });
    }
    const opsWithHashToBundle = simulatedOps.filter((op) => op.reason === undefined).map((op) => op.owh);
    childLogger = this.logger.child({
      userOperations: opsWithHashToBundle.map((owh) => owh.userOperationHash),
      entryPoint
    });
    childLogger.trace({ gasLimit }, "got gas limit");
    let txHash;
    try {
      const gasOptions = this.noEip1559Support ? {
        gasPrice: gasPriceParameters.maxFeePerGas
      } : {
        maxFeePerGas: gasPriceParameters.maxFeePerGas,
        maxPriorityFeePerGas: gasPriceParameters.maxPriorityFeePerGas
      };
      txHash = await ep.write.handleOps([
        opsWithHashToBundle.map((owh) => toPackedUserOperation(owh.mempoolUserOperation)),
        wallet2.address
      ], {
        account: wallet2,
        gas: gasLimit,
        nonce,
        ...gasOptions
      });
    } catch (err) {
      sentry12.captureException(err);
      childLogger.error({ error: JSON.stringify(err) }, "error submitting bundle transaction");
      this.markWalletProcessed(wallet2);
      return opsWithHashes.map((owh) => {
        return {
          status: "failure",
          error: {
            userOpHash: owh.userOperationHash,
            reason: "INTERNAL FAILURE"
          }
        };
      });
    }
    const userOperationInfos = opsWithHashToBundle.map((op) => {
      return {
        mempoolUserOperation: op.mempoolUserOperation,
        userOperationHash: op.userOperationHash,
        lastReplaced: Date.now(),
        firstSubmitted: Date.now()
      };
    });
    const transactionInfo = {
      transactionType: "default",
      transactionHash: txHash,
      previousTransactionHashes: [],
      transactionRequest: {
        account: wallet2,
        to: ep.address,
        data: encodeFunctionData({
          abi: ep.abi,
          functionName: "handleOps",
          args: [
            opsWithHashToBundle.map((owh) => toPackedUserOperation(owh.mempoolUserOperation)),
            wallet2.address
          ]
        }),
        gas: gasLimit,
        chain: this.walletClient.chain,
        maxFeePerGas: gasPriceParameters.maxFeePerGas,
        maxPriorityFeePerGas: gasPriceParameters.maxPriorityFeePerGas,
        nonce
      },
      executor: wallet2,
      userOperationInfos,
      lastReplaced: Date.now(),
      firstSubmitted: Date.now(),
      timesPotentiallyIncluded: 0
    };
    const userOperationResults = simulatedOpsToResults2(simulatedOps, transactionInfo);
    childLogger.info({
      transactionRequest: {
        ...transactionInfo.transactionRequest,
        abi: undefined
      },
      txHash,
      opHashes: opsWithHashToBundle.map((owh) => owh.userOperationHash)
    }, "submitted bundle transaction");
    return userOperationResults;
  }
  async bundleCompressed(entryPoint, compressedOps) {
    const compressionHandler3 = this.getCompressionHandler();
    const wallet2 = await this.senderManager.getWallet();
    const childLogger = this.logger.child({
      compressedUserOperations: compressedOps,
      entryPoint: this.entryPoint
    });
    childLogger.debug("bundling compressed user operation");
    const gasPriceParameters = await this.gasPriceManager.getGasPrice();
    childLogger.debug({ gasPriceParameters }, "got gas price");
    const nonce = await this.publicClient.getTransactionCount({
      address: wallet2.address,
      blockTag: "pending"
    });
    childLogger.trace({ nonce }, "got nonce");
    const callContext = {
      publicClient: this.publicClient,
      bundleBulker: compressionHandler3.bundleBulkerAddress,
      perOpInflatorId: compressionHandler3.perOpInflatorId,
      type: "compressed"
    };
    let { gasLimit, simulatedOps, resubmitAllOps } = await filterOpsAndEstimateGas2(callContext, wallet2, compressedOps.map((compressedOp) => {
      return {
        mempoolUserOperation: compressedOp,
        userOperationHash: getUserOperationHash2(toPackedUserOperation(compressedOp.inflatedOp), entryPoint, this.walletClient.chain.id)
      };
    }), nonce, gasPriceParameters.maxFeePerGas, gasPriceParameters.maxPriorityFeePerGas, "pending", this.noEip1559Support, this.customGasLimitForEstimation, this.reputationManager, childLogger);
    gasLimit += 10000n;
    if (resubmitAllOps) {
      this.markWalletProcessed(wallet2);
      return compressedOps.map((compressedOp) => {
        return {
          status: "resubmit",
          info: {
            userOpHash: getUserOperationHash2(toPackedUserOperation(compressedOp.inflatedOp), entryPoint, this.walletClient.chain.id),
            userOperation: compressedOp,
            reason: FeeCapTooLowError.name
          }
        };
      });
    }
    if (simulatedOps.length === 0) {
      childLogger.warn("no ops to bundle");
      this.markWalletProcessed(wallet2);
      return compressedOps.map((compressedOp) => {
        return {
          status: "failure",
          error: {
            userOpHash: getUserOperationHash2(toPackedUserOperation(compressedOp.inflatedOp), entryPoint, this.walletClient.chain.id),
            reason: "INTERNAL FAILURE"
          }
        };
      });
    }
    if (simulatedOps.some((simulatedOp) => simulatedOp.reason !== undefined)) {
      childLogger.warn("some ops failed simulation");
      this.markWalletProcessed(wallet2);
      return simulatedOps.map((simulatedOp) => {
        return {
          status: "failure",
          error: {
            userOpHash: simulatedOp.owh.userOperationHash,
            reason: simulatedOp.reason
          }
        };
      });
    }
    const opsToBundle = simulatedOps.filter((simulatedOp) => simulatedOp.reason === undefined).map((simulatedOp) => simulatedOp.owh);
    let txHash;
    try {
      const gasOptions = this.noEip1559Support ? {
        gasPrice: gasPriceParameters.maxFeePerGas
      } : {
        maxFeePerGas: gasPriceParameters.maxFeePerGas,
        maxPriorityFeePerGas: gasPriceParameters.maxPriorityFeePerGas
      };
      txHash = await this.walletClient.sendTransaction({
        account: wallet2,
        to: compressionHandler3.bundleBulkerAddress,
        data: createCompressedCalldata2(compressedOps, compressionHandler3.perOpInflatorId),
        gas: gasLimit,
        nonce,
        ...gasOptions
      });
    } catch (err) {
      sentry12.captureException(err);
      childLogger.error({ error: JSON.stringify(err) }, "error submitting bundle transaction");
      this.markWalletProcessed(wallet2);
      return opsToBundle.map((op) => {
        return {
          status: "failure",
          error: {
            userOpHash: op.userOperationHash,
            reason: "INTERNAL FAILURE"
          }
        };
      });
    }
    const userOperationInfos = opsToBundle.map((owh) => {
      return {
        mempoolUserOperation: owh.mempoolUserOperation,
        userOperationHash: owh.userOperationHash,
        lastReplaced: Date.now(),
        firstSubmitted: Date.now()
      };
    });
    const transactionInfo = {
      transactionType: "compressed",
      transactionHash: txHash,
      previousTransactionHashes: [],
      transactionRequest: {
        to: compressionHandler3.bundleBulkerAddress,
        data: createCompressedCalldata2(compressedOps, compressionHandler3.perOpInflatorId),
        gas: gasLimit,
        account: wallet2,
        chain: this.walletClient.chain,
        maxFeePerGas: gasPriceParameters.maxFeePerGas,
        maxPriorityFeePerGas: gasPriceParameters.maxPriorityFeePerGas,
        nonce
      },
      executor: wallet2,
      userOperationInfos,
      lastReplaced: Date.now(),
      firstSubmitted: Date.now(),
      timesPotentiallyIncluded: 0
    };
    const userOperationResults = simulatedOpsToResults2(simulatedOps, transactionInfo);
    childLogger.info({
      txHash,
      opHashes: opsToBundle.map((owh) => owh.userOperationHash)
    }, "submitted bundle transaction");
    return userOperationResults;
  }
}
// entrypoint-0.7/executor/executorManager.ts
var getTransactionsFromUserOperationEntries2 = function(entries) {
  return Array.from(new Set(entries.map((entry) => {
    return entry.transactionInfo;
  })));
};

class ExecutorManager2 {
  executor;
  mempool;
  monitor;
  publicClient;
  entryPointAddress;
  pollingInterval;
  logger;
  metrics;
  reputationManager;
  unWatch;
  currentlyHandlingBlock = false;
  timer;
  bundlerFrequency;
  gasPriceManager;
  constructor(executor3, mempool8, monitor, reputationManager5, publicClient, entryPointAddress, pollingInterval, logger3, metrics2, bundleMode, bundlerFrequency, gasPriceManager2) {
    this.reputationManager = reputationManager5;
    this.executor = executor3;
    this.mempool = mempool8;
    this.monitor = monitor;
    this.publicClient = publicClient;
    this.entryPointAddress = entryPointAddress;
    this.pollingInterval = pollingInterval;
    this.logger = logger3;
    this.metrics = metrics2;
    this.bundlerFrequency = bundlerFrequency;
    this.gasPriceManager = gasPriceManager2;
    if (bundleMode === "auto") {
      this.timer = setInterval(async () => {
        await this.bundle();
      }, bundlerFrequency);
    }
  }
  setBundlingMode(bundleMode) {
    if (bundleMode === "auto" && !this.timer) {
      this.timer = setInterval(async () => {
        await this.bundle();
      }, this.bundlerFrequency);
    } else if (bundleMode === "manual" && this.timer) {
      clearInterval(this.timer);
      this.timer = undefined;
    }
  }
  async bundleNow() {
    const ops = await this.mempool.process(5000000n, 1);
    if (ops.length === 0) {
      throw new Error("no ops to bundle");
    }
    const txHash = await this.sendToExecutor(ops);
    if (!txHash) {
      throw new Error("no tx hash");
    }
    return txHash;
  }
  async sendToExecutor(mempoolOps) {
    const ops = mempoolOps.filter((op) => !isCompressedType2(op)).map((op) => op);
    const compressedOps = mempoolOps.filter((op) => isCompressedType2(op)).map((op) => op);
    const bundles = [];
    if (ops.length > 0) {
      bundles.push(await this.executor.bundle(this.entryPointAddress, ops));
    }
    if (compressedOps.length > 0) {
      bundles.push(await this.executor.bundleCompressed(this.entryPointAddress, compressedOps));
    }
    for (const bundle of bundles) {
      const isBundleSuccess = bundle.every((result) => result.status === "success");
      if (isBundleSuccess) {
        this.metrics.bundlesSubmitted.labels({ status: "success" }).inc();
      } else {
        this.metrics.bundlesSubmitted.labels({ status: "failed" }).inc();
      }
    }
    const results = bundles.flat();
    const filteredOutOps = mempoolOps.length - results.length;
    if (filteredOutOps > 0) {
      this.logger.debug({ filteredOutOps }, "user operations filtered out");
      this.metrics.userOperationsSubmitted.labels({ status: "filtered" }).inc(filteredOutOps);
    }
    let txHash = undefined;
    for (const result of results) {
      if (result.status === "success") {
        const res = result.value;
        this.mempool.markSubmitted(res.userOperation.userOperationHash, res.transactionInfo);
        this.monitor.setUserOperationStatus(res.userOperation.userOperationHash, {
          status: "submitted",
          transactionHash: res.transactionInfo.transactionHash
        });
        txHash = res.transactionInfo.transactionHash;
        this.startWatchingBlocks(this.handleBlock.bind(this));
        this.metrics.userOperationsSubmitted.labels({ status: "success" }).inc();
      }
      if (result.status === "failure") {
        this.mempool.removeProcessing(result.error.userOpHash);
        this.monitor.setUserOperationStatus(result.error.userOpHash, {
          status: "rejected",
          transactionHash: null
        });
        this.logger.warn({
          userOpHash: result.error.userOpHash,
          reason: result.error.reason
        }, "user operation rejected");
        this.metrics.userOperationsSubmitted.labels({ status: "failed" }).inc();
      }
      if (result.status === "resubmit") {
        this.logger.info({
          userOpHash: result.info.userOpHash,
          reason: result.info.reason
        }, "resubmitting user operation");
        this.mempool.removeProcessing(result.info.userOpHash);
        this.mempool.add(result.info.userOperation);
        this.metrics.userOperationsResubmitted.inc();
      }
    }
    return txHash;
  }
  async bundle() {
    const opsToBundle = [];
    while (true) {
      const ops = await this.mempool.process(5000000n, 1);
      if (ops?.length > 0) {
        opsToBundle.push(ops);
      } else {
        break;
      }
    }
    if (opsToBundle.length === 0) {
      return;
    }
    await Promise.all(opsToBundle.map(async (ops) => {
      await this.sendToExecutor(ops);
    }));
  }
  startWatchingBlocks(handleBlock) {
    if (this.unWatch) {
      return;
    }
    this.unWatch = this.publicClient.watchBlocks({
      onBlock: handleBlock,
      onError: (error) => {
        this.logger.error({ error }, "error while watching blocks");
      },
      emitMissed: false,
      includeTransactions: false,
      pollingInterval: this.pollingInterval
    });
    this.logger.debug("started watching blocks");
  }
  stopWatchingBlocks() {
    if (this.unWatch) {
      this.logger.debug("stopped watching blocks");
      this.unWatch();
      this.unWatch = undefined;
    }
  }
  async refreshTransactionStatus(transactionInfo) {
    const hashesToCheck = [
      transactionInfo.transactionHash,
      ...transactionInfo.previousTransactionHashes
    ];
    const opInfos = transactionInfo.userOperationInfos;
    const transactionStatuses = await Promise.all(hashesToCheck.map(async (hash4) => {
      return {
        hash: hash4,
        transactionStatuses: await transactionIncluded2(hash4, this.publicClient)
      };
    }));
    const status = transactionStatuses.find((status2) => status2.transactionStatuses.status === "included" || status2.transactionStatuses.status === "failed" || status2.transactionStatuses.status === "reverted");
    if (!status) {
      opInfos.map((info) => {
        this.logger.trace({
          userOpHash: info.userOperationHash,
          transactionHash: transactionInfo.transactionHash
        }, "user op still pending");
      });
      return;
    }
    this.metrics.userOperationsOnChain.labels({ status: status.transactionStatuses.status }).inc(opInfos.length);
    if (status.transactionStatuses.status === "included") {
      opInfos.map((info) => {
        this.metrics.userOperationInclusionDuration.observe((Date.now() - info.firstSubmitted) / 1000);
        this.reputationManager.updateUserOperationIncludedStatus(deriveUserOperation2(info.mempoolUserOperation), status.transactionStatuses[info.userOperationHash].accountDeployed);
        this.mempool.removeSubmitted(info.userOperationHash);
        this.monitor.setUserOperationStatus(info.userOperationHash, {
          status: "included",
          transactionHash: status.hash
        });
        this.logger.info({
          userOpHash: info.userOperationHash,
          transactionHash: status.hash
        }, "user op included");
      });
      this.executor.markWalletProcessed(transactionInfo.executor);
    } else if (status.transactionStatuses.status === "failed" || status.transactionStatuses.status === "reverted") {
      opInfos.map((info) => {
        this.mempool.removeSubmitted(info.userOperationHash);
        this.monitor.setUserOperationStatus(info.userOperationHash, {
          status: "rejected",
          transactionHash: status.hash
        });
        this.logger.info({
          userOpHash: info.userOperationHash,
          transactionHash: status.hash
        }, "user op rejected");
      });
      this.executor.markWalletProcessed(transactionInfo.executor);
    }
  }
  async refreshUserOperationStatuses() {
    const ops = this.mempool.dumpSubmittedOps();
    const txs = getTransactionsFromUserOperationEntries2(ops);
    await Promise.all(txs.map(async (txInfo) => {
      await this.refreshTransactionStatus(txInfo);
    }));
  }
  async handleBlock(block7) {
    if (this.currentlyHandlingBlock) {
      return;
    }
    this.currentlyHandlingBlock = true;
    this.logger.debug({ blockNumber: block7.number }, "handling block");
    const submittedEntries = this.mempool.dumpSubmittedOps();
    if (submittedEntries.length === 0) {
      this.stopWatchingBlocks();
      this.currentlyHandlingBlock = false;
      return;
    }
    await this.refreshUserOperationStatuses();
    const gasPriceParameters = await this.gasPriceManager.getGasPrice();
    this.logger.trace({ gasPriceParameters }, "fetched gas price parameters");
    const transactionInfos = getTransactionsFromUserOperationEntries2(this.mempool.dumpSubmittedOps());
    await Promise.all(transactionInfos.map(async (txInfo) => {
      if (txInfo.transactionRequest.maxFeePerGas >= gasPriceParameters.maxFeePerGas && txInfo.transactionRequest.maxPriorityFeePerGas >= gasPriceParameters.maxPriorityFeePerGas) {
        return;
      }
      await this.replaceTransaction(txInfo, "gas_price");
    }));
    const transactionInfos2 = getTransactionsFromUserOperationEntries2(this.mempool.dumpSubmittedOps());
    await Promise.all(transactionInfos2.map(async (txInfo) => {
      if (Date.now() - txInfo.lastReplaced < 300000) {
        return;
      }
      await this.replaceTransaction(txInfo, "stuck");
    }));
    this.currentlyHandlingBlock = false;
  }
  async replaceTransaction(txInfo, reason) {
    let replaceResult = undefined;
    try {
      replaceResult = await this.executor.replaceTransaction(txInfo);
    } finally {
      this.metrics.replacedTransactions.labels({ reason, status: replaceResult?.status || "failed" }).inc();
    }
    if (replaceResult.status === "failed") {
      txInfo.userOperationInfos.map((opInfo) => {
        this.mempool.removeSubmitted(opInfo.userOperationHash);
      });
      this.logger.warn({ oldTxHash: txInfo.transactionHash, reason }, "failed to replace transaction");
      return;
    }
    if (replaceResult.status === "potentially_already_included") {
      this.logger.info({ oldTxHash: txInfo.transactionHash, reason }, "transaction potentially already included");
      txInfo.timesPotentiallyIncluded += 1;
      if (txInfo.timesPotentiallyIncluded >= 3) {
        txInfo.userOperationInfos.map((opInfo) => {
          this.mempool.removeSubmitted(opInfo.userOperationHash);
        });
        this.executor.markWalletProcessed(txInfo.executor);
        this.logger.warn({ oldTxHash: txInfo.transactionHash, reason }, "transaction potentially already included too many times, removing");
      }
      return;
    }
    const newTxInfo = replaceResult.transactionInfo;
    const missingOps = txInfo.userOperationInfos.filter((info) => !newTxInfo.userOperationInfos.map((ni) => ni.userOperationHash).includes(info.userOperationHash));
    const matchingOps = txInfo.userOperationInfos.filter((info) => newTxInfo.userOperationInfos.map((ni) => ni.userOperationHash).includes(info.userOperationHash));
    matchingOps.map((opInfo) => {
      this.mempool.replaceSubmitted(opInfo, newTxInfo);
    });
    missingOps.map((opInfo) => {
      this.mempool.removeSubmitted(opInfo.userOperationHash);
      this.logger.warn({
        oldTxHash: txInfo.transactionHash,
        newTxHash: newTxInfo.transactionHash,
        reason
      }, "missing op in new tx");
    });
    this.logger.info({
      oldTxHash: txInfo.transactionHash,
      newTxHash: newTxInfo.transactionHash,
      reason
    }, "replaced transaction");
    return;
  }
}
// entrypoint-0.7/cli/setup-entrypoint-point-seven.ts
var getReputationManager2 = ({
  client,
  parsedArgs,
  logger: logger3
}) => {
  if (parsedArgs.safeMode) {
    return new ReputationManager2(client, parsedArgs.entryPoint, BigInt(parsedArgs.minStake), BigInt(parsedArgs.minUnstakeDelay), logger3.child({ module: "reputation_manager" }, {
      level: parsedArgs.reputationManagerLogLevel || parsedArgs.logLevel
    }));
  }
  return new NullReputationManager2;
};
var getValidator2 = ({
  client,
  parsedArgs,
  logger: logger3,
  senderManager: senderManager2,
  metrics: metrics2,
  gasPriceManager: gasPriceManager2
}) => {
  if (!parsedArgs.entryPointSimulationsAddress) {
    throw new Error("entryPointSimulationsAddress is required for v0.7");
  }
  if (parsedArgs.safeMode) {
    return new SafeValidator3(client, senderManager2, parsedArgs.entryPoint, logger3.child({ module: "rpc" }, { level: parsedArgs.rpcLogLevel || parsedArgs.logLevel }), metrics2, gasPriceManager2, parsedArgs.utilityPrivateKey, parsedArgs.apiVersion, parsedArgs.entryPointSimulationsAddress, parsedArgs.tenderlyEnabled, parsedArgs.balanceOverrideEnabled);
  }
  return new UnsafeValidator4(client, parsedArgs.entryPoint, logger3.child({ module: "rpc" }, { level: parsedArgs.rpcLogLevel || parsedArgs.logLevel }), metrics2, gasPriceManager2, parsedArgs.utilityPrivateKey, parsedArgs.apiVersion, parsedArgs.entryPointSimulationsAddress, parsedArgs.tenderlyEnabled, parsedArgs.balanceOverrideEnabled, parsedArgs.disableExpirationCheck);
};
var getMonitor2 = () => {
  return new Monitor2;
};
var getMempool2 = ({
  monitor,
  reputationManager: reputationManager5,
  validator,
  client,
  parsedArgs,
  logger: logger3,
  metrics: metrics2
}) => {
  return new MemoryMempool2(monitor, reputationManager5, validator, client, parsedArgs.entryPoint, parsedArgs.safeMode, logger3.child({ module: "mempool" }, { level: parsedArgs.mempoolLogLevel || parsedArgs.logLevel }), metrics2);
};
var getCompressionHandler2 = async ({
  client,
  parsedArgs
}) => {
  let compressionHandler3 = null;
  if (parsedArgs.bundleBulkerAddress !== undefined && parsedArgs.perOpInflatorAddress !== undefined) {
    compressionHandler3 = await CompressionHandler2.createAsync(parsedArgs.bundleBulkerAddress, parsedArgs.perOpInflatorAddress, client);
  }
  return compressionHandler3;
};
var getExecutor2 = ({
  client,
  walletClient,
  senderManager: senderManager2,
  reputationManager: reputationManager5,
  parsedArgs,
  logger: logger3,
  metrics: metrics2,
  compressionHandler: compressionHandler3,
  gasPriceManager: gasPriceManager2
}) => {
  return new BasicExecutor2(client, walletClient, senderManager2, reputationManager5, parsedArgs.entryPoint, logger3.child({ module: "executor" }, { level: parsedArgs.executorLogLevel || parsedArgs.logLevel }), metrics2, compressionHandler3, gasPriceManager2, !parsedArgs.tenderlyEnabled, parsedArgs.noEip1559Support, parsedArgs.customGasLimitForEstimation, parsedArgs.useUserOperationGasLimitsForSubmission);
};
var getExecutorManager2 = ({
  executor: executor5,
  mempool: mempool9,
  monitor,
  reputationManager: reputationManager5,
  client,
  parsedArgs,
  logger: logger3,
  metrics: metrics2,
  gasPriceManager: gasPriceManager2
}) => {
  return new ExecutorManager2(executor5, mempool9, monitor, reputationManager5, client, parsedArgs.entryPoint, parsedArgs.pollingInterval, logger3.child({ module: "executor" }, { level: parsedArgs.executorLogLevel || parsedArgs.logLevel }), metrics2, parsedArgs.bundleMode, parsedArgs.bundlerFrequency, gasPriceManager2);
};
var getNonceQueuer2 = ({
  mempool: mempool9,
  client,
  parsedArgs,
  logger: logger3
}) => {
  return new NonceQueuer2(mempool9, client, parsedArgs.entryPoint, logger3.child({ module: "nonce_queuer" }, { level: parsedArgs.nonceQueuerLogLevel || parsedArgs.logLevel }));
};
var getRpcHandler2 = ({
  client,
  validator,
  mempool: mempool9,
  executor: executor5,
  monitor,
  nonceQueuer: nonceQueuer3,
  executorManager: executorManager3,
  reputationManager: reputationManager5,
  parsedArgs,
  logger: logger3,
  metrics: metrics2,
  compressionHandler: compressionHandler3,
  gasPriceManager: gasPriceManager2
}) => {
  return new RpcHandler2(parsedArgs.entryPoint, client, validator, mempool9, executor5, monitor, nonceQueuer3, executorManager3, reputationManager5, parsedArgs.tenderlyEnabled ?? false, parsedArgs.minimumGasPricePercent, parsedArgs.apiVersion, parsedArgs.noEthCallOverrideSupport, parsedArgs.rpcMaxBlockRange, logger3.child({ module: "rpc" }, { level: parsedArgs.rpcLogLevel || parsedArgs.logLevel }), metrics2, parsedArgs.environment, compressionHandler3, parsedArgs.noEip1559Support, gasPriceManager2, parsedArgs.dangerousSkipUserOperationValidation);
};
var getServer2 = ({
  rpcEndpoint,
  parsedArgs,
  logger: logger3,
  registry,
  metrics: metrics2
}) => {
  return new Server2(rpcEndpoint, parsedArgs.port, parsedArgs.requestTimeout, logger3.child({ module: "rpc" }, { level: parsedArgs.rpcLogLevel || parsedArgs.logLevel }), registry, metrics2);
};
var setupEntryPointPointSeven = async ({
  client,
  walletClient,
  parsedArgs,
  logger: logger3,
  rootLogger,
  registry,
  metrics: metrics2,
  senderManager: senderManager2,
  gasPriceManager: gasPriceManager2
}) => {
  const validator = getValidator2({
    client,
    logger: logger3,
    parsedArgs,
    senderManager: senderManager2,
    metrics: metrics2,
    gasPriceManager: gasPriceManager2
  });
  const reputationManager5 = getReputationManager2({
    client,
    parsedArgs,
    logger: logger3
  });
  await senderManager2.validateAndRefillWallets(client, walletClient, parsedArgs.minBalance);
  setInterval(async () => {
    await senderManager2.validateAndRefillWallets(client, walletClient, parsedArgs.minBalance);
  }, parsedArgs.refillInterval);
  const monitor = getMonitor2();
  const mempool9 = getMempool2({
    monitor,
    reputationManager: reputationManager5,
    validator,
    client,
    parsedArgs,
    logger: logger3,
    metrics: metrics2
  });
  const compressionHandler3 = await getCompressionHandler2({
    client,
    parsedArgs
  });
  const executor5 = getExecutor2({
    client,
    walletClient,
    senderManager: senderManager2,
    reputationManager: reputationManager5,
    parsedArgs,
    logger: logger3,
    metrics: metrics2,
    compressionHandler: compressionHandler3,
    gasPriceManager: gasPriceManager2
  });
  const executorManager3 = getExecutorManager2({
    executor: executor5,
    mempool: mempool9,
    monitor,
    reputationManager: reputationManager5,
    client,
    parsedArgs,
    logger: logger3,
    metrics: metrics2,
    gasPriceManager: gasPriceManager2
  });
  const nonceQueuer3 = getNonceQueuer2({ mempool: mempool9, client, parsedArgs, logger: logger3 });
  const rpcEndpoint = getRpcHandler2({
    client,
    validator,
    mempool: mempool9,
    executor: executor5,
    monitor,
    nonceQueuer: nonceQueuer3,
    executorManager: executorManager3,
    reputationManager: reputationManager5,
    parsedArgs,
    logger: logger3,
    metrics: metrics2,
    compressionHandler: compressionHandler3,
    gasPriceManager: gasPriceManager2
  });
  if (parsedArgs.flushStuckTransactionsDuringStartup) {
    executor5.flushStuckTransactions();
  }
  rootLogger.info(`Initialized ${senderManager2.wallets.length} executor wallets`);
  const server3 = getServer2({
    rpcEndpoint,
    parsedArgs,
    logger: logger3,
    registry,
    metrics: metrics2
  });
  server3.start();
  const gracefulShutdown = async (signal) => {
    rootLogger.info(`${signal} received, shutting down`);
    await server3.stop();
    rootLogger.info("server stopped");
    const outstanding = mempool9.dumpOutstanding().length;
    const submitted = mempool9.dumpSubmittedOps().length;
    const processing = mempool9.dumpProcessing().length;
    rootLogger.info({ outstanding, submitted, processing }, "dumping mempool before shutdown");
    process.exit(0);
  };
  process.on("SIGINT", gracefulShutdown);
  process.on("SIGTERM", gracefulShutdown);
};
// cli/handler.ts
async function bundlerHandler(args) {
  const parsedArgs = parseArgs(args);
  if (parsedArgs.signerPrivateKeysExtra !== undefined) {
    parsedArgs.signerPrivateKeys = [
      ...parsedArgs.signerPrivateKeys,
      ...parsedArgs.signerPrivateKeysExtra
    ];
  }
  let logger3;
  if (parsedArgs.logEnvironment === "development") {
    logger3 = initDebugLogger(parsedArgs.logLevel);
  } else {
    logger3 = initProductionLogger(parsedArgs.logLevel);
  }
  const rootLogger = logger3.child({ module: "root" }, { level: parsedArgs.logLevel });
  const getChainId6 = async () => {
    const client2 = createPublicClient({
      transport: customTransport(args.rpcUrl, {
        logger: logger3.child({ module: "public_client" }, {
          level: parsedArgs.publicClientLogLevel || parsedArgs.logLevel
        })
      })
    });
    return await client2.getChainId();
  };
  const chainId = await getChainId6();
  const chain6 = {
    id: chainId,
    name: args.networkName,
    network: args.networkName,
    nativeCurrency: {
      name: "ETH",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      default: { http: [args.rpcUrl] },
      public: { http: [args.rpcUrl] }
    }
  };
  const client = createPublicClient({
    transport: customTransport(args.rpcUrl, {
      logger: logger3.child({ module: "public_client" }, {
        level: parsedArgs.publicClientLogLevel || parsedArgs.logLevel
      })
    }),
    chain: chain6
  });
  const gasPriceManager2 = new GasPriceManager(chain6, client, parsedArgs.noEip1559Support, logger3.child({ module: "gas_price_manager" }, {
    level: parsedArgs.publicClientLogLevel || parsedArgs.logLevel
  }), parsedArgs.gasPriceTimeValidityInSeconds);
  const registry = new $Registry;
  registry.setDefaultLabels({
    network: chain6.name,
    chainId,
    entrypoint_version: parsedArgs.entryPointVersion
  });
  const metrics2 = createMetrics(registry);
  await preFlightChecks(client, parsedArgs);
  const walletClient = createWalletClient({
    transport: customTransport(parsedArgs.executionRpcUrl ?? args.rpcUrl, {
      logger: logger3.child({ module: "wallet_client" }, {
        level: parsedArgs.walletClientLogLevel || parsedArgs.logLevel
      })
    }),
    chain: chain6
  });
  const senderManager2 = new SenderManager(parsedArgs.signerPrivateKeys, parsedArgs.utilityPrivateKey, logger3.child({ module: "executor" }, { level: parsedArgs.executorLogLevel || parsedArgs.logLevel }), metrics2, parsedArgs.noEip1559Support, parsedArgs.apiVersion, gasPriceManager2, parsedArgs.maxSigners);
  if (parsedArgs.entryPointVersion === "0.6") {
    await setupEntryPointPointSix({
      client,
      walletClient,
      parsedArgs,
      logger: logger3,
      rootLogger,
      registry,
      metrics: metrics2,
      senderManager: senderManager2,
      gasPriceManager: gasPriceManager2
    });
  }
  if (parsedArgs.entryPointVersion === "0.7") {
    await setupEntryPointPointSeven({
      client,
      walletClient,
      parsedArgs,
      logger: logger3,
      rootLogger,
      registry,
      metrics: metrics2,
      senderManager: senderManager2,
      gasPriceManager: gasPriceManager2
    });
  }
}
var parseArgs = (args) => {
  const parsing = bundlerArgsSchema.safeParse(args);
  if (!parsing.success) {
    const error = import_zod_validation_error6.fromZodError(parsing.error);
    throw new Error(error.message);
  }
  return parsing.data;
};
var preFlightChecks = async (publicClient, args) => {
  const entryPointCode = await publicClient.getBytecode({
    address: args.entryPoint
  });
  if (entryPointCode === "0x") {
    throw new Error(`entry point ${args.entryPoint} does not exist`);
  }
};

// cli/config/options.ts
var bundlerOptions = {
  networkName: {
    description: "Name of the network (used for metrics)",
    type: "string",
    require: true
  },
  entryPoint: {
    description: "EntryPoint contract addresses split by commas",
    type: "string",
    require: true
  },
  entryPointSimulationsAddress: {
    description: "Address of the entry point simulations contract",
    type: "string",
    require: false
  },
  signerPrivateKeys: {
    description: "Private key of the signer",
    type: "string",
    require: true
  },
  signerPrivateKeysExtra: {
    description: "Private key of the signer",
    type: "string"
  },
  utilityPrivateKey: {
    description: "Private key of the utility account",
    type: "string",
    require: true
  },
  maxSigners: {
    description: "Maximum number of signers to use from the list of signer private keys",
    type: "number"
  },
  minBalance: {
    description: "Minimum balance required for the signer",
    type: "string",
    require: true
  },
  perOpInflatorAddress: {
    description: "Address of the PerOpInflator contract",
    type: "string",
    require: false
  },
  bundleBulkerAddress: {
    description: "Address of the BundleBulker contract",
    type: "string",
    require: false
  },
  refillInterval: {
    description: "Interval to refill the signer balance (in ms)",
    type: "number",
    require: true,
    default: 1200000
  },
  requestTimeout: {
    description: "Timeout for the request (in ms)",
    type: "number",
    require: false
  },
  rpcUrl: {
    description: "RPC url to connect to",
    type: "string",
    require: true
  },
  executionRpcUrl: {
    description: "RPC url to send transactions to",
    type: "string",
    require: false
  },
  minStake: {
    description: "Minimum stake required for a relay (in 10e18)",
    type: "number",
    require: true,
    default: 1
  },
  minUnstakeDelay: {
    description: "Minimum unstake delay",
    type: "number",
    require: true,
    default: 1
  },
  maxBundleWaitTime: {
    description: "Maximum time to wait for a bundle to be submitted",
    type: "number",
    require: true,
    default: 3
  },
  maxBundleSize: {
    description: "Maximum number of operations in mempool before a bundle is submitted",
    type: "number",
    require: true,
    default: 3
  },
  port: {
    description: "Port to listen on",
    type: "number",
    require: true,
    default: 3000
  },
  pollingInterval: {
    description: "Polling interval for the executor module (ms)",
    type: "number",
    require: true,
    default: 1000
  },
  logLevel: {
    description: "Default log level",
    type: "string",
    require: true,
    default: "debug"
  },
  publicClientLogLevel: {
    description: "Log level for the publicClient module",
    type: "string",
    require: false
  },
  walletClientLogLevel: {
    description: "Log level for the walletClient module",
    type: "string",
    require: false
  },
  rpcLogLevel: {
    description: "Log level for the rpc module",
    type: "string",
    require: false
  },
  mempoolLogLevel: {
    description: "Log level for the mempool module",
    type: "string",
    require: false
  },
  executorLogLevel: {
    description: "Log level for the executor module",
    type: "string",
    require: false
  },
  reputationManagerLogLevel: {
    description: "Log level for the executor module",
    type: "string",
    require: false
  },
  nonceQueuerLogLevel: {
    description: "Log level for the executor module",
    type: "string",
    require: false
  },
  environment: {
    description: "Environment",
    type: "string",
    require: true,
    default: "production"
  },
  logEnvironment: {
    description: "Log environment",
    type: "string",
    require: true,
    default: "production"
  },
  tenderlyEnabled: {
    description: "Rpc url is a tenderly url",
    type: "boolean",
    require: true,
    default: false
  },
  minimumGasPricePercent: {
    description: "Minimum % of userop gasPrice compared to gasPrice used by the bundler",
    type: "number",
    require: true,
    default: 0
  },
  apiVersion: {
    description: "API version of the bundler",
    type: "string",
    require: false,
    default: "v1"
  },
  noEip1559Support: {
    description: "Rpc url does not support EIP1559",
    type: "boolean",
    require: true,
    default: false
  },
  noEthCallOverrideSupport: {
    description: "Rpc url does not support eth_call overrides",
    type: "boolean",
    require: true,
    default: false
  },
  balanceOverrideEnabled: {
    description: "True if RPC url supports eth_call balance state overrides",
    type: "boolean",
    require: true,
    default: false
  },
  useUserOperationGasLimitsForSubmission: {
    description: "Use user operation gas limits during submission",
    type: "boolean",
    require: true,
    default: false
  },
  flushStuckTransactionsDuringStartup: {
    description: "Should the bundler try to flush out all stuck pending transactions on startup",
    type: "boolean",
    require: true,
    default: false
  },
  customGasLimitForEstimation: {
    description: "Custom gas limit for estimation",
    type: "string"
  },
  disableExpirationCheck: {
    description: "Should the node make expiration checks",
    type: "boolean",
    require: false,
    default: false
  },
  bundleMode: {
    description: "Set if the bundler should run in auto bundle mode or not.",
    type: "string",
    require: false,
    default: "auto"
  },
  safeMode: {
    description: "Enable safe mode",
    type: "boolean",
    require: false,
    default: false
  },
  bundlerFrequency: {
    description: "How ofter in milliseconds to check and build new bundles",
    type: "number",
    require: false,
    default: 1000
  },
  rpcMaxBlockRange: {
    description: "Max block range for rpc calls",
    type: "number",
    require: false
  },
  dangerousSkipUserOperationValidation: {
    description: "Skip user operation validation, use with caution",
    type: "boolean",
    require: false,
    default: false
  },
  entryPointVersion: {
    description: "Version of the entry point",
    type: "string",
    require: false,
    default: "0.6"
  },
  gasPriceTimeValidityInSeconds: {
    description: "Time in seconds that the gas price is valid for",
    type: "number",
    require: false,
    default: 10
  }
};
var bundlerCommand = {
  command: "run",
  describe: "Starts a bundler",
  options: bundlerOptions,
  handler: bundlerHandler,
  examples: [
    {
      command: "run --entryPoint 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789,0x0576a174D229E3cFA37253523E645A78A0C91B57 --signerPrivateKeys 1060ac9646dffa5dc19c188e148c627c50a0e8250a2f195ec3c493ffae3ed019",
      description: "Starts a bundler"
    }
  ]
};
// cli/util.ts
function registerCommandToYargs(yargs, cliCommand) {
  yargs.command({
    command: cliCommand.command,
    describe: cliCommand.describe,
    builder: (yargsBuilder) => {
      yargsBuilder.options(cliCommand.options || {});
      for (const subcommand of cliCommand.subcommands || []) {
        registerCommandToYargs(yargsBuilder, subcommand);
      }
      if (cliCommand.examples) {
        for (const example of cliCommand.examples) {
          yargsBuilder.example(`\$0 ${example.command}`, example.description);
        }
      }
      return yargs;
    },
    handler: cliCommand.handler || function emptyHandler() {
    }
  });
}

// cli/alto.ts
function getAltoCli() {
  const alto = yarg.wrap(null).env("ALTO").parserConfiguration({
    "dot-notation": true
  }).options(bundlerOptions).scriptName("").demandCommand(1).usage(topBanner).epilogue(bottomBanner).showHelpOnFail(false).alias("h", "help").alias("v", "version").recommendCommands();
  alto.recommendCommands();
  alto.config();
  registerCommandToYargs(alto, bundlerCommand);
  return alto;
}
if (process.env.DOTENV_CONFIG_PATH) {
  import_dotenv.default.config({ path: process.env.DOTENV_CONFIG_PATH });
} else {
  import_dotenv.default.config();
}
if (process.env.SENTRY_DSN) {
  sentry13.init({
    dsn: process.env.SENTRY_DSN,
    tracesSampleRate: 1,
    profilesSampleRate: 1,
    environment: process.env.ENVIRONMENT
  });
}
var yarg = yargs_default(hideBin(process.argv));
var topBanner = `\uD83C\uDFD4\uFE0F Alto: TypeScript ERC-4337 Bundler.
  * by Pimlico, 2023`;
var bottomBanner = `\uD83D\uDCD6 For more information, check the our docs:
  * https://docs.pimlico.io/
`;

class YargsError extends Error {
  constructor() {
    super(...arguments);
  }
}
var alto = getAltoCli();
alto.fail((msg, err) => {
  if (msg) {
    if (msg.includes("Not enough non-option arguments")) {
      yarg.showHelp();
      console.log("\n");
    }
  }
  const errorMessage = err !== undefined ? err instanceof YargsError ? err.message : err.stack : msg || "Unknown error";
  console.error(` \u2716 ${errorMessage}\n`);
  process.exit(1);
}).parse();
export {
  yarg,
  getAltoCli,
  YargsError
};
